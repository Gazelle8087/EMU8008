 AS V1.42 Beta [Bld 290] - Source File sc1.asm - Page 1 - 7/26/2025 11:40:27


    1/   0 :                            ;	SCELBAL BASIC for EMU8008
    2/   0 :                            ;
    3/   0 :                            ;Gazelle states the copyright about;
    4/   0 :                            ;Converted old 8008 mnemonics to new 8008 mnemonics.
    5/   0 :                            ;Relocate code for ROM start at 2000h and RAM at lower address.
    6/   0 :                            ;Added IO routines to match the specifications of the DOS loader.
    7/   0 :                            ;
    8/   0 :                            ;	Copyright (C) 2025 by Gazelle
    9/   0 :                            ;
   10/   0 :                            ;Permission is hereby granted, free of charge, to any person
   11/   0 :                            ;obtaining a copy of this software and associated documentation
   12/   0 :                            ;files (the "Software"), to deal in the Software without
   13/   0 :                            ;restriction, including without limitation the rights to use,
   14/   0 :                            ;copy, modify, merge, publish, distribute, sublicense, and/or sell
   15/   0 :                            ;copies of the Software, and to permit persons to whom the
   16/   0 :                            ;Software is furnished to do so, subject to the following
   17/   0 :                            ;conditions:
   18/   0 :                            ;
   19/   0 :                            ;The above copyright notice and this permission notice shall be
   20/   0 :                            ;included in all copies or substantial portions of the Software.
   21/   0 :                            ;
   22/   0 :                            ;THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   23/   0 :                            ;EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
   24/   0 :                            ;OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   25/   0 :                            ;NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
   26/   0 :                            ;HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
   27/   0 :                            ;WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   28/   0 :                            ;FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   29/   0 :                            ;OTHER DEALINGS IN THE SOFTWARE.
   30/   0 :                            ;
   31/   0 :                            ;Repository https://github.com/Gazelle8087/EMU8008
   32/   0 :                            ;
   33/   0 :                            ;original source for SELBAL is available here under
   34/   0 :                            ;https://www.willegal.net/scelbi/the8008andScelbi.html
   35/   0 :                            ;
   36/   0 :                            ;2025/07/26 Rev. 1.00 Initial release
   37/   0 :                            ;
   38/   0 :                            ;;; This is the Scelbi Basic Program from 1974 known as
   39/   0 :                            ;;; SCELBAL by Mark G. Arnold (MGA) and Nat Wadsworth  
   40/   0 :                            ;;;
   41/   0 :                            ;;;  Copyright 1975 Scelbi Computer Consulting, Inc.
   42/   0 :                            ;;;  All rights reserved
   43/   0 :                            ;;;
   44/   0 :                            ;;; MGA gives permission to use SCELBAL for 
   45/   0 :                            ;;; educational, historical, non-commercial purposes.
   46/   0 :                            ;;; Versions of this have been circulating on the web since
   47/   0 :                            ;;; about 2000; this version is authorized by MGA (Mar 2012)
   48/   0 :                            ;;; with the understanding no warranty is expressed or implied.
   49/   0 :                            ;;; As stated in the original, "no responsibility is assumed for
   50/   0 :                            ;;; for inaccuracies or for the success or failure of
   51/   0 :                            ;;; various applications to which the information herein
   52/   0 :                            ;;; may be applied."
   53/   0 :                            ;;; 
   54/   0 :                            ;;; SCELBAL is the only open-source, floating-point 
   55/   0 :                            ;;; high-level language ever implemented on Intel's first
   56/   0 :                            ;;; general-purpose microprocessor, the 8008.  It was
   57/   0 :                            ;;; published in book form:
   58/   0 :                            ;;;
   59/   0 :                            ;;;  SCELBAL: A Higher-Level Language for 8008/8080 Systems
   60/   0 :                            ;;;
 AS V1.42 Beta [Bld 290] - Source File sc1.asm - Page 2 - 7/26/2025 11:40:27


   61/   0 :                            ;;; (Tiny BASIC only used 16-bit integers; the MCM\70
   62/   0 :                            ;;; was a closed system; calculators implemented with 8008
   63/   0 :                            ;;; were floating-point, but not high-level.)
   64/   0 :                            ;;;
   65/   0 :                            ;;; This version is modified to assemble with the
   66/   0 :                            ;;; as8 assembler (using the -octal option) 
   67/   0 :                            ;;; for the Intel 8008 by Thomas E. Jones.
   68/   0 :                            ;;; This current form is made up non-relocatable so that
   69/   0 :                            ;;; locations of all code and data is identical to the
   70/   0 :                            ;;; original SCELBAL documents and patches.  It should be
   71/   0 :                            ;;; reasonable after debugging code to convert this to a
   72/   0 :                            ;;; relocatable and ROMable code with variables in RAM.
   73/   0 :                            ;;; This code originates from a version made by 
   74/   0 :                            ;;;
   75/   0 :                            ;;;    Steve Loboyko in 2001.
   76/   0 :                            ;;;
   77/   0 :                            ;;; This version has all 3 patches for SCELBAL (the two
   78/   0 :                            ;;; pasted in the original manual, and a third which was
   79/   0 :                            ;;; written in SCELBAL UPDATE publication, as well as
   80/   0 :                            ;;; a couple changes to constants which didn't actually
   81/   0 :                            ;;; require a patch, just changes to bytes of data or
   82/   0 :                            ;;; arguments to an instruction--one of these (Tucker) was 
   83/   0 :                            ;;; incorrect and restored to original by MGA March 2012).
   84/   0 :                            ;;; 
   85/   0 :                            ;;; This comment must be incorporated with any version of SCELBAL
   86/   0 :                            ;;; downloaded, distributed, posted or disemenated.
   87/   0 :                            
   88/   0 :                            		CPU	8008new
   89/   0 :                            		page	0,100
   90/   0 :                            
   91/   0 : =1FH                       ENDPGRAM	EQU	1fh	;055o	;MGA 4/10/12 as in orig; for his ROMable Loboyko said 077       [077]
   92/   0 : =6H                        BGNPGRAM	EQU	6h	;033o	;MGA 4/10/12 as in orig; for his ROMable Loboyko said 044       [044]
   93/   0 : =2000H                     code_start	EQU	2000h
   94/   0 : =41H                       INT_PTR		EQU	41h	; DO NOT change, Should match to PIC firmware
   95/   0 : =0H                        IN_STATUS	EQU 	00h	; DO NOT change, Should match to PIC firmware
   96/   0 : =1H                        IN_DATA		EQU	01h	; DO NOT change, Should match to PIC firmware
   97/   0 : =10H                       OUT_DATA	EQU 	10h	; DO NOT change, Should match to PIC firmware
   98/   0 :                            
   99/   0 :                            ;;; Here are labels originally attempting to make the code
  100/   0 :                            ;;; relocatable.  These 4 pages contain variable data
  101/   0 :                            ;;; which needs to be relocated from ROM to RAM.
  102/   0 :                            ;;; I can't vouch for ALL references to these pages in
  103/   0 :                            ;;; the code being switched to these labels, but they
  104/   0 :                            ;;; seem to be.
  105/   0 :                            
  106/   0 : =2H                        PG01		EQU	2	;OLDPG1:	EQU	001#000
  107/   0 : =3H                        PG26		EQU	3	;OLDPG26:	EQU	026#000
  108/   0 : =4H                        PG27		EQU	4	;OLDPG27:	EQU	027#000
  109/   0 : =5H                        PG57		EQU	5	;OLDPG57:	EQU	057#000
  110/   0 :                            
  111/   0 :                            ;;; Page zero will contain the I/O Routines.  These are actually
  112/   0 :                            ;;; just as suggested by Scelbal Manual for Serial I/O.
  113/   0 :                            
  114/   0 :                            		org	0
  115/   0 : 44 50 01                   		JMP	HAJIME		;inturrupt procedure
  116/   3 : 53                         		OUT	9		;DO NOT delete this "OUT 9" need to exit from INT procedure
  117/   4 :                            
  118/  41 :                            		org	INT_PTR		;PIC fetch inturrupt code from ram[INT_PTR]
  119/  41 : 00                         		db	0		;Power on INT code stored in ram[0]
  120/  42 : 80                         		db	80h		;Inturrupt log will be stored in ram[0x80]-
  121/  43 :                            
  122/ 100 :                            		org	100h
  123/ 100 : 4E                         OPN:		db	OPN_MSG1 - OPN_MSG
  124/ 101 : 46 61 73 74 65 72 20 53 43 OPN_MSG:	db	"Faster SCELBAL (2012)",0dh,0ah
       10A : 45 4C 42 41 4C 20 28 32 30
       113 : 31 32 29 0D 0A            
  125/ 118 : 43 6F 64 65 20 52 65 6C 6F 		db	"Code Relocation, IO and start up code by Gazelle 2025",0dh,0ah
       121 : 63 61 74 69 6F 6E 2C 20 49
       12A : 4F 20 61 6E 64 20 73 74 61
       133 : 72 74 20 75 70 20 63 6F 64
       13C : 65 20 62 79 20 47 61 7A 65
       145 : 6C 6C 65 20 32 30 32 35 0D
       14E : 0A                        
  126/ 14F : 00                         OPN_MSG1:	db	0
  127/ 150 :                            
  128/ 150 : 2E 01                      HAJIME:		MVI	H,OPN / 256
  129/ 152 : 36 00                      		MVI	L,OPN - OPN/256*256
  130/ 154 : 46 51 21                   		CALL	TEXTC
  131/ 157 : 44 0A 27                   		JMP	ENTRY_SCR
  132/ 15A :                            ;---------------------------------------------------------------------
  133/ 15A :                            ;		HARDWARE DEPENDENT ROUTINE
  134/ 15A :                            SAVE:
  135/ 15A : 7F                         LOAD:		OUT	1FH	; Exit from emulator.
  136/ 15B : 44 B6 26                   UDEFX:		JMP	EXEC
  137/ 15E :                            ;;; no user defined functions yet, stop here if we see one.
  138/ 15E :                            
  139/ 15E : 41                         CINP:		IN	IN_STATUS
  140/ 15F : 24 01                      		ANI	1
  141/ 161 : 68 5E 01                   		JZ	CINP
  142/ 164 :                            
  143/ 164 : 43                         		IN	IN_DATA
  144/ 165 : 3C 08                      		CPI	08H
  145/ 167 : 68 6E 01                   		JZ	CINP_BS
  146/ 16A : 61                         		OUT	OUT_DATA
  147/ 16B : 34 80                      		ORI	80H
  148/ 16D : 07                         		RET
  149/ 16E :                            
  150/ 16E : 06 FF                      CINP_BS:	MVI	A,0FFH
  151/ 170 : 07                         		RET
  152/ 171 :                            
  153/ 171 : 3C DC                      CPRINT:		CPI	0DCH
  154/ 173 : 68 91 01                   		JZ	CP_BS
  155/ 176 : 24 7F                      		ANI	7Fh
  156/ 178 : 3C 0D                      		CPI	0DH
  157/ 17A : 68 87 01                   		JZ	CP_OK
  158/ 17D : 3C 0A                      		CPI	0AH
  159/ 17F : 68 87 01                   		JZ	CP_OK
  160/ 182 : 3C 20                      		CPI	20H
  161/ 184 : 60 90 01                   		JC	CP_NO
  162/ 187 :                            
  163/ 187 : E8                         CP_OK:		MOV	H,A
  164/ 188 : 41                         CPRINT_1:	IN	IN_STATUS
  165/ 189 : 24 02                      		ANI	2
  166/ 18B : 68 88 01                   		JZ	CPRINT_1
  167/ 18E : C5                         		MOV	A,H
  168/ 18F : 61                         		OUT	OUT_DATA
  169/ 190 : 07                         CP_NO:		RET
  170/ 191 :                            
  171/ 191 : 41                         CP_BS:		IN	IN_STATUS
  172/ 192 : 24 02                      		ANI	2
  173/ 194 : 68 91 01                   		JZ	CP_BS
  174/ 197 : 06 08                      		MVI	A,08H
  175/ 199 : 61                         		OUT	OUT_DATA
  176/ 19A :                            
  177/ 19A : 41                         CP_BS2:		IN	IN_STATUS
  178/ 19B : 24 02                      		ANI	2
  179/ 19D : 68 9A 01                   		JZ	CP_BS2
  180/ 1A0 : 06 20                      		MVI	A,20H
  181/ 1A2 : 61                         		OUT	OUT_DATA
  182/ 1A3 :                            
  183/ 1A3 : 41                         CP_BS3:		IN	IN_STATUS
  184/ 1A4 : 24 02                      		ANI	2
  185/ 1A6 : 68 A3 01                   		JZ	CP_BS3
  186/ 1A9 : 06 08                      		MVI	A,08H
  187/ 1AB : 61                         		OUT	OUT_DATA
  188/ 1AC : 07                         		RET
  189/ 1AD :                            
  190/ 1AD :                            ;------------------------------------------------------------------------
  191/ 1AD :                            
  192/ 1AD :                            ;;; THE ABOVE MUST CONCLUDE BEFORE BY PAGE 1 STARTS
  193/ 1AD :                            
  194/ 1AD :                            ;;; Page one has many constants and variables.
  195/ 1AD :                            
  196/ 200 :                            		ORG	PG01 * 0100h	;001#000
  197/ 200 :                            
  198/ 200 : 00 00 00 00                		db	0,0,0,0		;DATA *4
  199/ 204 : 00 00 40 01                		db	0,0,100o,1	;DATA 000,000,100,001	; STORES FLOATING POINT CONSTANT +1.0
  200/ 208 : 00 00 00                   		db	0,0,0		;DATA *3
  201/ 20B : 00                         		db	0		;DATA 000		; EXPONENT COUNTER
  202/ 20C : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; STORES FLOATING POINT NUMBER TEMPORARILLY
  203/ 210 : 00 00 00 00                		db	0,0,0,0		;DATA *4
  204/ 214 : 00 00 C0 01                		db	0,0,300o,1	;DATA 000,000,300,001	; STORES FLOATING POINT CONSTANT -1.0
  205/ 218 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; SCRATCH PAD AREA (16 BYTES)
  206/ 21C : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
  207/ 220 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
  208/ 224 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
  209/ 228 : 01 50 72 02                		db	1,120o,162o,2o	;DATA 001,120,162,002	; STORES RANDOM NUMBER GENERATOR CONSTANT VALUE
  210/ 22C : 00 00 00 00                		db	0,0,0,0		;DATA *4
  211/ 230 : 03 68 6F 0C                		db	3,150o,157o,14o	;DATA 003,150,157,014	; STORES RANDOM NUMBER GENERATOR CONSTANT VALUE
  212/ 234 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; SCRATCH PAD AREA (12 BYTES) (01 064-077)
  213/ 238 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
  214/ 23C : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
  215/ 240 : 00 00                      		db	0,0		;DATA 000,000		; SIGN INDICATOR
  216/ 242 : 00                         		db	0		;DATA 000		; BITS COUNTER
  217/ 243 : 00 00                      		db	0,0		;DATA 000,000		; SIGN INDICATOR
  218/ 245 : 00                         IN_DIGIT_CC_L0	db	0		;DATA 000		; INPUT DIGIT COUNTER
  219/ 246 : =45H                       IN_DIGIT_CC_L	equ	105o
  220/ 246 : 00                         		db	0		;DATA 000		; TEMP STORATE
  221/ 247 : 00                         		db	0		;DATA 000		; OUTPUT DIGIT COUNTER
  222/ 248 : 00                         		db	0		;DATA 000 		; FP MODE INDICATOR
  223/ 249 : 00 00 00 00 00 00 00       		db	0,0,0,0,0,0,0	;DATA *7		; NOT ASSIGNED (SHOULD BE 01 111-117)
  224/ 250 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; FPACC EXTENSION
  225/ 254 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; FPACC LSW, NSW, MSW, EXPONENT
  226/ 258 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; FPOP  Extension
  227/ 25C : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; FPOP  LSW, NSW, MSW, EXPONENT
  228/ 260 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; FLOATING POINT WORKING AREA
  229/ 264 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; (SHOULD BE AT 01 140-01-167)
  230/ 268 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
  231/ 26C : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
  232/ 270 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
  233/ 274 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
  234/ 278 : 00 00 00 00 00 00 00 00    		db	0,0,0,0,0,0,0,0	;DATA *8		; NOT ASSIGNED (SHOULD BE 01 170-01 177)
  235/ 280 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; TEMPORARY REGISTER STORAGE AREA (D,E,H&L)
  236/ 284 : 00 00 00 00                		db	0,0,0,0		;DATA *4		; NOT ASSIGNED (01 204-01 207)
  237/ 288 : 00 00 50 04                		db	0,0,120o,4	;DATA 000,000,120,004	; STORES FLOATING POINT CONSTANT +10.0
  238/ 28C : 67 66 66 FD                		db	147o,146o,146o,375o	;DATA 147,146,146,375	; STORES FLOATING POINT CONSTANT +0.1
  239/ 290 : 00                         		db	0		;DATA 000		; GETINP COUNTER
  240/ 291 : 00 00 00 00 00 00          		db	0,0,0,0,0,0	;DATA *6		; NOT ASSIGNED (01 221-01 226)
  241/ 297 : 00                         		db	0		;DATA 000		; ARITHMETIC STACK POINTER (01 227)
  242/ 298 : 00                         		db	0		;DATA 000		; ARITHMETIC STACK (NOT CLEAR HOW LONG)
  243/ 299 :                            
  244/ 2BA :                            		ORG	PG01 * 0100h + 0bah	;001#272
  245/ 2BA : 04                         		db	4		;DATA 004		; CC FOR SAVE
  246/ 2BB :                            ;		db	"SAVE"		;DATA "SAVE"
  247/ 2BB : D3                         		db	"S"+80h
  248/ 2BC : C1                         		db	"A"+80h
  249/ 2BD : D6                         		db	"V"+80h
  250/ 2BE : C5                         		db	"E"+80h
  251/ 2BF : 04                         		db	4		;DATA 004		; CC FOR LOAD
  252/ 2C0 :                            ;		db	"LOAD"		;DATA "LOAD"
  253/ 2C0 : CC                         		db	"L"+80h
  254/ 2C1 : CF                         		db	"O"+80h
  255/ 2C2 : C1                         		db	"A"+80h
  256/ 2C3 : C4                         		db	"D"+80h
  257/ 2C4 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; UNCLEAR WHAT THIS IS (01 304-01 317) ZEROS
  258/ 2C8 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; (PROBABLY STEP, FOR/NEXT, AND ARRAY PTR TEMP)
  259/ 2CC : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
  260/ 2D0 :                            					;; AT THIS POINT WE SHOULD BE AT LOCATION 01 320 01d0h
  261/ 2D0 : 04                         		db	4		;DATA 4
  262/ 2D1 :                            ;		db	"THEN"		;DATA "THEN"
  263/ 2D1 : D4                         		db	"T"+80h
  264/ 2D2 : C8                         		db	"H"+80h
  265/ 2D3 : C5                         		db	"E"+80h
  266/ 2D4 : CE                         		db	"N"+80h
  267/ 2D5 : 02                         		db	2		;DATA 2
  268/ 2D6 :                            ;		db	"TO"		;DATA "TO"
  269/ 2D6 : D4                         		db	"T"+80h
  270/ 2D7 : CF                         		db	"O"+80h
  271/ 2D8 : 04                         		db	4		;DATA 4
  272/ 2D9 :                            ;		db	"STEP"		;DATA "STEP"
  273/ 2D9 : D3                         		db	"S"+80h
  274/ 2DA : D4                         		db	"T"+80h
  275/ 2DB : C5                         		db	"E"+80h
  276/ 2DC : D0                         		db	"P"+80h
  277/ 2DD : 04                         		db	4		;DATA 4
  278/ 2DE :                            ;		db	"LIST"		;DATA "LIST"
  279/ 2DE : CC                         		db	"L"+80h
  280/ 2DF : C9                         		db	"I"+80h
  281/ 2E0 : D3                         		db	"S"+80h
  282/ 2E1 : D4                         		db	"T"+80h
  283/ 2E2 : 03                         		db	3		;DATA 3
  284/ 2E3 :                            ;		db	"RUN"		;DATA "RUN"
  285/ 2E3 : D2                         		db	"R"+80h
  286/ 2E4 : D5                         		db	"U"+80h
  287/ 2E5 : CE                         		db	"N"+80h
  288/ 2E6 : 03                         		db	3		;DATA 3
  289/ 2E7 :                            ;		db	"SCR"		;DATA "SCR
  290/ 2E7 : D3                         		db	"S"+80h
  291/ 2E8 : C3                         		db	"C"+80h
  292/ 2E9 : D2                         		db	"R"+80h
  293/ 2EA : 0B                         		db	013o		;DATA 013		; CC FOR "READY" MESSAGE
  294/ 2EB : 94 8D 8A                   		db	224o,215o,212o	;DATA 224,215,212	; CTRL-T, CARRIAGE RETURN, LINE FEED
  295/ 2EE :                            ;		db	"READY"		;DATA "READY"
  296/ 2EE : D2                         		db	"R"+80h
  297/ 2EF : C5                         		db	"E"+80h
  298/ 2F0 : C1                         		db	"A"+80h
  299/ 2F1 : C4                         		db	"D"+80h
  300/ 2F2 : D9                         		db	"Y"+80h
  301/ 2F3 : 8D 8A 8A                   		db	215o,212o,212o	;DATA 215,212,212	; CARRIAGE RETURN, LINE FEED, LINE FEED;
  302/ 2F6 : 09                         		db	011o		;DATA 011
  303/ 2F7 :                            ;		db	" AT LINE "	;DATA " AT LINE "
  304/ 2F7 : A0                         		db	" "+80h
  305/ 2F8 : C1                         		db	"A"+80h
  306/ 2F9 : D4                         		db	"T"+80h
  307/ 2FA : A0                         		db	" "+80h
  308/ 2FB : CC                         		db	"L"+80h
  309/ 2FC : C9                         		db	"I"+80h
  310/ 2FD : CE                         		db	"N"+80h
  311/ 2FE : C5                         		db	"E"+80h
  312/ 2FF : A0                         		db	" "+80h
  313/ 300 :                            
  314/ 300 :                            	;; THIS SHOULD BE THE END OF PAGE 01
  315/ 300 :                            
  316/ 300 :                            	ORG	PG26 * 100h	;026#000
  317/ 300 :                            
  318/ 300 : 00                         	db	0		;DATA 000		; CC FOR INPUT LINE BUFFER
  319/ 301 : 00 00 00 00 00 00 00 00 00 	db	79 dup (0)	;DATA *79 		; THE INPUT LINE BUFFER
       30A : 00 00 00 00 00 00 00 00 00
       313 : 00 00 00 00 00 00 00 00 00
       31C : 00 00 00 00 00 00 00 00 00
       325 : 00 00 00 00 00 00 00 00 00
       32E : 00 00 00 00 00 00 00 00 00
       337 : 00 00 00 00 00 00 00 00 00
       340 : 00 00 00 00 00 00 00 00 00
       349 : 00 00 00 00 00 00 00      
  320/ 350 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; THESE ARE SYMBOL BUFFER STORAGE
  321/ 354 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
  322/ 358 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; SHOULD BE 26-120 TO 26 143
  323/ 35C : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
  324/ 360 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
  325/ 364 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; THESE LOCATIONS ARE AUXILIARY SYMBOL BUFFER
  326/ 368 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
  327/ 36C : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; SHOULD BE 26 144 TO 26 175
  328/ 370 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
  329/ 374 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
  330/ 378 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
  331/ 37C : 00 00                      	db	0,0		;DATA 000,000
  332/ 37E : 00                         	db	0		;DATA 000		; TEMP SCAN STORAGE REGISTER
  333/ 37F : 00                         	db	0		;DATA 000		; TAB FLAG
  334/ 380 : 00                         	db	0		;DATA 000		; EVAL CURRENT TEMP REG.
  335/ 381 : 00                         	db	0		;DATA 000		; SYNTAX LINE NUMBER
  336/ 382 : 00                         	db	0		;DATA 000		; SCAN TEMPORARY REGISTER
  337/ 383 : 00                         	db	0		;DATA 000		; STATEMENT TOKEN
  338/ 384 : 00 00                      	db	0,0		;DATA 000,000		; TEMPORARY WORKING REGISTERS
  339/ 386 : 00 00                      	db	0,0		;DATA 000,000		; ARRAY POINTERS
  340/ 388 :                            ;;; NOW WE SHOULD BE UP TO 26 210 1688h
  341/ 388 : 00                         	db	0		;DATA 000		; OPERATOR STACK POINTER
  342/ 389 : 00 00 00 00 00 00 00 00 00 	db	15 dup (0)	;DATA *15		; OPERATOR STACK
       392 : 00 00 00 00 00 00         
  343/ 398 : 00                         	db	0		;DATA 000		; FUN/ARRAY STACK POINTER
  344/ 399 : 00 00 00 00 00 00 00       	db	7 dup (0)	;DATA *7			; FUNCTION/ARRAY STACK
  345/ 3A0 :                            ;;; THE LAST BYTE SHOULD HAVE BEEN 26 237 169fh
  346/ 3A0 :                            
  347/ 3A0 :                            
  348/ 3A0 :                            	;; HEIRARCHY TABLE (FOR OUT OF STACK OPS)
  349/ 3A0 :                            	;; USED BY PARSER ROUTINE.
  350/ 3A0 :                            ;;; This SHOULD START AT 26 240
  351/ 3A0 : 00                         	db	0		;DATA 000		; EOS
  352/ 3A1 : 03                         	db	3		;DATA 003		; PLUS SIGN
  353/ 3A2 : 03                         	db	3		;DATA 003		; MINUS SIGN
  354/ 3A3 : 04                         	db	4		;DATA 004		; MULTIPLICATION SIGN
  355/ 3A4 : 04                         	db	4		;DATA 004		; DIVISION SIGN
  356/ 3A5 : 05                         	db	5		;DATA 005		; EXPONENT SIGN
  357/ 3A6 : 06                         	db	6		;DATA 006		; LEFT PARENTHESIS
  358/ 3A7 : 01                         	db	1		;DATA 001		; RIGHT PARENTHESIS
  359/ 3A8 : 02                         	db	2		;DATA 002		; NOT ASSIGNED
  360/ 3A9 : 02                         	db	2		;DATA 002		; LESS THAN SIGN
  361/ 3AA : 02                         	db	2		;DATA 002		; Equal sign
  362/ 3AB : 02                         	db	2		;DATA 002		; GREATER THAN SIGN
  363/ 3AC : 02                         	db	2		;DATA 002		; LESS THAN OR EQUAL COMBO
  364/ 3AD : 02                         	db	2		;DATA 002		; EQUAL OR GREATER THAN
  365/ 3AE : 02                         	db	2		;DATA 002		; LESS THAN OR GREATER THAN
  366/ 3AF :                            
  367/ 3AF :                            	;; HEIRARCHY TABLE (FOR INTO STACK OPS)
  368/ 3AF :                            	;; USED BY PARSER ROUTINE.
  369/ 3AF :                            ;;; This SHOULD START AT 26 257 16afh
  370/ 3AF : 00                         	db	0		;DATA 000		; EOS
  371/ 3B0 : 03                         	db	3		;DATA 003		; PLUS SIGN
  372/ 3B1 : 03                         	db	3		;DATA 003		; MINUS SIGN
  373/ 3B2 : 04                         	db	4		;DATA 004		; MULTIPLICATION SIGN
  374/ 3B3 : 04                         	db	4		;DATA 004		; DIVISION SIGN
  375/ 3B4 : 05                         	db	5		;DATA 005		; EXPONENTIATION SIGN
  376/ 3B5 : 01                         	db	1		;DATA 001		; LEFT PARENTHESIS
  377/ 3B6 : 01                         	db	1		;DATA 001		; RIGHT PARENTHESIS
  378/ 3B7 : 02                         	db	2		;DATA 002		; NOT ASSIGNED
  379/ 3B8 : 02                         	db	2		;DATA 002		; LESS THAN SIGN
  380/ 3B9 : 02                         	db	2		;DATA 002		; EQUAL SIGN
  381/ 3BA : 02                         	db	2		;DATA 002		; GREATER THAN SIGN
  382/ 3BB : 02                         	db	2		;DATA 002		; LESS THAN OR EQUAL SIGN
  383/ 3BC : 02                         	db	2		;DATA 002		; EQUAL TO OR GREATER THAN
  384/ 3BD : 02                         	db	2		;DATA 002		; LESS THAN OR GREATER THAN
  385/ 3BE :                            
  386/ 3BE : 00                         	db	0		;DATA 000		; EVAL START POINTER
  387/ 3BF : 00                         	db	0		;DATA 000		; EVAL FINISH POINTER
  388/ 3C0 :                            
  389/ 3C0 :                            	;; FUNCTION NAMES TABLE
  390/ 3C0 :                            ;;; This SHOULD START AT 26 300 16c0h
  391/ 3C0 :                            
  392/ 3C0 : 03                         	db	3		;DATA 3
  393/ 3C1 :                            ;	db	"INT"		;DATA "INT"
  394/ 3C1 : C9                         	db	"I"+80h
  395/ 3C2 : CE                         	db	"N"+80h
  396/ 3C3 : D4                         	db	"T"+80h
  397/ 3C4 : 03                         	db	3		;DATA 3
  398/ 3C5 :                            ;	db	"SGN"		;DATA "SGN"
  399/ 3C5 : D3                         	db	"S"+80h
  400/ 3C6 : C7                         	db	"G"+80h
  401/ 3C7 : CE                         	db	"N"+80h
  402/ 3C8 : 03                         	db	3		;DATA 3
  403/ 3C9 :                            ;	db	"ABS"		;DATA "ABS"
  404/ 3C9 : C1                         	db	"A"+80h
  405/ 3CA : C2                         	db	"B"+80h
  406/ 3CB : D3                         	db	"S"+80h
  407/ 3CC : 03                         	db	3		;DATA 3
  408/ 3CD :                            ;	db	"SQR"		;DATA "SQR"
  409/ 3CD : D3                         	db	"S"+80h
  410/ 3CE : D1                         	db	"Q"+80h
  411/ 3CF : D2                         	db	"R"+80h
  412/ 3D0 : 03                         	db	3		;DATA 3
  413/ 3D1 :                            ;	db	"TAB"		;DATA "TAB"
  414/ 3D1 : D4                         	db	"T"+80h
  415/ 3D2 : C1                         	db	"A"+80h
  416/ 3D3 : C2                         	db	"B"+80h
  417/ 3D4 : 03                         	db	3		;DATA 3
  418/ 3D5 :                            ;	db	"RND"		;DATA "RND"
  419/ 3D5 : D2                         	db	"R"+80h
  420/ 3D6 : CE                         	db	"N"+80h
  421/ 3D7 : C4                         	db	"D"+80h
  422/ 3D8 : 03                         	db	3		;DATA 3
  423/ 3D9 :                            ;	db	"CHR"		;DATA "CHR"
  424/ 3D9 : C3                         	db	"C"+80h
  425/ 3DA : C8                         	db	"H"+80h
  426/ 3DB : D2                         	db	"R"+80h
  427/ 3DC : 03                         	db	3		;DATA 3
  428/ 3DD :                            ;	db	"UDF"		;DATA "UDF"
  429/ 3DD : D5                         	db	"U"+80h
  430/ 3DE : C4                         	db	"D"+80h
  431/ 3DF : C6                         	db	"F"+80h
  432/ 3E0 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; LINE NUMBER BUFFER STORAGE
  433/ 3E4 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; (SHOULD BE 340-347)
  434/ 3E8 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; AUX LINE NUMBER BUFFER
  435/ 3EC : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; (SHOULD BE 350-357)
  436/ 3F0 :                            ;;; The following data is a change in page 3 of Scelbal update issue 4
  437/ 3F0 :                            ;;; which apparently makes the "INSERT" command work correctly, the
  438/ 3F0 :                            ;;; first time (later SCR commands load 33 into this spot) 
  439/ 3F0 : 1B                         	db	033o		;DATA 033 		; USER PGM LINE PTR (PG)
  440/ 3F1 : 00                         	db	0		;DATA 000 		; USER PGM LINE PTR (LOW)
  441/ 3F2 : 00                         	db	0		;DATA 000 		; AUX PGM LINE PTR (PG)
  442/ 3F3 : 00                         	db	0		;DATA 000 		; AUX PGM LINE PTR (LOW)
  443/ 3F4 : 00                         	db	0		;DATA 000 		; END OF USER PGM BUFFER PTR (PG)
  444/ 3F5 : 00                         	db	0		;DATA 000 		; END OF USER PGM BUFFER PTR (LOW)
  445/ 3F6 : 00                         	db	0		;DATA 000		; PARENTHESIS COUNTER (366)
  446/ 3F7 : 00                         	db	0		;DATA 000		; QUOTE INDICATOR
  447/ 3F8 : 00                         	db	0		;DATA 000		; TABLE COUNTER (370)
  448/ 3F9 :                            ;;; locations 371-377 NOT ASSIGNED
  449/ 3F9 :                            
  450/ 400 :                            	org	PG27 * 100h		;ORG 027#000
  451/ 400 : 03                         	db	3		;DATA 3
  452/ 401 :                            ;	db	"REM"		;DATA "REM"
  453/ 401 : D2                         	db	"R"+80h
  454/ 402 : C5                         	db	"E"+80h
  455/ 403 : CD                         	db	"M"+80h
  456/ 404 : 02                         	db	2		;DATA 2
  457/ 405 :                            ;	db	"IF"		;DATA "IF"
  458/ 405 : C9                         	db	"I"+80h
  459/ 406 : C6                         	db	"F"+80h
  460/ 407 : 03                         	db	3		;DATA 3
  461/ 408 :                            ;	db	"LET"		;DATA "LET"
  462/ 408 : CC                         	db	"L"+80h
  463/ 409 : C5                         	db	"E"+80h
  464/ 40A : D4                         	db	"T"+80h
  465/ 40B : 04                         	db	4		;DATA 4
  466/ 40C :                            ;	db	"GOTO"		;DATA "GOTO"
  467/ 40C : C7                         	db	"G"+80h
  468/ 40D : CF                         	db	"O"+80h
  469/ 40E : D4                         	db	"T"+80h
  470/ 40F : CF                         	db	"O"+80h
  471/ 410 : 05                         	db	5		;DATA 5
  472/ 411 :                            ;	db	"PRINT"		;DATA "PRINT"
  473/ 411 : D0                         	db	"P"+80h
  474/ 412 : D2                         	db	"R"+80h
  475/ 413 : C9                         	db	"I"+80h
  476/ 414 : CE                         	db	"N"+80h
  477/ 415 : D4                         	db	"T"+80h
  478/ 416 : 05                         	db	5		;DATA 5
  479/ 417 :                            ;	db	"INPUT"		;DATA "INPUT"
  480/ 417 : C9                         	db	"I"+80h
  481/ 418 : CE                         	db	"N"+80h
  482/ 419 : D0                         	db	"P"+80h
  483/ 41A : D5                         	db	"U"+80h
  484/ 41B : D4                         	db	"T"+80h
  485/ 41C : 03                         	db	3		;DATA 3
  486/ 41D :                            ;	db	"FOR"		;DATA "FOR"
  487/ 41D : C6                         	db	"F"+80h
  488/ 41E : CF                         	db	"O"+80h
  489/ 41F : D2                         	db	"R"+80h
  490/ 420 : 04                         	db	4		;DATA 4
  491/ 421 :                            ;	db	"NEXT"		;DATA "NEXT"
  492/ 421 : CE                         	db	"N"+80h
  493/ 422 : C5                         	db	"E"+80h
  494/ 423 : D8                         	db	"X"+80h
  495/ 424 : D4                         	db	"T"+80h
  496/ 425 : 05                         	db	5		;DATA 5
  497/ 426 :                            ;	db	"GOSUB"		;DATA "GOSUB"
  498/ 426 : C7                         	db	"G"+80h
  499/ 427 : CF                         	db	"O"+80h
  500/ 428 : D3                         	db	"S"+80h
  501/ 429 : D5                         	db	"U"+80h
  502/ 42A : C2                         	db	"B"+80h
  503/ 42B : 06                         	db	6		;DATA 6
  504/ 42C :                            ;	db	"RETURN"	;DATA "RETURN"
  505/ 42C : D2                         	db	"R"+80h
  506/ 42D : C5                         	db	"E"+80h
  507/ 42E : D4                         	db	"T"+80h
  508/ 42F : D5                         	db	"U"+80h
  509/ 430 : D2                         	db	"R"+80h
  510/ 431 : CE                         	db	"N"+80h
  511/ 432 : 03                         	db	3		;DATA 3
  512/ 433 :                            ;	db	"DIM"		;DATA "DIM"
  513/ 433 : C4                         	db	"D"+80h
  514/ 434 : C9                         	db	"I"+80h
  515/ 435 : CD                         	db	"M"+80h
  516/ 436 : 03                         	db	3		;DATA 3
  517/ 437 :                            ;	db	"END"		;DATA "END"
  518/ 437 : C5                         	db	"E"+80h
  519/ 438 : CE                         	db	"N"+80h
  520/ 439 : C4                         	db	"D"+80h
  521/ 43A : 00                         	db	0		;DATA 0
  522/ 43B :                            
  523/ 43B :                            	; END OF TABLE, SHOULD BE 072 3ah
  524/ 43B :                            
  525/ 43B : 00                         	db	0		;DATA 000		; GOSUB STACK POINTER
  526/ 43C : 00                         	db	0		;DATA *1			; NOT ASSIGNED;
  527/ 43D : 00                         	db	0		;DATA 000		; NUMBER OF ARRAYS COUNTER
  528/ 43E : 00                         	db	0		;DATA 000		; ARRAY POINTER
  529/ 43F : 00                         	db	0		;DATA 000		; VARIABLES COUNTER SHOULD BE 077
  530/ 440 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; USED AS THE GOSUB STACK 100-117
  531/ 444 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
  532/ 448 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
  533/ 44C : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
  534/ 450 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; USED AS ARRAY VARIABLES TABLE
  535/ 454 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; SHOULD BE 120-137
  536/ 458 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
  537/ 45C : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
  538/ 460 :                            
  539/ 460 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; USED FOR FOR/NEXT STACK STORAGE
  540/ 464 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; SHOULD BE 140 TO 177
  541/ 468 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
  542/ 46C : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
  543/ 470 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
  544/ 474 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
  545/ 478 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
  546/ 47C : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
  547/ 480 : 00                         	db	0		;DATA 000		; FOR/NEXT STACK POINTER
  548/ 481 : 00                         	db	0		;DATA 000		; ARRAY/VARIABLE FLAG
  549/ 482 : 00                         	db	0		;DATA 000  		; STOSYM COUNTER
  550/ 483 : 00                         	db	0		;DATA 000		; FUN/ARRAY STACK POINTER (203
  551/ 484 : 00                         	db	0		;DATA 000		; ARRAY VALUES POINTER
  552/ 485 : 00 00 00                   	db	0,0,0		;DATA *3			; NOT USED (SHOULD BE 205-207)
  553/ 488 : 00                         	db	0		;DATA 000		; USED AS VARIABLES SYMBOL TABLE
  554/ 489 : 00 00 00 00 00 00 00 00 00 	db	119 dup (0)	;DATA *119		; (SHOULD BE 211-377 RESERVED)
       492 : 00 00 00 00 00 00 00 00 00
       49B : 00 00 00 00 00 00 00 00 00
       4A4 : 00 00 00 00 00 00 00 00 00
       4AD : 00 00 00 00 00 00 00 00 00
       4B6 : 00 00 00 00 00 00 00 00 00
       4BF : 00 00 00 00 00 00 00 00 00
       4C8 : 00 00 00 00 00 00 00 00 00
       4D1 : 00 00 00 00 00 00 00 00 00
       4DA : 00 00 00 00 00 00 00 00 00
       4E3 : 00 00 00 00 00 00 00 00 00
       4EC : 00 00 00 00 00 00 00 00 00
       4F5 : 00 00 00 00 00 00 00 00 00
       4FE : 00 00                     
  555/ 500 :                            
  556/2000 :                                       ORG	code_start	;002#000		; START PAGE 02, THE CODE
  557/2000 :                            
  558/2000 : 46 AD 20                   SYNTAX:    CALL	CLESYM		;Clear the SYMBOL BUFFER area
  559/2003 : 36 E0                                 MVI	L,0e0h	;340o	;Set L to start of LINE NUMBER BUFFER
  560/2005 : 2E 03                                 MVI	H,PG26	;	;** Set H to page of LINE NUMBER BUFFER
  561/2007 : 3E 00                                 MVI	M,0	;000o	;Initialize line number buff by placing zero as (cc)
  562/2009 : 36 81                                 MVI	L, 201o		;Change pointer to syntax counter/pointer storage loc.
  563/200B : 3E 01                                 MVI	M, 001o		;Set pointer to first character (after cc) in line buffer
  564/200D : 36 81                      SYNTX1:    MVI	L, 201o		;Set pointer to syntax cntr/pntr storage location
  565/200F : 46 A0 20                              CALL	GETCHR		;Fetch the character pointed to by contents of syntax
  566/2012 : 68 24 20                              JZ	SYNTX2		;Cntr/pntr from the line input buffer. If character was
  567/2015 : 3C B0                                 CPI	260o		;A space, ignore. Else, test to see if character was ASCII
  568/2017 : 70 31 20                              JM	SYNTX3		;Code for a decimal digit. If not a decimal digit, consider
  569/201A : 3C BA                                 CPI	272o		;Line number to have been processed by jumping
  570/201C : 50 31 20                              JP	SYNTX3		;Over the remainder of this SYNTX1 section.
  571/201F : 36 E0                                 MVI	L, 340o		;If have decimal digit, set pointer to start of LINE
  572/2021 : 46 CC 20                              CALL	CONCT1		;NUMBER BUFFER and append incoming digit there.
  573/2024 : 36 81                      SYNTX2:    MVI	L, 201o		;Reset L to syntax cntr/pntr storage location. Call sub-
  574/2026 : 46 03 21                              CALL	LOOP		;Routine to advance pntr and test for end of inr)ut buffer
  575/2029 : 48 0D 20                              JNZ	SYNTX1		;If not end of input buffer, go back for next digit
  576/202C : 36 83                                 MVI	L, 203o		;If end of buffer, only had a line number in the line.
  577/202E : 3E 00                                 MVI	M, 000o		;Set pntr to TOKEN storage location. Set TOKEN = 000.
  578/2030 : 07                                    RET			;Return to caller.
  579/2031 : 36 81                      SYNTX3:    MVI	L, 201o		;Reset pointer to syntax cntr/pntr and fetch
  580/2033 : CF                                    MOV	B,M		;Position of next character after the line number
  581/2034 : 36 82                                 MVI	L, 202o		;Change pntr to SCAN pntr storage location
  582/2036 : F9                                    MOV	M,B		;Store address when SCAN takes up after line number
  583/2037 : 36 82                      SYNTX4:    MVI	L, 202o		;Set pntr to SCAN pntr stomge location
  584/2039 : 46 A0 20                              CALL	GETCHR		;Fetch the character pointed to by contents of the SCAN
  585/203C : 68 54 20                              JZ	SYNTX6		;Pointer storage location. If character was ASCII code
  586/203F : 3C BD                                 CPI	275o		;For space, ignore. Else, compare character with "=" sign
  587/2041 : 68 88 20                              JZ	SYNTX7		;If is an equal sign, go set TOKEN for IMPLIED LET.
  588/2044 : 3C A8                                 CPI	250o		;Else, compare character with left parenthesis " ( "
  589/2046 : 68 8D 20                              JZ	SYNTX8		;If left parenthesis, go set TOKEN for implied array LET
  590/2049 : 46 C8 20                              CALL	CONCTS		;Otherwise, concatenate the character onto the string
  591/204C :                            				; MGA 4/2012 begin "fast SYNTX5" patch: 
  592/204C :                            				; the following patch doubles the overall speed of execution.  
  593/204C :                            				; It is similar to the approach taken on 8080 SCELBAL II in 1978 
  594/204C :                            				; it adhears to the rules for patches in issue 1 of SCELBAL update 
  595/204C :                            				;SYNTX6:   these four lines moved up w/o label
  596/204C : 36 82                                 MVI	L, 202o		;Set L to SCAN pointer storage location
  597/204E :                            				;LHI \HB\OLDPG26       ;** Set H to page of SCAN pointer stomge location
  598/204E :                            				;MGA 4/2012 except LHI needed at original place, not here 
  599/204E : 46 03 21                              CALL	LOOP		;Call routine to advance pntr & test for end of In buffer
  600/2051 : 48 37 20                              JNZ	SYNTX4		;Go back and add another character to SYMBOL BUFF
  601/2054 :                            SYNTX6:   			; MGA 4/2012 label here 
  602/2054 : 36 83                                 MVI	L, 203o		;Being constructed in the SYMBOL BUFFER. Now set
  603/2056 : 3E 01                                 MVI	M, 001o		;Up TOKEN storage location to an initial value of 001.
  604/2058 : 2E 04                                 MVI	H,PG27		;\HB\OLDPG27   ;** Set H to point to start of KEYWORD TABLE.
  605/205A : 36 00                                 MVI	L, 000o		;Set L to point to start of KEYWORD TABLE.
  606/205C : 1E 03                      SYNTX5:    MVI	D,PG26		;\HB\OLDPG26   ;** Set D to page of SYMBOL BUFFER
  607/205E : 26 50                                 MVI	E, 120o		;Set E to start of SYMBOL BUFFER
  608/2060 : 46 DA 20                              CALL	STRCP		;Compare char string presently in SYMBOL BUFFER
  609/2063 : 2B                                    RZ			;With entry in KEYWORD TABLE. Exit if match.
  610/2064 : 46 D9 30                              CALL	SWITCH		;TOKEN will be set to keyword found. Else, switch
  611/2067 : 30                         SYNTXL:    INR	L		;Pointers to get table address back and advance pntr to
  612/2068 : C7                                    MOV	A,M		;KEYWORD TABLE. Now look for start of next entry
  613/2069 : 24 C0                                 ANI	300o		;In KEYWORD TABLE by looking for (cc) byte which
  614/206B : 48 67 20                              JNZ	SYNTXL             ;Will NOT have a one in the two most sig. bits. Advance
  615/206E : 46 D9 30                              CALL	SWITCH             ;Pntr til next entry found. Then switch pointers apin so
  616/2071 : 36 83                                 MVI	L, 203o               ;Table pointer is in D&E. Put addr of TOKEN in L.
  617/2073 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** And page of TOKEN in H. Fetch the value currently
  618/2075 : CF                                    MOV	B,M                    ;In TOKEN and advance it to account for going on to
  619/2076 : 08                                    INR	B                    ;The next entry in the KEYWORD TABLE.
  620/2077 : F9                                    MOV	M,B                    ;Restore the updated TOKEN value back to storage.
  621/2078 : 46 D9 30                              CALL	SWITCH             ;Restore the keyword table pointer back to H&L.
  622/207B : C1                                    MOV	A,B                    ;Put TOKEN count in ACC.
  623/207C : 3C 0D                                 CPI	015o               ;See if have tested all entries in the keyword table.
  624/207E : 48 5C 20                              JNZ	SYNTX5             ;If not, continue checking the keyword table.
  625/2081 :                            				;MGA 4/2012 3 of 4 lines removed below (keep LHI)
  626/2081 : 2E 16                                 MVI	H, 26o	;\HB\OLDPG26        ;** Set H to page of SCAN pointer stomge location
  627/2083 :                            				; MGA 4/2012 end of "fast SYNTX5" patch: 
  628/2083 : 36 83                                 MVI	L, 203o               ;And search table for KEYWORD again. Unless reach
  629/2085 : 3E FF                                 MVI	M, 377o               ;End of line input buffer. In which case set TOKEN=377
  630/2087 : 07                                    RET                    ;As an error indicator and exit to caMVI L,ng routine.
  631/2088 : 36 83                      SYNTX7:    MVI	L, 203o               ;Set pointer to TOKEN storage register. Set TOKEN
  632/208A : 3E 0D                                 MVI	M, 015o               ;Equal to 015 when "=" sign found for IMPLIED LET.
  633/208C : 07                                    RET                    ;Exit to caMVI L,ng routine.
  634/208D : 36 83                      SYNTX8:    MVI	L, 203o               ;Set pointer to TOKEN storage register. Set TOKEN
  635/208F : 3E 0E                                 MVI	M, 016o               ;Equal to 016 when "(" found for IMPLIED array LET.
  636/2091 : 07                                    RET                    ;Exit to calling routine.
  637/2092 :                            
  638/2092 :                                                              ;The following are subroutines used by SYNTAX and
  639/2092 :                                                              ;other routines in SCELBAL.
  640/2092 :                            
  641/2092 : 06 C2                      BIGERR:    MVI	A, 302o               ;Load ASCII code for letters B and G to indicate BIG
  642/2094 : 16 C7                                 MVI	C, 307o               ;ERROR (for when buffer, stack,etc., overflows).
  643/2096 : 46 82 21                   ERROR:     CALL	ECHO               ;Call user provided display routine to print ASCII code
  644/2099 : C2                                    MOV	A,C                    ;In accumulator. Transfer ASCII code from C to ACC
  645/209A : 46 82 21                              CALL	ECHO               ;And repeat to display error codes.
  646/209D : 44 BB 28                              JMP	FINERR             ;Go cpmplete error message (AT LINE) as required.
  647/20A0 : C7                         GETCHR:    MOV	A,M                    ;Get pointer from memory location pointed to by H&L
  648/20A1 : 3C 50                                 CPI	120o               ;See if within range of line input buffer.
  649/20A3 : 50 92 20                              JP	BIGERR             ;If not then have an overflow condition = error.
  650/20A6 : F0                                    MOV	L,A                    ;Else can use it as addr of character to fetch from the
  651/20A7 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** LINE INPUT BUFFER by setting up H too.
  652/20A9 : C7                                    MOV	A,M                    ;Fetch the character from the line input buffer.
  653/20AA : 3C A0                                 CPI	240o               ;See if it is ASCII code for space.
  654/20AC : 07                                    RET                    ;Return to caller with flags set according to comparison.
  655/20AD : 36 50                      CLESYM:    MVI	L, 120o               ;Set L to start of SYMBOL BUFFER.
  656/20AF : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of SYMBOL BUFFER.
  657/20B1 : 3E 00                                 MVI	M, 000o               ;Place a zero byte at start of SYMBOL BUFFER.
  658/20B3 : 07                                    RET                    ;To effectively clear the buffer. Then exit to caller.
  659/20B4 :                            
  660/20B4 :                            
  661/20B4 :                                                              ;Subroutine to concatenate (append) a character to the
  662/20B4 :                                                              ;SYMBOL BUFFER. Character must be alphanumeric.
  663/20B4 :                            
  664/20B4 : 3C C1                      CONCTA:    CPI	301o               ;See if character code less than that for letter A.
  665/20B6 : 70 BE 20                              JM	CONCTN             ;If so, go see if it is numeric.
  666/20B9 : 3C DB                                 CPI	333o               ;See if character code greater than that for letter Z.
  667/20BB : 70 C8 20                              JM	CONCTS             ;If not, have valid alphabetical character.
  668/20BE : 3C B0                      CONCTN:    CPI	260o               ;Else, see if character in valid numeric range.
  669/20C0 : 70 D7 20                              JM	CONCTE             ;If not, have an error condition.
  670/20C3 : 3C BA                                 CPI	272o               ;Continue to check for valid number.
  671/20C5 : 50 D7 20                              JP	CONCTE             ;If not, have an error condition.
  672/20C8 : 36 50                      CONCTS:    MVI	L, 120o               ;If character alphanumeric, can concatenate. Set pointer
  673/20CA : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** To starting address of SYMBOL BUFFER.
  674/20CC : D7                         CONCT1:    MOV	C,M                    ;Fetch old character count in SYMBOL BUFFER.
  675/20CD : 10                                    INR	C                    ;Increment the value to account for adding new
  676/20CE : FA                                    MOV	M,C                    ;Character to the buffer. Restore updated (cc).
  677/20CF : C8                                    MOV	B,A                    ;Save character to be appended in register B.
  678/20D0 : 46 09 31                              CALL	INDEXC             ;Add (cc) to address in H & L to get new end of buffer
  679/20D3 : F9                                    MOV	M,B                    ;Address and append the new character to buffer
  680/20D4 : 06 00                                 MVI	A, 000o               ;Clear the accumulator
  681/20D6 : 07                                    RET                    ;Exit to caller
  682/20D7 : 44 6A 27                   CONCTE:    JMP	SYNERR             ;If character to be appended not alphanumeric, ERROR!
  683/20DA :                            
  684/20DA :                                                              ;Subroutine to compare
  685/20DA :                                                              ;character strings pointed to by
  686/20DA :                                                              ;register pairs D & E and H & L.
  687/20DA :                            
  688/20DA : C7                         STRCP:     MOV	A,M                    ;Fetch (cc) of first string.
  689/20DB : 46 D9 30                              CALL	SWITCH             ;Switch pointers and fetch length of second string (cc)
  690/20DE : CF                                    MOV	B,M                    ;Into register B. Compare the lengths of the two strings.
  691/20DF : B9                                    CMP	B                    ;If they are not the same
  692/20E0 : 0B                                    RNZ                    ;Return to caller with flags set to non-zero condition
  693/20E1 : 46 D9 30                              CALL	SWITCH             ;Else, exchange the pointers back to first string.
  694/20E4 : 46 FF 20                   STRCPL:    CALL	ADV                ;Advance the pointer to string number 1 and fetch a
  695/20E7 : C7                                    MOV	A,M                    ;Character from that string into the accumulator.
  696/20E8 : 46 D9 30                              CALL	SWITCH             ;Now switch the pointers to string number 2.
  697/20EB : 46 FF 20                              CALL	ADV                ;Advance the pointer in line number 2.
  698/20EE : BF                         STRCPE:    CMP	M                    ;Compare char in stxing 1 (ACC) to string 2 (memory)
  699/20EF : 0B                                    RNZ                    ;If not equal, return to cauer with flags set to non-zero
  700/20F0 : 46 D9 30                              CALL	SWITCH             ;Else, exchange pointers to restore pntr to string 1
  701/20F3 : 09                                    DCR	B                    ;Decrement the string length counter in register B
  702/20F4 : 48 E4 20                              JNZ	STRCPL             ;If not finiahed, continue testing entire string
  703/20F7 : 07                                    RET                    ;If complete match, return with flag in zero condition
  704/20F8 : C7                         STRCPC:    MOV	A,M                    ;Fetch character pointed to by pointer to string 1
  705/20F9 : 46 D9 30                              CALL	SWITCH             ;Exchange pointer to examine string 2
  706/20FC : 44 EE 20                              JMP	STRCPE             ;Continue the string comparison loop
  707/20FF :                            
  708/20FF :                                                              ;Subroutine to advance the two byte
  709/20FF :                                                              ;value in CPU registers H and L.
  710/20FF :                            
  711/20FF : 30                         ADV:       INR	L                    ;Advance value in register L.
  712/2100 : 0B                                    RNZ                    ;If new value not zero, return to caller.
  713/2101 : 28                                    INR	H                    ;Else must increment value in H
  714/2102 : 07                                    RET                    ;Before retuming to caller
  715/2103 :                            
  716/2103 :                                                              ;Subroutine to advance a buffer pointer
  717/2103 :                                                              ;and test to see if the end of the buffer
  718/2103 :                                                              ;has been reached.
  719/2103 :                            
  720/2103 : CF                         LOOP:      MOV	B,M                    ;Fetch memory location pointed to by H & L into B.
  721/2104 : 08                                    INR	B                    ;Increment the value.
  722/2105 : F9                                    MOV	M,B                    ;Restore it back to memory.
  723/2106 : 36 00                                 MVI	L, 000                ;Change pointer to start of INPUT LINE BUFFER
  724/2108 : C7                                    MOV	A,M                    ;Fetch buffer length (cc) value into the accumulator
  725/2109 : 09                                    DCR	B                    ;Make value in B original value
  726/210A : B9                                    CMP	B                    ;See if buffer length same as that in B
  727/210B : 07                                    RET                    ;Return with flags yielding results of the comparison
  728/210C :                            
  729/210C :                                                              ;The following subroutine is used to
  730/210C :                                                              ;input characters from the system's
  731/210C :                                                              ;input device (such as a keyboard)
  732/210C :                                                              ;into the LINE INPUT BUFFER. Routine has limited
  733/210C :                                                              ;editing capability included.
  734/210C :                                                              ;(Rubout = delete previous character(s) entered.)
  735/210C :                            ;;; This label, STRIN:	should be location 03 014 030ch
  736/210C : 16 00                      STRIN:     MVI	C, 000                ;Initialize register C to zero.
  737/210E : 46 91 21                   STRIN1:    CALL	CINPUT             ;Call user provided device input subroutine to fetch one
  738/2111 : 3C FF                                 CPI	0FFH	;modifiedby gazelle 2025/6/1 ;377o  ;Character from the input device. Is it ASCII code for
  739/2113 : 48 25 21                              JNZ	NOTDEL             ;Rubout? Skip to next section if not rubout.
  740/2116 :                            ;          MVI	A, 0DCH	;modified by Gazelle 2025/6/1 ;334o ;Else, load ASCII code for backslash into ACC.
  741/2116 :                            ;          CALL	ECHO	;modified by gazelle 2025/6/1 ;Call user display driver to present backslash as a delete
  742/2116 : 11                                    DCR	C                    ;Indicator. Now decrement the input character counter.
  743/2117 : 70 0C 21                              JM	STRIN              ;If at beginning of line do NOT decrement H and L.
  744/211A : 46 74 21                              CALL	DEC                ;Else, decrement H & L line pointer to erase previous
  745/211D : 06 DC                                 MVI	A, 0DCH	;modified by gazelle 2025/6/1
  746/211F : 46 82 21                              CALL	ECHO	;modified by gazelle 2025/6/1
  747/2122 :                            
  748/2122 : 44 0E 21                              JMP	STRIN1             ;Entry, then go back for a new input.
  749/2125 : 3C 83                      NOTDEL:    CPI	203o               ;See if character inputted was'CONTROL C'
  750/2127 : 68 B4 28                              JZ	CTRLC              ;If so, stop inputting and go back to the EXECutive
  751/212A : 3C 8D                                 CPI	215o               ;If not, see if character was carriage-return
  752/212C : 68 42 21                              JZ	STRINF             ;If so, have end of line of input
  753/212F : 3C 8A                                 CPI	212o               ;If not, see if character was line-feed
  754/2131 : 68 0E 21                              JZ	STRIN1             ;If so, ignore the input, get another character
  755/2134 : 46 FF 20                              CALL	ADV                ;If none of the above, advance contents of H & L
  756/2137 : 10                                    INR	C                    ;Increment the character counter
  757/2138 : F8                                    MOV	M,A                    ;Store the new character in the line input buffer
  758/2139 : C2                                    MOV	A,C                    ;Put new character count in the accumulator
  759/213A : 3C 50                                 CPI	120o               ;Make sure maximum buffer size not exceeded
  760/213C : 50 92 20                              JP	BIGERR             ;If buffer size exceeded, go display BG error message
  761/213F : 44 0E 21                              JMP	STRIN1             ;Else can go back to look for next input
  762/2142 : CA                         STRINF:    MOV	B,C                    ;Transfer character count from C to B
  763/2143 : 46 4B 21                              CALL	SUBHL              ;Subtract B from H & L to get starting address of
  764/2146 : FA                                    MOV	M,C                    ;The string and place the character count (cc) there
  765/2147 : 46 61 21                              CALL	CRLF               ;Provide a line ending CR & LF combination on the
  766/214A : 07                                    RET                    ;Display device. Then exit to caller.
  767/214B :                            
  768/214B :                                                              ;Subroutine to subtract contents of CPU register B from
  769/214B :                                                              ;the two byte value in CPU registers H & L.
  770/214B :                            
  771/214B : C6                         SUBHL:     MOV	A,L                    ;Load contents of register L into the accumulator
  772/214C : 91                                    SUB	B                    ;Subtract the contents of register B
  773/214D : F0                                    MOV	L,A                    ;Restore the new value back to L
  774/214E : 03                                    RNC                    ;If no carry, then no underflow. Exit to caller.
  775/214F : 29                                    DCR	H                    ;Else must also decrement contents of H.
  776/2150 : 07                                    RET                    ;Before retuming to caller.
  777/2151 :                            
  778/2151 :                                                              ;Subroutine to display a character string on the system's
  779/2151 :                                                              ;display device.
  780/2151 :                            
  781/2151 : D7                         TEXTC:     MOV	C,M                    ;Fetch (cc) from the first location in the buffer (H & L
  782/2152 : C7                                    MOV	A,M                    ;Pointing there upon entry) into register B and ACC.
  783/2153 : A0                                    ANA	A                    ;Test the character count value.
  784/2154 : 2B                                    RZ                    ;No display if (cc) is zero.
  785/2155 : 46 FF 20                   TEXTCL:    CALL	ADV                ;Advance pointer to next location in buffer
  786/2158 : C7                                    MOV	A,M                    ;Fetch a character from the buffer into ACC
  787/2159 : 46 82 21                              CALL	ECHO               ;Call the user's display driver subroutine
  788/215C : 11                                    DCR	C                    ;Decrement the (cc)
  789/215D : 48 55 21                              JNZ	TEXTCL             ;If character counter not zero, continue display
  790/2160 : 07                                    RET                    ;Exit to caller when (cc) is zero.
  791/2161 :                            
  792/2161 :                                                              ;Subroutine to provide carriage-return and line-feed
  793/2161 :                                                              ;combination to system's display device. Routine also
  794/2161 :                                                              ;initializes a column counter to zero. Column counter
  795/2161 :                                                              ;is used by selected output routines to count the num-
  796/2161 :                                                              ;ber of characters that have been displayed on a line.
  797/2161 :                            
  798/2161 : 06 8D                      CRLF:      MVI	A, 215o               ;Load ASCII code for carriage-return into ACC
  799/2163 : 46 82 21                              CALL	ECHO               ;Call user provided display driver subroutine
  800/2166 : 06 8A                                 MVI	A, 212o               ;Load ASCII code for line-feed into ACC
  801/2168 : 46 82 21                              CALL	ECHO               ;Call user provided display driver subroutine
  802/216B : 36 23                                 MVI	L, 043o               ;Set L to point to COLUMN COUNTER storage location
  803/216D : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of COLUMN COUNTER
  804/216F : 3E 01                                 MVI	M, 001o               ;Initialize COLUMN COUNTER to a value of one
  805/2171 : EB                                    MOV	H,D                    ;Restore H from D (saved by ECHO subroutine)
  806/2172 : F4                                    MOV	L,E                    ;Restore L from E (saved by ECHO subroutine)
  807/2173 : 07                                    RET                    ;Then exit to calling routine
  808/2174 :                            
  809/2174 :                                                              ;Subroutine to decrement double-byte value in CPU
  810/2174 :                                                              ;registers H and L.
  811/2174 :                            
  812/2174 : 31                         DEC:       DCR	L                    ;Decrement contents of L
  813/2175 : 30                                    INR	L                    ;Now increment to exercise CPU flags
  814/2176 : 48 7A 21                              JNZ	DECNO              ;If L not presently zero, skip decrementing H
  815/2179 : 29                                    DCR	H                    ;Else decrement H
  816/217A : 31                         DECNO:     DCR	L                    ;Do the actual decrement of L
  817/217B : 07                                    RET                    ;Return to caller
  818/217C :                            
  819/217C :                            
  820/217C :                                                              ;Subroutine to index the value in CPU registers H and L
  821/217C :                                                              ;by the contents of CPU register B.
  822/217C :                            
  823/217C : C6                         INDEXB:    MOV	A,L                    ;Load L into the accumulator
  824/217D : 81                                    ADD	B                    ;Add B to that value
  825/217E : F0                                    MOV	L,A                    ;Restore the new value to L
  826/217F : 03                                    RNC                    ;If no carry,  return to caller
  827/2180 : 28                                    INR	H                    ;Else, increment value in H
  828/2181 : 07                                    RET                    ;Before returning to caller
  829/2182 :                            
  830/2182 :                                                              ;The following subroutine is used to
  831/2182 :                                                              ;display the ASCII encoded character in the ACC on the
  832/2182 :                                                              ;system's display device. This routine calls a routine
  833/2182 :                                                              ;labeled CINPUT which must be provided by the user to
  834/2182 :                                                              ;actually drive the system's output device. The subroutine
  835/2182 :                                                              ;below also increments an output column counter each time
  836/2182 :                                                              ;it is used.
  837/2182 :                            
  838/2182 : DD                         ECHO:      MOV	D,H                    ;Save entry value of H in register D
  839/2183 : E6                                    MOV	E,L                    ;And save entry value of L in register E
  840/2184 : 36 23                                 MVI	L, 043o               ;Set L to point to COLUMN COUNTER storage location
  841/2186 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of COLUMN COUNTER
  842/2188 : CF                                    MOV	B,M                    ;Fetch the value in the COLUMN COUNTER
  843/2189 : 08                                    INR	B                    ;And increment it for each character displayed
  844/218A : F9                                    MOV	M,B                    ;Restore the updated count in memory
  845/218B : 46 71 01                              CALL	CPRINT             ;tt Call the user's device driver subroutine
  846/218E : EB                                    MOV	H,D                    ;Restore entry value of H from D
  847/218F : F4                                    MOV	L,E                    ;Restore entry value of L from E
  848/2190 : 07                                    RET                    ;Return to calling routine
  849/2191 : 44 5E 01                   CINPUT:	   JMP	CINP               ;Reference to user defined input subroutine
  850/2194 :                            
  851/2194 :                            ;;; The label EVAL: SHOULD BE AT 03 224 0394h
  852/2194 : 36 97                      EVAL:      MVI	L, 227o               ;Load L with address of ARITHMETIC STACK pointer
  853/2196 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of ARITHMETIC STACK pointer
  854/2198 : 3E 94                                 MVI	M, 224o               ;Initialize ARITH STACK pointer value to addr minus 4
  855/219A : 30                                    INR	L                    ;Advance memory pointer to FUN/ARRAY STACK pntr
  856/219B : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of FUN/ARRAY STACK pointer
  857/219D : 3E 00                                 MVI	M, 000o               ;Initialize FUNIARRAY STACK pointer to start of stack
  858/219F : 46 AD 20                              CALL	CLESYM             ;Initialize the SYMBOL BUFFER to empty condition
  859/21A2 : 36 88                                 MVI	L, 210o               ;Load L with address of OPERATOR STACK pointer
  860/21A4 : 3E 00                                 MVI	M, 000                ;Initialize OPERATOR STACK pointer value
  861/21A6 : 36 BE                                 MVI	L, 276o               ;Set L to address of EVAL pointer (start of expression)
  862/21A8 : CF                                    MOV	B,M                    ;Fetch the EVAL pointer value into register B
  863/21A9 : 36 80                                 MVI	L, 200o               ;Set up a working pointer register in this location
  864/21AB : F9                                    MOV	M,B                    ;And initialize EVAL CURRENT pointer
  865/21AC : 36 80                      SCAN1:     MVI	L, 200o               ;Load L with address of EVAL CURRENT pointer
  866/21AE : 46 A0 20                              CALL	GETCHR             ;Fetch a character in the expression being evaluated
  867/21B1 : 68 C1 22                              JZ	SCAN10             ;If character is a space, jump out of this section
  868/21B4 : 3C AB                                 CPI	253o               ;See if character is a "+" sign
  869/21B6 : 48 C0 21                              JNZ	SCAN2              ;If not, continue checking for an operator
  870/21B9 : 36 7E                                 MVI	L, 176o               ;If yes, set pointer to PARSER TOKEN storage location
  871/21BB : 3E 01                                 MVI	M, 001                ;Place TOKEN value for "+" sign in PARSER TOKEN
  872/21BD : 44 E9 21                              JMP	SCANFN             ;Go to PARSER subroutine entry point
  873/21C0 : 3C AD                      SCAN2:     CPI	255o               ;See if character is a minus ("-") sign
  874/21C2 : 48 EF 21                              JNZ	SCAN4              ;If not, continue checking for an operator
  875/21C5 : 36 50                                 MVI	L, 120o               ;If yes, check the length of the symbol stored in the
  876/21C7 : C7                                    MOV	A,M                    ;SYMBOL BUFFER by fetching the (cc) byte
  877/21C8 : A0                                    ANA	A                    ;And testing to see if (cc) is zero
  878/21C9 : 48 E5 21                              JNZ	SCAN3              ;If length not zero, then not a unary minus indicator
  879/21CC : 36 7E                                 MVI	L, 176o               ;Else, check to see if last operator was a right parenthesi
  880/21CE : C7                                    MOV	A,M                    ;By fetching the value in the PARSER TOKEN storage
  881/21CF : 3C 07                                 CPI	007                ;Location and seeing if it is token value for ")"
  882/21D1 : 68 E5 21                              JZ	SCAN3              ;If last operator was I')" then do not have a unary minus
  883/21D4 : 3C 03                                 CPI	003                ;Check to see if last operator was C4*~2
  884/21D6 : 68 6A 27                              JZ	SYNERR             ;If yes, then have a syntax error
  885/21D9 : 3C 05                                 CPI	005                ;Check to see if last operator was exponentiation
  886/21DB : 68 6A 27                              JZ	SYNERR             ;If yes, then have a syntax error
  887/21DE : 36 50                                 MVI	L, 120o               ;If none of the above, then minus sign is unary, put
  888/21E0 : 3E 01                                 MVI	M, 001                ;Character string representing the
  889/21E2 : 30                                    INR	L                    ;Value zero in the SYMBOL BUFFER in string format
  890/21E3 : 3E B0                                 MVI	M, 260o               ;(Character count (cc) followed by ASCII code for zero)
  891/21E5 : 36 7E                      SCAN3:     MVI	L, 176o               ;Set L to address of PARSER TOKEN storage location
  892/21E7 : 3E 02                                 MVI	M, 002                ;Set PARSER TOKEN value for minus operator
  893/21E9 : 46 D4 22                   SCANFN:    CALL	PARSER             ;Call the PARSER subroutine to process current symbol
  894/21EC : 44 C1 22                              JMP	SCAN10             ;And operator. Then jump to continue processing.
  895/21EF : 3C AA                      SCAN4:     CPI	252o               ;See if character fetched from expression is
  896/21F1 : 48 FB 21                              JNZ	SCAN5              ;If not, continue checking for an operator
  897/21F4 : 36 7E                                 MVI	L, 176o               ;If yes, set pointer to PARSER TOKEN storage location
  898/21F6 : 3E 03                                 MVI	M, 003                ;Place TOKEN value for "*" (multiplication) operator in
  899/21F8 : 44 E9 21                              JMP	SCANFN             ;PARSER TOKEN and go to PARSER subroutine entry
  900/21FB : 3C AF                      SCAN5:     CPI	257o               ;See if character fetched from expression is
  901/21FD : 48 07 22                              JNZ	SCAN6              ;If not, continue checking for an operator
  902/2200 : 36 7E                                 MVI	L, 176o               ;If yes, set pointer to PARSER TOKEN storage location
  903/2202 : 3E 04                                 MVI	M, 004                ;Place TOKEN value for "/" (division) operator in
  904/2204 : 44 E9 21                              JMP	SCANFN             ;PARSER TOKEN and go to PARSER subroutine entry
  905/2207 : 3C A8                      SCAN6:     CPI	250o               ;See if character fetched from expression is
  906/2209 : 48 1B 22                              JNZ	SCAN7              ;If not, continue checking for an operator
  907/220C : 36 98                                 MVI	L, 230o               ;If yes, load L with address of FUN/ARRAY STACK
  908/220E : CF                                    MOV	B,M                    ;Pointer. Fetch the value in the stack pointer. Increment
  909/220F : 08                                    INR	B                    ;It to indicate number of "(" operators encountered.
  910/2210 : F9                                    MOV	M,B                    ;Restore the updated stack pointer back to memory
  911/2211 : 46 40 25                              CALL	FUNARR             ;Call subroutine to process possible FUNCTION or
  912/2214 : 36 7E                                 MVI	L, 176o               ;ARRAY variable subscript. Ihen set pointer to
  913/2216 : 3E 06                                 MVI	M, 006                ;PARSER TOKEN storage and set value for operator
  914/2218 : 44 E9 21                              JMP	SCANFN             ;Go to PARSER subroutine entry point.
  915/221B : 3C A9                      SCAN7:     CPI	251o               ;See if character fetched from expression is
  916/221D : 48 34 22                              JNZ	SCAN8              ;If not, continue checking for an operator
  917/2220 : 36 7E                                 MVI	L, 176o               ;If yes, load L with address of PARSER TOKEN
  918/2222 : 3E 07                                 MVI	M, 007                ;Set PARSER TOKEN value to reflect ")"
  919/2224 : 46 D4 22                              CALL	PARSER             ;Call the  PARSER subroutine to process current symbol
  920/2227 :                            
  921/2227 : 46 03 25                              CALL	PRIGHT             ;Call subroutine to handle FUNCTION or ARRAY
  922/222A : 36 98                                 MVI	L, 230o               ;Load L with address of FUN/ARRAY STACK pointer
  923/222C : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of FUN/ARRAY STACK pointer
  924/222E : CF                                    MOV	B,M                    ;Fetch the value in the stack pointer. Decrement it
  925/222F : 09                                    DCR	B                    ;To account for left parenthesis just processed.
  926/2230 : F9                                    MOV	M,B                    ;Restore the updated value back to memory.
  927/2231 : 44 C1 22                              JMP	SCAN10             ;Jump to continue processing expression.
  928/2234 : 3C DE                      SCAN8:     CPI	336o               ;See if character fetched from expression is " t
  929/2236 : 48 40 22                              JNZ	SCAN9              ;If not, continue checking for an operator
  930/2239 : 36 7E                                 MVI	L, 176o               ;If yes, load L with address of PARSER TOKEN
  931/223B : 3E 05                                 MVI	M, 005                ;Put in value for exponentiation
  932/223D : 44 E9 21                              JMP	SCANFN             ;Go to PARSER subroutine entry point.
  933/2240 : 3C BC                      SCAN9:     CPI	274o               ;See if character fetched is the "less than" sign
  934/2242 : 48 63 22                              JNZ	SCAN11             ;If not, continue checking for an operator
  935/2245 : 36 80                                 MVI	L, 200o               ;If yes, set L to the EVAL CURRENT pointer
  936/2247 : CF                                    MOV	B,M                    ;Fetch the pointer
  937/2248 : 08                                    INR	B                    ;Increment it to point to the next character
  938/2249 : F9                                    MOV	M,B                    ;Restore the updated pointer value
  939/224A : 46 A0 20                              CALL	GETCHR             ;Fetch the next character in the expression
  940/224D : 3C BD                                 CPI	275o               ;Is the character the "= 9 $ sign?
  941/224F : 68 A9 22                              JZ	SCAN13             ;If so, have 'less than or equal" combination
  942/2252 : 3C BE                                 CPI	276o               ;Is the character the "greater than" sign?
  943/2254 : 68 B7 22                              JZ	SCAN15             ;If so, have "less than or greater than" combination
  944/2257 : 36 80                                 MVI	L, 200o               ;Else character is not part of the operator. Set L back
  945/2259 : CF                                    MOV	B,M                    ;To the EVAL CURRENT pointer. Fetch the pointer
  946/225A : 09                                    DCR	B                    ;Value and decriment it back one character in the
  947/225B : F9                                    MOV	M,B                    ;Expression. Restore the original pointer value.
  948/225C : 36 7E                                 MVI	L, 176o               ;Have just the 'less than" operator. Set L to the
  949/225E : 3E 09                                 MVI	M, 011o               ;PARSER TOKEN storage location and set the value for
  950/2260 : 44 E9 21                              JMP	SCANFN             ;The 'less than" sign then go to PARSER entry point.
  951/2263 : 3C BD                      SCAN11:    CPI	275o               ;See if character fetched is the "= " sign
  952/2265 : 48 86 22                              JNZ	SCAN12             ;If not, continue checking for an operator
  953/2268 : 36 80                                 MVI	L, 200o               ;If yes, set L to the EVAL CURRENT pointer
  954/226A : CF                                    MOV	B,M                    ;Fetch the pointer
  955/226B : 08                                    INR	B                    ;Increment it to point to the next character
  956/226C : F9                                    MOV	M,B                    ;Restore the updated pointer value
  957/226D : 46 A0 20                              CALL	GETCHR             ;Fetch the next character in the expression
  958/2270 : 3C BC                                 CPI	274o               ;Is the character the "less than" sign?
  959/2272 : 68 A9 22                              JZ	SCAN13             ;If so, have "less than or equal" combination
  960/2275 : 3C BE                                 CPI	276o               ;Is the character the "greater than" sign?
  961/2277 : 68 B0 22                              JZ	SCAN14             ;If so, have "equal or greater than" combination
  962/227A : 36 80                                 MVI	L, 200o               ;Else character is not part of the operator. Set L back
  963/227C : CF                                    MOV	B,M                    ;To the EVAL CURRENT pointer. Fetch the pointer
  964/227D : 09                                    DCR	B                    ;Value and decrement it back one character in the
  965/227E : F9                                    MOV	M,B                    ;Expression. Restore the original pointer value.
  966/227F : 36 7E                                 MVI	L, 176o               ;Just have '~-- " operator. Set L to the PARSER TOKEN
  967/2281 : 3E 0A                                 MVI	M, 012o               ;Storage location and set the value for the sign.
  968/2283 : 44 E9 21                              JMP	SCANFN             ;Go to the PARSER entry point.
  969/2286 : 3C BE                      SCAN12:    CPI	276o               ;See if character fetched is the "greater than" sign
  970/2288 : 48 BE 22                              JNZ	SCAN16             ;If not, go append the character to the SYMBOL BUFF
  971/228B : 36 80                                 MVI	L, 200o               ;If so, set L to the EVAL CURRENT pointer
  972/228D : CF                                    MOV	B,M                    ;Fetch the pointer
  973/228E : 08                                    INR	B                    ;Increment it to point to the next character
  974/228F : F9                                    MOV	M,B                    ;Restore the updated pointer value
  975/2290 : 46 A0 20                              CALL	GETCHR             ;Fetch the next character in the expression
  976/2293 : 3C BC                                 CPI	274o               ;Is the character the "less than" sign?
  977/2295 : 68 B7 22                              JZ	SCAN15             ;If so, have "less than or greater than" combination
  978/2298 : 3C BD                                 CPI	275o               ;Is the character the "= " sign?
  979/229A : 68 B0 22                              JZ	SCAN14             ;If so, have the "equal to or greater than " combination
  980/229D : 36 80                                 MVI	L, 200o               ;Else character is not part of the operator. Set L back
  981/229F : CF                                    MOV	B,M                    ;To the EVAL CURRENT pointer. Fetch the pointer
  982/22A0 : 09                                    DCR	B                    ;Value and decrement it back one character in the
  983/22A1 : F9                                    MOV	M,B                    ;Expression. Restore the original pointer value.
  984/22A2 : 36 7E                                 MVI	L, 176o               ;Have just the "greater than" operator. Set L to the
  985/22A4 : 3E 0B                                 MVI	M, 013o               ;PARSER TOKEN storage location and set the value for
  986/22A6 : 44 E9 21                              JMP	SCANFN             ;The "greater than" sign then go to PARSER entry
  987/22A9 : 36 7E                      SCAN13:    MVI	L, 176o               ;When have 'less than or equal" combination set L to
  988/22AB : 3E 0C                                 MVI	M, 014o               ;PARSER TOKEN storage location and set the value.
  989/22AD : 44 E9 21                              JMP	SCANFN             ;Then go to the PARSER entry point.
  990/22B0 : 36 7E                      SCAN14:    MVI	L, 176o               ;When have "equal to or greater than" combination set L
  991/22B2 : 3E 0D                                 MVI	M, 015o               ;To PARSER TOKEN storage location and set the value.
  992/22B4 : 44 E9 21                              JMP	SCANFN             ;Then go to the PARSER entry point.
  993/22B7 : 36 7E                      SCAN15:    MVI	L, 176o               ;When have 'less than or greater than" combination set
  994/22B9 : 3E 0E                                 MVI	M, 016o               ;L to PARSER TOKEN storage location and set value.
  995/22BB : 44 E9 21                              JMP	SCANFN             ;Then go to the PARSER entry point.
  996/22BE : 46 C8 20                   SCAN16:    CALL	CONCTS             ;Concatenate the character to the SYMBOL BUFFER
  997/22C1 : 36 80                      SCAN10:    MVI	L, 200o               ;Set L to the EVAL CURRENT pointer storage location
  998/22C3 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of EVAL CURRENT pointer
  999/22C5 : CF                                    MOV	B,M                    ;Fetch the EVAL CURRENT pointer value into B
 1000/22C6 : 08                                    INR	B                    ;Increment the pointer value to point to next character
 1001/22C7 : F9                                    MOV	M,B                    ;In the expression and restore the updated value.
 1002/22C8 : 36 BF                                 MVI	L, 277o               ;Set L to EVAL FINISH storage location.
 1003/22CA : C7                                    MOV	A,M                    ;Fetch the EVAL FINISH value into the accumulator.
 1004/22CB : 09                                    DCR	B                    ;Set B to last character processed in the expression.
 1005/22CC : B9                                    CMP	B                    ;See if last character was at EVAL FINISH location.
 1006/22CD : 48 AC 21                              JNZ	SCAN1              ;If not, continue processing the expression. Else, jump
 1007/22D0 : 44 98 35                              JMP	PARSEP             ;To final evaluation procedure and test.  (Directs routine
 1008/22D3 : 00                                    HLT             ;To a dislocated section.) Safety Halt in unused byte.
 1009/22D4 : 36 50                      PARSER:    MVI	L, 120o               ;Load L with starting address of SYMBOL BUFFER
 1010/22D6 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of SYMBOL BUFFER
 1011/22D8 : C7                                    MOV	A,M                    ;Fetch the (cc) for  contents of SYMBOL BUFFER
 1012/22D9 : A0                                    ANA	A                    ;Into the ACC and see if buffer is  empty
 1013/22DA : 68 99 23                              JZ	PARSE              ;If empty then no need to convert contents
 1014/22DD : 30                                    INR	L                    ;If not empty, advance buffer pointer
 1015/22DE : C7                                    MOV	A,M                    ;Fetch the first character in the buffer
 1016/22DF : 3C AE                                 CPI	256o               ;See if it is ASCII code for decimal sign
 1017/22E1 : 68 EE 22                              JZ	PARNUM             ;If yes, consider contents of buffer to be a number
 1018/22E4 : 3C B0                                 CPI	260o               ;If not decimal sign, see if first character represents
 1019/22E6 : 70 1B 23                              JM	LOOKUP             ;A deciinal digit, if not, should have a variable
 1020/22E9 : 3C BA                                 CPI	272o               ;Continue to test for a decimal digit
 1021/22EB : 50 1B 23                              JP	LOOKUP             ;If not, go look up the variable nwne
 1022/22EE : 31                         PARNUM:    DCR	L                    ;If SYMBOL BUFFER contains number, decrement
 1023/22EF : C7                                    MOV	A,M                    ;Buffer pointer back to (cc) and fetch it to ACC
 1024/22F0 : 3C 01                                 CPI	001o               ;See if length of string in buffer is just one
 1025/22F2 : 68 05 23                              JZ	NOEXPO             ;If so, cannot have number with scientific notation
 1026/22F5 : 86                                    ADD	L                    ;If not, add length to buffer pointer to
 1027/22F6 : F0                                    MOV	L,A                    ;Point to last character in the buffer
 1028/22F7 : C7                                    MOV	A,M                    ;Fetch the last character in buffer and see if it
 1029/22F8 : 3C C5                                 CPI	305o               ;Represents letter E for Exponent
 1030/22FA : 48 05 23                              JNZ	NOEXPO             ;If not, cannot have number with scientific notation
 1031/22FD : 36 80                                 MVI	L, 200o               ;If yes, have part of a scientific number, set pointer to
 1032/22FF : 46 A0 20                              CALL	GETCHR             ;Get the operator that follows the E and append it to
 1033/2302 : 44 C8 20                              JMP	CONCTS             ;The SYMBOL BUFFER and return to EVAL routine
 1034/2305 : 36 97                      NOEXPO:    MVI	L, 227o               ;Load L with address of ARITHMETIC STACK pointer
 1035/2307 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with page of ARITHMETIC STACK pointer
 1036/2309 : C7                                    MOV	A,M                    ;Fetch AS pointer value to ACC and add four to account
 1037/230A : 04 04                                 ADI	004o               ;For the number of bytes required to store a number in
 1038/230C : F8                                    MOV	M,A                    ;Floating point format. Restore pointer to mernory.
 1039/230D : F0                                    MOV	L,A                    ;Then, change L to point to entry position in the AS
 1040/230E : 46 98 30                              CALL	FSTORE             ;Place contents of the FPACC onto top of the AS
 1041/2311 : 36 50                                 MVI	L, 120o               ;Change L to point to start of the SYMBOL BUFFER
 1042/2313 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of the SYMBOL BUFFER
 1043/2315 : 46 0F 31                              CALL	DINPUT             ;Convert number in the buffer to floating point format
 1044/2318 : 44 99 23                              JMP	PARSE              ;In the FPACC then jump to check operator sign.
 1045/231B : 36 F8                      LOOKUP:    MVI	L, 370o               ;Load L with address of LOOK-UP COUNTER
 1046/231D : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of the counter
 1047/231F : 3E 00                                 MVI	M, 000                ;Initialize the counter to zero
 1048/2321 : 36 50                                 MVI	L, 120o               ;Load L with starting address of the SYMBOL BUFFER
 1049/2323 : 1E 04                                 MVI	D,PG27 ;\HB\OLDPG27   ;** Load D with page of the VARIABLES TABLE
 1050/2325 : 26 88                                 MVI	E, 210o               ;Load E with start of the VARL433LES TABLE
 1051/2327 : C7                                    MOV	A,M                    ;Fetch the (cc) for the string in the SYMBOL BUFFER
 1052/2328 : 3C 01                                 CPI	001                ;See if the name length is just one character. If not,
 1053/232A : 48 31 23                              JNZ	LOOKU1             ;Should be two so proceed to look-up routine. Else,
 1054/232D : 36 52                                 MVI	L, 122o               ;Change L to second character byte in the buffer and set
 1055/232F : 3E 00                                 MVI	M, 000                ;It to zero to provide compatibility with entries in table
 1056/2331 : 36 51                      LOOKU1:    MVI	L, 121o               ;Load L with addr of first character in the SYMBOL
 1057/2333 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** BUFFER. Set H to page of the SYMBOL BUFFER.
 1058/2335 : 46 D9 30                              CALL	SWITCH             ;Exchange contents of D&E with H&L so that can
 1059/2338 : C7                                    MOV	A,M                    ;Fetch the first character of a name in the VARIABLES
 1060/2339 : 30                                    INR	L                    ;TABLE. Advance the table pointer and save the
 1061/233A : CF                                    MOV	B,M                    ;Second byte of name in B. Then advance the pointer
 1062/233B : 30                                    INR	L                    ;Again to reach first bvte of floating point forrnatted
 1063/233C : 46 D9 30                              CALL	SWITCH             ;Number in table. Now exchange D&E with H&L and
 1064/233F : BF                                    CMP	M                    ;Compare first byte in table against first char in buffer
 1065/2340 : 48 49 23                              JNZ	LOOKU2             ;If not the same, go try next entry in table. If same,
 1066/2343 : 30                                    INR	L                    ;Advance pointer to next char in buffer. Transfer the
 1067/2344 : C1                                    MOV	A,B                    ;Character in B (second byte in table entry) to the ACC
 1068/2345 : BF                                    CMP	M                    ;Compare it against second character in the buffer.
 1069/2346 : 68 81 23                              JZ	LOOKU4             ;If match, have found the name in the VARIABLES tbl.
 1070/2349 : 46 AE 24                   LOOKU2:    CALL	AD4DE              ;Call subroutine to add four to the pointer in D&E to
 1071/234C : 36 F8                                 MVI	L, 370o               ;Advance the table pointer over value bytes. Then set
 1072/234E : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Up H and L to point to LOOK-UP COUNTER.
 1073/2350 : CF                                    MOV	B,M                    ;Fetch counter value (counts number of entries tested
 1074/2351 : 08                                    INR	B                    ;In the VARIABLES TABLE), increment it
 1075/2352 : F9                                    MOV	M,B                    ;And restore it back to meynory
 1076/2353 : 36 3F                                 MVI	L, 077o               ;Load L with address of SYMBOL VARIABLES counter
 1077/2355 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Do same for H. (Counts number of names in table.)
 1078/2357 : C1                                    MOV	A,B                    ;Place LOOK-UP COUNTER value in the accumulator.
 1079/2358 : BF                                    CMP	M                    ;Compare it with number of entries in the table.
 1080/2359 : 48 31 23                              JNZ	LOOKU1             ;If have not reached end of table, keep looking for name.
 1081/235C : 36 3F                                 MVI	L, 077o               ;If reach end of table without match, need to add name
 1082/235E : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** To table. First set H & L to the SYMBOL
 1083/2360 : CF                                    MOV	B,M                    ;VARIABLES counter. Fetch the counter value and
 1084/2361 : 08                                    INR	B                    ;Increment to account for new name being added to the
 1085/2362 : F9                                    MOV	M,B                    ;Table. Restore the updated count to meinory. Also,
 1086/2363 : C1                                    MOV	A,B                    ;Move the new counter value to the accumulator and
 1087/2364 : 3C 15                                 CPI	025o               ;Check to see that table size is not exceeded. If try to
 1088/2366 : 50 92 20                              JP	BIGERR             ;Go over 20 (decirnal) entries then have BIG error.
 1089/2369 : 36 51                                 MVI	L, 121o               ;Else, set L to point to first character in the SYMBOL
 1090/236B : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** BUFFER and set H to proper page. Set the number
 1091/236D : 0E 02                                 MVI	B, 002                ;Of bytes to be transferred into register B as a counter.
 1092/236F : 46 F6 2E                              CALL	MOVEIT             ;Move the symbol name from the buffer to the
 1093/2372 : F4                                    MOV	L,E                    ;VARIABLES TABLE. Now set up H & L with value
 1094/2373 : EB                                    MOV	H,D                    ;Contained in D & E after moving ops (points to first
 1095/2374 : A8                                    XRA	A                    ;Byte of the value to be associated with the symbol
 1096/2375 : F8                                    MOV	M,A                    ;Name.) Clear the accumulator and place zero in all four
 1097/2376 : 30                                    INR	L                    ;Bytes associated with the variable name entered
 1098/2377 : F8                                    MOV	M,A                    ;In the VARIABLES TABLE
 1099/2378 : 30                                    INR	L                    ;In order to
 1100/2379 : F8                                    MOV	M,A                    ;Assign an
 1101/237A : 30                                    INR	L                    ;Initial value
 1102/237B : F8                                    MOV	M,A                    ;To the variable narne
 1103/237C : C6                                    MOV	A,L                    ;Then transfer the address in L to the acc'umulator
 1104/237D : 14 04                                 SUI	004                ;Subtract four to reset the pointer to start of zeroing ops
 1105/237F : E0                                    MOV	E,A                    ;Restore the address in D & E to be in same state as if
 1106/2380 : DD                                    MOV	D,H                    ;Name was found in the table in the LOOKUP routine
 1107/2381 : 46 BA 30                   LOOKU4:    CALL	SAVEHL             ;Save current address to VARIABLES TABLE
 1108/2384 : 36 97                                 MVI	L, 227o               ;Load L with address of ARITHMETIC STACK pointer
 1109/2386 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with page of the pointer
 1110/2388 : C7                                    MOV	A,M                    ;Fetch the AS pointer value to the accumulator
 1111/2389 : 04 04                                 ADI	004                ;Add four to account for next floating point forrnatted
 1112/238B : F8                                    MOV	M,A                    ;Number to be stored in the stack. Restore the stack
 1113/238C : F0                                    MOV	L,A                    ;Pointer to memory and set it up in register L too.
 1114/238D : 46 98 30                              CALL	FSTORE             ;Place the value in the FPACC on the top of the
 1115/2390 : 46 CA 30                              CALL	RESTHL             ;ARITHMETIC STACK. Restore the VARIABLES
 1116/2393 : 46 D9 30                              CALL	SWITCH             ;TABLE pointer to H&L and move it to D&E. Now load
 1117/2396 : 46 8F 30                              CALL	FLOAD              ;The VARIABLE value from the table to the FPACC.
 1118/2399 : 46 AD 20                   PARSE:     CALL	CLESYM             ;Clear the SYMBOL BUFFER
 1119/239C : 36 7E                                 MVI	L, 176o               ;Load L with address of PARSER TOKEN VALUE
 1120/239E : C7                                    MOV	A,M                    ;And fetch the token value into the accumulator
 1121/239F : 3C 07                                 CPI	007                ;Is it token value for right parenthesis ")" ? If so, have
 1122/23A1 : 68 DA 23                              JZ	PARSE2             ;Special case where must perforin ops til find a "(" !
 1123/23A4 : 04 A0                                 ADI	240o               ;Else, fon-n address to HEIRARCHY IN table and
 1124/23A6 : F0                                    MOV	L,A                    ;Set L to point to HEIRARCHY IN VALUE in the table
 1125/23A7 : CF                                    MOV	B,M                    ;Fetch the heirarchy value from the table to register B
 1126/23A8 : 36 88                                 MVI	L, 210o               ;Set L to OPERATOR STACK pointer storage location
 1127/23AA : D7                                    MOV	C,M                    ;Fetch the OS pointer into CPU register C
 1128/23AB : 46 09 31                              CALL	INDEXC             ;Add OS pointer to address of OS pointer storage loc
 1129/23AE : C7                                    MOV	A,M                    ;Fetch the token value for the operator at top of the OS
 1130/23AF : 04 AF                                 ADI	257o               ;And form address to HEIRARCHY OUT table
 1131/23B1 : F0                                    MOV	L,A                    ;Set L to point to HEIRARCHY OUT VALUE in the
 1132/23B2 : C1                                    MOV	A,B                    ;Table. Move the HEIRARCHY IN value to the ACC.
 1133/23B3 : BF                                    CMP	M                    ;Compare the HEIRARCHY IN with the HEIRARCHY
 1134/23B4 : 68 C7 23                              JZ	PARSE1             ;OUT value. If heirarchy of current operator equal to or
 1135/23B7 : 70 C7 23                              JM	PARSE1             ;Less than operator on top of OS stack, perfo
 1136/23BA : 36 7E                                 MVI	L, 176o               ;Operation indicated in top of OS stack. Else, fetch the
 1137/23BC : CF                                    MOV	B,M                    ;Current operator token value into register B.
 1138/23BD : 36 88                                 MVI	L, 210o               ;Load L with address of the OPERATOR STACK pntr
 1139/23BF : D7                                    MOV	C,M                    ;Fetch the stack pointer value
 1140/23C0 : 10                                    INR	C                    ;Increment it to account for new entry on the stack
 1141/23C1 : FA                                    MOV	M,C                    ;Restore the stack pointer value to memory
 1142/23C2 : 46 09 31                              CALL	INDEXC             ;For in pointer to next entry in OPERATOR STACK
 1143/23C5 : F9                                    MOV	M,B                    ;Place the current operator token value on top of the OS
 1144/23C6 : 07                                    RET                    ;Exit back to the EVAL routine.
 1145/23C7 : 36 88                      PARSE1:    MVI	L, 210o               ;Load L with address of the OPERATOR STACK pntr
 1146/23C9 : C7                                    MOV	A,M                    ;Fetch the stack pointer value to the accumulator
 1147/23CA : 86                                    ADD	L                    ;Add in the value of the stack pointer address to form
 1148/23CB : F0                                    MOV	L,A                    ;Address that points to top entry in the OS
 1149/23CC : C7                                    MOV	A,M                    ;Fetch the token value at the top of the OS to the ACC
 1150/23CD : A0                                    ANA	A                    ;Check to see if the token value is zero for end of stack
 1151/23CE : 2B                                    RZ                    ;Exit back to the EVAL routine if stack empty
 1152/23CF : 36 88                                 MVI	L, 210o               ;Else, reset L to the OS pointer storage location
 1153/23D1 : D7                                    MOV	C,M                    ;Fetch the pointer value
 1154/23D2 : 11                                    DCR	C                    ;Decrement it to account for operator rernoved from
 1155/23D3 : FA                                    MOV	M,C                    ;The OPERATOR STACK and restore the pointer value
 1156/23D4 : 46 F4 23                              CALL	FPOPER             ;Perform the operation obtained from the top of the OS
 1157/23D7 : 44 99 23                              JMP	PARSE              ;Continue to compare current operator against top of OS
 1158/23DA : 36 88                      PARSE2:    MVI	L, 210o               ;Load L with address of the OPERATOR STACK pntr
 1159/23DC : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of the pointer
 1160/23DE : C7                                    MOV	A,M                    ;Fetch the stack pointer value to the accumulator
 1161/23DF : 86                                    ADD	L                    ;Add in the value of the stack pointer address to form
 1162/23E0 : F0                                    MOV	L,A                    ;Address that points to top entry in the OS
 1163/23E1 : C7                                    MOV	A,M                    ;Fetch the token value at the top of the 0 S to the ACC
 1164/23E2 : A0                                    ANA	A                    ;Check to see if the token value is zero for end of stack
 1165/23E3 : 68 44 24                              JZ	PARNER             ;If end of stack, then have a parenthesis error condx
 1166/23E6 : 36 88                                 MVI	L, 210o               ;Else, reset L to the OS pointer storage location
 1167/23E8 : D7                                    MOV	C,M                    ;Fetch the pointer value
 1168/23E9 : 11                                    DCR	C                    ;Decrement it to account for operator removed from
 1169/23EA : FA                                    MOV	M,C                    ;The OPERATOR STACK and restore the pointer value
 1170/23EB : 3C 06                                 CPI	006                ;Check to see if token value is "(" to close parenthesis
 1171/23ED : 2B                                    RZ                    ;If so, exit back to EVAL routine.
 1172/23EE : 46 F4 23                              CALL	FPOPER             ;Else, perforin the op obtained from the top of the OS
 1173/23F1 : 44 DA 23                              JMP	PARSE2             ;Continue to process data in parenthesis
 1174/23F4 : 36 F9                      FPOPER:    MVI	L, 371o               ;Load L with address of TEMP OP storage location
 1175/23F6 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of TEMP OP storage location
 1176/23F8 : F8                                    MOV	M,A                    ;Store OP (from top of OPERATOR STACK)
 1177/23F9 : 36 97                                 MVI	L, 227o               ;Change L to address of ARff HMETIC STACK pointer
 1178/23FB : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with page of AS pointer
 1179/23FD : C7                                    MOV	A,M                    ;Fetch AS pointer value into ACC
 1180/23FE : F0                                    MOV	L,A                    ;Set L to top of ARITHMETIC STACK
 1181/23FF : 46 A1 30                              CALL	OPLOAD             ;Transfer number from ARffHMETIC STACK to FPOP
 1182/2402 : 36 97                                 MVI	L, 227o               ;Restore pointer to AS pointer
 1183/2404 : C7                                    MOV	A,M                    ;Fetch the pointer value to the ACC and subtract four
 1184/2405 : 14 04                                 SUI	004                ;To remove top value from the ARITHMETIC STACK
 1185/2407 : F8                                    MOV	M,A                    ;Restore the updated AS pointer to memory
 1186/2408 : 36 F9                                 MVI	L, 371o               ;Set L to address of TEMP OP storage location
 1187/240A : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of TEMP OP storage location
 1188/240C : C7                                    MOV	A,M                    ;Fetch the operator token value to the ACC
 1189/240D : 3C 01                                 CPI	001                ;Find out which kind of operation indicated
 1190/240F : 68 70 2E                              JZ	FPADD              ;Perforn addition if have plus operator
 1191/2412 : 3C 02                                 CPI	002                ;If not plus, see if minus
 1192/2414 : 68 05 2F                              JZ	FPSUB              ;Perform subtraction if have minus operator
 1193/2417 : 3C 03                                 CPI	003                ;If not minus, see if multiplication
 1194/2419 : 68 11 2F                              JZ	FPMULT             ;Perform multiplication if have multiplication operator
 1195/241C : 3C 04                                 CPI	004                ;If not multiplication, see if division
 1196/241E : 68 BD 2F                              JZ	FPDIV              ;Perform division if have division operator
 1197/2421 : 3C 05                                 CPI	005                ;If not division, see if exponentiation
 1198/2423 : 68 B3 24                              JZ	INTEXP             ;Perform exponentiation if have exponentiation operator
 1199/2426 : 3C 09                                 CPI	011o               ;If not exponentiation, see if "less than" operator
 1200/2428 : 68 51 24                              JZ	LT                 ;Perform compaison for "less than" op if indicated
 1201/242B : 3C 0A                                 CPI	012o               ;If not 'less than" see if have "equal" operator
 1202/242D : 68 5E 24                              JZ	EQ                 ;Perforin comparison for "equal" op if indicated
 1203/2430 : 3C 0B                                 CPI	013o               ;If not "equal" see if have "greater than" operator
 1204/2432 : 68 6B 24                              JZ	GT                 ;Perform comparison for "greater than" op if indicated
 1205/2435 : 3C 0C                                 CPI	014o               ;If not "'greater than" see if have 'less than or equal" op
 1206/2437 : 68 7B 24                              JZ	LE                 ;Perform comparison for the combination op if indicated
 1207/243A : 3C 0D                                 CPI	015o               ;See if have "equal to or greater than" operator
 1208/243C : 68 8B 24                              JZ	GE                 ;Perform comparison for the combination op if indicated
 1209/243F : 3C 0E                                 CPI	016o               ;See if have "less than or greater than" operator
 1210/2441 : 68 98 24                              JZ	NE                 ;Perform comparison for the combination op if indicated
 1211/2444 : 36 98                      PARNER:    MVI	L, 230o               ;If cannot find operator, expression is not balanced
 1212/2446 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H and L to address of F/A STACK pointer
 1213/2448 : 3E 00                                 MVI	M, 000                ;Clear the F/A STACK pointer to re-initialize
 1214/244A : 06 C9                                 MVI	A, 311o               ;Load ASCII code for letter I into the accumulator
 1215/244C : 16 A8                                 MVI	C, 250o               ;And code for "(" character into register C
 1216/244E : 44 96 20                              JMP	ERROR              ;Go display 1( for "Imbalanced Parenthesis") error msg
 1217/2451 : 46 05 2F                   LT:        CALL	FPSUB              ;Subtract contents of FPACC from FPOP to compare
 1218/2454 : 36 56                                 MVI	L, 126o               ;Set L to point to the MSW of the FPACC (Contains
 1219/2456 : C7                                    MOV	A,M                    ;Result of the subtraction.) Fetch the MSW of the
 1220/2457 : A0                                    ANA	A                    ;FPACC to the accumulator and test to see if result is
 1221/2458 : 70 A2 24                              JM	CTRUE              ;Positive or negative. Set up the FPACC as a function
 1222/245B : 44 A7 24                              JMP	CFALSE             ;Of the result obtained.
 1223/245E : 46 05 2F                   EQ:        CALL	FPSUB              ;Subtract contents of FPACC from FPOP to compare
 1224/2461 : 36 56                                 MVI	L, 126o               ;Set L to point to the MSW of the FPACC (Contains
 1225/2463 : C7                                    MOV	A,M                    ;Result of the subtraction.) Fetch the MSW of the
 1226/2464 : A0                                    ANA	A                    ;FPACC to the accumulator and test to see if result is
 1227/2465 : 68 A2 24                              JZ	CTRUE              ;Equal. Set up the FPACC as a function
 1228/2468 : 44 A7 24                              JMP	CFALSE             ;Of the result obtained.
 1229/246B : 46 05 2F                   GT:        CALL	FPSUB              ;Subtract contents of FPACC from FPOP to compare
 1230/246E : 36 56                                 MVI	L, 126o               ;Set L to point to the MSW of the FPACC (Contains
 1231/2470 : C7                                    MOV	A,M                    ;Result of the subtraction.) Fetch the MSW of the
 1232/2471 : A0                                    ANA	A                    ;FPACC to the accumulator and test to see if result is
 1233/2472 : 68 A7 24                              JZ	CFALSE             ;Positive, Negative, or Equal. Set up the FPACC
 1234/2475 : 50 A2 24                              JP	CTRUE              ;As a function
 1235/2478 : 44 A7 24                              JMP	CFALSE             ;Of the result obtained.
 1236/247B : 46 05 2F                   LE:        CALL	FPSUB              ;Subtract contents of FPACC from FPOP to compare
 1237/247E : 36 56                                 MVI	L, 126o               ;Set L to point to the MSW of the FPACC (Contains
 1238/2480 : C7                                    MOV	A,M                    ;Result of the subtraction.) Fetch the MSW of the
 1239/2481 : A0                                    ANA	A                    ;FPACC to the accumulator and test to see if result is
 1240/2482 : 68 A2 24                              JZ	CTRUE              ;Positive, Negative, or Equal. Set up the FPACC
 1241/2485 : 70 A2 24                              JM	CTRUE              ;As a function
 1242/2488 : 44 A7 24                              JMP	CFALSE             ;Of the result obtained
 1243/248B : 46 05 2F                   GE:        CALL	FPSUB              ;Submit contents of FPACC from FPOP to compare
 1244/248E : 36 56                                 MVI	L, 126o               ;Set L to point to the MSW of the FPACC (Contains
 1245/2490 : C7                                    MOV	A,M                    ;Result of the subtraction.) Fetch the MSW of the
 1246/2491 : A0                                    ANA	A                    ;FPACC to the accumulator and test to see if result is
 1247/2492 : 50 A2 24                              JP	CTRUE              ;Positive or Negative. Set up the FPACC
 1248/2495 : 44 A7 24                              JMP	CFALSE             ;As a function of the result obtained
 1249/2498 : 46 05 2F                   NE:        CALL	FPSUB              ;Subtract contents of FPACC from FPOP to compare
 1250/249B : 36 56                                 MVI	L, 126o               ;Set L to point to the MSW of the FPACC (Contains
 1251/249D : C7                                    MOV	A,M                    ;Result of the subtraction.) Fetch the MSW of the
 1252/249E : A0                                    ANA	A                    ;FPACC to the accumulator and test to see if result is
 1253/249F : 68 A7 24                              JZ	CFALSE             ;Equal. Set up the FPACC as a function of the result.
 1254/24A2 :                            CTRUE:
 1255/24A2 : 36 04                      FPONE:     MVI	L, 004                ;Load L with address of floating point value +1.0
 1256/24A4 : 44 8F 30                              JMP	FLOAD              ;Load FPACC with value +1.0 and exit to caller
 1257/24A7 : 36 57                      CFALSE:    MVI	L, 127o               ;Load L with address of FPACC Exponent register
 1258/24A9 : 3E 00                                 MVI	M, 000                ;Set the FPACC Exponent to zero and then set the
 1259/24AB : 44 10 2E                              JMP	FPZERO             ;Mantissa portion of the FPACC to zero. Exit to caller.
 1260/24AE : C4                         AD4DE:     MOV	A,E                    ;Subroutine to add four to the value in register E.
 1261/24AF : 04 04                                 ADI	004                ;Move contents of E to the ACC and add four.
 1262/24B1 : E0                                    MOV	E,A                    ;Restore the updated value back to register E.
 1263/24B2 : 07                                    RET                    ;Return to the caMVI L,ng routine.
 1264/24B3 : 36 56                      INTEXP:    MVI	L, 126o               ;Load L with address of WSW of FPACC (Floating Point
 1265/24B5 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** ACCumulator). Load H with page of FPACC.
 1266/24B7 : C7                                    MOV	A,M                    ;Fetch MSW of the FPACC into the accumulator.
 1267/24B8 : 36 03                                 MVI	L, 003                ;Load L with address of EXP TEMP storage location
 1268/24BA : F8                                    MOV	M,A                    ;Store the FPACC MSW value in EXP TEMP location
 1269/24BB : A0                                    ANA	A                    ;Test contents of the MSW of the FPACC. ff zero, then
 1270/24BC : 68 A2 24                              JZ	FPONE              ;Set FPACC equal to +1.0 (any nr to zero power = 1.0!)
 1271/24BF : 72 69 2E                              CM	 FPCOMP             ;If MSW indicates negative number, complement
 1272/24C2 : 46 E7 2D                              CALL	FPFIX              ;The FPACC. Then convert floating point number to
 1273/24C5 : 36 54                                 MVI	L, 124o               ;Fixed point. Load L with address of LSW of fixed nr
 1274/24C7 : CF                                    MOV	B,M                    ;Fetch the LSW into CPU register B.
 1275/24C8 : 36 0B                                 MVI	L, 013o               ;Set L to address of EXPONENT COUNTER
 1276/24CA : F9                                    MOV	M,B                    ;Place the fixed value in the EXP CNTR to indicate
 1277/24CB : 36 5C                                 MVI	L, 134o               ;Number of multiplications needed (power). Now set L
 1278/24CD : 26 0C                                 MVI	E, 014o               ;To LSW of FPOP and E to address of FP TEMP (LSW)
 1279/24CF : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to floating point working area page.
 1280/24D1 : DD                                    MOV	D,H                    ;Set D to same page address.
 1281/24D2 : 0E 04                                 MVI	B, 004o               ;Set transfer (precision) counter. Call subroutine to move
 1282/24D4 : 46 F6 2E                              CALL	MOVEIT             ;Contents of FPOP into FP TEMP registers to save
 1283/24D7 : 46 A2 24                              CALL	FPONE              ;Original value of FPOP. Now set FPACC to +1.0.
 1284/24DA : 36 03                                 MVI	L, 003                ;Load L with pointer to original value of FPACC
 1285/24DC : C7                                    MOV	A,M                    ;(Stored in FP TEMP) MSW and fetch contents to ACC.
 1286/24DD : A0                                    ANA	A                    ;Test to see if raising to a negative power. If so, divide
 1287/24DE : 70 F2 24                              JM	DVLOOP             ;Instead of multiply!
 1288/24E1 : 36 0C                      MULOOP:    MVI	L, 014o               ;Load L with address of LSW of FP TEMP (original
 1289/24E3 : 46 AA 30                              CALL	FACXOP             ;Value in FPOP). Move FP TEMP into FPOP.
 1290/24E6 : 46 11 2F                              CALL	FPMULT             ;Multiply FPACC by FPOP. Result left in FPACC.
 1291/24E9 : 36 0B                                 MVI	L, 013o               ;Load L with address of EXPONENT COUNTER.
 1292/24EB : CF                                    MOV	B,M                    ;Fetch the counter value
 1293/24EC : 09                                    DCR	B                    ;Decrement it
 1294/24ED : F9                                    MOV	M,B                    ;Restore it to memory
 1295/24EE : 48 E1 24                              JNZ	MULOOP             ;If counter not zero, continue exponentiation process
 1296/24F1 : 07                                    RET                    ;When have raised to proper power, return to caller.
 1297/24F2 : 36 0C                      DVLOOP:    MVI	L, 014o               ;Load L with address of LSW of FP TEMP (original
 1298/24F4 : 46 AA 30                              CALL	FACXOP             ;Value in FPOP). Move FP TEMP into FPOP.
 1299/24F7 : 46 BD 2F                              CALL	FPDIV              ;Divide FPACC by FPOP. Result left in FPACC.
 1300/24FA : 36 0B                                 MVI	L, 013o               ;Load L with address of EXPONENT COUNTER
 1301/24FC : CF                                    MOV	B,M                    ;Fetch the counter value
 1302/24FD : 09                                    DCR	B                    ;Decrement it
 1303/24FE : F9                                    MOV	M,B                    ;Restore to memory
 1304/24FF : 48 F2 24                              JNZ	DVLOOP             ;If counter not zero, continue exponentiation process
 1305/2502 : 07                                    RET                    ;When have raised to proper power, return to caller.
 1306/2503 :                            
 1307/2503 :                            ;;; The label PRIGHT: SHOULD BE UP TO 07 003 0703h
 1308/2503 : 36 98                      PRIGHT:    MVI	L, 230o               ;Load L with address of F/A STACK pointer
 1309/2505 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of F/A STACK pointer
 1310/2507 : C7                                    MOV	A,M                    ;Fetch the pointer value into the ACC
 1311/2508 : 86                                    ADD	L                    ;Form pointer to top of the F/A STACK
 1312/2509 : F0                                    MOV	L,A                    ;Set L to point to top of the F/A STACK
 1313/250A : C7                                    MOV	A,M                    ;Fetch the contents of the top of the F/A STACK into
 1314/250B : 3E 00                                 MVI	M, 000                ;The ACC then clear the top of the F/A STACK
 1315/250D : 36 83                                 MVI	L, 203o               ;Load L with address of F /A STACK TEMP storage
 1316/250F : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Location. Set H to page of F/A STACK TEMP
 1317/2511 : F8                                    MOV	M,A                    ;Store value from top of F/A STACK into temp loc.
 1318/2512 : A0                                    ANA	A                    ;Test to see if token value in top of stack was zero
 1319/2513 : 2B                                    RZ                    ;If so, just had simple grouping parenthesis!
 1320/2514 : 70 90 36                              JM	PRIGH1             ;@@ If token value minus, indicates array subscript
 1321/2517 : 3C 01                                 CPI	001                ;For positive token value, look for appropriate function
 1322/2519 : 68 A3 25                              JZ	INTX               ;If token value for INTeger function, go do it.
 1323/251C : 3C 02                                 CPI	002                ;Else, see if token value for SIGN function.
 1324/251E : 68 F0 25                              JZ	SGNX               ;If so, go do it.
 1325/2521 : 3C 03                                 CPI	003                ;Else, see if token value for ABSolute function
 1326/2523 : 68 E6 25                              JZ	ABSX               ;If so, go do it.
 1327/2526 : 3C 04                                 CPI	004                ;If not, see if token value for SQuare Root function
 1328/2528 : 68 AA 35                              JZ	SQRX               ;If so, go do it.
 1329/252B : 3C 05                                 CPI	005                ;If not, see if token value for TAB function
 1330/252D : 68 0F 26                              JZ	TABX               ;If so, go do it.
 1331/2530 : 3C 06                                 CPI	006                ;If not, see if token value for RaNDom function
 1332/2532 : 68 46 36                              JZ	RNDX               ;If so, go find a random number.
 1333/2535 : 3C 07                                 CPI	007                ;If not, see if token value for CHaRacter function
 1334/2537 : 68 FF 25                              JZ	CHRX               ;If so, go perform the function.
 1335/253A : 3C 08                                 CPI	010o               ;Else, see if token for user defined machine language
 1336/253C : 68 5B 01                              JZ	UDEFX              ;# Function. If so, perform the User DEfined Function
 1337/253F : 00                                    HLT             ;Safety halt. Program should not reach this location!
 1338/2540 :                            
 1339/2540 :                            ;;; The label FUNARR SHOULD BE AT 07 100 0740h
 1340/2540 : 36 50                      FUNARR:    MVI	L, 120o               ;Load L with starting address of SYMBOL BUFFER
 1341/2542 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of SYMBOL BUFFER
 1342/2544 : C7                                    MOV	A,M                    ;Fetch the (cc) for contents of buffer to the ACC
 1343/2545 : A0                                    ANA	A                    ;See if (cc) is zero, if so buffer is empty, return to
 1344/2546 : 2B                                    RZ                    ;Caller as have simple grouping parenthesis sign
 1345/2547 : 36 82                                 MVI	L, 202o               ;Else set L to TEMP COUNTER location
 1346/2549 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to TEMP COUNTER page
 1347/254B : 3E 00                                 MVI	M, 000                ;Initialize TEMP COUNTER to zero
 1348/254D : 36 82                      FUNAR1:    MVI	L, 202o               ;Load L with address of TEMP COUNTER
 1349/254F : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Load H with page of TEMP COUNTER
 1350/2551 : CF                                    MOV	B,M                    ;Fetch the counter value to register B
 1351/2552 : 08                                    INR	B                    ;Increment the counter
 1352/2553 : F9                                    MOV	M,B                    ;Restore the updated value to memory
 1353/2554 : 16 02                                 MVI	C, 002                ;Initialize C to a value of two for future ops
 1354/2556 : 36 BC                                 MVI	L, 274o               ;Load L with starting address (less four) of FUNCTION
 1355/2558 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** LOOK-UP TABLE. Set H to table page.
 1356/255A : 46 98 25                              CALL	TABADR             ;Find address of next entry in the table
 1357/255D : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Load D with page of SYMBOL BUFFER
 1358/255F : 26 50                                 MVI	E, 120o               ;Load E with starting address of SYMBOL BUFFER
 1359/2561 : 46 DA 20                              CALL	STRCP              ;Compare entry in FUNCTION LOOK-UP TABLE with
 1360/2564 : 68 87 25                              JZ	FUNAR4             ;Contents of SYMBOL BUFFER. If find match, go set
 1361/2567 : 36 82                                 MVI	L, 202o               ;Up the function token value. Else, set L to the TEMP
 1362/2569 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** COUNTER and set H to the proper page. Fetch the
 1363/256B : C7                                    MOV	A,M                    ;Current counter value and see if have tried all eight
 1364/256C : 3C 08                                 CPI	010o               ;Possible functions in the table.
 1365/256E : 48 4D 25                              JNZ	FUNAR1             ;If not, go back and check the next entry.
 1366/2571 : 36 82                                 MVI	L, 202o               ;If have tried all of the entries in the table, set L
 1367/2573 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** As well as H to the address of the TEMP COUI,.7ER
 1368/2575 : 3E 00                                 MVI	M, 000                ;And reset it to zero. Now go see if have subscripted
 1369/2577 : 44 BC 36                              JMP	FUNAR2             ;@@ Array (unless array capability not in program).
 1370/257A : 36 98                      FAERR:     MVI	L, 230o               ;Load L with address of F/A STACK pointer
 1371/257C : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of F/A STACK pointer
 1372/257E : 3E 00                                 MVI	M, 000                ;Clear the F/A STACK pointer to reset on an error
 1373/2580 : 06 C6                                 MVI	A, 306o               ;Load the ASCII code for letter F into the ACC
 1374/2582 : 16 C1                                 MVI	C, 301o               ;Load the ASCII code for letter A into register C
 1375/2584 : 44 96 20                              JMP	ERROR              ;Go display the FA error message
 1376/2587 : 36 82                      FUNAR4:    MVI	L, 202o               ;Load L with address of TEMP COUNTER
 1377/2589 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to page of TEMP COUNTER
 1378/258B : CF                                    MOV	B,M                    ;Load value in counter to register B. This is FUNCTION
 1379/258C : 36 98                                 MVI	L, 230o               ;TOKEN VALUE. Cbange- L to F/A STACK pointer.
 1380/258E : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of F/A STACK pointer.
 1381/2590 : D7                                    MOV	C,M                    ;Fetch the F/A STACK pointer value into register C.
 1382/2591 : 46 09 31                              CALL	INDEXC             ;Form the address to the top of the F/A STACK.
 1383/2594 : F9                                    MOV	M,B                    ;Store the FUNCTION TOKEN VALUE in the F/A
 1384/2595 : 44 AD 20                              JMP	CLESYM             ;STACK. Then exit by clearing the SYMBOL BUFFER.
 1385/2598 : C1                         TABADR:    MOV	A,B                    ;Move the TEMP COUNTER value from B to ACC
 1386/2599 : 02                         TABAD1:    RLC                    ;Multiply by four using this loop to form value equal
 1387/259A : 11                                    DCR	C                    ;To number of bytes per entry (4) times current entry
 1388/259B : 48 99 25                              JNZ	TABAD1             ;In the FUNCTION LOOK-UP TABLE.
 1389/259E : 86                                    ADD	L                    ;Add this value to the starting address of the table.
 1390/259F : F0                                    MOV	L,A                    ;Form pointer to next entry in table
 1391/25A0 : 03                                    RNC                    ;If no carry return to caller
 1392/25A1 : 28                                    INR	H                    ;Else, increment H before
 1393/25A2 : 07                                    RET                    ;Returning to caller
 1394/25A3 :                            
 1395/25A3 :                            ;;; The label INTX SHOULD BE AT 07 243 07a3h
 1396/25A3 : 36 56                      INTX:      MVI	L, 126o               ;Load L with address of MSW of the FPACC
 1397/25A5 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with the page of the PPACC
 1398/25A7 : C7                                    MOV	A,M                    ;Fetch the MSW of the FPACC into the accumulator
 1399/25A8 : A0                                    ANA	A                    ;Test the sign of the number in the FPACC. If
 1400/25A9 : 50 D7 25                              JP	INT1               ;Positive jump ahead to integerize
 1401/25AC : 36 0C                                 MVI	L, 014o               ;If negative, load L with address of FP TEMP registers
 1402/25AE : 46 98 30                              CALL	FSTORE             ;Store the value in the FPACC in FP TEMP
 1403/25B1 : 46 E7 2D                              CALL	FPFIX              ;Convert the value in FPACC from floating point to
 1404/25B4 : 36 53                                 MVI	L, 123o               ;Fixed point. Load L with address of FPACC
 1405/25B6 : 3E 00                                 MVI	M, 000                ;Extension register and clear it.
 1406/25B8 : 46 1B 2E                              CALL	FPFLT              ;Convert fixed binary back to FP to integerize
 1407/25BB : 36 0C                                 MVI	L, 014o               ;Load L with address of FP TEMP registers
 1408/25BD : 46 A1 30                              CALL	OPLOAD             ;Load the value in FP TEMP into FPOP
 1409/25C0 : 46 05 2F                              CALL	FPSUB              ;Subtract integerized value from original
 1410/25C3 : 36 56                                 MVI	L, 126o               ;Set L to address of MSW of FPACC
 1411/25C5 : C7                                    MOV	A,M                    ;Fetch the MSW of the FPACC into the accumulator
 1412/25C6 : A0                                    ANA	A                    ;See if original value and integerized value the same
 1413/25C7 : 68 E1 25                              JZ	INT2               ;If so, have integer value in FP TEMP
 1414/25CA : 36 0C                                 MVI	L, 014o               ;Else, load L with address of FP TEMP registers
 1415/25CC : 46 8F 30                              CALL	FLOAD              ;Restore FPACC to original (non-integerized) value
 1416/25CF : 36 14                                 MVI	L, 024o               ;Set L to register containing small value
 1417/25D1 : 46 AA 30                              CALL	FACXOP             ;Set up to add small value to original value in FPACC
 1418/25D4 : 46 70 2E                              CALL	FPADD              ;Perform the addition
 1419/25D7 : 46 E7 2D                   INT1:      CALL	FPFIX              ;Convert the number in FPACC from floating point
 1420/25DA : 36 53                                 MVI	L, 123o               ;To fixed point. Load L with address of FPACC
 1421/25DC : 3E 00                                 MVI	M, 000                ;Extension register and clear it. Now convert the number
 1422/25DE : 44 1B 2E                              JMP	FPFLT              ;Back to floating point to integerize it and exit to caller
 1423/25E1 : 36 0C                      INT2:      MVI	L, 014o               ;Load L with address of FP TEMP registers. Transfer
 1424/25E3 : 44 8F 30                              JMP	FLOAD              ;Number from FP TEMP (orig) to FPACC and return.
 1425/25E6 : 36 56                      ABSX:      MVI	L, 126o               ;Load L with address of MSW of the FPACC
 1426/25E8 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of the FPACC
 1427/25EA : C7                                    MOV	A,M                    ;Fetch the MSW of the FPACC into the accumulator
 1428/25EB : A0                                    ANA	A                    ;Test the sign of the number to see if it is positive.
 1429/25EC : 70 69 2E                              JM	FPCOMP             ;If negative, complement the number before returning.
 1430/25EF : 07                                    RET                    ;Else, just return with absolute value in the FPACC.
 1431/25F0 : 36 56                      SGNX:      MVI	L, 126o               ;Load L with address of MSW of the FPACC
 1432/25F2 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with the page of the FPACC
 1433/25F4 : C7                                    MOV	A,M                    ;Fetch the MSW of the FPACC into the accumulator
 1434/25F5 : A0                                    ANA	A                    ;Test to see if the FPACC is zero
 1435/25F6 : 2B                                    RZ                    ;Return to caller if FPACC is zero
 1436/25F7 : 50 A2 24                              JP	FPONE              ;If FPACC is positive, load +1.0 into FPACC and exit
 1437/25FA : 36 14                                 MVI	L, 024o               ;If FPACC is negative, set up to load -1.0 into the
 1438/25FC : 44 8F 30                              JMP	FLOAD              ;FPACC and exit to caller
 1439/25FF : 46 E7 2D                   CHRX:      CALL	FPFIX              ;Convert contents of FPACC from floating point to
 1440/2602 : 36 54                                 MVI	L, 124o               ;Fixed point. Load L with address of LSW of fixed
 1441/2604 : C7                                    MOV	A,M                    ;Value. Fetch this byte into the accumulator.
 1442/2605 : 46 82 21                              CALL	ECHO               ;Display the value.
 1443/2608 : 36 7F                                 MVI	L, 177o               ;Set L to address of the TAB FLAG
 1444/260A : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of the TAB FLAG
 1445/260C : 3E FF                                 MVI	M, 377o               ;Set TAB FLAG (to inhibit display of FP value)
 1446/260E : 07                                    RET                    ;Exit to caller.
 1447/260F : 46 E7 2D                   TABX:      CALL	FPFIX              ;Convert contents of FPACC from floating point to
 1448/2612 : 36 54                      TAB1:      MVI	L, 124o               ;Fixed point. Load L with address of 1,SW of fixed
 1449/2614 : C7                                    MOV	A,M                    ;Value. Fetch this byte into the accumulator.
 1450/2615 : 36 23                                 MVI	L, 043o               ;Load L with address of COLUMN COUNTER
 1451/2617 : 97                                    SUB	M                    ;Subtract value in C-OLUMN COUNTER from desired
 1452/2618 : 36 7F                                 MVI	L, 177o               ;TAB position. Load L with address of the TAB FLAG.
 1453/261A : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of the TAB FLAG.
 1454/261C : 3E FF                                 MVI	M, 377o               ;Set TAB FLAG (to inhibit display of FP value)
 1455/261E : 70 67 35                              JM	BACKSP             ;If beyond TAB point desired, simulate back spacing
 1456/2621 : 2B                                    RZ                    ;Return to caller if at desired TAB location
 1457/2622 : D0                         TABC:      MOV	C,A                    ;Else, put difference count in register C
 1458/2623 : 06 A0                                 MVI	A, 240o               ;Place ASCII code for space in ACC
 1459/2625 : 46 82 21                   TABLOP:    CALL	ECHO               ;Display space on output device
 1460/2628 : 11                                    DCR	C                    ;Decrement displacement counter
 1461/2629 : 48 25 26                              JNZ	TABLOP             ;If have not reached TAB position, continue to space
 1462/262C : 07                                    RET                    ;Else, return to calling routine.
 1463/262D :                            
 1464/262D :                            ;;; The label STOSYM should be AT 10 055 082dh
 1465/262D : 36 81                      STOSYM:    MVI	L, 201o               ;Load L with address of ARRAY FLAG
 1466/262F : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Load H with page of ARRAY FLAG
 1467/2631 : C7                                    MOV	A,M                    ;Fetch the value of the ARRAY FLAG into the ACC
 1468/2632 : A0                                    ANA	A                    ;Check to see if the flag is set indicating processing an
 1469/2633 : 68 40 26                              JZ	STOSY1             ;Array variable value. Jump ahead if flag not set.
 1470/2636 : 3E 00                                 MVI	M, 000                ;If ARRAY FLAG was set, clear it for next time.
 1471/2638 : 36 84                                 MVI	L, 204o               ;Then load L with address of array address storage loc
 1472/263A : F7                                    MOV	L,M                    ;Fetch the array storage address as new pointer
 1473/263B : 2E 05                                 MVI	H,PG57 ;\HB\OLDPG57   ;tt Set H to ARRAY VALUES page   ****************
 1474/263D : 44 98 30                              JMP	FSTORE             ;Store the array variable value and exit to caller.
 1475/2640 : 36 F8                      STOSY1:    MVI	L, 370o               ;Load L with address of TEMP CNTR
 1476/2642 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of TEMP CNTR
 1477/2644 : 3E 00                                 MVI	M, 000                ;Initialize the TEMP CNTR by clearing it
 1478/2646 : 36 50                                 MVI	L, 120o               ;Load L with starting address of SYMBOL BUFFER
 1479/2648 : 1E 04                                 MVI	D,PG27 ;\HB\OLDPG27   ;** Load D with page of VARIABLES LOOK-UP table
 1480/264A : 26 88                                 MVI	E, 210o               ;Load E with starting addr of VARIABLES LOOK-UP
 1481/264C : C7                                    MOV	A,M                    ;Table. Fetch the (cc) for the SYMBOL BUFFER into
 1482/264D : 3C 01                                 CPI	001                ;The ACC and see if length of variable name is just one
 1483/264F : 48 56 26                              JNZ	STOSY2             ;Character. If not, skip next couple of instructions.
 1484/2652 : 36 52                                 MVI	L, 122o               ;Else, set pointer to second character location in the
 1485/2654 : 3E 00                                 MVI	M, 000                ;SYMBOL BUFFER and set it to zero
 1486/2656 : 36 51                      STOSY2:    MVI	L, 121o               ;load L with address of first character in the SYMBOL
 1487/2658 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** BUFFER. Load H with page of the buffer.
 1488/265A : 46 D9 30                              CALL	SWITCH             ;Exchange pointer to buffer for pointer to VARIABLES
 1489/265D : C7                                    MOV	A,M                    ;LOOK-UP table. Fetch first char in a name from the
 1490/265E : 30                                    INR	L                    ;Table. Advance the pointer to second char in a name.
 1491/265F : CF                                    MOV	B,M                    ;Fetch the second character into register B.
 1492/2660 : 30                                    INR	L                    ;Advance the pointer to first byte of a value in the table.
 1493/2661 : 46 D9 30                              CALL	SWITCH             ;Exchange table pointer for pointer to SYMBOL BUFF
 1494/2664 : BF                                    CMP	M                    ;Compare first character in buffer against first character
 1495/2665 : 48 6E 26                              JNZ	STOSY3             ;In table entry. If no match, try next entry in the table.
 1496/2668 : 30                                    INR	L                    ;If match, advance pointer to second character in buffer.
 1497/2669 : C1                                    MOV	A,B                    ;Move second character obtained from table into ACC.
 1498/266A : BF                                    CMP	M                    ;Compare second characters in table and buffer.
 1499/266B : 68 97 26                              JZ	STOSY5             ;If same, have found the variable name in the table.
 1500/266E : 46 AE 24                   STOSY3:    CALL	AD4DE              ;Add four to pointer in registers D&E to skip over value
 1501/2671 : 36 F8                                 MVI	L, 370o               ;Portion of entry in table. Load L with address of TEMP
 1502/2673 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** CNTR. Load H with page of TEMP CNTR.
 1503/2675 : CF                                    MOV	B,M                    ;Fetch the counter
 1504/2676 : 08                                    INR	B                    ;Increment the counter
 1505/2677 : F9                                    MOV	M,B                    ;Restore it to storage
 1506/2678 : 36 3F                                 MVI	L, 077o               ;Set L to address of VARIABLES CNTR (indicates
 1507/267A : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Number of variables currently in table.) Set H too
 1508/267C : C1                                    MOV	A,B                    ;Move the TEMP CNTR value into the ACC. (Number of
 1509/267D : BF                                    CMP	M                    ;Entries checked.) Compare with number of entries in
 1510/267E : 48 56 26                              JNZ	STOSY2             ;The table. If have not checked all entries, try next one.
 1511/2681 : 36 3F                                 MVI	L, 077o               ;If have checked all entries, load L with address of the
 1512/2683 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** VARIABLES CNTR. Set H too. Fetch the counter
 1513/2685 : CF                                    MOV	B,M                    ;Value and incrernent it to account for
 1514/2686 : 08                                    INR	B                    ;New variable nwne that will now be
 1515/2687 : F9                                    MOV	M,B                    ;Added to the table. Save the new value.
 1516/2688 : C1                                    MOV	A,B                    ;Place the new counter value into the accumulator
 1517/2689 : 3C 15                                 CPI	025o               ;And check to see that adding new variable name to the
 1518/268B : 50 92 20                              JP	BIGERR             ;Table will not cause table overflow. Big Error if it does!
 1519/268E : 36 51                                 MVI	L, 121o               ;If room available in table, set L to address of first
 1520/2690 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Caracter in the SYMBOL BUFFER. Set H too.
 1521/2692 : 0E 02                                 MVI	B, 002                ;Set a counter for number of characters to transfer.
 1522/2694 : 46 F6 2E                              CALL	MOVEIT             ;Move the variable name from buffer to table.
 1523/2697 : 46 D9 30                   STOSY5:    CALL	SWITCH             ;Exchange buffer pointer for table pointer.
 1524/269A : 46 98 30                              CALL	FSTORE             ;Transfer new mathematical value into the table.
 1525/269D : 44 AD 20                              JMP	CLESYM             ;Clear the SYMBOL BUFFER and exit to calling routine.
 1526/26A0 :                            
 1527/26A0 :                                                              ;The subroutines below are used by some of the routines
 1528/26A0 :                                                              ;in this chapter as well as other parts of the program.
 1529/26A0 :                            
 1530/26A0 : 36 50                      SAVESY:    MVI	L, 120o               ;Load L with the address of the start of the SYMBOL
 1531/26A2 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** BUFFER. Load H with the page of the buffer.
 1532/26A4 : DD                                    MOV	D,H                    ;Load register D with the page of the AUX SYMBOL
 1533/26A5 : 26 64                                 MVI	E, 144o               ;BUFFER and set register E to start of that buffer.
 1534/26A7 : 44 B1 26                              JMP	MOVECP             ;Transfer SYMBOL BF contents to AUX SYMBOL BF
 1535/26AA :                            
 1536/26AA : 36 64                      RESTSY:    MVI	L, 144o               ;Load L with address of start of AUX SYMBOL BUFF
 1537/26AC : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of AUX SYMBOL BUFFER
 1538/26AE : DD                                    MOV	D,H                    ;Set D to page of SYMBOL BUFFER (same as H)
 1539/26AF : 26 50                                 MVI	E, 120o               ;Load E with start of SYMBOL BUFFER
 1540/26B1 : CF                         MOVECP:    MOV	B,M                    ;Load (cc) for source string (first byte in source buffer)
 1541/26B2 : 08                                    INR	B                    ;Add one to (cc) to include (cc) byte itself
 1542/26B3 : 44 F6 2E                              JMP	MOVEIT             ;Move the source string to destination buffer
 1543/26B6 :                            
 1544/26B6 :                            ;;; The label Exec SHOULD BE AT 10 266 (This is the start of the code) 08b6h
 1545/26B6 : 36 EA                      EXEC:      MVI	L, 352o               ;Load L with address of READY message
 1546/26B8 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with page of READY message
 1547/26BA : 46 51 21                              CALL	TEXTC              ;Call subroutine to display the READY message
 1548/26BD :                            
 1549/26BD : 36 00                      EXEC1:     MVI	L, 000                ;Load L with starting address of INPUT LINE BUFFER
 1550/26BF : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of INPUT LINE BUFFER
 1551/26C1 : 46 0C 21                              CALL	STRIN              ;Call subroutine to input a line into the buffer
 1552/26C4 : C7                                    MOV	A,M                    ;The STRIN subroutine will exit with pointer set to the
 1553/26C5 : A0                                    ANA	A                    ;CHARACTER COUNT for the line inputted. Fetch the
 1554/26C6 : 68 BD 26                              JZ	EXEC1              ;Value of the counter, if it is zero then line was blank.
 1555/26C9 : 36 DD                                 MVI	L, 335o               ;Load L with address of LIST in look up table
 1556/26CB : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;Load H with address of LIST in look up table
 1557/26CD : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;Load D with page of line input buffer
 1558/26CF : 26 00                                 MVI	E, 000                ;Load E with start of line input buffer
 1559/26D1 : 46 DA 20                              CALL	STRCP              ;Call string compare subroutine to see if first word in
 1560/26D4 : 48 EC 26                              JNZ	NOLIST             ;Input buffer is LIST. Jump 3 ahead if not LIST.
 1561/26D7 : 36 00                                 MVI	L, 000                ;If LIST, set up pointers to start of USER PROGRAM
 1562/26D9 : 2E 06                                 MVI	H, BGNPGRAM           ;BUFFER. (Note user could alter this starting addr)   *****
 1563/26DB :                            
 1564/26DB :                                                              ;Next portion of program will LIST the contents of the
 1565/26DB :                                                              ;USER PROGRAM BUFFER until an end of buffer
 1566/26DB :                                                              ;(zero byte) indicator is detected.
 1567/26DB :                            
 1568/26DB : C7                         LIST:      MOV	A,M                    ;Fetch the first byte of a line in the USER PROGRAM
 1569/26DC : A0                                    ANA	A                    ;BUFFER and see if it is zero. If so, have finished LIST
 1570/26DD : 68 B6 26                              JZ	EXEC               ;So go back to start of Executive and display READY.
 1571/26E0 : 46 51 21                              CALL	TEXTC              ;Else call subroutine to display a line of information
 1572/26E3 : 46 FF 20                              CALL	ADV                ;Now call subroutine to advance buffer pointer to
 1573/26E6 : 46 61 21                              CALL	CRLF               ;Character count in next line. Also display a CR & LF.
 1574/26E9 : 44 DB 26                              JMP	LIST               ;Continue LISTing process
 1575/26EC :                            
 1576/26EC :                                                              ;If line inputted by operator did not contain a LIST comman
 1577/26EC :                                                              ;continue program to see if RUN or SCRatch command.
 1578/26EC :                            
 1579/26EC : 36 E2                      NOLIST:    MVI	L, 342o               ;Load L with address of RUN in look up table
 1580/26EE : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with address of RUN in look up table
 1581/26F0 : 26 00                                 MVI	E, 000                ;Load E with start of line input buffer
 1582/26F2 : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Load D with page of line input buffer
 1583/26F4 : 26 00                                 MVI	E, 000                ;(Reserve 2 locs in case of patching by duplicating above)
 1584/26F6 : 46 DA 20                              CALL	STRCP              ;Call string compare subroutine to see if first word in
 1585/26F9 : 68 27 29                              JZ	RUN                ;Input buffer is RUN. Go to RUN routine if match.
 1586/26FC : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;** If not RUN command, reset address pointers back
 1587/26FE : 26 00                                 MVI	E, 000                ;To the start of the line input buffer
 1588/2700 : 36 E6                                 MVI	L, 346o               ;Load L with address of SCR in look up table
 1589/2702 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with page of SCR in look up table
 1590/2704 : 46 DA 20                              CALL	STRCP              ;Call string compare subroutine to see if first word in
 1591/2707 : 48 39 27                              JNZ	NOSCR              ;Input buffer is SCR. If not then jump ahead.
 1592/270A : 2E 03                      ENTRY_SCR: MVI	H,PG26 ;\HB\OLDPG26   ;** If found SCR command then load memory pointer
 1593/270C : 36 F4                                 MVI	L, 364o               ;With address of a pointer storage location. Set that
 1594/270E : 3E 06                                 MVI	M, BGNPGRAM           ;tt Storage location to page of start of USER PRO-  *******
 1595/2710 : 30                                    INR	L                    ;GRAM BUFFER. (Buffer start loc may be altered).
 1596/2711 : 3E 00                                 MVI	M, 000                ;Then adv pntr and do same for low addr portion of pntr
 1597/2713 : 36 3F                                 MVI	L, 077o               ;Now set pointer to address of VARIABLES counter
 1598/2715 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Storage location. Initialize this counter by placing
 1599/2717 : 3E 01                                 MVI	M, 001                ;The count of one into it. Now change the memory pntr
 1600/2719 :                            ;MGA 3/31/12 put it back to 001; solves nested FOR/NEXT, but limits vars to 19
 1601/2719 :                            ;   as the letter from James Tucker (1/77) mentioned
 1602/2719 :                            ;   apparently, James didn't test FOR/NEXT; original Loboyko didn't have this
 1603/2719 :                            ;;;           LMI 001                ;The count of one into it. Now change the memory pntr
 1604/2719 :                            ;;; Apparently, in Page 3 of Issue 4 of Scelbal update (1/77) they say the above should change.
 1605/2719 :                            ;;; This makes the SCR command clear the whole variable space, otherwise one space is lost.  
 1606/2719 : 36 3D                                 MVI	L, 075o               ;To storage location for number of dimensioned arrays
 1607/271B : 3E 00                                 MVI	M, 000                ;@@ And initialize to zero. (@@ = Substitute NOPs if
 1608/271D : 36 50                                 MVI	L, 120o               ;@@ DIMension capability not used in package.) Also
 1609/271F : 3E 00                                 MVI	M, 000                ;@@ Initialize l'st byte of array name table to zero.
 1610/2721 : 36 88                                 MVI	L, 210o               ;Set pointer to storage location for the first byte of the
 1611/2723 : 3E 00                                 MVI	M, 000                ;VARIABLES symbol table. Initialize it to zero too.
 1612/2725 : 30                                    INR	L                    ;Advance the pointer and zero the second location
 1613/2726 : 3E 00                                 MVI	M, 000                ;In the Variables table also.
 1614/2728 : 2E 06                                 MVI	H, BGNPGRAM           ;tt Load H with page of start of USER PROGRAM    **********
 1615/272A : 36 00                                 MVI	L, 000                ;BUFFER. (Buffer start location could be altered.)
 1616/272C : 3E 00                                 MVI	M, 000                ;Clear first location to indicate end of user program.
 1617/272E : 2E 05                                 MVI	H,PG57 ;\HB\OLDPG57   ;@@ Load H with page of ARRAYS storage
 1618/2730 : 3E 00                      SCRLOP:    MVI	M, 000                ;@@ And form a loop to clear out all the locations
 1619/2732 : 30                                    INR	L                    ;@@ On the ARRAYS storage page. (@@ These become
 1620/2733 : 48 30 27                              JNZ SCRLOP             ;@@ NOPs if DIMension capability deleted fm package.)
 1621/2736 : 44 B6 26                              JMP EXEC               ;SCRatch operations completed, go back to EXEC.
 1622/2739 :                            
 1623/2739 :                                                              ;If line inputted did not contain RUN or SCRatch com-
 1624/2739 :                                                              ;mand, program continues by testing for SAVE or LOAD
 1625/2739 :                                                              ;commands. If it does not find either of these com-
 1626/2739 :                                                              ;mands, then operator did not input an executive com-
 1627/2739 :                                                              ;mand. Program then sets up to see if the first entry in
 1628/2739 :                                                              ;the line inputted is a LINE NUMBER.
 1629/2739 :                            
 1630/2739 : 26 BA                      NOSCR:     MVI	E, 272o               ;Load E with address of SAVE in look up table
 1631/273B : 1E 02                                 MVI	D,PG01 ;\HB\OLDPG1    ;Load D with page of look up table
 1632/273D : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;Load H with page of input line buffer
 1633/273F : 36 00                                 MVI	L, 000                ;Set L to start of input line buffer
 1634/2741 : 46 DA 20                              CALL	STRCP              ;Call string compare subroutine to see if first word in
 1635/2744 : 68 5A 01                              JZ	SAVE               ;tt Input buffer is SAVE. If so, go to user's SAVE rtn
 1636/2747 : 36 BF                                 MVI	L, 277o               ;If not SAVE then load L with address of LOAD in look
 1637/2749 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;Up table and load H with page of look up table
 1638/274B : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;Load D with page of input line buffer
 1639/274D : 26 00                                 MVI	E, 000                ;And L to start of input line buffer
 1640/274F : 46 DA 20                              CALL	STRCP              ;Call string compare subroutine to see if first word in
 1641/2752 : 68 5A 01                              JZ	LOAD               ;tt Input buffer is LOAD. If so, go to user's LOAD rtn
 1642/2755 : 36 F0                                 MVI	L, 360o               ;If not LOAD then set pointer to address of storage loc
 1643/2757 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** For USER PROGRAM BUFFER pointer. Initialize this
 1644/2759 : 3E 06                                 MVI	M, BGNPGRAM           ;tt Pointer to the starting address of the program buffer.
 1645/275B : 30                                    INR	L                    ;Advance memory pntr. Since pointer storage requires
 1646/275C : 3E 00                                 MVI	M, 000                ;Two locations, initialize the low addr portion also.
 1647/275E : 46 00 20                              CALL	SYNTAX             ;Call the SYNTAX subroutine to obtain a TOKEN indi-
 1648/2761 : 36 83                                 MVI	L, 203o               ;Cator which will be stored in this location. Upon return
 1649/2763 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** From SYNTAX subroutine set memory pointer to
 1650/2765 : C7                                    MOV	A,M                    ;The TOKEN indicator storage location and fetch the
 1651/2766 : A0                                    ANA	A                    ;Value of the TOKEN. If the value of the syntax TOKEN
 1652/2767 : 50 71 27                              JP	SYNTOK             ;Is positive then have a valid entry.
 1653/276A : 06 D3                      SYNERR:    MVI	A, 323o               ;However, if SYNTAX returns a negative value TOKEN
 1654/276C : 16 D9                                 MVI	C, 331o               ;Then have an error condition. Set up the letters SY in
 1655/276E : 44 96 20                              JMP	ERROR              ;ASCII code and go to display error message to operator.
 1656/2771 : 36 E0                      SYNTOK:    MVI	L, 340o               ;Set pointer to start of LINE NUMBER storage area
 1657/2773 : C7                                    MOV	A,M                    ;First byte there will contain the length of the line
 1658/2774 : A0                                    ANA	A                    ;Number character string. Fetch that value (cc).
 1659/2775 : 68 78 29                              JZ	DIRECT             ;DIRECT If line number blank, have a DIRECT statement!
 1660/2778 : 36 F0                                 MVI	L, 360o               ;If have a line number must get line in input buffer into
 1661/277A : 3E 06                                 MVI	M, BGNPGRAM           ;tt User program buffer. Initialize pointer to user buffer.
 1662/277C : 30                                    INR	L                    ;This is a two byte pointer so after initializing page addr
 1663/277D : 3E 00                                 MVI	M, 000                ;Advance pointer and initialize location on page address
 1664/277F :                            
 1665/277F :                                                              ;If the line in the LINE INPUT BUFFER has a line num-
 1666/277F :                                                              ;ber then the line is to be placed in the USER PRO-
 1667/277F :                                                              ;GRAM BUFFER. It is now necessary to determine
 1668/277F :                                                              ;where the new line is to be placed in the USER PRO-
 1669/277F :                                                              ;GRAM BUFFER. This is dictated by the value of the
 1670/277F :                                                              ;new line number in relation to the line numbers cur-
 1671/277F :                                                              ;rently in the program buffer. The next portion of the
 1672/277F :                                                              ;program goes through the contents of the USER PRO-
 1673/277F :                                                              ;GRAM BUFFER comparing the values of the line num-
 1674/277F :                                                              ;bers already stored against the value of the line number
 1675/277F :                                                              ;currently being held in the LINE INPUT BUFFER.
 1676/277F :                                                              ;Appropriate action is then taken to Insert or Append,
 1677/277F :                                                              ;Change, or Delete a line in the program buffer.
 1678/277F :                            
 1679/277F : 36 81                      GETAUX:    MVI	L, 201o               ;Set memory pointer to line character pointer storage
 1680/2781 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Location and then initialize that storage location
 1681/2783 : 3E 01                                 MVI	M, 001                ;To point to the 1'st character in a line
 1682/2785 : 36 E8                                 MVI	L, 350o               ;Set memory pointer to addr of start of auxiliary line
 1683/2787 : 3E 00                                 MVI	M, 000                ;Number storage area and initialize first byte to zero
 1684/2789 : 36 81                      GETAU0:    MVI	L, 201o               ;Set memory pointer to line character pointer storage loc
 1685/278B : 46 3C 28                              CALL	GETCHP             ;Fetch a char in line pointed to by line pointer
 1686/278E : 68 A2 27                              JZ	GETAU1             ;If character is a space, skip it by going to advance pntrs
 1687/2791 : 3C B0                                 CPI	260o               ;If not a space check to see if character represents a
 1688/2793 : 70 B7 27                              JM	GETAU2             ;Valid decimal digit in the range 0 to 9 by testing the
 1689/2796 : 3C BA                                 CPI	272o               ;ASCII code value obtained. If not a deciznal digit then
 1690/2798 : 50 B7 27                              JP	GETAU2             ;Assume have obtained the line number. Go process.
 1691/279B : 36 E8                                 MVI	L, 350o               ;If valid decimal digit want to append the digit to the
 1692/279D : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Current string being built up in the auxiliary line
 1693/279F : 46 CC 20                              CALL	CONCT1             ;Number storage area so call sub to concat a character.
 1694/27A2 : 36 81                      GETAU1:    MVI	L, 201o               ;Reset memory pointer to line character pntr storage loc
 1695/27A4 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;On the appropriate page.
 1696/27A6 : CF                                    MOV	B,M
 1697/27A7 : 08                                    INR	B                    ;Fetch the pointer, increment it, and restore new value
 1698/27A8 : F9                                    MOV	M,B
 1699/27A9 : 36 F0                                 MVI	L, 360o               ;Set memory pointer to pgm buff line pntr storage loc
 1700/27AB : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   
 1701/27AD : D7                                    MOV	C,M                    ;Bring the high order byte of this double byte pointer
 1702/27AE : 30                                    INR	L                    ;Into CPU register C. Then advance the memory pntr
 1703/27AF : F7                                    MOV	L,M                    ;And bring the low order byte into register L. Now trans-
 1704/27B0 : EA                                    MOV	H,C                    ;Fer the higher order portion into memory pointer H.
 1705/27B1 : C7                                    MOV	A,M                    ;Obtain the char cntr (cc) which indicates the length of
 1706/27B2 : 09                                    DCR	B                    ;The line being pointed to by the user program line pntr
 1707/27B3 : B9                                    CMP	B                    ;Compare this with the value of the chars processed so
 1708/27B4 : 48 89 27                              JNZ	GETAU0             ;Far in current line. If not equal, continue getting line n
 1709/27B7 : 36 F0                      GETAU2:    MVI	L, 360o               ;Reset mem pntr to pgm buffer line pntr storage
 1710/27B9 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** On this page and place the high order byte
 1711/27BB : DF                                    MOV	D,M                    ;Of this pointer into CPU register D
 1712/27BC : 30                                    INR	L                    ;Advance the memory pointer, fetch the second
 1713/27BD : F7                                    MOV	L,M                    ;Byte of the pgm buffer line pointer into register L
 1714/27BE : EB                                    MOV	H,D                    ;Now make the memory pointer equal to this value
 1715/27BF : C7                                    MOV	A,M                    ;Fetch the first byte of a line in the program buffer
 1716/27C0 : A0                                    ANA	A                    ;Test to see if end of contents of pgm buff (zero byte)
 1717/27C1 : 48 C7 27                              JNZ	NOTEND             ;If not zero continue processing. If zero have reached
 1718/27C4 : 44 EE 27                              JMP	NOSAME             ;End of buffer contents so go APPEND line to buffer.
 1719/27C7 :                            ;;; there are some open addresses here.  Above JUMP starts at 11-304;
 1720/27C7 :                            
 1721/27C7 :                            ;          ORG	09deh              ;011#336
 1722/27C7 : 36 E8                      NOTEND:    MVI	L, 350o               ;Load L with addr of auxiliary line number storage loc
 1723/27C9 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;Load H with addr of aux line number storage loc
 1724/27CB : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;Load D with addr of line number buffer location
 1725/27CD : 26 E0                                 MVI	E, 340o               ;Load E with address of line number buffer location
 1726/27CF : 46 DA 20                              CALL	STRCP              ;Compare line nr in input buffer with line number in
 1727/27D2 : 70 24 28                              JM	CONTIN             ;User program buffer. If lesser in value keep looking.
 1728/27D5 : 48 EE 27                              JNZ	NOSAME             ;If greater in value then go to Insert line in pgm buffer
 1729/27D8 : 36 F0                                 MVI	L, 360o               ;If same values then must remove the line with the same
 1730/27DA : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Line number from the user program buffer. Set up
 1731/27DC : D7                                    MOV	C,M                    ;The CPU memory pointer to point to the current
 1732/27DD : 30                                    INR	L                    ;Position in the user program buffer by retrieving that
 1733/27DE : F7                                    MOV	L,M                    ;Pointer from its storage location. Then obtain the first
 1734/27DF : EA                                    MOV	H,C                    ;Byte of data pointed to which will be the character
 1735/27E0 : CF                                    MOV	B,M                    ;Count for that line (cc). Add one to the cc value to take
 1736/27E1 : 08                                    INR	B                    ;Account of the (cc) byte itself and then remove that
 1737/27E2 : 46 4D 28                              CALL	REMOVE             ;Many bytes to effectively delete the line fm the user
 1738/27E5 : 36 83                                 MVI	L, 203o               ;Program buffer. Now see if line in input buffer consists
 1739/27E7 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Only of a line number by checking SYNTAX
 1740/27E9 : C7                                    MOV	A,M                    ;TOKEN value. Fetch the TOKEN value from its
 1741/27EA : A0                                    ANA	A                    ;Storage location. If it is zero then input buffer only
 1742/27EB : 68 B6 26                              JZ	EXEC               ;Contains a line number. Action is a pure Delete.
 1743/27EE : 36 F0                      NOSAME:    MVI	L, 360o               ;Reset memory pointer to program buffer
 1744/27F0 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;Line pointer storage location
 1745/27F2 : DF                                    MOV	D,M                    ;Load high order byte into CPU register D
 1746/27F3 : 30                                    INR	L                    ;Advance memory pointer
 1747/27F4 : E7                                    MOV	E,M                    ;Load low order byte into CPU register E
 1748/27F5 : 36 00                                 MVI	L, 000                ;Load L with address of start of line input buffer
 1749/27F7 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Do same for CPU register H
 1750/27F9 : CF                                    MOV	B,M                    ;Get length of line input buffer
 1751/27FA : 08                                    INR	B                    ;Advance length by one to include (cc) byte
 1752/27FB : 46 6E 28                              CALL	INSERT             ;Go make room to insert line into user program buffer
 1753/27FE : 36 F0                                 MVI	L, 360o               ;Reset memory pointer to program buffer
 1754/2800 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Line pointer storage location
 1755/2802 : DF                                    MOV	D,M                    ;Load higher byte into CPU register D
 1756/2803 : 30                                    INR	L                    ;Advance memory pointer
 1757/2804 : E7                                    MOV	E,M                    ;Load low order byte into CPU register E
 1758/2805 : 36 00                                 MVI	L, 000                ;Load L with address of start of line input buffer
 1759/2807 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Do same for CPU register H
 1760/2809 : 46 0F 28                              CALL	MOVEC              ;Call subroutine to Insert line in input buffer into the
 1761/280C : 44 BD 26                              JMP	EXEC1              ;User program buffer then go back to start of EXEC.
 1762/280F : CF                         MOVEC:     MOV	B,M                    ;Fetch length of string in line input buffer
 1763/2810 : 08                                    INR	B                    ;Increment that value to provide for (cc)
 1764/2811 : C7                         MOVEPG:    MOV	A,M                    ;Fetch character from line input buffer
 1765/2812 : 46 FF 20                              CALL	ADV                ;Advance pointer for line input buffer
 1766/2815 : 46 D9 30                              CALL	SWITCH             ;Switch memory pointer to point to user pgm buffer
 1767/2818 : F8                                    MOV	M,A                    ;Deposit character fm input buff into user pgm buff
 1768/2819 : 46 FF 20                              CALL	ADV                ;Advance pointer for user program buffer
 1769/281C : 46 D9 30                              CALL	SWITCH             ;Switch memory pntr back to point to input buffer
 1770/281F : 09                                    DCR	B                    ;Decrement character counter stored in CPU register B
 1771/2820 : 48 11 28                              JNZ	MOVEPG             ;If counter does not go to zero continue transfer ops
 1772/2823 : 07                                    RET                    ;When counter equals zero return to caMVI L,ng routine
 1773/2824 : 36 F0                      CONTIN:    MVI	L, 360o               ;Reset memory pointer to program buffer
 1774/2826 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Line pointer storage location
 1775/2828 : DF                                    MOV	D,M                    ;Load high order byte into CPU register D
 1776/2829 : 30                                    INR	L                    ;Advance memory pointer
 1777/282A : E7                                    MOV	E,M                    ;Load low order byte into CPU register E
 1778/282B : EB                                    MOV	H,D                    ;Now set CPU register H to high part of address
 1779/282C : F4                                    MOV	L,E                    ;And set CPU register L to low part of address
 1780/282D : CF                                    MOV	B,M                    ;Fetch the character counter (cc) byte fm line in
 1781/282E : 08                                    INR	B                    ;Program buffer and add one to compensate for (cc)
 1782/282F : 46 AE 28                              CALL	ADBDE              ;Add length of line value to old value to get new pointer
 1783/2832 : 36 F0                                 MVI	L, 360o               ;Reset memory pointer to program buffer
 1784/2834 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Line pointer storage location
 1785/2836 : FB                                    MOV	M,D                    ;Restore new high portion
 1786/2837 : 30                                    INR	L                    ;Advance memory pointer
 1787/2838 : FC                                    MOV	M,E                    ;And restore new low portion
 1788/2839 : 44 7F 27                              JMP	GETAUX             ;Continue til find point at which to enter new line
 1789/283C : 2E 03                      GETCHP:    MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with pointer page (low portion set upon
 1790/283E : CF                                    MOV	B,M                    ;Entry). Now fetch pointer into CPU register B.
 1791/283F : 36 F0                                 MVI	L, 360o               ;Reset pntr to pgm buffer line pointer storage location
 1792/2841 : DF                                    MOV	D,M                    ;Load high order byte into CPU register D
 1793/2842 : 30                                    INR	L                    ;Advance memory pointer
 1794/2843 : E7                                    MOV	E,M                    ;Load low order byte into CPU register E
 1795/2844 : 46 AE 28                              CALL	ADBDE              ;Add pointer to pgm buffer pointer to obtain address of
 1796/2847 : EB                                    MOV	H,D                    ;Desired character. Place high part of new addr in H.
 1797/2848 : F4                                    MOV	L,E                    ;And low part of new address in E.
 1798/2849 : C7                                    MOV	A,M                    ;Fetch character from position in line in user pgm buffer
 1799/284A : 3C A0                                 CPI	240o               ;See if it is the ASCII code for space
 1800/284C : 07                                    RET                    ;Return to caller with flags set to indicate result
 1801/284D : 46 7C 21                   REMOVE:    CALL	INDEXB             ;Add (cc) plus one to addr of start of line
 1802/2850 : D7                                    MOV	C,M                    ;Obtain byte from indexed location and
 1803/2851 : 46 4B 21                              CALL	SUBHL              ;Subtract character count to obtain old location
 1804/2854 : FA                                    MOV	M,C                    ;Put new byte in old location
 1805/2855 : C2                                    MOV	A,C                    ;As well as in the Accumulator
 1806/2856 : A0                                    ANA	A                    ;Test to see if zero byte to indicate end of user pgm buff
 1807/2857 : 68 60 28                              JZ	REMOV1             ;If it is end of user pgm buffer, go complete process
 1808/285A : 46 FF 20                              CALL	ADV                ;Otherwise add one to the present pointer value
 1809/285D : 44 4D 28                              JMP	REMOVE             ;And continue removing chamcters from the user pgm bf
 1810/2860 : 36 F4                      REMOV1:    MVI	L, 364o               ;Load L with end of user pgm buffer pointer storage loc
 1811/2862 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of that pointer storage location
 1812/2864 : DF                                    MOV	D,M                    ;Get page portion of end of pgm buffer address
 1813/2865 : 30                                    INR	L                    ;Advance memory pointer
 1814/2866 : C7                                    MOV	A,M                    ;And get low portion of end of pgm buffer address into
 1815/2867 : 91                                    SUB	B                    ;Accumulator then subtract displacement value in B
 1816/2868 : F8                                    MOV	M,A                    ;Restore new low portion of end of pgm buffer address
 1817/2869 : 03                                    RNC                    ;If subtract did not cause carry can return now
 1818/286A : 31                                    DCR	L                    ;Otherwise decrement memory pointer back to page
 1819/286B : 19                                    DCR	D                    ;Storage location, decrement page value to give new page
 1820/286C : FB                                    MOV	M,D                    ;And store new page value back in buffer pntr storage loc
 1821/286D : 07                                    RET                    ;Then return to calling routine
 1822/286E : 36 F4                      INSERT:    MVI	L, 364o               ;Load L with end of user pgm buffer pointer storage loc
 1823/2870 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of that pointer storage location
 1824/2872 : C7                                    MOV	A,M                    ; Get page portion of end of program buffer address
 1825/2873 : 30                                    INR	L                    ;Advance memory pointer
 1826/2874 : F7                                    MOV	L,M                    ;Load low portion of end of program buffer address
 1827/2875 : E8                                    MOV	H,A                    ;Into L and finish setting up memory pointer
 1828/2876 : 46 7C 21                              CALL	INDEXB             ;Add (cc) of line in input buffer to form new end of
 1829/2879 : C5                                    MOV	A,H                    ;Program buffer address. Fetch new end of buffer page
 1830/287A : 3C 1F                                 CPI	ENDPGRAM           ;tt Address and see if this value would exceed user's
 1831/287C : 50 92 20                              JP	BIGERR             ;System capabilit'y. Go display error message if so!
 1832/287F : 46 4B 21                              CALL	SUBHL              ;Else restore original value of end of buffer address
 1833/2882 : D7                         INSER1:    MOV	C,M                    ;Bring byte pointed to by H & L into CPU register C
 1834/2883 : 46 7C 21                              CALL	INDEXB             ;Add displacement value to current memory pointer
 1835/2886 : FA                                    MOV	M,C                    ;Store the byte in the new location
 1836/2887 : 46 4B 21                              CALL	SUBHL              ;Now subtract displacement value from H & L
 1837/288A : 46 A8 28                              CALL	CPHLDE             ;Compare this with the address stored in D & E
 1838/288D : 68 96 28                              JZ	INSER3             ;If same then go finish up Insert operation
 1839/2890 : 46 74 21                              CALL	DEC                ;Else set pointer to the byte before the byte just
 1840/2893 : 44 82 28                              JMP	INSER1             ;Processed and continue the Insert operation
 1841/2896 :                            INSER3:
 1842/2896 : 36 00                      INCLIN:    MVI	L, 000                ;Load L with start of line input buffer
 1843/2898 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of start of line input buffer
 1844/289A : CF                                    MOV	B,M                    ;Fetch length of the line in line input buffer
 1845/289B : 08                                    INR	B                    ;Increment value by one to include (cc) byte
 1846/289C : 36 F4                                 MVI	L, 364o               ;Set memory pointer to end of user pgrn buffer pointer
 1847/289E : DF                                    MOV	D,M                    ;Storage location on same page and fetch page address
 1848/289F : 30                                    INR	L                    ;Of this pointer into D. Then advance memory pointer
 1849/28A0 : E7                                    MOV	E,M                    ;And get low part of this pointer into CPU register E.
 1850/28A1 : 46 AE 28                              CALL	ADBDE              ;Now add displacement (cc) of line in input buffer to
 1851/28A4 : FC                                    MOV	M,E                    ;The end of program buffer pointer. Replace the updated
 1852/28A5 : 31                                    DCR	L                    ;Low portion of the new pointer value back in stomge
 1853/28A6 : FB                                    MOV	M,D                    ;And restore the new page value back into storage
 1854/28A7 : 07                                    RET                    ;Then return to calling routine
 1855/28A8 : C5                         CPHLDE:    MOV	A,H                    ;Subroutine to compare if the contents of CPU registers
 1856/28A9 : BB                                    CMP	D                    ;H & L are equal to registers D & E. First compare
 1857/28AA : 0B                                    RNZ                    ;Register H to D. Return with flags set if not equal. If
 1858/28AB : C6                                    MOV	A,L                    ;Equal continue by comparing register L to E.
 1859/28AC : BC                                    CMP	E                    ;IF L equals E then H & L equal to D & E so return to
 1860/28AD : 07                                    RET                    ;Calling routines with flags set to equality status
 1861/28AE : C4                         ADBDE:     MOV	A,E                    ;Subroutine to add the contents of CPU register B (single
 1862/28AF : 81                                    ADD	B                    ;Byte value) to the double byte value in registers D & E.
 1863/28B0 : E0                                    MOV	E,A                    ;First add B to E to form new least significant byte
 1864/28B1 : 03                                    RNC                    ;Restore new value to E and exit if no carry resulted
 1865/28B2 : 18                                    INR	D                    ;If had a carry then must increment most significant byte
 1866/28B3 : 07                                    RET                    ;In register D before returning to calling routine
 1867/28B4 : 06 DE                      CTRLC:     MVI	A, 336o               ;Set up ASCII code for t (up arrow) in Accumulator.
 1868/28B6 : 16 C3                                 MVI	C, 303o               ;Set up ASCII code for letter 'C' in CPU register C.
 1869/28B8 : 44 96 20                              JMP	ERROR              ;Go display the 'Control C' condition message.
 1870/28BB : 36 E0                      FINERR:    MVI	L, 340o               ;Load L with starting address of line number storage area
 1871/28BD : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of line number storage area
 1872/28BF : C7                                    MOV	A,M                    ;Get (cc) for line number string. If length is zero meaning
 1873/28C0 : A0                                    ANA	A                    ;There is no line number stored in the buffer then jump
 1874/28C1 : 68 D2 28                              JZ	FINER1             ;Ahead to avoid displaying "AT LINE" message
 1875/28C4 : 36 F6                                 MVI	L, 366o               ;Else load L with address of start of "AT LINE" message
 1876/28C6 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Stored on this page
 1877/28C8 : 46 51 21                              CALL	TEXTC              ;Call subroutine to display the "AT LINE" message
 1878/28CB : 36 E0                                 MVI	L, 340o               ;Now reset L to starting address of line number storage
 1879/28CD : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Area and do same for CPU register H
 1880/28CF : 46 51 21                              CALL	TEXTC              ;Call subroutine to display the line number
 1881/28D2 : 46 61 21                   FINER1:    CALL	CRLF               ;Call subroutine to provide a carriage-return and line-feed
 1882/28D5 :                            ;	   JMP	PATCH3 
 1883/28D5 :                            ;;; The below label patch3 should start at 11 307 09c7h
 1884/28D5 : 36 81                      PATCH3:	   MVI	L, 201o               ; ptr to A/V storage
 1885/28D7 : 2E 04                      	   MVI	H,PG27 ;\HB\OLDPG27   ; MGA 3/31/12 make relocatable; prev: LHI 027
 1886/28D9 : 3E 00                      	   MVI	M, 000o               ; clear A/V flag
 1887/28DB : 44 B6 26                   	   JMP	EXEC
 1888/28DE :                            ;;; The following is the old code, before patch 3
 1889/28DE :                            ;;;        JMP	EXEC               ;To the display device then return to EXECUTIVE.
 1890/28DE : 06 C4                      DVERR:     MVI	A, 304o               ;Set up ASCII code for letter 'D' in Accumulator
 1891/28E0 : 16 DA                                 MVI	C, 332o               ;Set up ASCII code for letter 'Z' in CPU register C
 1892/28E2 : 44 96 20                              JMP	ERROR              ;Go display the 'DZ' (divide by zero) error message
 1893/28E5 : 06 C6                      FIXERR:    MVI	A, 306o               ;Set up ASCII code for letter 'F' in Accumulator
 1894/28E7 : 16 D8                                 MVI	C, 330o               ;Set up ASCII code for letter 'X' in CPU register C
 1895/28E9 : 44 96 20                              JMP	ERROR              ;Go display the 'FX' (FiX) error message
 1896/28EC : 06 C9                      NUMERR:    MVI	A, 311o               ;Set up ASCII code for letter 'I' in Accumulator
 1897/28EE : 16 CE                                 MVI	C, 316o               ;Set up ASCII code for letter 'N' in CPU register C
 1898/28F0 : 36 90                                 MVI	L, 220o               ;Load L with address of pointer used by DINPUT
 1899/28F2 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Routine. Do same for register H.
 1900/28F4 : 3E 00                                 MVI	M, 000                ;Clear the location
 1901/28F6 : 44 96 20                              JMP	ERROR              ;Go display the'IN'(Illegal Number) error message
 1902/28F9 :                            
 1903/28F9 :                                                              ;The following subroutine, used by various sections of
 1904/28F9 :                                                              ;SCELBAL, will search the LINE INPUT BUGGER for
 1905/28F9 :                                                              ;a character string which is contained in a buffer starting
 1906/28F9 :                                                              ;at the address pointed to by CPU registers H & L when
 1907/28F9 :                                                              ;the subroutine is entered.
 1908/28F9 :                            
 1909/28F9 : 1E 03                      INSTR:     MVI	D,PG26 ;\HB\OLDPG26   ;**Set D to starting page of LINE INPUT BUFFER
 1910/28FB : 26 00                                 MVI	E, 000                ;Load E with starting location of LINE INPUT BUFFER
 1911/28FD : 46 23 29                   INSTR1:    CALL	ADVDE              ;Advancer D & E pointer to the next location (input
 1912/2900 : 46 BA 30                              CALL	SAVEHL             ;Buffer). Now save contents of d, E, H & L vefore the
 1913/2903 : CF                                    MOV	B,M                    ;Compare operations. Get length of TEST buffer in B.
 1914/2904 : 46 FF 20                              CALL	ADV                ;Advance H & L buffer to first char in TEST buffer.
 1915/2907 : 46 F8 20                              CALL	STRCPC             ;Compare contents of TEST buffer against input buffer
 1916/290A : 68 CA 30                              JZ	RESTHL             ;For length B. If match, restore pntrs and exit to caller.
 1917/290D : 46 CA 30                              CALL	RESTHL             ;If no match, restore pointers for loop test.
 1918/2910 : 36 00                                 MVI	L, 000                ;Load L with start of input buffer (to get the char cntr).
 1919/2912 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;**Load H with page of input buffer.
 1920/2914 : C7                                    MOV	A,M                    ;Get length of buffer (cc) into the accumulator.
 1921/2915 : BC                                    CMP	E                    ;Compare with current input buffer pointer value.
 1922/2916 : 68 20 29                              JZ	INSTR2             ;If at end of buffer, jump ahead.
 1923/2919 : 46 CA 30                              CALL	RESTHL             ;Else restore test string address (H&L) and input buffer
 1924/291C : 44 FD 28                              JMP	INSTR1             ;Address (D&E). Look gor occurrence of test string in ln.
 1925/291F : 00                                    HLT             ;Safety halt. If program reaches here have system failure.
 1926/2920 : 26 00                      INSTR2:    MVI	E, 000                ;If reach end of input buffer without finding a match
 1927/2922 : 07                                    RET                    ;Load E with 000 as an indicator and return to caller.
 1928/2923 : 20                         ADVDE:     INR	E                    ;Subroutine to advance the pointer in the register
 1929/2924 : 0B                                    RNZ                    ;Pair D & E. Advance contents of E. Return if not zero.
 1930/2925 : 18                                    INR	D                    ;If register E goes to 0 when advanced, then advance
 1931/2926 : 07                                    RET                    ;Register D too. Exit to calling routine.
 1932/2927 :                            
 1933/2927 :                            ;;; The label RUN should start at 13-170 0b78h
 1934/2927 : 36 3B                      RUN:       MVI	L, 073o               ;Load L with addr of GOSUB/RETURN stack pointer
 1935/2929 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Load H with page of same pointer
 1936/292B : 3E 00                                 MVI	M, 000                ;Initialize the GOSUB/RETURN stack pointer to zero
 1937/292D : 36 85                                 MVI	L, 205o               ;Load L with addr of FOR/NEXT stack pointer
 1938/292F : 3E 00                                 MVI	M, 000                ;Initialize the FOR/NEXT stack pointer to zero
 1939/2931 : 36 F0                                 MVI	L, 360o               ;Load L with addr of user pgm buffer line pointer
 1940/2933 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of user pgm buffer line pointer
 1941/2935 : 3E 06                                 MVI	M, BGNPGRAM           ;tt Initialize pointer (may be altered by user)   *******
 1942/2937 : 30                                    INR	L                    ;Advance memory pointer to low portion of user pgm
 1943/2938 : 3E 00                                 MVI	M, 000                ;Buffer pointer and initialize to start of buffer
 1944/293A : 44 5D 29                              JMP	SAMLIN             ;Start executing user program with first line in buffer
 1945/293D : 36 F0                      NXTLIN:    MVI	L, 360o               ;Load L with addr of user program buffer line pointer
 1946/293F : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of user pgm buffer line pointer
 1947/2941 : DF                                    MOV	D,M                    ;Place page addr of pgm buffer line pointer in D
 1948/2942 : 30                                    INR	L                    ;Advance the memory pointer
 1949/2943 : E7                                    MOV	E,M                    ;Place low addr of pgm buffer line pointer in E
 1950/2944 : EB                                    MOV	H,D                    ;Also put page addr of pgm buffer line pointer in H
 1951/2945 : F4                                    MOV	L,E                    ;And low addr of pgm buffer line pointer in L
 1952/2946 : CF                                    MOV	B,M                    ;Now fetch the (cc) of current line into register B
 1953/2947 : 08                                    INR	B                    ;Add one to account for (cc) byte itself
 1954/2948 : 46 AE 28                              CALL	ADBDE              ;Add value in B to D&E to point to next line in
 1955/294B : 36 F0                                 MVI	L, 360o               ;User program buffer. Reset L to addr of user logrn
 1956/294D : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Buffer pointer storage location. Store the new
 1957/294F : FB                                    MOV	M,D                    ;Updated user pgm line pointer in pointer storage
 1958/2950 : 30                                    INR	L                    ;Location. Store both the high portion
 1959/2951 : FC                                    MOV	M,E                    ;And low portion. (Now points to next line to be
 1960/2952 : 36 E0                                 MVI	L, 340o               ;Processed from user program buffer.) Change pointer
 1961/2954 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** To address of line number buffer. Fetch the last
 1962/2956 : C7                                    MOV	A,M                    ;Line number (length) processed. Test to see if it was
 1963/2957 : A0                                    ANA	A                    ;Blank. If it was blank
 1964/2958 : 68 B6 26                              JZ	EXEC               ;Then stop processing and return to the Executive
 1965/295B : C0                                    MOV	A,A                    ;Insert two effective NOPs here
 1966/295C : C0                                    MOV	A,A                    ;In case of patching
 1967/295D : 36 F0                      SAMLIN:    MVI	L, 360o               ;Load L with addr of user program buffer line pointer
 1968/295F : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of same pointer
 1969/2961 : D7                                    MOV	C,M                    ;Fetch the high portion of the pointer into register C
 1970/2962 : 30                                    INR	L                    ;Advance the memory pointer
 1971/2963 : F7                                    MOV	L,M                    ;Fetch the low portion of the pointer into register L
 1972/2964 : EA                                    MOV	H,C                    ;Now move the high portion into register H
 1973/2965 : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Set D to page of line input buffer
 1974/2967 : 26 00                                 MVI	E, 000                ;Set E to address of start of line input buffer
 1975/2969 : 46 0F 28                              CALL	MOVEC              ;Move the line ftom the user program buffer into the
 1976/296C : 36 00                                 MVI	L, 000                ;Line input buffer. Now reset the pointer to the start
 1977/296E : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Of the line input buffer.
 1978/2970 : C7                                    MOV	A,M                    ;Fetch the first byte of the line input buffer (cc)
 1979/2971 : A0                                    ANA	A                    ;Test (cc) value to see if fetched a blank line
 1980/2972 : 68 B6 26                              JZ	EXEC               ;If fetched a blank line, return to the Executive
 1981/2975 : 46 00 20                              CALL	SYNTAX             ;Else call subrtn to strip off line nr & set statement toke
 1982/2978 :                            
 1983/2978 : 36 83                      DIRECT:    MVI	L, 203o               ;Load L with address of syntax TOKEN storage location
 1984/297A : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of syntax TOKEN location
 1985/297C : C7                                    MOV	A,M                    ;Fetch the TOKEN value into the accumulator
 1986/297D : 3C 01                                 CPI	001                ;Is it token value for REM statement? If so, ignore the
 1987/297F : 68 3D 29                              JZ	NXTLIN             ;Current line and go on to the next line in pgm buffer.
 1988/2982 : 3C 02                                 CPI	002                ;Is it token value for IF statement?
 1989/2984 : 68 06 2C                              JZ	IF                 ;If yes, then go to the IF statement routine.
 1990/2987 : 3C 03                                 CPI	003                ;Is it token value for LET statement? (Using keyword)
 1991/2989 : 68 08 2B                              JZ	LET                ;If yes, then go to the LET statement routine.
 1992/298C : 3C 04                                 CPI	004                ;Is it token value for GOTO statement?
 1993/298E : 68 6B 2B                              JZ	GOTO               ;If yes, then go to the GOTO statement routine.
 1994/2991 : 3C 05                                 CPI	005                ;Is it token value for PRINT statement?
 1995/2993 : 68 D4 29                              JZ	PRINT              ;If yes, then go to the PRINT statement routine.
 1996/2996 : 3C 06                                 CPI	006                ;Is it token value for INPUT statement?
 1997/2998 : 68 E4 2C                              JZ	INPUT              ;If yes, then go to the INPUT statement routine.
 1998/299B : 3C 07                                 CPI	007                ;Is it token value for FOR statement?
 1999/299D : 68 63 2D                              JZ	FOR                ;If yes, then go to the FOR statement routine.
 2000/29A0 : 3C 08                                 CPI	010o               ;Is it token value for NEXT statement?
 2001/29A2 : 68 E3 33                              JZ	NEXT               ;If yes, then go to the NEXT statement routine.
 2002/29A5 : 3C 09                                 CPI	011o               ;Is it token value for GOSUB statement?
 2003/29A7 : 68 8D 2C                              JZ	GOSUB              ;If yes, then go to the GOSUB statement routine.
 2004/29AA : 3C 0A                                 CPI	012o               ;Is it token value for RETURN statement?
 2005/29AC : 68 B3 2C                              JZ	RETURN             ;If yes, then go to the RETURN statement routine.
 2006/29AF : 3C 0B                                 CPI	013o               ;Is it token value for DIM statement?
 2007/29B1 : 68 85 37                              JZ	DIM                ;If yes, then go to the DIM statement routine.
 2008/29B4 : 3C 0C                                 CPI	014o               ;Is it token value for END statement?
 2009/29B6 : 68 B6 26                              JZ	EXEC               ;If yes, then go back to the Executive, user pgm finished!
 2010/29B9 : 3C 0D                                 CPI	015o               ;Is it token value for IMPLIED LET statement?
 2011/29BB : 68 FA 2A                              JZ	LET0               ;If yes, then go to special LET entry point.
 2012/29BE : 3C 0E                                 CPI	016o               ;@@ Is it token value for ARRAY IMPLIED LET?
 2013/29C0 : 48 6A 27                              JNZ	SYNERR             ;If not, then assume a syntax error condition.
 2014/29C3 : 46 FB 36                              CALL	ARRAY1             ;@@ Else, perform array storage set up subroutine.
 2015/29C6 : 36 86                                 MVI	L, 206o               ;@@ Set L to array pointer storage location.
 2016/29C8 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;@@ * * Set H to array pointer storage location.
 2017/29CA : CF                                    MOV	B,M                    ;@@ Fetch array pointer to register B.
 2018/29CB : 36 82                                 MVI	L, 202o               ;@@ Change memory pointer to syntax pntr storage loc.
 2019/29CD : F9                                    MOV	M,B                    ;@@ Save array pointer value there.
 2020/29CE : 46 A0 26                              CALL	SAVESY             ;@@ Save array name in auxiliary symbol buffer
 2021/29D1 : 44 11 2B                              JMP	LET1
 2022/29D4 : 36 82                      PRINT:     MVI	L, 202o               ;Load L with address of SCAN pointer storage location
 2023/29D6 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of SCAN pointer
 2024/29D8 : C7                                    MOV	A,M                    ;Fetch the pointer value (last character scanned by the
 2025/29D9 : 36 00                                 MVI	L, 000                ;SYNTAX routine). Change pointer to line buffer (cc).
 2026/29DB : BF                                    CMP	M                    ;Compare pointer value to buffer length. If not equal
 2027/29DC : 70 E5 29                              JM	PRINT1             ;Then line contains more than stand alone PRINT state-
 2028/29DF : 46 61 21                              CALL	CRLF               ;Ment. However, if just have PRINT statement then issue
 2029/29E2 : 44 3D 29                              JMP	NXTLIN             ;A carriage-return & line-feed combination, then exit.
 2030/29E5 : 46 AD 20                   PRINT1:    CALL	CLESYM             ;Initialize the SYMBOL buffer for new entry.
 2031/29E8 : 36 82                                 MVI	L, 202o               ;Load L with address of SCAN buffer pointer
 2032/29EA : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of SCAN pointer
 2033/29EC : CF                                    MOV	B,M                    ;Pointer points to last char scanned by SYNTAX. Need
 2034/29ED : 08                                    INR	B                    ;To increment it to point to next char in statement line.
 2035/29EE : 36 83                                 MVI	L, 203o               ;Load L with address of former TOKEN value. Use it as
 2036/29F0 : F9                                    MOV	M,B                    ;Storage location for a PRINT statement pointer.
 2037/29F1 : 36 83                      PRINT2:    MVI	L, 203o               ;Set memory pointer to PRINT pointer storage location
 2038/29F3 : 46 A0 20                              CALL	GETCHR             ;Fetch character in input buffer pointed to by PRINT
 2039/29F6 : 3C A7                                 CPI	247o               ;Pointer. See if it is ASCII code for single quote mark.
 2040/29F8 : 68 72 2A                              JZ	QUOTE              ;If so, go to QUOTE section to process text string.
 2041/29FB : 3C A2                                 CPI	242o               ;If not, see if it is ASCII code for double quote mark.
 2042/29FD : 68 72 2A                              JZ	QUOTE              ;If so, go to QUOTE section to process text string.
 2043/2A00 : 3C AC                                 CPI	254o               ;If not, see if it is ASCII code for comma sign.
 2044/2A02 : 68 12 2A                              JZ	PRINT3             ;If so, go evaluate expression.
 2045/2A05 : 3C BB                                 CPI	273o               ;If not, see if it is ASCII code for semi-colon sign.
 2046/2A07 : 68 12 2A                              JZ	PRINT3             ;If so, go evaluate expression.
 2047/2A0A : 36 83                                 MVI	L, 203o               ;Load L with address of PRINT pointer storage location.
 2048/2A0C : 46 03 21                              CALL	LOOP               ;Increment pointer and test for end of line.
 2049/2A0F : 48 F1 29                              JNZ	PRINT2             ;If not end of line, fetch the next character.
 2050/2A12 : 36 82                      PRINT3:    MVI	L, 202o               ;Load L with address of SCAN pointer storage location
 2051/2A14 : CF                                    MOV	B,M                    ;Fetch value of the pointer (last letter of KEYWORD)
 2052/2A15 : 08                                    INR	B                    ;Add one to point to first character of expression
 2053/2A16 : 36 BE                                 MVI	L, 276o               ;Load L with addr of EVAL pointer storage location
 2054/2A18 : F9                                    MOV	M,B                    ;Store addr at which EVAL should start scanning
 2055/2A19 : 36 83                                 MVI	L, 203o               ;Load L with address of PRINT pointer
 2056/2A1B : CF                                    MOV	B,M                    ;Which points to field terminator
 2057/2A1C : 09                                    DCR	B                    ;Decrement pointer value to last character of expression
 2058/2A1D : 36 BF                                 MVI	L, 277o               ;Load L with address of EVAL FINISH pntr storage loc.
 2059/2A1F : F9                                    MOV	M,B                    ;Place address value of last char in PRINT field there
 2060/2A20 : 36 F7                                 MVI	L, 367o               ;Load L with address of QUOTE flag
 2061/2A22 : C7                                    MOV	A,M                    ;Fetch the value of the QUOTE flag into the ACC
 2062/2A23 : A0                                    ANA	A                    ;Test the QUOTE flag status
 2063/2A24 : 68 2C 2A                              JZ	PRINT4             ;If field not quoted, proceed to evaluate expression
 2064/2A27 : 3E 00                                 MVI	M, 000                ;If field quoted, then clear the QUOTE flag for next field
 2065/2A29 : 44 44 2A                              JMP	PRINT6             ;And skip the evaluation procedure
 2066/2A2C : 46 94 21                   PRINT4:    CALL	EVAL               ;Evaluate the current PRINT field
 2067/2A2F : 36 7F                                 MVI	L, 177o               ;Then load L,with address of the TAB flag
 2068/2A31 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with the page of the TAB flag
 2069/2A33 : C7                                    MOV	A,M                    ;Fetch the value of the TAB flag into the accumulator
 2070/2A34 : A0                                    ANA	A                    ;Test the TAB flag
 2071/2A35 : 36 48                                 MVI	L, 110o               ;Change L to the FIXED/FLOAT flag location
 2072/2A37 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Change H to the FIXED/FLOAT flag page
 2073/2A39 : 3E FF                                 MVI	M, 377o               ;Set FIXED/FLOAT flag to fixed point
 2074/2A3B : 6A BB 2A                   PRINT5:    CZ	PFPOUT             ;If TAB flag not set, display value of expression
 2075/2A3E : 36 7F                                 MVI	L, 177o               ;Load L with address of TAB flag
 2076/2A40 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of TAB flag
 2077/2A42 : 3E 00                                 MVI	M, 000                ;Reset TAB flag for next PRINT field
 2078/2A44 : 36 83                      PRINT6:    MVI	L, 203o               ;Load L with address of PRINT pointer stomge location
 2079/2A46 : 46 A0 20                              CALL	GETCHR             ;Fetch the character pointed to by the PRINT pointer
 2080/2A49 : 3C AC                                 CPI	254o               ;See if the last character scanned was a comma sign
 2081/2A4B : 6A DE 2A                              CZ	PCOMMA             ;If so, then display spaces to next TA.B location
 2082/2A4E : 36 83                                 MVI	L, 203o               ;Reset L to address of PRINT pointer storage location
 2083/2A50 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Reset H to page of PRINT pointer stomge location
 2084/2A52 : CF                                    MOV	B,M                    ;Fetch the value of the pointer into register B
 2085/2A53 : 36 82                                 MVI	L, 202o               ;Change L to SCAN pointer storage location
 2086/2A55 : F9                                    MOV	M,B                    ;Place end of last field processed into SCAN pointer
 2087/2A56 : 36 00                                 MVI	L, 000                ;Change pointer to start of line input buffer
 2088/2A58 : C1                                    MOV	A,B                    ;Place pntr to last char scanned into the accumulator
 2089/2A59 : BF                                    CMP	M                    ;Compare this value to the (cc) for the line buffer
 2090/2A5A : 70 E5 29                              JM	PRINT1             ;If not end of line, continue to process next field
 2091/2A5D : 36 00                                 MVI	L, 000                ;If end of line, fetch the last character in the line
 2092/2A5F : 46 A0 20                              CALL	GETCHR             ;And check to see if it
 2093/2A62 : 3C AC                                 CPI	254o               ;Was a comma. If it was, go on to the next line in the
 2094/2A64 : 68 3D 29                              JZ	NXTLIN             ;User program buffer without displaying a CR & LF.
 2095/2A67 : 3C BB                                 CPI	273o               ;If not a comma, check to see if it was a semi-colon.
 2096/2A69 : 68 3D 29                              JZ	NXTLIN             ;If so, do not provide a CR & LF combination.
 2097/2A6C : 46 61 21                              CALL	CRLF               ;If not comma or semi-colon, provide CR & LF at end
 2098/2A6F : 44 3D 29                              JMP	NXTLIN             ;Of a PRINT statement. Go process next line of pgrm.
 2099/2A72 : 36 F7                      QUOTE:     MVI	L, 367o               ;Load L with address of QUOTE flag
 2100/2A74 : F8                                    MOV	M,A                    ;Store type of quote in flag storage location
 2101/2A75 : 46 AD 20                              CALL	CLESYM             ;Initialize the SYMBOL buffer for new entry
 2102/2A78 : 36 83                                 MVI	L, 203o               ;Load L with address of PRINT pointer
 2103/2A7A : CF                                    MOV	B,M                    ;Fetch the PRINT pointer into register B
 2104/2A7B : 08                                    INR	B                    ;Add one to advance over quote character
 2105/2A7C : 36 84                                 MVI	L, 204o               ;Load L with address of QUOTE pointer
 2106/2A7E : F9                                    MOV	M,B                    ;Store the beginning of the QUOTE field pointer
 2107/2A7F : 36 84                      QUOTE1:    MVI	L, 204o               ;Load L with address of QUOTE pointer
 2108/2A81 : 46 A0 20                              CALL	GETCHR             ;Fetch the next character in the TEXT field
 2109/2A84 : 36 F7                                 MVI	L, 367o               ;Load L with the QUOTE flag (type of quote)
 2110/2A86 : BF                                    CMP	M                    ;Compare to see if latest character this quote mark
 2111/2A87 : 68 A2 2A                              JZ	QUOTE2             ;If so, finish up this quote field
 2112/2A8A : 46 82 21                              CALL	ECHO               ;If not, display the character as part of TEXT
 2113/2A8D : 36 84                                 MVI	L, 204o               ;Reset L to QUOTE pointer storage location
 2114/2A8F : 46 03 21                              CALL	LOOP               ;Increment QUOTE pointer and test for end of line
 2115/2A92 : 48 7F 2A                              JNZ	QUOTE1             ;If not end of line, continue processing TEXT field
 2116/2A95 : 06 C9                      QUOTER:    MVI	A, 311o               ;If end of line before closing quote mark have an error
 2117/2A97 : 16 D1                                 MVI	C, 321o               ;So load ACC with I and register C with Q
 2118/2A99 : 36 F7                                 MVI	L, 367o               ;Load L with the address of the QUOTE flag
 2119/2A9B : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with the page of the QUOTE flag
 2120/2A9D : 3E 00                                 MVI	M, 000                ;Clear the QUOTE flag for future use
 2121/2A9F : 44 96 20                              JMP	ERROR              ;Go display the IQ (Illegal Quote) error message
 2122/2AA2 : 36 84                      QUOTE2:    MVI	L, 204o               ;Load L with address of QUOTE pointer
 2123/2AA4 : CF                                    MOV	B,M                    ;Fetch the QUOTE pointer into register B
 2124/2AA5 : 36 82                                 MVI	L, 202o               ;Load L with address of SCAN pointer storage location
 2125/2AA7 : F9                                    MOV	M,B                    ;Store former QUOTE vointer as start of next field
 2126/2AA8 : C1                                    MOV	A,B                    ;Place QUOTE pointer into the accumulator
 2127/2AA9 : 36 00                                 MVI	L, 000                ;Change L to point to start of the input line buffer
 2128/2AAB : BF                                    CMP	M                    ;Compare QUOTE pointer value with (cc) value
 2129/2AAC : 48 E5 29                              JNZ	PRINT1             ;If not end of line, process next PRINT field
 2130/2AAF : 46 61 21                              CALL	CRLF               ;Else display a CR & LF combination at the end of line
 2131/2AB2 : 36 F7                                 MVI	L, 367o               ;Load L with the address of the TAB flag
 2132/2AB4 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with the page of the TAB flag
 2133/2AB6 : 3E 00                                 MVI	M, 000                ;Clear the TAB flag for future use
 2134/2AB8 : 44 3D 29                              JMP	NXTLIN             ;Go process next line of the program.
 2135/2ABB :                            
 2136/2ABB :                                                              ;The following subroutines are utilized by the PRINT
 2137/2ABB :                                                              ;routine.
 2138/2ABB :                            ;;; The label PFPOUT SHOULD BE AT 14 314 0ccch
 2139/2ABB : 36 56                      PFPOUT:    MVI	L, 126o               ;Load L with the address of the FPACC MSW (Floating
 2140/2ABD : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Point ACC). Load H with page of the FPACC MSW.
 2141/2ABF : C7                                    MOV	A,M                    ;Fetch the FPACC MSW into the accumulator. Test to
 2142/2AC0 : A0                                    ANA	A                    ;See if the FPACC MSW is zero. If so, then simply go and
 2143/2AC1 : 68 CD 2A                              JZ	ZERO               ;Display the value "0"
 2144/2AC4 : 30                                    INR	L                    ;Else advance the pointer to the FPACC Exponent
 2145/2AC5 : C7                                    MOV	A,M                    ;Fetch the FPACC Exponent into the accumulator
 2146/2AC6 : A0                                    ANA	A                    ;See if any exponent value. If not, mantissa is in range
 2147/2AC7 : 68 D7 2A                              JZ	FRAC               ;0.5 to 1.0. Treat number as a fraction.
 2148/2ACA : 44 60 32                              JMP	FPOUT              ;Else perform regular numerical output routine.
 2149/2ACD : 06 A0                      ZERO:      MVI	A, 240o               ;Load ASCII code for space into the ACC
 2150/2ACF : 46 82 21                              CALL	ECHO               ;Display the space
 2151/2AD2 : 06 B0                                 MVI	A, 260o               ;Load ASCII code for 0 into the ACC
 2152/2AD4 : 44 82 21                              JMP	ECHO               ;Display 0 and exit to calling routine
 2153/2AD7 : 36 48                      FRAC:      MVI	L, 110o               ;Load L with address of FIXED/FLOAT flag
 2154/2AD9 : 3E 00                                 MVI	M, 000                ;Reset it to indicate floating point mode
 2155/2ADB : 44 60 32                              JMP	FPOUT              ;Display floating point number and return to caller
 2156/2ADE : 36 00                      PCOMMA:    MVI	L, 000                ;Load L with address of (cc) in line input buffer
 2157/2AE0 : C7                                    MOV	A,M                    ;Fetch the (cc) for the line into the ACC
 2158/2AE1 : 36 83                                 MVI	L, 203o               ;Change pointer to PRINT pointer storage location
 2159/2AE3 : 97                                    SUB	M                    ;Subtract value of PRINT pointer from line (cc)
 2160/2AE4 : 33                                    RM                    ;If at end of buffer, do not TAB
 2161/2AE5 : 36 23                                 MVI	L, 043o               ;If not end, load L with address of COLUMN COUNTER
 2162/2AE7 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of COLUMN COUNTER
 2163/2AE9 : C7                                    MOV	A,M                    ;Fetch COLUMN COUNTER into the accumulator
 2164/2AEA : 24 F0                                 ANI	360o               ;Find the last TAB position (multiple of 16 decimal)
 2165/2AEC : 04 10                                 ADI	020o               ;Add 16 (decimal) to get new TAB position
 2166/2AEE : 97                                    SUB	M                    ;Subtract current position from next TAB position
 2167/2AEF : D0                                    MOV	C,A                    ;Store this value in register C as a counter
 2168/2AF0 : 06 A0                                 MVI	A, 240o               ;Load the ACC with the ASCII code for space
 2169/2AF2 : 46 82 21                   PCOM1:     CALL	ECHO               ;Display the space
 2170/2AF5 : 11                                    DCR	C                    ;Decrement the loop counter
 2171/2AF6 : 48 F2 2A                              JNZ	PCOM1              ;Continue displaying spaces until loop counter is zero
 2172/2AF9 : 07                                    RET                    ;Then return to calling routine
 2173/2AFA : 46 A0 26                   LET0:      CALL	SAVESY             ;Entry point for IMPLIED LET statement. Save the
 2174/2AFD : 36 82                                 MVI	L, 202o               ;Variable (to left of the equal sign). Set L to the SCAN
 2175/2AFF : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Pointer. Set H to the page of the SCAN pointer.
 2176/2B01 : CF                                    MOV	B,M                    ;Fetch value of SCAN pointer. (Points to = sign in In bf)
 2177/2B02 : 36 83                                 MVI	L, 203o               ;Change pointer to LET pointer (was TOKEN value)
 2178/2B04 : F9                                    MOV	M,B                    ;Place the SCAN pointer value into the LET pointer
 2179/2B05 : 44 50 2B                              JMP	LET5               ;Continue processing the LET statement line
 2180/2B08 : 46 AD 20                   LET:       CALL	CLESYM             ;Initialize the SYMBOL BUFFER for new entry
 2181/2B0B : 36 64                                 MVI	L, 144o               ;Load L with address of start of AUX SYMBOL BUFF
 2182/2B0D : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of AUX SYMBOL BUFFER
 2183/2B0F : 3E 00                                 MVI	M, 000                ;Initialize AUX SYMBOL BUFFER
 2184/2B11 : 36 82                      LET1:      MVI	L, 202o               ;Entry point for ARRAY IMPLIED LET statement.
 2185/2B13 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set pointer to SCAN pointer storage location
 2186/2B15 : CF                                    MOV	B,M                    ;Fetch the SCAN pointer value (last letter scanned by
 2187/2B16 : 08                                    INR	B                    ;SYNTAX subroutine) and add one to next character
 2188/2B17 : 36 83                                 MVI	L, 203o               ;Change L to LET pointer storage location
 2189/2B19 : F9                                    MOV	M,B                    ;Store former SCAN value (updated) in LET pointer
 2190/2B1A : 36 83                      LET2:      MVI	L, 203o               ;Set L to gtorage location of LET pointer
 2191/2B1C : 46 A0 20                              CALL	GETCHR             ;Fetch the character pointed to by the LET pointer
 2192/2B1F : 68 41 2B                              JZ	LET4               ;If character is a space, ignore it
 2193/2B22 : 3C BD                                 CPI	275o               ;See if character is the equal (=) sign
 2194/2B24 : 68 50 2B                              JZ	LET5               ;If so, go process other side of the statement (after
 2195/2B27 : 3C A8                                 CPI	250o               ;@@ If not, see if character is a right parenthesis
 2196/2B29 : 48 3A 2B                              JNZ	LET3               ;If not, continue looking for equal sign
 2197/2B2C : 46 F5 36                              CALL	ARRAY              ;@@ If so, have subscript. Call array set up subroutine.
 2198/2B2F : 36 86                                 MVI	L, 206o               ;@@ Load L with address of ARRAY pointer
 2199/2B31 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;@@ ** Load H with page of ARRAY pointer
 2200/2B33 : CF                                    MOV	B,M                    ;@@ Fetch value (points to ")" character of subscript)
 2201/2B34 : 36 83                                 MVI	L, 203o               ;@@ Load L with address of LET pointer
 2202/2B36 : F9                                    MOV	M,B                    ;@@ Place ARRAY pointer value as new LET pointer
 2203/2B37 : 44 41 2B                              JMP	LET4               ;@@ Continue to look for = sign in statement line
 2204/2B3A : 36 64                      LET3:      MVI	L, 144o               ;Reset L to start of AUX SYMBOL BUFFER
 2205/2B3C : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ** Load H with page of AUX SYMBOL BUFFER
 2206/2B3E : 46 CC 20                              CALL	CONCT1             ;Concatenate character to the AUX SYMBOL BUFFER
 2207/2B41 : 36 83                      LET4:      MVI	L, 203o               ;Load L with address of LET pointer storage location
 2208/2B43 : 46 03 21                              CALL	LOOP               ;Add one to pointer and test for end of line input buffer
 2209/2B46 : 48 1A 2B                              JNZ	LET2               ;If not end of line, continue looking for the equal sign
 2210/2B49 : 06 CC                      LETERR:    MVI	A, 314o               ;If do not find an equal sign in the LET statement line
 2211/2B4B : 16 C5                                 MVI	C, 305o               ;Then have a LE (Let Error). Load the code for L and E
 2212/2B4D : 44 96 20                              JMP	ERROR              ;Into registers ACC and C and go display the error msg.
 2213/2B50 : 36 83                      LET5:      MVI	L, 203o               ;When find the equal sign, reset L to point to the LET
 2214/2B52 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Pointer and H to the proper page. Fetch the pointer
 2215/2B54 : CF                                    MOV	B,M                    ;Value into register B and add one to advance pointer
 2216/2B55 : 08                                    INR	B                    ;Over the equal sign to first char in the expression.
 2217/2B56 : 36 BE                                 MVI	L, 276o               ;Set L to point to the address of the EVAL pointer
 2218/2B58 : F9                                    MOV	M,B                    ;Set EVAL pointer to start evaluating right after the
 2219/2B59 : 36 00                                 MVI	L, 000                ;Equal sign. Now change L to start of line input buffer.
 2220/2B5B : CF                                    MOV	B,M                    ;Fetch the (cc) value into register B. (Length of line.)
 2221/2B5C : 36 BF                                 MVI	L, 277o               ;Load L with EVAL FINISH pointer storage location.
 2222/2B5E : F9                                    MOV	M,B                    ;Set it to stop evaluating at end of the line.
 2223/2B5F : 46 94 21                              CALL	EVAL               ;Call the subroutine to evaluate the expression.
 2224/2B62 : 46 AA 26                              CALL	RESTSY             ;Restore the name of the variable to receive new value.
 2225/2B65 : 46 2D 26                              CALL	STOSYM             ;Store the new value for the variable in variables table.
 2226/2B68 : 44 3D 29                              JMP	NXTLIN             ;Go process next line of the program.
 2227/2B6B : 36 E8                      GOTO:      MVI	L, 350o               ;Load L with start of AUX LINE NR BUFFER
 2228/2B6D : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of AUX LINE NR BUFFER
 2229/2B6F : 3E 00                                 MVI	M, 000                ;Initialize the AUX LINE NR BUFFER to zero
 2230/2B71 : 36 82                                 MVI	L, 202o               ;Load L with address of SCAN pointer storage location
 2231/2B73 : CF                                    MOV	B,M                    ;Fetch pointer value (last char scanned by SYNTAX)
 2232/2B74 : 08                                    INR	B                    ;Add one to skip over the last 0 in GOTO keyword
 2233/2B75 : 36 83                                 MVI	L, 203o               ;Change pointer to GOTO pointer (formerly TOKEN)
 2234/2B77 : F9                                    MOV	M,B                    ;Store the updated SCAN pointer as the GOTO pointer
 2235/2B78 : 36 83                      GOTO1:     MVI	L, 203o               ;Load L with address of GOTO pointer
 2236/2B7A : 46 A0 20                              CALL	GETCHR             ;Fetch the character pointed to by the GOTO pointer
 2237/2B7D : 68 8F 2B                              JZ	GOTO2              ;If character was a space, ignore it
 2238/2B80 : 3C B0                                 CPI	260o               ;See if character is in the range of a decimal digit
 2239/2B82 : 70 97 2B                              JM	GOTO3              ;If not, must have end of the line number digit string
 2240/2B85 : 3C BA                                 CPI	272o               ;Continue to test for decitnal digit
 2241/2B87 : 50 97 2B                              JP	GOTO3              ;If not, mugt have end of the line number digit string
 2242/2B8A : 36 E8                                 MVI	L, 350o               ;If valid decimal digit, load L with addr of AUX LINE
 2243/2B8C : 46 CC 20                              CALL	CONCT1             ;NR BUFFER and concatenate digit to the buffer.
 2244/2B8F : 36 83                      GOTO2:     MVI	L, 203o               ;Reset pointer to GOTO pointer storage location
 2245/2B91 : 46 03 21                              CALL	LOOP               ;Advance the pointer value and test for end of line
 2246/2B94 : 48 78 2B                              JNZ	GOTO1              ;If not end of line, fetch next digit in GOTO line number
 2247/2B97 : 36 F0                      GOTO3:	   MVI	L, 360o               ;Set L to user program buffer pointer storage location
 2248/2B99 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of program buffer pointer
 2249/2B9B : 3E 06                                 MVI	M, BGNPGRAM           ;Initialize high part of pointer to start of pgm buffer
 2250/2B9D : 30                                    INR	L                    ;Advance the memory point
 2251/2B9E : 3E 00                                 MVI	M, 000                ;Initialize the low part of pointer to start of pgm buffer
 2252/2BA0 : 46 AD 20                   GOTO4:     CALL	CLESYM             ;Clear the SYMBOL BUFFER
 2253/2BA3 : 36 84                                 MVI	L, 204o               ;Load L with address of GOTO SEARCH pointer
 2254/2BA5 : 3E 01                                 MVI	M, 001                ;Initialize to one for first char of line
 2255/2BA7 : 36 84                      GOTO5:     MVI	L, 204o               ;Load L with address of GOTO SEARCH pointer
 2256/2BA9 : 46 3C 28                              CALL	GETCHP             ;Fetch character pointed to by GOTO SEARCH pointer
 2257/2BAC : 68 BC 2B                              JZ	GOTO6              ;From line pointed to in user program buffer. Ignore
 2258/2BAF : 3C B0                                 CPI	260o               ;Spaces. Check to see if character is a decirnal digit.
 2259/2BB1 : 70 CF 2B                              JM	GOTO7              ;If not, then have processed line number at the start of
 2260/2BB4 : 3C BA                                 CPI	272o               ;The current line. Continue the check for a valid decimal
 2261/2BB6 : 50 CF 2B                              JP	GOTO7              ;Digit. If have a decirnal digit then concatenate the digit
 2262/2BB9 : 46 C8 20                              CALL	CONCTS             ;Onto the current string in the SYMBOL BUFFER,
 2263/2BBC : 36 84                      GOTO6:     MVI	L, 204o               ;Change L to the address of the GOTO SEARCH pointer
 2264/2BBE : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** And H to the proper page of the pointer
 2265/2BC0 : CF                                    MOV	B,M                    ;Fetch the GOTO SEARCH pointer value
 2266/2BC1 : 08                                    INR	B                    ;Increment the GOTO SEARCH pointer
 2267/2BC2 : F9                                    MOV	M,B                    ;And restore it back to memory
 2268/2BC3 : 36 F0                                 MVI	L, 360o               ;Change L to address of user program buffer pointer
 2269/2BC5 : D7                                    MOV	C,M                    ;Save the high part of this pointer value in register C
 2270/2BC6 : 30                                    INR	L                    ;Advance L to the low part of the pgrn buffer pointer
 2271/2BC7 : F7                                    MOV	L,M                    ;Now load it into L
 2272/2BC8 : EA                                    MOV	H,C                    ;And transfer C into H to point to start of the line
 2273/2BC9 : C7                                    MOV	A,M                    ;Fetch the (cc) of the current line being pointed to in the
 2274/2BCA : 09                                    DCR	B                    ;User pgm buff. Decrernent B to previous value. Compare
 2275/2BCB : B9                                    CMP	B                    ;GOTO SEARCH pointer value to length of current line.
 2276/2BCC : 48 A7 2B                              JNZ	GOTO5              ;If not end of line then continue getting current line nr.
 2277/2BCF : 36 50                      GOTO7:     MVI	L, 120o               ;Load L with address of start of the SYMBOL BUFFER
 2278/2BD1 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;Set H to the page of the SYMBOL BUFFER
 2279/2BD3 : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;Set D to the page of the AUX LINE NR BUFFER
 2280/2BD5 : 26 E8                                 MVI	E, 350o               ;Set E to the start of the AUX LINE NR BUFFER
 2281/2BD7 : 46 DA 20                              CALL	STRCP              ;Compare GOTO line number against current line nr.
 2282/2BDA : 68 5D 29                              JZ	SAMLIN             ;If they match, found GOTO line. Pick up ops there!
 2283/2BDD : 36 F0                                 MVI	L, 360o               ;Else, set L to user program buffer pntr storage location
 2284/2BDF : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of user program buffer pointer
 2285/2BE1 : DF                                    MOV	D,M                    ;Fetch the high part of this pointer into register D
 2286/2BE2 : 30                                    INR	L                    ;Advance the memory pointer
 2287/2BE3 : E7                                    MOV	E,M                    ;Fetch the low part into register E
 2288/2BE4 : EB                                    MOV	H,D                    ;Transfer the pointer to H
 2289/2BE5 : F4                                    MOV	L,E                    ;And L. Fetch the (cc) of the current line into register
 2290/2BE6 : CF                                    MOV	B,M                    ;B and then add one to account for the (cc) byte to get
 2291/2BE7 : 08                                    INR	B                    ;Total length of the current line in the user pgm buffer
 2292/2BE8 : 46 AE 28                              CALL	ADBDE              ;Add the total length to the pointer value in D & E
 2293/2BEB : 36 F0                                 MVI	L, 360o               ;To get the starting address of the next line in the user
 2294/2BED : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** User program buffer. Place the new value for the user
 2295/2BEF : FB                                    MOV	M,D                    ;Program buffer pointer back into the user program
 2296/2BF0 : 30                                    INR	L                    ;Buffer pointer storage locations so that it points to the
 2297/2BF1 : FC                                    MOV	M,E                    ;Next line to be processed in the user program buffer.
 2298/2BF2 : 36 F4                                 MVI	L, 364o               ;Load L with address of end of user pgm buffer storage
 2299/2BF4 : C3                                    MOV	A,D                    ;Location (page address) and fetch end of buffer page.
 2300/2BF5 : BF                                    CMP	M                    ;Compare this with next line pointer (updated).
 2301/2BF6 : 48 A0 2B                              JNZ	GOTO4              ;If not end of buffer, keep looking for the specified line
 2302/2BF9 : 30                                    INR	L                    ;If have same page addresses, check the low address
 2303/2BFA : C4                                    MOV	A,E                    ;Portions to see if
 2304/2BFB : BF                                    CMP	M                    ;Have reached end of user program buffer
 2305/2BFC : 48 A0 2B                              JNZ	GOTO4              ;If not, continue looking. If end of buffer without
 2306/2BFF : 06 D5                      GOTOER:    MVI	A, 325o               ;Finding specified line, then have an error condition.
 2307/2C01 : 16 CE                                 MVI	C, 316o               ;Load ACC and register C with code for "UN" and go
 2308/2C03 : 44 96 20                              JMP	ERROR              ;Display "Undefined Line" error message.
 2309/2C06 : 36 82                      IF:        MVI	L, 202o               ;Set L to SCAN pointer storage location.
 2310/2C08 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H to page of SCAN pointer storage location.
 2311/2C0A : CF                                    MOV	B,M                    ;Fetch the SCAN pointer value to register B.
 2312/2C0B : 08                                    INR	B                    ;Add one to advance pointer over last char scanned.
 2313/2C0C : 36 BE                                 MVI	L, 276o               ;Change L to address of EVAL pointer. Set up EVAL
 2314/2C0E : F9                                    MOV	M,B                    ;Pointer to begin evaluation with next char in the line.
 2315/2C0F : 46 AD 20                              CALL	CLESYM             ;Clear the SYMBOL BUFFER.
 2316/2C12 : 36 D0                                 MVI	L, 320o               ;Set L to starting address of THEN in look-up table.
 2317/2C14 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of the look-up table.
 2318/2C16 : 46 F9 28                              CALL	INSTR              ;Search for occurrence of THEN in the line input buffer.
 2319/2C19 : C4                                    MOV	A,E                    ;Transfer register E to ACC. If THEN not found
 2320/2C1A : A0                                    ANA	A                    ;The value in E will be zero.
 2321/2C1B : 48 31 2C                              JNZ	IF1                ;If THEN found, can evaluate the IF expression.
 2322/2C1E : 36 0B                                 MVI	L, 013o               ;If THEN not found, set L to Auting address of GOTO
 2323/2C20 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** In the KEYWORD look-up table. Set H to table
 2324/2C22 : 46 F9 28                              CALL	INSTR              ;Search for occurrence of GOTO in the line input buffer.
 2325/2C25 : C4                                    MOV	A,E                    ;Transfer E to ACC. If GOTO not found
 2326/2C26 : A0                                    ANA	A                    ;The value in E will be zero.
 2327/2C27 : 48 31 2C                              JNZ	IF1                ;If GOTO found, can evaluate the IF expression.
 2328/2C2A : 06 C9                      IFERR:     MVI	A, 311o               ;Set ASCII code for letter I in ACC
 2329/2C2C : 16 C6                                 MVI	C, 306o               ;And code for letter F in register C
 2330/2C2E : 44 96 20                              JMP	ERROR              ;Go display the IF error message
 2331/2C31 : 36 BF                      IF1:       MVI	L, 277o               ;Load L with addr of EVAL FINISH pointer storage loc
 2332/2C33 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of storage location
 2333/2C35 : 21                                    DCR	E                    ;Subtract one from pointer in E and set the EVAL
 2334/2C36 : FC                                    MOV	M,E                    ;FINISH pointer so that it will evaluate up to the THEN
 2335/2C37 : 46 94 21                              CALL	EVAL               ;Or GOTO directive. Evaluate the expression.
 2336/2C3A : 36 56                                 MVI	L, 126o               ;Load L with address of FPACC Most Significant Word
 2337/2C3C : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with page of FPACC MSW
 2338/2C3E : C7                                    MOV	A,M                    ;Fetch the FPACC MSW into the accumulator
 2339/2C3F : A0                                    ANA	A                    ;Test the value of the FPACC MSW
 2340/2C40 : 68 3D 29                              JZ	NXTLIN             ;If it is zero, IF condition failed, ignore rest of line.
 2341/2C43 : 36 BF                                 MVI	L, 277o               ;If not, load L with addr of EVAL FINISH pointer
 2342/2C45 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to the appmpriate page
 2343/2C47 : C7                                    MOV	A,M                    ;Fetch the value in the EVAL FINISH pointer
 2344/2C48 : 04 05                                 ADI	005                ;Add five to skip over THEN or GOTO directive
 2345/2C4A : 36 82                                 MVI	L, 202o               ;Change L to SCAN pointer stomge location
 2346/2C4C : F8                                    MOV	M,A                    ;Set up the SCAN pointer to location after THEN or
 2347/2C4D : C8                                    MOV	B,A                    ;GOTO directive. Also put this value in register B.
 2348/2C4E : 08                                    INR	B                    ;Add one to the value in B to point to next character
 2349/2C4F : 36 84                                 MVI	L, 204o               ;After THEN or GOTO. Change L to addr of THEN pntr
 2350/2C51 : F9                                    MOV	M,B                    ;Storage location and store the pointer value.
 2351/2C52 : 36 84                      IF2:       MVI	L, 204o               ;Load L with the address of the THEN pointer
 2352/2C54 : 46 A0 20                              CALL	GETCHR             ;Fetch the character pointed to by the THEN pointer
 2353/2C57 : 48 65 2C                              JNZ	IF3                ;If character is not a space, exit this loop
 2354/2C5A : 36 84                                 MVI	L, 204o               ;If fetch a space, ignore. Reset L to the THEN pointer
 2355/2C5C : 46 03 21                              CALL	LOOP               ;Add one to the THEN pointer and test for end of line
 2356/2C5F : 48 52 2C                              JNZ	IF2                ;If not end of line, keep looking for a character other
 2357/2C62 : 44 2A 2C                              JMP	IFERR              ;Than a space. If reach end of line first, then error
 2358/2C65 : 3C B0                      IF3:       CPI	260o               ;When find a character see if it is numeric.
 2359/2C67 : 70 6F 2C                              JM	IF4                ;If not numeric, then should have a new type of
 2360/2C6A : 3C BA                                 CPI	272o               ;Statement. If numeric, then should have a line number.
 2361/2C6C : 70 6B 2B                              JM	GOTO               ;So process as though have a GOTO statement!
 2362/2C6F : 36 00                      IF4:       MVI	L, 000                ;Load L with addr of start of line input buffer.
 2363/2C71 : C7                                    MOV	A,M                    ;Fetch the (cc) byte to get length of line value.
 2364/2C72 : 36 84                                 MVI	L, 204o               ;Change L to current value of THEN pointer (where first
 2365/2C74 : 97                                    SUB	M                    ;Non-space char. found after THEN or GOTO). Subtract
 2366/2C75 : C8                                    MOV	B,A                    ;This value from length of line to get remainder. Now
 2367/2C76 : 08                                    INR	B                    ;Have length of second statement portion. Add one for
 2368/2C77 : D7                                    MOV	C,M                    ;(cc) count. Save THEN pointer value in register C.
 2369/2C78 : 36 00                                 MVI	L, 000                ;Reset L to start of line input buffer. Now put length of
 2370/2C7A : F9                                    MOV	M,B                    ;Second statement into (cc) position of input buffer.
 2371/2C7B : F2                                    MOV	L,C                    ;Set L to where second statement starts.
 2372/2C7C : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Set D to page of line input buffer.
 2373/2C7E : 26 01                                 MVI	E, 001                ;Set E to first character position of line input buffer.
 2374/2C80 : 46 F6 2E                              CALL	MOVEIT             ;Move the second statement up in line to become first!
 2375/2C83 : 36 82                                 MVI	L, 202o               ;Load L with address of new SCAN pointer. Load
 2376/2C85 : 3E 01                                 MVI	M, 001                ;It with starting position for SYNTAX scan.
 2377/2C87 : 46 37 20                              CALL	SYNTX4             ;Use special entry to SYNTAX to get new TOKEN value.
 2378/2C8A : 44 78 29                              JMP	DIRECT             ;Process the second statement in the original line.
 2379/2C8D : 36 E0                      GOSUB:     MVI	L, 340o               ;Load L with start of LINE NUMBER BUFFER
 2380/2C8F : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;Fetch (cc) of cuffent line number into register D
 2381/2C91 : DF                                    MOV	D,M                    ;Fetch high value (page) of pgm line pointer to D
 2382/2C92 : 18                                    INR	D                    ;Test contents of register by first incrementing
 2383/2C93 : 19                                    DCR	D                    ;And then decrementing the value in the register
 2384/2C94 : 68 9C 2C                              JZ	GOSUB1             ;If no line number, then processing a DIRECT statement
 2385/2C97 : 36 F0                                 MVI	L, 360o               ;Else, load L with address of user pgm buff line pointer
 2386/2C99 : DF                                    MOV	D,M                    ;Fetch high value (page) of pgm line pointer to D
 2387/2C9A : 30                                    INR	L                    ;Advance the memory pointer
 2388/2C9B : E7                                    MOV	E,M                    ;Fetch the low part of pgm line pointer to E
 2389/2C9C : 36 3B                      GOSUB1:    MVI	L, 073o               ;Set L to address of GOSUB STACK POINTER
 2390/2C9E : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to page of GOSUB STACK POINTER
 2391/2CA0 : C7                                    MOV	A,M                    ;Fetch value in GOSUB stack pointer to ACC
 2392/2CA1 : 04 02                                 ADI	002                ;Add two to current stack pointer for new data to be
 2393/2CA3 : 3C 11                                 CPI	021o               ;Placed on the stack and see if stack overflows
 2394/2CA5 : 50 D6 2C                              JP	GOSERR             ;If stack filled, have an error condition
 2395/2CA8 : F8                                    MOV	M,A                    ;Else, store updated stack pointer
 2396/2CA9 : 36 3E                                 MVI	L, 076o               ;Load L with address of start of stack less offset (2)
 2397/2CAB : 86                                    ADD	L                    ;Add GOSUB stack pointer to base address
 2398/2CAC : F0                                    MOV	L,A                    ;To get pointer to top of stack (page byte)
 2399/2CAD : FB                                    MOV	M,D                    ;Store page part of pgm buffer line pointer in stack
 2400/2CAE : 30                                    INR	L                    ;Advance pointer to next byte in stack
 2401/2CAF : FC                                    MOV	M,E                    ;Store low part of pgm buffer line pointer in stack
 2402/2CB0 : 44 6B 2B                              JMP	GOTO               ;Proceed from here as though processing a GOTO
 2403/2CB3 : 36 3B                      RETURN:    MVI	L, 073o               ;Set L to address of GOSUB STACK POINTER
 2404/2CB5 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to page of GOSUB STACK POINTER
 2405/2CB7 : C7                                    MOV	A,M                    ;Fetch the value of GOSUB stack pointer to ACC
 2406/2CB8 : 14 02                                 SUI	002                ;Subtract two for data to be removed from stack
 2407/2CBA : 70 DD 2C                              JM	RETERR             ;If stack underflow, then have an error condition
 2408/2CBD : F8                                    MOV	M,A                    ;Restore new stack pointer to memory
 2409/2CBE : 04 02                                 ADI	002                ;Add two to point to previous top of stack
 2410/2CC0 : 36 3E                                 MVI	L, 076o               ;Load L with address of start of GOSUB stack less two
 2411/2CC2 : 86                                    ADD	L                    ;Add address of previous top of stack to base value
 2412/2CC3 : F0                                    MOV	L,A                    ;Set pointer to high address value in the stack
 2413/2CC4 : DF                                    MOV	D,M                    ;Fetch the high address value from stack to register D
 2414/2CC5 : 18                                    INR	D                    ;Exercise the register contents to see if high address
 2415/2CC6 : 19                                    DCR	D                    ;Obtained is zero. If so, original GOSUB statement was
 2416/2CC7 : 68 B6 26                              JZ	EXEC               ;A DIRECT statement. Must return to Executive!
 2417/2CCA : 30                                    INR	L                    ;Else, advance pointer to get low address value from the
 2418/2CCB : E7                                    MOV	E,M                    ;Stack into CPU register E.
 2419/2CCC : 36 F0                                 MVI	L, 360o               ;Load L with address of user pgm line pointer storage
 2420/2CCE : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Location. Load H with page of user pgm line pntr.
 2421/2CD0 : FB                                    MOV	M,D                    ;Put high address from stack into pgm line pointer.
 2422/2CD1 : 30                                    INR	L                    ;Advance the memory pointer
 2423/2CD2 : FC                                    MOV	M,E                    ;Put low address from stack into pgrn line pointer.
 2424/2CD3 : 44 3D 29                              JMP	NXTLIN             ;Execute the next line after originating GOSUB line!
 2425/2CD6 : 06 C7                      GOSERR:    MVI	A, 307o               ;Load ASCII code for letter G into accumulator
 2426/2CD8 : 16 D3                                 MVI	C, 323o               ;Load ASCII code for letter S into register C
 2427/2CDA : 44 96 20                              JMP	ERROR              ;Go display GoSub (GS) error message.
 2428/2CDD : 06 D2                      RETERR:    MVI	A, 322o               ;Load ASCII code for letter R into accumulator
 2429/2CDF : 16 D4                                 MVI	C, 324o               ;Load ASCII code for letter T into register C
 2430/2CE1 : 44 96 20                              JMP	ERROR              ;Go display ReTurn (RT) error message.
 2431/2CE4 : 46 AD 20                   INPUT:     CALL	CLESYM             ;Clear the SYMBOL BUFFER
 2432/2CE7 : 36 82                                 MVI	L, 202o               ;Load L with address of SCAN pointer storage location
 2433/2CE9 : CF                                    MOV	B,M                    ;Fetch value of SCAN pointer to register B
 2434/2CEA : 08                                    INR	B                    ;Increment value to point to next chamcter
 2435/2CEB : 36 83                                 MVI	L, 203o               ;Change L to point to INPUT pointer (formerly TOKEN)
 2436/2CED : F9                                    MOV	M,B                    ;Updated SCAN pointer becomes INPUT pointer
 2437/2CEE : 36 83                      INPUT1:    MVI	L, 203o               ;Load L with address of INPUT pointer
 2438/2CF0 : 46 A0 20                              CALL	GETCHR             ;Fetch a character from the line input buffer
 2439/2CF3 : 68 11 2D                              JZ	INPUT3             ;If character is a space, ignore it. Else,
 2440/2CF6 : 3C AC                                 CPI	254o               ;See if character is a comma. If so, process the
 2441/2CF8 : 68 22 2D                              JZ	INPUT4             ;Variable that preceeds the comma.
 2442/2CFB : 3C A8                                 CPI	250o               ;If not, see if character is a left parenthesis.
 2443/2CFD : 48 0E 2D                              JNZ	INPUT2             ;If not, continue processing to build up symbolic variable
 2444/2D00 : 46 00 37                              CALL	ARRAY2             ;@@ If so, call array subscripting subroutine
 2445/2D03 : 36 86                                 MVI	L, 206o               ;@@ Load L with address of array set up pointer
 2446/2D05 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;@@ ** Load H with page of array set up pointer
 2447/2D07 : CF                                    MOV	B,M                    ;@@ Fetch pointer value (point to ")" of subscript)
 2448/2D08 : 36 83                                 MVI	L, 203o               ;@@ Change pointer to address of INPUT pointer
 2449/2D0A : F9                                    MOV	M,B                    ;@@ Update INPUT pointer
 2450/2D0B : 44 11 2D                              JMP	INPUT3             ;@@ Jump over concatenate instruction below
 2451/2D0E : 46 C8 20                   INPUT2:    CALL	CONCTS             ;Concatenate character to SYMBOL BUFFER
 2452/2D11 : 36 83                      INPUT3:    MVI	L, 203o               ;Load L with address of INPUT pointer
 2453/2D13 : 46 03 21                              CALL	LOOP               ;Increment INPUT pointer and test for end of line
 2454/2D16 : 48 EE 2C                              JNZ	INPUT1             ;If not end of line, go get next character
 2455/2D19 : 46 33 2D                              CALL	INPUTX             ;If end of buffer, get input for variable in the SYMBOL
 2456/2D1C : 46 2D 26                              CALL	STOSYM             ;BUFFER and store the value in the VARIABLES table
 2457/2D1F : 44 3D 29                              JMP	NXTLIN             ;Then continue to interpret next statement line
 2458/2D22 : 46 33 2D                   INPUT4:    CALL	INPUTX             ;Get input from user for variable in SYMBOL BUFFER
 2459/2D25 : 46 2D 26                              CALL	STOSYM             ;Store the inputted value in the VARIABLES table
 2460/2D28 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of INPUT pointer
 2461/2D2A : 36 83                                 MVI	L, 203o               ;Set L to location of INPUT pointer
 2462/2D2C : CF                                    MOV	B,M                    ;Fetch pointer value for last character examined
 2463/2D2D : 36 82                                 MVI	L, 202o               ;Change L to point to SCAN pointer storage location
 2464/2D2F : F9                                    MOV	M,B                    ;Update the SCAN pointer
 2465/2D30 : 44 E4 2C                              JMP	INPUT              ;Continue processing statement line for next variable
 2466/2D33 : 36 50                      INPUTX:    MVI	L, 120o               ;Load L with start of SYMBOL BUFFER (contains cc)
 2467/2D35 : C7                                    MOV	A,M                    ;Fetch the (cc) (length of symbol in the buffer) to ACC
 2468/2D36 : 86                                    ADD	L                    ;Add (cc) to base address to set up
 2469/2D37 : F0                                    MOV	L,A                    ;Pointer to last character in the SYMBOL BUFFER
 2470/2D38 : C7                                    MOV	A,M                    ;Fetch the last character in the SYMBOL BUFFER
 2471/2D39 : 3C A4                                 CPI	244o               ;See if the last chamcter was a $ sign
 2472/2D3B : 48 4F 2D                              JNZ	INPUTN             ;If not a $ sign, get variable value as a numerical entry
 2473/2D3E : 36 50                                 MVI	L, 120o               ;If $ sign, reset L to start of the SYMBOL BUFFER
 2474/2D40 : CF                                    MOV	B,M                    ;Fetch the (cc) for the variable in the SYMBOL BUFF
 2475/2D41 : 09                                    DCR	B                    ;Subtract one from (cc) to chop off the $ sign
 2476/2D42 : F9                                    MOV	M,B                    ;Restore the new (cc) for the SYMBOL BUFFER
 2477/2D43 : 46 5E 2D                              CALL	FP0                ;Call subroutine to zero the floating point accumulator
 2478/2D46 : 46 91 21                              CALL	CINPUT             ;Input one character from system input device
 2479/2D49 : 36 54                                 MVI	L, 124o               ;Load L with address of the LSW of the FPACC
 2480/2D4B : F8                                    MOV	M,A                    ;Place the ASCII code for the character inputted there
 2481/2D4C : 44 1B 2E                              JMP	FPFLT              ;Convert value to floating point format in FPACC
 2482/2D4F : 36 64                      INPUTN:    MVI	L, 144o               ;Load L with address of start of AUX SYMBOL BUFF
 2483/2D51 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of AUX SYMBOL BUFFER
 2484/2D53 : 06 BF                                 MVI	A, 277o               ;Load accumulator with ASCII code for ? mark
 2485/2D55 : 46 82 21                              CALL	ECHO               ;Call output subroutine to display the ? mark
 2486/2D58 : 46 0C 21                              CALL	STRIN              ;Input string of characters (number) fm input device
 2487/2D5B : 44 0F 31                              JMP	DINPUT             ;Convert decimal string into binary floating point nr.
 2488/2D5E : 2E 02                      FP0:       MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with floating point working registers page
 2489/2D60 : 44 A7 24                              JMP	CFALSE             ;Zero the floating point accumulator & exit to caller
 2490/2D63 : 36 64                      FOR:       MVI	L, 144o               ;Load L with address of AUX SYMBOL BUFFER
 2491/2D65 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of AUX SYMBOL BUFFER
 2492/2D67 : 3E 00                                 MVI	M, 000                ;Initialize buffer by clearing first byte
 2493/2D69 : 36 66                                 MVI	L, 146o               ;Load L with location of second character in buffer
 2494/2D6B : 3E 00                                 MVI	M, 000                ;Clear that location in case of single character variable
 2495/2D6D : 36 85                                 MVI	L, 205o               ;Load L with address of FOR/NEXT STACK pointer
 2496/2D6F : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Load H with page of FOR/NEXT STACK pointer
 2497/2D71 : CF                                    MOV	B,M                    ;Fetch the FOR/NEXT STACK pointer
 2498/2D72 : 08                                    INR	B                    ;Increment it in preparation for pushing operation
 2499/2D73 : F9                                    MOV	M,B                    ;Restore it back to its storage location
 2500/2D74 : 36 F0                                 MVI	L, 360o               ;Load L with address of user pgrn buffer line pointer
 2501/2D76 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of line pointer
 2502/2D78 : DF                                    MOV	D,M                    ;Fetch page address of pgm buffer line pntr into D
 2503/2D79 : 30                                    INR	L                    ;Advance the memory pointer to pick up low part
 2504/2D7A : E7                                    MOV	E,M                    ;Fetch low address of pgm buffer line pntr into E
 2505/2D7B : C1                                    MOV	A,B                    ;Restore updated FOR/NEXT STACK pointer to ACC
 2506/2D7C : 02                                    RLC                    ;Rotate it left to multiply by two, then rotate it again to
 2507/2D7D : 02                                    RLC                    ;Multiply by four. Add this value to the base address of
 2508/2D7E : 04 5C                                 ADI	134o               ;The FOR/NEXT STACK to point to the new top of
 2509/2D80 : F0                                    MOV	L,A                    ;The FOR/NEXT STACK and set up to point to stack
 2510/2D81 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H for page of the FOR/NEXT STACK
 2511/2D83 : FB                                    MOV	M,D                    ;Store the page portion of the user pgrn buffer line pntr
 2512/2D84 : 30                                    INR	L                    ;In the FORINEXT STACK, advance register 4 then
 2513/2D85 : FC                                    MOV	M,E                    ;Store the low portion of the pgrn line pntr on the stack
 2514/2D86 : 36 D5                                 MVI	L, 325o               ;Change L to point to start of TO string which is stored
 2515/2D88 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** In a text strings storage area on this page
 2516/2D8A : 46 F9 28                              CALL	INSTR              ;Search the statement line for the occurrence of TO
 2517/2D8D : C4                                    MOV	A,E                    ;Register E wiU be zero if TO not found. Move E to ACC
 2518/2D8E : A0                                    ANA	A                    ;To make a test
 2519/2D8F : 48 99 2D                              JNZ	FOR1               ;If TO found then proceed with FOR statement
 2520/2D92 : 06 C6                      FORERR:    MVI	A, 306o               ;Else have a For Error. Load ACC with ASCII code for
 2521/2D94 : 16 C5                                 MVI	C, 305o               ;Letter F and register C with code for letter E.
 2522/2D96 : 44 96 20                              JMP	ERROR              ;Then go display the FE message.
 2523/2D99 : 36 82                      FOR1:      MVI	L, 202o               ;Load L with address of SCAN pointer storage location
 2524/2D9B : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of the SCAN pointer
 2525/2D9D : CF                                    MOV	B,M                    ;Fetch pointer value to ACC (points to letter R in the
 2526/2D9E : 08                                    INR	B                    ;For directive). Increment it to point to next character
 2527/2D9F : 36 84                                 MVI	L, 204o               ;In the line. Change register L and set this value up
 2528/2DA1 : F9                                    MOV	M,B                    ;As an updated FOR pointer.
 2529/2DA2 : 36 83                                 MVI	L, 203o               ;Set L to address of TO pointer (formerly TOKEN)
 2530/2DA4 : FC                                    MOV	M,E                    ;Save pointer to TO in the TO pointer!
 2531/2DA5 : 36 84                      FOR2:      MVI	L, 204o               ;Load L with address of the FOR pointer
 2532/2DA7 : 46 A0 20                              CALL	GETCHR             ;Fetch a character from the statement line
 2533/2DAA : 68 B7 2D                              JZ	FOR3               ;If it is a space, ignore it
 2534/2DAD : 3C BD                                 CPI	275o               ;Test to see if character is the "=" sign
 2535/2DAF : 68 C2 2D                              JZ	FOR4               ;If so, variable name is in the AUX SYMBOLBUFFER
 2536/2DB2 : 36 64                                 MVI	L, 144o               ;If not, then set L to point to start of the AUX SYMBOL
 2537/2DB4 : 46 CC 20                              CALL	CONCT1             ;BUFFER and concatenate the character onto the buffer
 2538/2DB7 : 36 84                      FOR3:      MVI	L, 204o               ;Reset L to address of the FOR pointer
 2539/2DB9 : 46 03 21                              CALL	LOOP               ;Increment the pointer and see if end of line
 2540/2DBC : 48 A5 2D                              JNZ	FOR2               ;If not end of line, continue looking for the "=" sign
 2541/2DBF : 44 92 2D                              JMP	FORERR             ;If reach end of line before "=" sign, then have error
 2542/2DC2 : 36 84                      FOR4:      MVI	L, 204o               ;Set L with address of the FOR pointer
 2543/2DC4 : CF                                    MOV	B,M                    ;Fetch pointer value to ACC (pointing to sign)
 2544/2DC5 : 08                                    INR	B                    ;Increment it to skip over the "=" sign
 2545/2DC6 : 36 BE                                 MVI	L, 276o               ;Set L to address of the EVAL pointer
 2546/2DC8 : F9                                    MOV	M,B                    ;Restore the updated pointer to storage
 2547/2DC9 : 36 83                                 MVI	L, 203o               ;Set L to the address of the TO pointer
 2548/2DCB : CF                                    MOV	B,M                    ;Fetch pointer value to ACC (pointing to letter T in TO)
 2549/2DCC : 09                                    DCR	B                    ;Decrement it to point to character before the T in TO
 2550/2DCD : 36 BF                                 MVI	L, 277o               ;Set L to EVAL FINISH pointer storage location
 2551/2DCF : F9                                    MOV	M,B                    ;Store the EVAL FINISH pointer value
 2552/2DD0 : 46 94 21                              CALL	EVAL               ;Evaluate the expression between the "=" sign and TO
 2553/2DD3 : 46 AA 26                              CALL	RESTSY             ;Directive. Place the variable name in the variables table.
 2554/2DD6 : 36 64                                 MVI	L, 144o               ;Load L with starting address of the AUX SYMBOL BF
 2555/2DD8 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with the page of the AUX SYMBOL BUFF
 2556/2DDA : C7                                    MOV	A,M                    ;Fetch the (cc) for the name in the buffer
 2557/2DDB : 3C 01                                 CPI	001o               ;See if the symbol (name) length is just one character
 2558/2DDD : 48 7E 35                              JNZ	FOR5               ;If not, go directly to place name in FOR/NEXT STACK
 2559/2DE0 : 36 66                                 MVI	L, 146o               ;If so, set L to point to second character location in the
 2560/2DE2 : 3E 00                                 MVI	M, 000                ;AUX SYMBOL BUFFER and set it equal to zero.
 2561/2DE4 : 44 7E 35                              JMP	FOR5               ;This jump directs program over ontrs/cntrs/table area
 2562/2DE7 :                            ;;; LAST LINE SHOULD START AT 17 365 0ff5h
 2563/2DE7 :                            ;;; PATCH AREA FOLLOWS THIS
 2564/2DE7 :                            
 2565/2DE7 :                            ;          ORG	1000h              ;020#000
 2566/2DE7 :                            
 2567/2DE7 : 36 56                      FPFIX:     MVI	L, 126o               ;Set L to point to MSW of FPACC
 2568/2DE9 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to point to page of FPACC
 2569/2DEB : C7                                    MOV	A,M                    ;Fetch MSW of FPACC
 2570/2DEC : 36 40                                 MVI	L, 100o               ;Change pointer to SIGN indicator on same page
 2571/2DEE : F8                                    MOV	M,A                    ;Place MSW of FPACC into SIGN indicator
 2572/2DEF : A0                                    ANA	A                    ;Now test sign bit of MSW of FPACC
 2573/2DF0 : 72 69 2E                              CM	FPCOMP             ;Two's complement value in FPACC if negative
 2574/2DF3 : 36 57                                 MVI	L, 127o               ;Change pointer to FPACC Exponent register
 2575/2DF5 : 06 17                                 MVI	A, 027o               ;Set accumulator to 23 (decimal) for number of bits
 2576/2DF7 : CF                                    MOV	B,M                    ;Load FPACC Exponent into CPU register B
 2577/2DF8 : 08                                    INR	B                    ;Exercise the value in register B
 2578/2DF9 : 09                                    DCR	B                    ;To set CPU flags
 2579/2DFA : 70 10 2E                              JM	FPZERO             ;If FPACC Exponent is negative set FPACC to zero
 2580/2DFD : 91                                    SUB	B                    ;Subtract value of FPACC Exponent from 23 decimal
 2581/2DFE : 70 E5 28                              JM	FIXERR             ;If Exp larger than 23 decimal cannot convert
 2582/2E01 : D0                                    MOV	C,A                    ;Else place result in register C as counter for number
 2583/2E02 : 36 56                      FPFIXL:    MVI	L, 126o               ;Of rotate ops. Set pointer to MSW of FPACC
 2584/2E04 : 0E 03                                 MVI	B, 003                ;Set precision counter (number of bytes in mantissa)
 2585/2E06 : 46 74 30                              CALL	ROTATR             ;Rotate FPACC right the number of places indicated
 2586/2E09 : 11                                    DCR	C                    ;By count in register C to effectively rotate all the
 2587/2E0A : 48 02 2E                              JNZ	FPFIXL             ;Significant bits to the left of the floating point decimal
 2588/2E0D : 44 64 2E                              JMP	RESIGN             ;Point. Go check original sign & negate answer if req'd.
 2589/2E10 :                            
 2590/2E10 :                                                              ;Following subroutine clears the FPACC to the zero
 2591/2E10 :                                                              ;condition.
 2592/2E10 :                            
 2593/2E10 : 36 56                      FPZERO:    MVI	L, 126o               ;Set L to point to MSW of FPACC
 2594/2E12 : A8                                    XRA	A                    ;Clear the accumulator
 2595/2E13 : F8                                    MOV	M,A                    ;Set the MSW of FPACC to zero
 2596/2E14 : 31                                    DCR	L                    ;Decrement the pointer
 2597/2E15 : F8                                    MOV	M,A                    ;Set the next significant word of FPACC to zero
 2598/2E16 : 31                                    DCR	L                    ;Decrement the pointer
 2599/2E17 : F8                                    MOV	M,A                    ;Set the LSW of FPACC to zero
 2600/2E18 : 31                                    DCR	L                    ;Decrement the pointer
 2601/2E19 : F8                                    MOV	M,A                    ;Set the auxiliary FPACC byte to zero
 2602/2E1A : 07                                    RET                    ;Exit to calling routine
 2603/2E1B :                            
 2604/2E1B :                                                              ;The next instruction is a special entry point to
 2605/2E1B :                                                              ;the FPNORM subroutine that is used when a number is
 2606/2E1B :                                                              ;converted from fixed to floating point. The FPNORM
 2607/2E1B :                                                              ;label is the entry point when a number already in float-
 2608/2E1B :                                                              ;ing point fonnat is to be normalized.
 2609/2E1B :                            
 2610/2E1B : 0E 17                      FPFLT:     MVI	B, 027o               ;For fixed to float set CPU register B to 23 decimal
 2611/2E1D : C1                         FPNORM:    MOV	A,B                    ;Get CPU register B into ACC to check for special case
 2612/2E1E : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of FPACC
 2613/2E20 : 36 57                                 MVI	L, 127o               ;Set L to FPACC Exponent byte
 2614/2E22 : A0                                    ANA	A                    ;Set CPU flags to test what was in CPU register B
 2615/2E23 : 68 27 2E                              JZ	NOEXC0             ;If B was zero then do standard normalization
 2616/2E26 : F9                                    MOV	M,B                    ;Else set Exponent of FPACC to 23 decimal
 2617/2E27 : 31                         NOEXC0:    DCR	L                    ;Change pointer to MSW of FPACC
 2618/2E28 : C7                                    MOV	A,M                    ;Fetch MSW of FPACC into accumulator
 2619/2E29 : 36 40                                 MVI	L, 100o               ;Change pointer to SIGN indicator storage location
 2620/2E2B : F8                                    MOV	M,A                    ;Place the MSW of FPACC there for future reference
 2621/2E2C : A0                                    ANA	A                    ;Set CPU flags to test MSW of FPACC
 2622/2E2D : 50 37 2E                              JP	ACZERT             ;If sign bit not set then jump ahead to do next test
 2623/2E30 : 0E 04                                 MVI	B, 004                ;If sign bit set, number in FPACC is negative. Set up
 2624/2E32 : 36 53                                 MVI	L, 123o               ;For two's complement operation
 2625/2E34 : 46 53 30                              CALL	COMPLM             ;And negate the value in the FPACC to make it positive
 2626/2E37 : 36 56                      ACZERT:    MVI	L, 126o               ;Reset pointer to MSW of FPACC
 2627/2E39 : 0E 04                                 MVI	B, 004                ;Set precision counter to number of bytes in FPACC
 2628/2E3B : C7                         LOOK0:     MOV	A,M                    ;Plus one. Fetch a byte of the FPACC.
 2629/2E3C : A0                                    ANA	A                    ;Set CPU flags
 2630/2E3D : 48 4A 2E                              JNZ	ACNONZ             ;If find anything then FPACC is not zero
 2631/2E40 : 31                                    DCR	L                    ;Else decrement pointer to NSW of FPACC
 2632/2E41 : 09                                    DCR	B                    ;Decrement precision counter
 2633/2E42 : 48 3B 2E                              JNZ	LOOK0              ;Continue checking to see if FPACC contains anything
 2634/2E45 : 36 57                                 MVI	L, 127o               ;Until precision counter is zero. If reach here then
 2635/2E47 : A8                                    XRA	A                    ;Reset pointer to FPACC Exponent. Clear the ACC and
 2636/2E48 : F8                                    MOV	M,A                    ;Clear out the FPACC Exponent. Value of FPACC is zip!
 2637/2E49 : 07                                    RET                    ;Exit to calling routine
 2638/2E4A : 36 53                      ACNONZ:    MVI	L, 123o               ;If FPACC has any value set pointer to LSW minus one
 2639/2E4C : 0E 04                                 MVI	B, 004                ;Set precision counter to number of bytes in FPACC
 2640/2E4E : 46 6A 30                              CALL	ROTATL             ;Plus one for special cases. Rotate the contents of the
 2641/2E51 : C7                                    MOV	A,M                    ;FPACC to the LEFT. Pointer will be set to MSW after
 2642/2E52 : A0                                    ANA	A                    ;Rotate ops. Fetch MSW and see if have anything in
 2643/2E53 : 70 5D 2E                              JM	ACCSET             ;Most significant bit position. If so, have rotated enough
 2644/2E56 : 30                                    INR	L                    ;If not, advance pointer to FPACC Exponent. Fetch
 2645/2E57 : CF                                    MOV	B,M                    ;The value of the Exponent and decrement it by one
 2646/2E58 : 09                                    DCR	B                    ;To compensate for the rotate left of the mantissa
 2647/2E59 : F9                                    MOV	M,B                    ;Restore the new value of the Exponent
 2648/2E5A : 44 4A 2E                              JMP	ACNONZ             ;Continue rotating ops to normalize the FPACC
 2649/2E5D : 36 56                      ACCSET:    MVI	L, 126o               ;Set pntr to FPACC MSW. Now must provide room for
 2650/2E5F : 0E 03                                 MVI	B, 003                ;Sign bit in nonnalized FPACC. Set precision counter.
 2651/2E61 : 46 74 30                              CALL	ROTATR             ;Rotate the FPACC once to the right now.
 2652/2E64 : 36 40                      RESIGN:    MVI	L, 100o               ;Set the pointer to SIGN indicator storage location
 2653/2E66 : C7                                    MOV	A,M                    ;Fetch the original sign of the FPACC
 2654/2E67 : A0                                    ANA	A                    ;Set CPU flags
 2655/2E68 : 13                                    RP                    ;If original sign of FPACC was positive, can exit now.
 2656/2E69 :                            
 2657/2E69 : 36 54                      FPCOMP:    MVI	L, 124o               ; However, if original sign was negative, must now restore
 2658/2E6B : 0E 03                                 MVI	B, 003                ;The FPACC to negative by performing two's comple-
 2659/2E6D : 44 53 30                              JMP	COMPLM             ;Ment on FPACC. Return to caring rtn via COMPLM.
 2660/2E70 :                            
 2661/2E70 :                                                              ;Floating point ADDITION. Adds contents of FPACC to
 2662/2E70 :                                                              ;FPOP and leaves result in FPACC. Routine first checks
 2663/2E70 :                                                              ;to see if either register contains zero. If so addition
 2664/2E70 :                                                              ;result is already present!
 2665/2E70 :                            
 2666/2E70 : 36 56                      FPADD:     MVI	L, 126o               ;Set L to point to MSW of FPACC
 2667/2E72 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Do same for register H
 2668/2E74 : C7                                    MOV	A,M                    ;Fetch MSW of FPACC to accumulator
 2669/2E75 : A0                                    ANA	A                    ;Set CPU flags after loading op
 2670/2E76 : 48 84 2E                              JNZ	NONZAC             ;If accumulator non-zero then FPACC has some value
 2671/2E79 : 36 54                      MOVOP:     MVI	L, 124o               ;But, if accumulator was zero then normalized FPACC
 2672/2E7B : DD                                    MOV	D,H                    ;Must also be zero. Thus answer to addition is simply the
 2673/2E7C : E6                                    MOV	E,L                    ;Value in FPOP. Set up pointers to transfer contents of
 2674/2E7D : 36 5C                                 MVI	L, 134o               ;FPOP to FPACC by pointing to the LSW of both
 2675/2E7F : 0E 04                                 MVI	B, 004                ;Registers and perform the transfer. Then exit to calling
 2676/2E81 : 44 F6 2E                              JMP	MOVEIT             ;Routine with answer in FPACC via MOVEIT.
 2677/2E84 : 36 5E                      NONZAC:    MVI	L, 136o               ;If FPACC was non-zero then check to see if FPOP has
 2678/2E86 : C7                                    MOV	A,M                    ;Some value by obtaining MSW of FPOP
 2679/2E87 : A0                                    ANA	A                    ;Set CPU flags after loading op. If MSW zero then
 2680/2E88 : 2B                                    RZ                    ;Normalized FPOP must be zero. Answer is in FPACC!
 2681/2E89 :                            
 2682/2E89 :                                                              ;If neither FPACC or FPOP was zero then must perform
 2683/2E89 :                                                              ;addition operation. Must first check to see if two num-
 2684/2E89 :                                                              ;bers are within significant mnge. If not, largest number
 2685/2E89 :                                                              ;is answer. If numbers within range, then must align ex-
 2686/2E89 :                                                              ;ponents before perforrning the addition of the man-
 2687/2E89 :                                                              ;tissa.
 2688/2E89 :                            
 2689/2E89 : 36 57                      CKEQEX:    MVI	L, 127o               ;Set pointer to FPACC Exponent storage location.
 2690/2E8B : C7                                    MOV	A,M                    ;Fetch the Exponent value to the accumulator.
 2691/2E8C : 36 5F                                 MVI	L, 137o               ;Change the pointer to the FPOP Exponent
 2692/2E8E : BF                                    CMP	M                    ;Compare the values of the exponents. If they are the
 2693/2E8F : 68 C8 2E                              JZ	SHACOP             ;Same then can immediately proceed to add operations.
 2694/2E92 : C8                                    MOV	B,A                    ;If not the same, store FPACC Exponent size in regis B
 2695/2E93 : C7                                    MOV	A,M                    ;Fetch the FPOP Exponent size into the ACC
 2696/2E94 : 99                                    SBB	B                    ;Subtract the FPACC Exponent from the FPOP Exp.
 2697/2E95 : 50 9B 2E                              JP	SKPNEG             ;If result is positive jump over the next few instructions
 2698/2E98 : C8                                    MOV	B,A                    ;If result was negative, store the result in B
 2699/2E99 : A8                                    XRA	A                    ;Clear the accumulator
 2700/2E9A : 99                                    SBB	B                    ;Subtract register B to negate the original value
 2701/2E9B : 3C 18                      SKPNEG:    CPI	030o               ;See if difference is less than 24 decimal.
 2702/2E9D : 70 AA 2E                              JM	LINEUP             ;If so, can align exponents. Go do it.
 2703/2EA0 : C7                                    MOV	A,M                    ;If not, find out which number is largest. Fetch FPOP
 2704/2EA1 : 36 57                                 MVI	L, 127o               ;Exponent into ACC. Change pointer to FPACC Exp.
 2705/2EA3 : 97                                    SUB	M                    ;Subtract FPACC from FPOP. If result is negative then
 2706/2EA4 : 33                                    RM                    ;was larger. Return with answer in FPACC.
 2707/2EA5 : 36 54                                 MVI	L, 124o               ;If result was positive, larger value in FPOP. Set pointers
 2708/2EA7 : 44 79 2E                              JMP	MOVOP              ;To transfer FPOP into FPACC and then exit to caller.
 2709/2EAA : C7                         LINEUP:    MOV	A,M                    ;Fetch FPOP Exponent into accumulator.
 2710/2EAB : 36 57                                 MVI	L, 127o               ;Change pointer to FPACC Exponent.
 2711/2EAD : 97                                    SUB	M                    ;Subtract FPACC Exponent from FPOP Exponent. If
 2712/2EAE : 70 BE 2E                              JM	SHIFT0             ;Result is negative FPACC is larger. Go shift FPOP.
 2713/2EB1 : D0                                    MOV	C,A                    ;If result positive FPOP larger, must shift FPACC. Store
 2714/2EB2 : 36 57                      MORACC:    MVI	L, 127o               ;Difference count in C. Reset pointer to FPACC Exp
 2715/2EB4 : 46 E7 2E                              CALL	SHLOOP             ;Call the SHift LOOP to rotate FPACC mantissa RIGHT
 2716/2EB7 : 11                                    DCR	C                    ;And INCREMENT Exponent. Decr difference counter
 2717/2EB8 : 48 B2 2E                              JNZ	MORACC             ;Continue rotate operations until diff counter is zero
 2718/2EBB : 44 C8 2E                              JMP	SHACOP             ;Go do final alignment and perform addition process
 2719/2EBE : D0                         SHIFT0:    MOV	C,A                    ;Routine to shift FPOP. Set difference count into reg. C
 2720/2EBF : 36 5F                      MOROP:     MVI	L, 137o               ;Set pointer to FPOP Exponent.
 2721/2EC1 : 46 E7 2E                              CALL	SHLOOP             ;Call the SHift LOOP to rotate FPOP mantissa RIGHT
 2722/2EC4 : 10                                    INR	C                    ;And INCREMENT Exponent. Then incr difference cntr
 2723/2EC5 : 48 BF 2E                              JNZ	MOROP              ;Continue rotate opemtions until diff counter is zero
 2724/2EC8 :                            ;;; The below two instructions are changed by PATCH NR.1
 2725/2EC8 :                            ;;;SHACOP:    LLI 123                ;Set pointer to FPACC LSW minus one to provide extra
 2726/2EC8 :                            ;;;           LMI 000                ;Byte for addition ops. Clear that location to zero.
 2727/2EC8 :                            SHACOP:
 2728/2EC8 :                            ;	   CALL	PATCH1		; patch 1 inserts a few lines at 30-000
 2729/2EC8 :                            
 2730/2EC8 :                            ;;; The following is PATCH NR.1
 2731/2EC8 :                            ;          ORG	1800h	;030#000
 2732/2EC8 : 36 53                      PATCH1:    MVI	L, 123o
 2733/2ECA : 3E 00                                 MVI	M, 000
 2734/2ECC : 36 5B                                 MVI	L, 133o
 2735/2ECE : 3E 00                                 MVI	M, 000
 2736/2ED0 :                            ;          RET
 2737/2ED0 :                            ;	   MOV	A,A
 2738/2ED0 :                            ;;;        MVI L, 133
 2739/2ED0 :                            ;;;        LMI 000                ;THIS IS PATCH #1
 2740/2ED0 : 36 57                                 MVI	L, 127o               ;Change pointer to FPACC Exponent
 2741/2ED2 : 46 E7 2E                              CALL	SHLOOP             ;Rotate FPACC mantissa RIGHT & Increment Exponent
 2742/2ED5 : 36 5F                                 MVI	L, 137o               ;Change pointer to FPOP Exponent
 2743/2ED7 : 46 E7 2E                              CALL	SHLOOP             ;Rotate FPOP mantissa RIGHT & Increment Exponent
 2744/2EDA : DD                                    MOV	D,H                    ;Rotate ops provide room for overflow. Now set up
 2745/2EDB : 26 53                                 MVI	E, 123o               ;Pointers to LSW minus one for both FPACC & FPOP
 2746/2EDD : 0E 04                                 MVI	B, 004                ;(FPOP already set after SHLOOP). Set precision counter
 2747/2EDF : 46 42 30                              CALL	ADDER              ;Call quad precision ADDITION subroutine.
 2748/2EE2 : 0E 00                                 MVI	B, 000                ;Set CPU register B to indicate standard normalization
 2749/2EE4 : 44 1D 2E                              JMP	FPNORM             ;Go normalize the result and exit to caller.
 2750/2EE7 : CF                         SHLOOP:    MOV	B,M                    ;Shifting loop. First fetch Exponent currently being
 2751/2EE8 : 08                                    INR	B                    ;Pointed to and Increment the value by one.
 2752/2EE9 : F9                                    MOV	M,B                    ;Return the updated Exponent value to memory.
 2753/2EEA : 31                                    DCR	L                    ;Decrement the pointer to mantissa portion MSW
 2754/2EEB : 0E 04                                 MVI	B, 004                ;Set precision counter
 2755/2EED : C7                         FSHIFT:    MOV	A,M                    ;Fetch MSW of mantissa
 2756/2EEE : A0                                    ANA	A                    ;Set CPU flags after load ops
 2757/2EEF : 50 74 30                              JP	ROTATR             ;If MSB not a one can do normal rotate ops
 2758/2EF2 : 12                         BRING1:    RAL                    ;If MSB is a one need to set up carrv bit for the negative
 2759/2EF3 : 44 75 30                              JMP	ROTR               ;Number case. Then make special entry to ROTATR sub
 2760/2EF6 :                            
 2761/2EF6 :                                                              ;The following subroutine moves the contents of a string
 2762/2EF6 :                                                              ;of memory locations from the address pointed to by
 2763/2EF6 :                                                              ;CPU registers H & L to the address specified by the con-
 2764/2EF6 :                                                              ;tents of registers D & E when the routine is entered. The
 2765/2EF6 :                                                              ;process continues until the counter in register B is zero.
 2766/2EF6 :                            
 2767/2EF6 : C7                         MOVEIT:    MOV	A,M                    ;Fetch a word from memory string A
 2768/2EF7 : 30                                    INR	L                    ;Advance A string pointer
 2769/2EF8 : 46 D9 30                              CALL	SWITCH             ;Switch pointer to string B
 2770/2EFB : F8                                    MOV	M,A                    ;Put word from string A into string B
 2771/2EFC : 30                                    INR	L                   ;Advance B string pointer
 2772/2EFD : 46 D9 30                              CALL	SWITCH             ;Switch pointer back to string A
 2773/2F00 : 09                                    DCR	B                    ;Decrement loop counter
 2774/2F01 : 2B                                    RZ                    ;Return to calling routine when counter reaches zero
 2775/2F02 : 44 F6 2E                              JMP	MOVEIT             ;Else continue transfer operations
 2776/2F05 :                            
 2777/2F05 :                                                              ;The following subroutine SUBTRACTS the
 2778/2F05 :                                                              ;contents of the FLOATING POINT ACCUMULATOR from the
 2779/2F05 :                                                              ;contents of the FLOATING POINT OPERAND and
 2780/2F05 :                                                              ;leaves the result in the FPACC. The routine merely
 2781/2F05 :                                                              ;negates the value in the FPACC and then goes to the
 2782/2F05 :                                                              ;FPADD subroutine just presented.
 2783/2F05 :                            
 2784/2F05 : 36 54                      FPSUB:     MVI	L, 124o               ;Set L to address of LSW of FPACC
 2785/2F07 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of FPACC
 2786/2F09 : 0E 03                                 MVI	B, 003                ;Set precision counter
 2787/2F0B : 46 53 30                              CALL	COMPLM             ;Two's complement the value in the FPACC
 2788/2F0E : 44 70 2E                              JMP	FPADD              ;Now go add the negated value to perform subtraction!
 2789/2F11 :                            
 2790/2F11 :                                                              ;The first part of the FLOATING POINT MULTIPLI-
 2791/2F11 :                                                              ;CATION subroutine calls a subroutine to check the
 2792/2F11 :                                                              ;original signs of the numbers that are to be multi-
 2793/2F11 :                                                              ;plied and perform working register clearing functions.
 2794/2F11 :                                                              ;Next the exponents of the numbers to be multiplied
 2795/2F11 :                                                              ;are added together.
 2796/2F11 :                            
 2797/2F11 : 46 61 2F                   FPMULT:    CALL	CKSIGN             ;Call routine to set up registers & ck signs of numbers
 2798/2F14 : 36 5F                      ADDEXP:    MVI	L, 137o               ;Set pointer to FPOP Exponent
 2799/2F16 : C7                                    MOV	A,M                    ;Fetch FPOP Exponent into the accumulator
 2800/2F17 : 36 57                                 MVI	L, 127o               ;Change pointer to FPACC Exponent
 2801/2F19 : 87                                    ADD	M                    ;Add FPACC Exponent to FPOP Exponent
 2802/2F1A : 04 01                                 ADI	001                ;Add one more to total for algorithm compensation
 2803/2F1C : F8                                    MOV	M,A                    ;Store result in FPACC Exponent location
 2804/2F1D : 36 42                      SETMCT:    MVI	L, 102o               ;Change pointer to bit counter storage location
 2805/2F1F : 3E 17                                 MVI	M, 027o               ;Initialize bit counter to 23 decimal
 2806/2F21 :                            
 2807/2F21 :                                                              ;Next portion of the FPMULT routine is the iinplernen-
 2808/2F21 :                                                              ;tation of the algorithm illustrated in the flow chart
 2809/2F21 :                                                              ;above. This portion multiplies the values of the two
 2810/2F21 :                                                              ;mantissas. The final value is rounded off to leave the
 2811/2F21 :                                                              ;23 most significant bits as the answer that is stored
 2812/2F21 :                                                              ;back in the FPACC.
 2813/2F21 :                            
 2814/2F21 : 36 56                      MULTIP:    MVI	L, 126o                ;Set pointer to MSW of FPACC mantissa
 2815/2F23 : 0E 03                                 MVI	B, 003                ;Set precision counter
 2816/2F25 : 46 74 30                              CALL	ROTATR             ;Rotate FPACC (multiplier) RIGHT into carry bit
 2817/2F28 : 62 A3 2F                              CC	ADOPPP             ;If carry is a one, add multiplicand to partial-product
 2818/2F2B : 36 66                                 MVI	L, 146o                ;Set pointer to partial-product most significant byte
 2819/2F2D : 0E 06                                 MVI	B, 006                ;Set precision counter (p-p register is double length)
 2820/2F2F : 46 74 30                              CALL	ROTATR             ;Shift partial-product RIGHT
 2821/2F32 : 36 42                                 MVI	L, 102o                ;Set pointer to bit counter storage location
 2822/2F34 : D7                                    MOV	C,M                    ;Fetch current value of bit counter
 2823/2F35 : 11                                    DCR	C                    ;Decrement the value of the bit counter
 2824/2F36 : FA                                    MOV	M,C                    ;Restore the updated bit counter to its storage location
 2825/2F37 : 48 21 2F                              JNZ	MULTIP             ;If have not multiplied for 23 (deciinal) bits, keep going
 2826/2F3A : 36 66                                 MVI	L, 146o                ;If have done 23 (decimal) bits, set pntr to p-p MSW
 2827/2F3C : 0E 06                                 MVI	B, 006                ;Set precision counter (for double length)
 2828/2F3E : 46 74 30                              CALL	ROTATR             ;Shift partial-product once more to the RIGHT
 2829/2F41 : 36 63                                 MVI	L, 143o                ;Set pointer to access 24'th bit in partial-product
 2830/2F43 : C7                                    MOV	A,M                    ;Fetch the byte containing the 24'th bit
 2831/2F44 : 12                                    RAL                    ;Position the 24'th bit to be MSB in the accumulator
 2832/2F45 : A0                                    ANA	A                    ;Set the CPU flags after to rotate operation and test to
 2833/2F46 : 72 AD 2F                              CM	MROUND             ;See if 24'th bit of p-p is a ONE. If so, must round-off
 2834/2F49 : 36 53                                 MVI	L, 123o                ;Now set up pointers
 2835/2F4B : E6                                    MOV	E,L                    ;To perform transfer
 2836/2F4C : DD                                    MOV	D,H                    ;Of the multiplication results
 2837/2F4D : 36 63                                 MVI	L, 143o                ;From the partial-product location
 2838/2F4F : 0E 04                                 MVI	B, 004                ;To the FPACC
 2839/2F51 :                            
 2840/2F51 :                            	
 2841/2F51 : 46 F6 2E                   EXMLDV:    CALL	MOVEIT             ;Perform the transfer from p-p to FPACC
 2842/2F54 : 0E 00                                 MVI	B, 000                ;Set up CPU register B to indicate regular normalization
 2843/2F56 : 46 1D 2E                              CALL	FPNORM             ;Normalize the result of multiplication
 2844/2F59 : 36 41                                 MVI	L, 101o               ;Now set the pointer to the original SIGNS indicator
 2845/2F5B : C7                                    MOV	A,M                    ;Fetch the indicator
 2846/2F5C : A0                                    ANA	A                    ;Exercise the CPU flags
 2847/2F5D : 0B                                    RNZ                    ;If indicator is non-zero, answer is positive, can exit her
 2848/2F5E : 44 69 2E                              JMP	FPCOMP             ;If not, answer must be negated, exit via 2's complement.
 2849/2F61 :                            
 2850/2F61 :                                                              ;The following portions of the FPMULT
 2851/2F61 :                                                              ;routine set up working locations in memory by clearing
 2852/2F61 :                                                              ;locations for an expanded FPOP area and the partial-produc
 2853/2F61 :                                                              ;area. Next, the signs of the two numbers to be multiplied
 2854/2F61 :                                                              ;are examined. Negative numbers are negated
 2855/2F61 :                                                              ;in preparation for the multiplication
 2856/2F61 :                                                              ;algorithm. A SIGNS indicator register is set up during
 2857/2F61 :                                                              ;this process to indicate whether the final result of the
 2858/2F61 :                                                              ;multiplication should be positive or negative. (Negative
 2859/2F61 :                                                              ;if original signs of the two numbers to be multiplied are
 2860/2F61 :                                                              ;different.)
 2861/2F61 :                            
 2862/2F61 : 36 60                      CKSIGN:    MVI	L, 140o               ;Set pointer to start of partial-product working area
 2863/2F63 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to proper page
 2864/2F65 : 0E 08                                 MVI	B, 010o               ;Set up a loop counter in CPU register B
 2865/2F67 : A8                                    XRA	A                    ;Clear the accumulator
 2866/2F68 :                            
 2867/2F68 : F8                         CLRNEX:    MOV	M,A                    ;Now clear out locations for the partial-product
 2868/2F69 : 30                                    INR	L                    ;Working registers
 2869/2F6A : 09                                    DCR	B                    ;Until the loop counter
 2870/2F6B : 48 68 2F                              JNZ	CLRNEX             ;Is zero
 2871/2F6E : 0E 04                      CLROPL:    MVI	B, 004                ;Set a loop counter
 2872/2F70 : 36 58                                 MVI	L, 130o               ;Set up pointer
 2873/2F72 : F8                         CLRNX1:    MOV	M,A                    ;Clear out some extra registers so that the
 2874/2F73 : 30                                    INR	L                    ;FPOP may be extended in length
 2875/2F74 : 09                                    DCR	B                    ;Perform clearing ops until loop counter
 2876/2F75 : 48 72 2F                              JNZ	CLRNX1             ;Is zero
 2877/2F78 : 36 41                                 MVI	L, 101o               ;Set pointer to M/D SIGNS indicator storage location
 2878/2F7A : 3E 01                                 MVI	M, 001                ;Set initial value of SIGNS indicator to plus one
 2879/2F7C : 36 56                                 MVI	L, 126o               ;Change pointer to MSW of FPACC
 2880/2F7E : C7                                    MOV	A,M                    ;Fetch MSW of mantissa into accumulator
 2881/2F7F : A0                                    ANA	A                    ;Test flags
 2882/2F80 : 70 94 2F                              JM	NEGFPA             ;If MSB in MSW of FPACC is a one, number is negative
 2883/2F83 : 36 5E                      OPSGNT:    MVI	L, 136o               ;Set pointer to MSW of FPOP
 2884/2F85 : C7                                    MOV	A,M                    ;Fetch MSW of mantissa into accumulator
 2885/2F86 : A0                                    ANA	A                    ;Test flags
 2886/2F87 : 13                                    RP                    ;Return to caller if number in FPOP is positive
 2887/2F88 : 36 41                                 MVI	L, 101o               ;Else change pointer to M/D SIGNS indicator
 2888/2F8A : D7                                    MOV	C,M                    ;Fetch the value in the SIGNS indicator
 2889/2F8B : 11                                    DCR	C                    ;Decrement the value by one
 2890/2F8C : FA                                    MOV	M,C                    ;Restore the new value back to storage location
 2891/2F8D : 36 5C                                 MVI	L, 134o               ;Set pointer to LSW of FPOP
 2892/2F8F : 0E 03                                 MVI	B, 003                ;Set precision counter
 2893/2F91 : 44 53 30                              JMP	COMPLM             ;Two's complement value of FPOP & return to caller
 2894/2F94 : 36 41                      NEGFPA:    MVI	L, 101o               ;Set pointer to M/D SIGNS indicator
 2895/2F96 : D7                                    MOV	C,M                    ;Fetch the value in the SIGNS indicator
 2896/2F97 : 11                                    DCR	C                    ;Decrement the value by one
 2897/2F98 : FA                                    MOV	M,C                    ;Restore the new value back to storage location
 2898/2F99 : 36 54                                 MVI	L, 124o               ;Set pointer to LSW of FPACC
 2899/2F9B : 0E 03                                 MVI	B, 003                ;Set precision counter
 2900/2F9D : 46 53 30                              CALL	COMPLM             ;Two's complement value of FPACC
 2901/2FA0 : 44 83 2F                              JMP	OPSGNT             ;Proceed to check sign of FPOP
 2902/2FA3 :                            
 2903/2FA3 :                                                              ;The following subroutine adds the double length (six regis
 2904/2FA3 :                                                              ;multiplicand in FPOP to the partial-product register when
 2905/2FA3 :                                                              ;called on by the multiplication algorithm.
 2906/2FA3 :                            
 2907/2FA3 : 26 61                      ADOPPP:    MVI	E, 141o               ;Pointer to LSW of partial-product
 2908/2FA5 : DD                                    MOV	D,H                    ;On same page as FPOP
 2909/2FA6 : 36 59                                 MVI	L, 131o               ;LSIV of FPOP which contains extended multiplicand
 2910/2FA8 : 0E 06                                 MVI	B, 006                ;Set precision counter (double length working registers)
 2911/2FAA : 44 42 30                              JMP	ADDER              ;Add multiplicand to partial-product & return to caller
 2912/2FAD :                            
 2913/2FAD : 0E 03                      MROUND:    MVI	B, 003                ;Set up precision counter
 2914/2FAF : 06 40                                 MVI	A, 100o               ;Prepare to add one to 24'th bit of partial-product
 2915/2FB1 : 87                                    ADD	M                    ;Add one to the 24'th bit of the partial-product
 2916/2FB2 : F8                         CROUND:    MOV	M,A                    ;Restore the updated byte to memory
 2917/2FB3 : 30                                    INR	L                    ;Advance the memory pointer to next most significant
 2918/2FB4 : 06 00                                 MVI	A, 000                ;Byte of partial-product, then clear ACC without
 2919/2FB6 : 8F                                    ADC	M                    ;Disturbing carry bit. Now perform add with carry to
 2920/2FB7 : 09                                    DCR	B                    ;Propagate any rounding in the partial-product registers.
 2921/2FB8 : 48 B2 2F                              JNZ	CROUND             ;If cotinter is not zero continue propagating any carry
 2922/2FBB : F8                                    MOV	M,A                    ;Restore final byte to memory
 2923/2FBC : 07                                    RET                    ;Exit to CALLling routine
 2924/2FBD :                            
 2925/2FBD : 46 61 2F                   FPDIV:     CALL	CKSIGN             ;Call routine to set up registers & ck signs of numbers
 2926/2FC0 : 36 56                                 MVI	L, 126o               ;Set pointer to MSW of FPACC (divisor)
 2927/2FC2 : C7                                    MOV	A,M                    ;Fetch MSW of FPACC to accumulator
 2928/2FC3 : A0                                    ANA	A                    ;Exercise CPU flags
 2929/2FC4 : 68 DE 28                              JZ	DVERR              ;If MSW of FPACC is zero go display 'DZ' error message
 2930/2FC7 : 36 5F                      SUBEXP:    MVI	L, 137o               ;Set pointer to FPOP (dividend) Exponent
 2931/2FC9 : C7                                    MOV	A,M                    ;Get FPOP Exponent into accumulator
 2932/2FCA : 36 57                                 MVI	L, 127o               ;Change pointer to FPACC (divisor) Exponent
 2933/2FCC : 97                                    SUB	M                    ;Subtract divisor exponent from dividend exponent
 2934/2FCD : 04 01                                 ADI	001                ;Add one for algorithm compensation
 2935/2FCF : F8                                    MOV	M,A                    ;Place result in FPACC Exponent
 2936/2FD0 : 36 42                      SETDCT:    MVI	L, 102o               ;Set pointer to bit counter storage location
 2937/2FD2 : 3E 17                                 MVI	M, 027o               ;Initialize bit counter to 23 decimal
 2938/2FD4 :                            
 2939/2FD4 :                                                              ;Main division algorithm for mantissas
 2940/2FD4 :                            
 2941/2FD4 : 46 2C 30                   DIVIDE:    CALL	SETSUB             ;Go subtmct divisor from dividend
 2942/2FD7 : 70 E9 2F                              JM	NOGO               ;If result is negative then place a zero bit in quotient
 2943/2FDA : 26 5C                                 MVI	E, 134o               ;If result zero or positive then move remainder after
 2944/2FDC : 36 59                                 MVI	L, 131o               ;Subtraction from working area to become new dividend
 2945/2FDE : 0E 03                                 MVI	B, 003                ;Set up moving pointers and initialize precision counter
 2946/2FE0 : 46 F6 2E                              CALL	MOVEIT             ;Perform the transfer
 2947/2FE3 : 06 01                                 MVI	A, 001                ;Place a one into least significant bit of accumulator
 2948/2FE5 : 1A                                    RAR                    ;And rotate it out into the carry bit
 2949/2FE6 : 44 EA 2F                              JMP	QUOROT             ;Proceed to rotate the carry bit into the current quotient
 2950/2FE9 : A8                         NOGO:      XRA	A                    ;When result is negative, put a zero in the carry bit, then
 2951/2FEA : 36 64                      QUOROT:    MVI	L, 144o               ;Set up pointer to LSW of quotient register
 2952/2FEC : 0E 03                                 MVI	B, 003                ;Set precision counter
 2953/2FEE : 46 6B 30                              CALL	ROTL               ;Rotate carry bit into quotient by using special entry to
 2954/2FF1 : 36 5C                                 MVI	L, 134o               ;ROTATL subroutine. Now set up pointer to dividend
 2955/2FF3 : 0E 03                                 MVI	B, 003                ;LSW and set precision counter
 2956/2FF5 : 46 6A 30                              CALL	ROTATL             ;Rotate the current dividend to the left
 2957/2FF8 : 36 42                                 MVI	L, 102o               ;Set pointer to bit counter storage location
 2958/2FFA : D7                                    MOV	C,M                    ;Fetch the value of the bit counter
 2959/2FFB : 11                                    DCR	C                    ;Decrement the value by one
 2960/2FFC : FA                                    MOV	M,C                    ;Restore the new counter value to storage
 2961/2FFD : 48 D4 2F                              JNZ	DIVIDE             ;If bit counter is not zero, continue division process
 2962/3000 : 46 2C 30                              CALL	SETSUB             ;After 23 (decimal) bits, do subtraction once more for
 2963/3003 : 70 23 30                              JM	DVEXIT             ;Possible rounding. Jump ahead if no rounding required.
 2964/3006 : 36 64                                 MVI	L, 144o               ;If rounding required set pointer to LSW of quotient
 2965/3008 : C7                                    MOV	A,M                    ;Fetch LSW of quotient to accumulator
 2966/3009 : 04 01                                 ADI	001                ;Add one to 23rd bit of quotient
 2967/300B : F8                                    MOV	M,A                    ;Restore updated LSW of quotient
 2968/300C : 06 00                                 MVI	A, 000                ;Clear accumulator without disturbing carry bit
 2969/300E : 30                                    INR	L                    ;Advance pointer to next significant byte of quotient
 2970/300F : 8F                                    ADC	M                    ;Propagate any carry as part of rounding process
 2971/3010 : F8                                    MOV	M,A                    ;Restore the updated byte of quotient
 2972/3011 : 06 00                                 MVI	A, 000                ;Clear ACC again without disturbing carry bit
 2973/3013 : 30                                    INR	L                    ;Advance pointer to MSW of quotient
 2974/3014 : 8F                                    ADC	M                    ;Propagate any carry to finish rounding process
 2975/3015 : F8                                    MOV	M,A                    ;Restore the updated byte of quotient
 2976/3016 : 50 23 30                              JP	DVEXIT             ;If most significant bit of quotient is zero, go finish up
 2977/3019 : 0E 03                                 MVI	B, 003                ;If not, set precision counter
 2978/301B : 46 74 30                              CALL	ROTATR             ;And rotate quotient to the right to clear the sign bit
 2979/301E : 36 57                                 MVI	L, 127o               ;Set pointer to FPACC Exponent
 2980/3020 : CF                                    MOV	B,M                    ;Fetch FPACC exponent
 2981/3021 : 08                                    INR	B                    ;Increment the value to compensate for the rotate right
 2982/3022 : F9                                    MOV	M,B                    ;Restore the updated exponent value
 2983/3023 : 36 63                      DVEXIT:    MVI	L, 143o               ;Set up pointers
 2984/3025 : 26 53                                 MVI	E, 123o               ;To transfer the quotient into the FPACC
 2985/3027 : 0E 04                                 MVI	B, 004                ;Set precision counter
 2986/3029 :                                                              ;THIS IS A CORRECTION FOUND IN THE NOTES
 2987/3029 : 44 51 2F                              JMP	EXMLDV             ;And exit through FPMULT routine at EXMLDV
 2988/302C :                            
 2989/302C :                                                              ;Subroutine to subtract divisor from dividend. Used by
 2990/302C :                                                              ;main DIVIDE subroutine.
 2991/302C :                            
 2992/302C : 26 59                      SETSUB:    MVI	E, 131o               ;Set pointer to LSW of working area
 2993/302E : DD                                    MOV	D,H                    ;On same page as FPACC
 2994/302F : 36 54                                 MVI	L, 124o               ;Set pointer to LSW of FPACC (divisor)
 2995/3031 : 0E 03                                 MVI	B, 003                ;Set precision counter
 2996/3033 : 46 F6 2E                              CALL	MOVEIT             ;Perform transfer
 2997/3036 : 26 59                                 MVI	E, 131o               ;Reset pointer to LSW of working area (now divisor)
 2998/3038 : 36 5C                                 MVI	L, 134o               ;Reset pointer to LSW of FPOP (dividend)
 2999/303A : 0E 03                                 MVI	B, 003                ;Set precision counter
 3000/303C : 46 7E 30                              CALL	SUBBER             ;Subtract divisor from dividend
 3001/303F : C7                                    MOV	A,M                    ;Get MSW of the result of the subtraction operations
 3002/3040 : A0                                    ANA	A                    ;Exercise CPU flags
 3003/3041 : 07                                    RET                    ;Return to caller with status
 3004/3042 : A0                         ADDER:     ANA	A                    ;Initialize the carry bit to zero upon entry
 3005/3043 : C7                         ADDMOR:    MOV	A,M                    ;Fetch byte from register group A
 3006/3044 : 46 D9 30                              CALL	SWITCH             ;Switch memory pointer to register group B
 3007/3047 : 8F                                    ADC	M                    ;Add byte from A to byte from B with carry
 3008/3048 : F8                                    MOV	M,A                    ;Leave result in register group B
 3009/3049 : 09                                    DCR	B                    ;Decrement number of bytes (precision) counter
 3010/304A : 2B                                    RZ                    ;Return to caller when all bytes in group processed
 3011/304B : 30                                    INR	L                    ;Else advance pointer for register group B
 3012/304C : 46 D9 30                              CALL	SWITCH             ;Switch memory pointer back to register group A
 3013/304F : 30                                    INR	L                    ;Advance the pointer for register group A
 3014/3050 : 44 43 30                              JMP	ADDMOR             ;Continue the multi-byte addition operation
 3015/3053 :                            
 3016/3053 :                                                              ;N'th precision two's complement (negate)
 3017/3053 :                                                              ;subroutine. Performs a two's complement on the multi-byte
 3018/3053 :                                                              ;registers tarting at the address pointed
 3019/3053 :                                                              ; to by H & L (least significant byte) upon entry.
 3020/3053 :                            
 3021/3053 : C7                         COMPLM:    MOV	A,M                    ;Fetch the least significant byte of the number to ACC
 3022/3054 : 2C FF                                 XRI	377o               ;Exclusive OR to complement the byte
 3023/3056 : 04 01                                 ADI	001                ;Add one to form two's complement of byte
 3024/3058 : F8                         MORCOM:    MOV	M,A                    ;Restore the negated byte to memory
 3025/3059 : 1A                                    RAR                   ;Save the carry bit
 3026/305A : D8                                    MOV	D,A                    ;In CPU register D
 3027/305B : 09                                    DCR	B                    ;Decrement number of bytes (precision) counter
 3028/305C : 2B                                    RZ                    ;Return to caller when all bytes in number processed
 3029/305D : 30                                    INR	L                    ;Else advance the pointer
 3030/305E : C7                                    MOV	A,M                    ;Fetch the next byte of the number to ACC
 3031/305F : 2C FF                                 XRI	377o               ;Exclusive OR to complement the byte
 3032/3061 : E0                                    MOV	E,A                    ;Save complemented value in register E temporarily
 3033/3062 : C3                                    MOV	A,D                    ;Restore previous carry status to ACC
 3034/3063 : 12                                    RAL                    ;And rotate it out to the carry bit
 3035/3064 : 06 00                                 MVI	A, 000                ;Clear ACC without disturbing carry status
 3036/3066 : 8C                                    ADC	E                    ;Add in any carry to complemented value
 3037/3067 : 44 58 30                              JMP	MORCOM             ;Continue the two's complement procedure as req'd
 3038/306A :                            
 3039/306A :                                                              ;N'th precision rotate left subroutine. Rotates a multi-
 3040/306A :                                                              ;byte number left starting at the address initially
 3041/306A :                                                              ;specified by the contents of CPU registers H & L upon
 3042/306A :                                                              ;subroutine entry (LSW). First entry point will clear
 3043/306A :                                                              ;the carry bit before beginning rotate operations. Second
 3044/306A :                                                              ;entry point does not clear the carry bit.
 3045/306A :                            
 3046/306A : A0                         ROTATL:    ANA	A                    ;Clear the carry bit at this entry point
 3047/306B : C7                         ROTL:      MOV	A,M                    ;Fetch a byte from memory
 3048/306C : 12                                    RAL                    ;Rotate it left (bring carry into LSB, push MSB to carry)
 3049/306D : F8                                    MOV	M,A                    ;Restore rotated word to memory
 3050/306E : 09                                    DCR	B                    ;Decrement precision counter
 3051/306F : 2B                                    RZ                    ;Exit to caller when finished
 3052/3070 : 30                                    INR	L                    ;Else advance pointer to next byte
 3053/3071 : 44 6B 30                              JMP	ROTL               ;Continue rotate left operations
 3054/3074 :                            
 3055/3074 :                            
 3056/3074 :                                                              ;N'th precision rotate
 3057/3074 :                                                              ;right subroutine. Opposite of
 3058/3074 :                                                              ;above subroutine.
 3059/3074 :                            
 3060/3074 : A0                         ROTATR:    ANA	A                    ;Clear the carry bit at this entry point
 3061/3075 : C7                         ROTR:      MOV	A,M                    ;Fetch a byte from memory
 3062/3076 : 1A                                    RAR                    ;Rotate it right (carry into MSB, LSB to carry)
 3063/3077 : F8                                    MOV	M,A                    ;Restore rotated word to memory
 3064/3078 : 09                                    DCR	B                    ;Decrement precision counter
 3065/3079 : 2B                                    RZ                    ;Exit to caller when finished
 3066/307A : 31                                    DCR	L                    ;Else decrement pointer to next byte
 3067/307B : 44 75 30                              JMP	ROTR               ;Continue rotate right operations
 3068/307E :                            
 3069/307E :                                                              ;N'th precision subtraction subroutine.
 3070/307E :                                                              ;Number starting at location pointed to by D & E (least
 3071/307E :                                                              ;significant byte) is subtracted from number starting at
 3072/307E :                                                              ;address specified by contents of H & L.
 3073/307E :                            
 3074/307E : A0                         SUBBER:    ANA	A                    ;Initialize the carry bit to zero upon entry
 3075/307F : C7                         SUBTRA:    MOV	A,M                    ;Fetch byte from register group A
 3076/3080 : 46 D9 30                              CALL	SWITCH             ;Switch memory pointer to register group B
 3077/3083 : 9F                                    SBB	M                    ;Subtract byte from group B ftom that in group A
 3078/3084 : F8                                    MOV	M,A                    ;Leave result in register group B
 3079/3085 : 09                                    DCR	B                    ;Decrement number of bytes (precision) counter
 3080/3086 : 2B                                    RZ                    ;Return to caller when all bytes in group processed
 3081/3087 : 30                                    INR	L                    ;Else advance pointer for register group B
 3082/3088 : 46 D9 30                              CALL	SWITCH             ;Switch memory pointer back to register group A
 3083/308B : 30                                    INR	L                    ;Advance the pointer for register group A
 3084/308C : 44 7F 30                              JMP	SUBTRA             ;Continue the multi-byte subtraction operation
 3085/308F :                            
 3086/308F :                                                              ;The next subroutine will transfer the four byte
 3087/308F :                                                              ;register string (generally a number in floating point
 3088/308F :                                                              ;format) from the starting address pointed to by CPU
 3089/308F :                                                              ;registers H & L when the subroutine is entered to
 3090/308F :                                                              ;the FPACC (floating point accumulator registers).
 3091/308F :                            
 3092/308F : 1E 02                      FLOAD:     MVI	D,PG01 ;\HB\OLDPG1    ;** Set page address of FPACC
 3093/3091 : 26 54                                 MVI	E, 124o               ;Set address of least signficant byte of FPACC
 3094/3093 : 0E 04                                 MVI	B, 004                ;Set precision counter to four bytes (mantissa bytes
 3095/3095 : 44 F6 2E                              JMP	MOVEIT             ;Plus Exponent) and exit via the transfer routine
 3096/3098 :                            
 3097/3098 :                                                              ;The next several subroutines are used to perform
 3098/3098 :                                                              ;floating pojnt register loading and transfer operations.
 3099/3098 :                            
 3100/3098 : E6                         FSTORE:    MOV	E,L                    ;Transfer contents of register L to E
 3101/3099 : DD                                    MOV	D,H                    ;Transfer contents of register H to D
 3102/309A : 36 54                                 MVI	L, 124o               ;Set L to least significant byte of FPACC mantissa
 3103/309C : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set page to FPACC storage area
 3104/309E : 44 A5 30                              JMP	SETIT              ;Go transfer FPACC contents to area pointed to by D&E
 3105/30A1 : 1E 02                      OPLOAD:    MVI	D,PG01 ;\HB\OLDPG1    ;** Set page to FPOP storage area
 3106/30A3 : 26 5C                                 MVI	E, 134o               ;Set pointer to least significant byte of FPOP
 3107/30A5 : 0E 04                      SETIT:     MVI	B, 004                ;Set precision counter. Transfer from H & L area to
 3108/30A7 : 44 F6 2E                              JMP	MOVEIT             ;Locations pointed to by D & E
 3109/30AA :                            
 3110/30AA :                                                              ;The next subroutine perforins a double transfer opera-
 3111/30AA :                                                              ;tion. It first transfers the contents of the FPACC into
 3112/30AA :                                                              ;the FPOP. It then transfers new data (as pointed to by
 3113/30AA :                                                              ;H & L upon entry to the subroutine) into the FPACC.
 3114/30AA :                            
 3115/30AA : 46 BA 30                   FACXOP:    CALL	SAVEHL             ;Save contents of H & L upon entry to subroutine
 3116/30AD : 36 54                                 MVI	L, 124o               ;Set pointer to FPACC LSW
 3117/30AF : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set pointer to page of FPACC
 3118/30B1 : 46 A1 30                              CALL	OPLOAD             ;Transfer FPACC to FPOP
 3119/30B4 : 46 CA 30                              CALL	RESTHL             ;Recover original subroutine entry values for H & L
 3120/30B7 : 44 8F 30                              JMP	FLOAD              ;Transfer registers pointed to by H & L into the FPACC
 3121/30BA :                            
 3122/30BA :                                                              ;Subroutine to save the contents of CPU registers D, E, H
 3123/30BA :                                                              ;and L in a temporary storage area in memory.
 3124/30BA :                            
 3125/30BA : C5                         SAVEHL:    MOV	A,H                    ;Transfer value in H to ACC
 3126/30BB : CE                                    MOV	B,L                    ;And value in L to B
 3127/30BC : 36 80                                 MVI	L, 200o               ;Now set L to start of tempomry storage locations
 3128/30BE : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** And set H to storage area page
 3129/30C0 : F8                                    MOV	M,A                    ;Save A (entry value of H) in memory
 3130/30C1 : 30                                    INR	L                    ;Advance pointer
 3131/30C2 : F9                                    MOV	M,B                    ;Save B (entry value of L) in memory
 3132/30C3 : 30                                    INR	L                    ;Advance pointer
 3133/30C4 : FB                                    MOV	M,D                    ;Save D in memory
 3134/30C5 : 30                                    INR	L                    ;Advance pointer
 3135/30C6 : FC                                    MOV	M,E                    ;Save E in memory
 3136/30C7 : E8                                    MOV	H,A                    ;Restore entry value of H
 3137/30C8 : F1                                    MOV	L,B                    ;Restore entry value of L
 3138/30C9 : 07                                    RET                    ;Exit to calling routine
 3139/30CA :                            
 3140/30CA :                                                              ;Subroutine to restore the contents of CPU registers D,
 3141/30CA :                                                              ;E, H and L from temporary storage in memory.
 3142/30CA :                            
 3143/30CA : 36 80                      RESTHL:    MVI	L, 200o               ;Set L to start of temporary storage locations
 3144/30CC : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to storage area page
 3145/30CE : C7                                    MOV	A,M                    ;Fetch stored value for li iii ACC
 3146/30CF : 30                                    INR	L                    ;Advance pointer
 3147/30D0 : CF                                    MOV	B,M                    ;Fetch stored value for L into B
 3148/30D1 : 30                                    INR	L                    ;Advance pointer
 3149/30D2 : DF                                    MOV	D,M                    ;Fetch stored value for T.)
 3150/30D3 : 30                                    INR	L                    ;Advance pointer
 3151/30D4 : E7                                    MOV	E,M                    ;Fetch stored value for
 3152/30D5 : E8                                    MOV	H,A                    ;Restore  saved value for H
 3153/30D6 : F1                                    MOV	L,B                    ;Restore saved value for L
 3154/30D7 : C7                                    MOV	A,M                    ;Leave stored value for E in ACC
 3155/30D8 : 07                                    RET                    ;Exit to calling routine
 3156/30D9 :                            
 3157/30D9 :                                                              ;Subroutine to exchange the contents of H & L with
 3158/30D9 :                                                              ;D & E.
 3159/30D9 :                            
 3160/30D9 : D5                         SWITCH:    MOV	C,H                    ;Transfer register H to C temporarily
 3161/30DA : EB                                    MOV	H,D                    ;Place value of D into H
 3162/30DB : DA                                    MOV	D,C                    ;Now put former H from C into D
 3163/30DC : D6                                    MOV	C,L                    ;Transfer register L to C temporarily
 3164/30DD : F4                                    MOV	L,E                    ;Place value of E into L
 3165/30DE : E2                                    MOV	E,C                    ;Now put former L from C into E
 3166/30DF : 07                                    RET                    ;Exit to calling routine
 3167/30E0 : 2E 02                      GETINP:    MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of GETINP character counter
 3168/30E2 : 36 90                                 MVI	L, 220o               ;Set L to address of GETINP character counter
 3169/30E4 : D7                                    MOV	C,M                    ;Load counter value into CPU register C
 3170/30E5 : 10                                    INR	C                    ;Exercise the counter in order
 3171/30E6 : 11                                    DCR	C                    ;To set CPU flags. If counter is non-zero, then indexing
 3172/30E7 : 48 F3 30                              JNZ	NOT0               ;Register (GETINP counter) is all set so jump ahead.
 3173/30EA : F4                                    MOV	L,E                    ;But, if counter zero, then starting to process a new
 3174/30EB : EB                                    MOV	H,D                    ;Character string. Transfer char string buffer pointer into
 3175/30EC : D7                                    MOV	C,M                    ;H & L and fetch the string's character count value (cc)
 3176/30ED : 10                                    INR	C                    ;Increment the (cc) by one to take account of (cc) byte
 3177/30EE : 46 09 31                              CALL	INDEXC             ;Add contents of regis C to H & L to point to end of the
 3178/30F1 : 3E 00                                 MVI	M, 000                ;Character string in buffer and place a zero byte marker
 3179/30F3 : 36 90                      NOT0:      MVI	L, 220o               ;Set L back to address of GETINP counter which is used
 3180/30F5 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** As an indexing value. Set H to correct page.
 3181/30F7 : D7                                    MOV	C,M                    ;Fetch the value of GETINP counter into register C
 3182/30F8 : 10                                    INR	C                    ;Increment the value in C
 3183/30F9 : FA                                    MOV	M,C                    ;Restore the updated value for future use
 3184/30FA : F4                                    MOV	L,E                    ;Bring the base address of the character string buffer into
 3185/30FB : EB                                    MOV	H,D                    ;CPU registers H & L
 3186/30FC : 46 09 31                              CALL	INDEXC             ;Add contents of register C to form indexed address of
 3187/30FF : C7                                    MOV	A,M                    ;Next character to be fetched as input. Fetch the next
 3188/3100 : A0                                    ANA	A                    ;Character. Exercise the CPU flags.
 3189/3101 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Restore page pointer to floating point working area
 3190/3103 : 0B                                    RNZ                    ;If character is non-zero, not end of string, exit to calle
 3191/3104 : 36 90                                 MVI	L, 220o               ;If zero character, must reset GETINP counter for next
 3192/3106 : 3E 00                                 MVI	M, 000                ;String. Reset pointer and clear GETINP counter to zero
 3193/3108 : 07                                    RET                    ;Then exit to calling routine
 3194/3109 :                            
 3195/3109 :                                                              ;Following subroutine causes register C to be used as an
 3196/3109 :                                                              ;indexing register. Value in C is added to address in H
 3197/3109 :                                                              ;and L to form new address.
 3198/3109 :                            
 3199/3109 : C6                         INDEXC:    MOV	A,L                    ;Place value from register L into accumulator
 3200/310A : 82                                    ADD	C                    ;Add quantity in register C
 3201/310B : F0                                    MOV	L,A                    ;Restore updated value back to L
 3202/310C : 03                                    RNC                    ;Exit to caller if no carry from addition
 3203/310D : 28                                    INR	H                    ;But, if have carry then must increment register H
 3204/310E : 07                                    RET                    ;Before returning to calling routine
 3205/310F :                            
 3206/310F :                                                              ;Main Decimal INPUT subroutine to convert strings of
 3207/310F :                                                              ;ASCII characters representing decimal fixed or floating
 3208/310F :                                                              ;point numbers to binary floating point numbers.
 3209/310F :                            
 3210/310F : E6                         DINPUT:    MOV	E,L                    ;Save entry value of register L in E. (Pointer to buffer
 3211/3110 : DD                                    MOV	D,H                    ;Containing ASCII character string.) Do same for H to D.
 3212/3111 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of floating point working registers
 3213/3113 : 36 68                                 MVI	L, 150o               ;Set L to start of decirnal-to-binary working area
 3214/3115 : A8                                    XRA	A                    ;Clear the accumulator
 3215/3116 : 0E 08                                 MVI	B, 010o               ;Set up a loop counter
 3216/3118 : F8                         CLRNX2:    MOV	M,A                    ;Deposit zero in working area to initialize
 3217/3119 : 30                                    INR	L                    ;Advance the memory pointer
 3218/311A : 09                                    DCR	B                    ;Decrement the loop counter
 3219/311B : 48 18 31                              JNZ	CLRNX2             ;Clear working area until loop counter is zero
 3220/311E : 36 43                                 MVI	L, 103o               ;Set pointer to floating point temporary registers and
 3221/3120 : 0E 04                                 MVI	B, 004                ;Indicators working area. Set up a loop counter.
 3222/3122 : F8                         CLRNX3:    MOV	M,A                    ;Deposit zero in working area to initialize
 3223/3123 : 30                                    INR	L                    ;Advance the memory pointer
 3224/3124 : 09                                    DCR	B                    ;Decrement the loop counter
 3225/3125 : 48 22 31                              JNZ	CLRNX3             ;Clear working area until loop counter is zero
 3226/3128 : 46 E0 30                              CALL	GETINP             ;Fetch a character from the ASCII chax string buffer
 3227/312B : 3C AB                                 CPI	253o               ;(Typically the SYMBOL/TOKEN buffer). See if it is
 3228/312D : 68 38 31                              JZ	NINPUT             ;Code for + sign. Jump ahead if code for + sign.
 3229/3130 : 3C AD                                 CPI	255o               ;See if code for minus (-) sign.
 3230/3132 : 48 3B 31                              JNZ	NOTPLM             ;Jump ahead if not code for minus sign. If code for
 3231/3135 : 36 43                                 MVI	L, 103o               ;Minus sign, set pointer to MINUS flag storage location.
 3232/3137 : F8                                    MOV	M,A                    ;Set the MINUS flag to indicate a minus number
 3233/3138 : 46 E0 30                   NINPUT:    CALL	GETINP             ;Fetch another character from the ASCII char string
 3234/313B : 3C AE                      NOTPLM:    CPI	256o               ;See if character represents a period (decimal point) in
 3235/313D : 68 6C 31                              JZ	PERIOD             ;Input string. Jump ahead if yes.
 3236/3140 : 3C C5                                 CPI	305o               ;If not period, see if code for E as in Exponent
 3237/3142 : 68 7C 31                              JZ	FNDEXP             ;Jump ahead if yes.
 3238/3145 : 3C A0                                 CPI	240o               ;Else see if code for space.
 3239/3147 : 68 38 31                              JZ	NINPUT             ;Ignore space character, go fetch another character.
 3240/314A : A0                                    ANA	A                    ;If none of the above see if zero byte
 3241/314B : 68 B4 31                              JZ	ENDINP             ;Indicating end of input char string. If yes, jumn ahead.
 3242/314E : 3C B0                                 CPI	260o               ;If not end of string, check to see
 3243/3150 : 70 EC 28                              JM	NUMERR             ;If character represents
 3244/3153 : 3C BA                                 CPI	272o               ;A valid decimal number (0 to 9)
 3245/3155 : 50 EC 28                              JP	NUMERR             ;Display error message if not a valid digit at this point!
 3246/3158 : 36 6E                                 MVI	L, 156o               ;For valid digit, set pointer to MSW of temporary
 3247/315A : D0                                    MOV	C,A                    ;Decimal to binary holding registers. Save character in C.
 3248/315B : 06 F8                                 MVI	A, 370o               ;Form mask for sizing in accumulator. Now see if
 3249/315D : A7                                    ANA	M                    ;Holding register has enough room for the conversion of
 3250/315E : 48 38 31                              JNZ	NINPUT             ;Another digit. Ignore the input if no more room.
 3251/3161 : 36 45                                 MVI	L, IN_DIGIT_CC_L      ;If have room in register then set pointer to input digit
 3252/3163 : CF                                    MOV	B,M                    ;Counter location. Fetch the present value.
 3253/3164 : 08                                    INR	B                    ;Increment it to account for incoming digit.
 3254/3165 : F9                                    MOV	M,B                    ;Restore updated count to storage location.
 3255/3166 : 46 19 32                              CALL	DECBIN             ;Call the DECimal to BINary conversion routine to add
 3256/3169 : 44 38 31                              JMP	NINPUT             ;In the new digit in holding registers. Continue inputting.
 3257/316C : C8                         PERIOD:    MOV	B,A                    ;Save character code in register B
 3258/316D : 36 46                                 MVI	L, 106o               ;Set pointer to PERIOD indicator storage location
 3259/316F : C7                                    MOV	A,M                    ;Fetch value in PERIOD indicator
 3260/3170 : A0                                    ANA	A                    ;Exercise CPU flags
 3261/3171 : 48 EC 28                              JNZ	NUMERR             ;If already have a period then display error message
 3262/3174 : 36 45                                 MVI	L, IN_DIGIT_CC_L      ;If not, change pointer to digit counter storage location
 3263/3176 : F8                                    MOV	M,A                    ;Clear the digit counter back to zero
 3264/3177 : 30                                    INR	L                    ;Advance pointer to PERIOD indicator
 3265/3178 : F9                                    MOV	M,B                    ;Set the PERIOD indicator
 3266/3179 : 44 38 31                              JMP	NINPUT             ;Continue processing the input character string
 3267/317C : 46 E0 30                   FNDEXP:    CALL	GETINP             ;Get next character in Exponent
 3268/317F : 3C AB                                 CPI	253o               ;See if it is code for + sign
 3269/3181 : 68 8C 31                              JZ	EXPINP             ;Jump ahead if yes.
 3270/3184 : 3C AD                                 CPI	255o               ;If not + sign, see if minus sign
 3271/3186 : 48 8F 31                              JNZ	NOEXPS             ;If not minus sign then jump ahead
 3272/3189 : 36 44                                 MVI	L, 104o               ;For minus sign, set pointer to EXP SIGN indicator
 3273/318B : F8                                    MOV	M,A                    ;Set the EXP SIGN indicator for a minus exponent
 3274/318C : 46 E0 30                   EXPINP:    CALL	GETINP             ;Fetch the next character in the decimal exponent
 3275/318F : A0                         NOEXPS:    ANA	A                    ;Exercise the CPU flags
 3276/3190 : 68 B4 31                              JZ	ENDINP             ;If character inputted was zero, then end of input string
 3277/3193 : 3C B0                                 CPI	260o               ;If not end of string, check to see
 3278/3195 : 70 EC 28                              JM	NUMERR             ;If character represents
 3279/3198 : 3C BA                                 CPI	272o               ;A valid decimal number (0 to 9)
 3280/319A : 50 EC 28                              JP	NUMERR             ;Display error message if not a valid digit at this point!
 3281/319D : 24 0F                                 ANI	017o               ;Else trim the ASCII code to BCD
 3282/319F : C8                                    MOV	B,A                    ;And save in register B
 3283/31A0 : 36 6F                                 MVI	L, 157o               ;Set pointer to input exponent storage location
 3284/31A2 : 06 03                                 MVI	A, 003                ;Set accumulator equal to three
 3285/31A4 : BF                                    CMP	M                    ;See if any previous digit in exponent greater than three
 3286/31A5 : 70 EC 28                              JM	NUMERR             ;Display error message if yes
 3287/31A8 : D7                                    MOV	C,M                    ;Else save any previous value in register C
 3288/31A9 : C7                                    MOV	A,M                    ;And also place any previous value in accumulator
 3289/31AA : A0                                    ANA	A                    ;Clear the carry bit with this instruction
 3290/31AB : 12                                    RAL                    ;Single precision multiply by ten algorithm
 3291/31AC : 12                                    RAL                    ;Two rotate lefts equals times four
 3292/31AD : 82                                    ADD	C                    ;Adding in the digit makes total times five
 3293/31AE : 12                                    RAL                    ;Rotating left again equals times ten
 3294/31AF : 81                                    ADD	B                    ;now add in digit just inputted
 3295/31B0 : F8                                    MOV	M,A                    ;Restore the value to exponent storage location
 3296/31B1 : 44 8C 31                              JMP	EXPINP             ;Go get any additional exponent int)ut
 3297/31B4 : 36 43                      ENDINP:    MVI	L, 103o               ;Set pointer to mantissa SIGN indicator
 3298/31B6 : C7                                    MOV	A,M                    ;Fetch the SIGN indicator to the acclimulator
 3299/31B7 : A0                                    ANA	A                    ;Exercise the CPU flags
 3300/31B8 : 68 C2 31                              JZ	FININP             ;If SIGN indicator is zero, go finish up as nr is positive
 3301/31BB : 36 6C                                 MVI	L, 154o               ;But, if indicator is non-zero, number is negative
 3302/31BD : 0E 03                                 MVI	B, 003                ;Set pntr to LSW of storage registers, set precision entr
 3303/31BF : 46 53 30                              CALL	COMPLM             ;Negate the triple-precision number in holding registers
 3304/31C2 : 36 6B                      FININP:    MVI	L, 153o               ;Set pointer to input storage LS~V minus one
 3305/31C4 : A8                                    XRA	A                    ;Clear the accumulator
 3306/31C5 : F8                                    MOV	M,A                    ;Clear the LSW minus one location
 3307/31C6 : DD                                    MOV	D,H                    ;Set register D to floating point working page
 3308/31C7 : 26 53                                 MVI	E, 123o               ;Set E to address of FPACC LSW minus one
 3309/31C9 : 0E 04                                 MVI	B, 004                ;Set precision counter
 3310/31CB : 46 F6 2E                              CALL	MOVEIT             ;Move number from input register to FPACC
 3311/31CE : 46 1B 2E                              CALL	FPFLT              ;Now convert the binary fixed point to floating point
 3312/31D1 : 36 44                                 MVI	L, 104o               ;Set pointer to Exponent SIGN indicator location
 3313/31D3 : C7                                    MOV	A,M                    ;Fetch the value of the EXP SIGN indicator
 3314/31D4 : A0                                    ANA	A                    ;Exercise the CPU flags
 3315/31D5 : 36 6F                                 MVI	L, 157o               ;Reset pointer to input exponent storage location
 3316/31D7 : 68 E0 31                              JZ	POSEXP             ;If EXP SIGN indicator zero, exponent is positive
 3317/31DA : C7                                    MOV	A,M                    ;Else, exponent is negative so must negate
 3318/31DB : 2C FF                                 XRI	377o               ;The value in the input exponent storage location
 3319/31DD : 04 01                                 ADI	001                ;By performing this two's complement
 3320/31DF : F8                                    MOV	M,A                    ;Restore the negated value to exponent storage location
 3321/31E0 : 36 46                      POSEXP:    MVI	L, 106o               ;Set pointer to PERIOD indicator storage location
 3322/31E2 : C7                                    MOV	A,M                    ;Fetch the contents of the PERIOD indicator
 3323/31E3 : A0                                    ANA	A                    ;Exercise the CPU flags
 3324/31E4 : 68 EB 31                              JZ	EXPOK              ;If PERIOD indicator clear, no decimal point involved
 3325/31E7 : 36 45                                 MVI	L, IN_DIGIT_CC_L      ;If have a decimal point, set pointer to digit counter
 3326/31E9 : A8                                    XRA	A                    ;Storage location. Clear the accumulator.
 3327/31EA : 97                                    SUB	M                    ;And get a negated value of the digit counter in ACC
 3328/31EB : 36 6F                      EXPOK:     MVI	L, 157o               ;Change pointer to input exponent storage location
 3329/31ED : 87                                    ADD	M                    ;Add this value to negated digit counter value
 3330/31EE : F8                                    MOV	M,A                    ;Restore new value to storage location
 3331/31EF : 70 06 32                              JM	MINEXP             ;If new value is minus, skip over next subroutine
 3332/31F2 : 2B                                    RZ                    ;If new value is zero, no further processing required
 3333/31F3 :                            
 3334/31F3 :                                                              ;Following subroutine will multiply the floating point
 3335/31F3 :                                                              ;binary number stored in FPACC by ten tirnes the
 3336/31F3 :                                                              ;value stored in the deciinal exponent storage location.
 3337/31F3 :                            
 3338/31F3 : 36 88                      FPX10:     MVI	L, 210o               ;Set pointer to registers containing floating point
 3339/31F5 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Binary representation of 10 (decimal).
 3340/31F7 : 46 AA 30                              CALL	FACXOP             ;Transfer FPACC to FPOP and 10 (dec) to FPACC
 3341/31FA : 46 11 2F                              CALL	FPMULT             ;Multiply FPOP (formerly FPACC) by 10 (decimal)
 3342/31FD : 36 6F                                 MVI	L, 157o               ;Set pointer to decimal exponent storage location
 3343/31FF : D7                                    MOV	C,M                    ;Fetch the exponent value
 3344/3200 : 11                                    DCR	C                    ;Decrement
 3345/3201 : FA                                    MOV	M,C                    ;Restore to storage
 3346/3202 : 48 F3 31                              JNZ	FPX10              ;If exponent value is not zero, continue multiplication
 3347/3205 : 07                                    RET                    ;When exponent is zero can exit. Conversion completed.
 3348/3206 :                            
 3349/3206 :                                                              ;Following subroutine will multiply the floating point
 3350/3206 :                                                              ;binary number stored in PPACC by 0.1 times the value
 3351/3206 :                                                              ;(negative) stored in the decimal exponent storage location
 3352/3206 :                            
 3353/3206 :                            MINEXP:
 3354/3206 : 36 8C                      FPD10:     MVI	L, 214o               ;Set pointer to registers containing floating point
 3355/3208 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Binary representation of 0.1 (decimal).
 3356/320A : 46 AA 30                              CALL	FACXOP             ;Transfer FPACC to FPOP and 0.1 (dec) to FPACC
 3357/320D : 46 11 2F                              CALL	FPMULT             ;Multitply FPOP (formerly FPACC) by 0.1 (decimal)
 3358/3210 : 36 6F                                 MVI	L, 157o               ;Set pointer to decimal exponent storage location
 3359/3212 : CF                                    MOV	B,M                    ;Fetch the exponent value
 3360/3213 : 08                                    INR	B                    ;Increment
 3361/3214 : F9                                    MOV	M,B                    ;Restore to storage
 3362/3215 : 48 06 32                              JNZ	FPD10              ;If exponent value is not zero, continue multiplication
 3363/3218 : 07                                    RET                    ;When exponent is zero can exit. Conversion completed.
 3364/3219 :                            
 3365/3219 :                                                              ;Following subroutine is used
 3366/3219 :                                                              ;to convert decimal charac-
 3367/3219 :                                                              ;ters to binary fixed point forinat
 3368/3219 :                                                              ;in a triple-precision format.
 3369/3219 :                            
 3370/3219 : 46 BA 30                   DECBIN:    CALL	SAVEHL             ;Save entry value of D, E, H and L in memory
 3371/321C : 36 6B                                 MVI	L, 153o               ;Set pointer to temporary storage location
 3372/321E : C2                                    MOV	A,C                    ;Restore character inputted to accumulator
 3373/321F : 24 0F                                 ANI	017o               ;Trim ASCII code to BCD
 3374/3221 : F8                                    MOV	M,A                    ;Store temporarily
 3375/3222 : 26 68                                 MVI	E, 150o               ;Set pointer to working area LSW of multi-byte register
 3376/3224 : 36 6C                                 MVI	L, 154o               ;Set another pointer to LSW of conversion register
 3377/3226 : DD                                    MOV	D,H                    ;Make sure D set to page of working area
 3378/3227 : 0E 03                                 MVI	B, 003                ;Set precision counter
 3379/3229 : 46 F6 2E                              CALL	MOVEIT             ;Move original value of conversion register to working
 3380/322C : 36 6C                                 MVI	L, 154o               ;Register. Reset pointer to LSW of conversion register.
 3381/322E : 0E 03                                 MVI	B, 003                ;Set precision counter
 3382/3230 : 46 6A 30                              CALL	ROTATL             ;Rotate register left, (Multiplies value by two.)
 3383/3233 : 36 6C                                 MVI	L, 154o               ;Reset pointer to LSW.
 3384/3235 : 0E 03                                 MVI	B, 003                ;Set precision counter
 3385/3237 : 46 6A 30                              CALL	ROTATL             ;Multiply by two again (total now times four).
 3386/323A : 26 6C                                 MVI	E, 154o               ;Set pointer to LSW of conversion register.
 3387/323C : 36 68                                 MVI	L, 150o               ;Set pointer to LSW of working register (original value).
 3388/323E : 0E 03                                 MVI	B, 003                ;Set precision counter.
 3389/3240 : 46 42 30                              CALL	ADDER              ;Add original value to rotated value (now times five).
 3390/3243 : 36 6C                                 MVI	L, 154o               ;Reset pointer to LSW
 3391/3245 : 0E 03                                 MVI	B, 003                ;Set precision counter
 3392/3247 : 46 6A 30                              CALL	ROTATL             ;Multiply by two once more (total now times ten).
 3393/324A : 36 6A                                 MVI	L, 152o               ;Set pointer to clear working register locatiotis
 3394/324C : A8                                    XRA	A                    ;Clear the accumulator
 3395/324D : F8                                    MOV	M,A                    ;Clear MSW of working register
 3396/324E : 31                                    DCR	L                    ;Decrement pointer
 3397/324F : F8                                    MOV	M,A                    ;Clear next byte
 3398/3250 : 36 6B                                 MVI	L, 153o               ;Set pointer to current digit storage location
 3399/3252 : C7                                    MOV	A,M                    ;Fetch the current digit
 3400/3253 : 36 68                                 MVI	L, 150o               ;Change pointer to LSW of working register
 3401/3255 : F8                                    MOV	M,A                    ;Deposit the current digit in LSW of working register
 3402/3256 : 26 6C                                 MVI	E, 154o               ;Set pointer to conversion register LSW
 3403/3258 : 0E 03                                 MVI	B, 003                ;Set precision counter
 3404/325A : 46 42 30                              CALL	ADDER              ;Add current digit to conversion register to complete
 3405/325D : 44 CA 30                              JMP	RESTHL             ;Conversion. Exit to caller by restoring CPU registers.
 3406/3260 : 2E 02                      FPOUT:     MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to working area for floating point routines
 3407/3262 : 36 6F                                 MVI	L, 157o               ;Set pointer to decimal exponent storage location
 3408/3264 : 3E 00                                 MVI	M, 000                ;Initialize storage location to zero
 3409/3266 : 36 56                                 MVI	L, 126o               ;Change pointer to FPACC (number to be outputted)
 3410/3268 : C7                                    MOV	A,M                    ;And fetch MSW of FPACC
 3411/3269 : A0                                    ANA	A                    ;Test the contents of MSW of FPACC
 3412/326A : 70 72 32                              JM	OUTNEG             ;If most significant bit of MSW is a one, have a minus nr.
 3413/326D : 06 A0                                 MVI	A, 240o               ;Else number is positive, set ASCII code for space for a
 3414/326F : 44 7B 32                              JMP	AHEAD1             ;Positive number and go display a space
 3415/3272 : 36 54                      OUTNEG:    MVI	L, 124o               ;If number in FPACC is negative must negate in order
 3416/3274 : 0E 03                                 MVI	B, 003                ;To display. Set pntr to LSW of FPACC & set prec. cntr.
 3417/3276 : 46 53 30                              CALL	COMPLM             ;Negate the number in the FPACC to make it positive
 3418/3279 : 06 AD                                 MVI	A, 255o               ;But load ACC with ASCII code for minus sign
 3419/327B : 46 82 21                   AHEAD1:    CALL	ECHO               ;Call user display driver to output space or minus sign
 3420/327E : 36 48                                 MVI	L, 110o               ;Set pointer to FIXED/FLOAT indicator
 3421/3280 : C7                                    MOV	A,M                    ;Fetch value of FIXED/FLOAT indicator
 3422/3281 : A0                                    ANA	A                    ;Test contents of indicator. If contents are zero, calling
 3423/3282 : 68 96 32                              JZ	OUTFLT             ;Routine has directed floating point output format.
 3424/3285 : 36 57                                 MVI	L, 127o               ;If indicator non-zero, fixed point fonnat requested if
 3425/3287 : 06 17                                 MVI	A, 027o               ;Possible. Point to FPACC Exponent. Put 23 decimal in
 3426/3289 : CF                                    MOV	B,M                    ;Accumulator. Fetch FPACC Exponent into register B
 3427/328A : 08                                    INR	B                    ;And exercise the register to test its
 3428/328B : 09                                    DCR	B                    ;Original contents. If FPACC Exponent is negative in
 3429/328C : 70 96 32                              JM	OUTFLT             ;Value then go to floating point output forrnat. If value
 3430/328F : 91                                    SUB	B                    ;Is positive, subtract value from 23 (decimal). If result
 3431/3290 : 70 96 32                              JM	OUTFLT             ;Negative, number is too big to use fixed format.
 3432/3293 : 44 A4 32                              JMP	OUTFIX             ;Else, can use fixed format so skip next routine
 3433/3296 : 36 48                      OUTFLT:    MVI	L, 110o               ;Set pointer to FIXED/FLOAT indicator.
 3434/3298 : 3E 00                                 MVI	M, 000                ;Clear indicator to indicate floating point output format
 3435/329A : 06 B0                                 MVI	A, 260o               ;Load ASCII code for '0' into accumulator
 3436/329C : 46 82 21                              CALL	ECHO               ;Call user display driver to output '0' as first character
 3437/329F : 06 AE                                 MVI	A, 256o               ;Number string. Now load ASCII code for decimal point.
 3438/32A1 : 46 82 21                              CALL	ECHO               ;Call user display driver to output '.'as second character.
 3439/32A4 : 36 57                      OUTFIX:    MVI	L, 127o               ;Set pointer to FPACC Exponent
 3440/32A6 : 06 FF                                 MVI	A, 377o               ;Load accumulator with minus one
 3441/32A8 : 87                                    ADD	M                    ;Add value in FPACC Exponent
 3442/32A9 : F8                                    MOV	M,A                    ;Restore compensated exponent value
 3443/32AA :                            
 3444/32AA :                                                              ;Next portion of routine establishes the value for the
 3445/32AA :                                                              ;decimal exponent that will be outputted by processing
 3446/32AA :                                                              ;the binary exponent value in the FPACC.
 3447/32AA :                            
 3448/32AA : 50 C9 32                   DECEXT:    JP	DECEXD             ;If compensated exponent value is zero or positive
 3449/32AD : 06 04                                 MVI	A, 004                ;Then go multiply FPACC by 0.1 (decimal). Else,
 3450/32AF : 87                                    ADD	M                    ;Add four to the exponent value.
 3451/32B0 : 50 DB 32                              JP	DECOUT             ;If exponent now zero or positive, ready to output
 3452/32B3 : 36 88                                 MVI	L, 210o               ;If exponent negative, multiply FPACC by 10 (decimal)
 3453/32B5 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set pointer to registers holding 10 (dec) in binary
 3454/32B7 : 46 AA 30                              CALL	FACXOP             ;Floating point format. Set up for multiplication.
 3455/32BA : 46 11 2F                              CALL	FPMULT             ;Perform the multiplication. Answer in FPACC.
 3456/32BD : 36 6F                                 MVI	L, 157o               ;Set pointer to decimal exponent storage location.
 3457/32BF : D7                                    MOV	C,M                    ;Each time the FPACC is multiplied by ten, need to
 3458/32C0 : 11                                    DCR	C                    ;Decrement the value in the decinial exponent storage
 3459/32C1 : FA                                    MOV	M,C                    ;Location. (This establishes decimal exponent value!)
 3460/32C2 : 36 57                      DECREP:    MVI	L, 127o               ;Reset pointer to FPACC Exponent
 3461/32C4 : C7                                    MOV	A,M                    ;Fetch value in exponent
 3462/32C5 : A0                                    ANA	A                    ;Test value
 3463/32C6 : 44 AA 32                              JMP	DECEXT             ;Repeat process as required
 3464/32C9 : 36 8C                      DECEXD:    MVI	L, 214o               ;If exponent is positive, multiply FPACC by 0.1
 3465/32CB : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set pointer to registers holding 0.1 dec in binary
 3466/32CD : 46 AA 30                              CALL	FACXOP             ;Floating point format. Set up for multipli(-ation.
 3467/32D0 : 46 11 2F                              CALL	FPMULT             ;Perform the multiplication. Answer in FPACC.
 3468/32D3 : 36 6F                                 MVI	L, 157o               ;Set pointer to decimal exponent storage location.
 3469/32D5 : CF                                    MOV	B,M                    ;Each time the FPACC is multiplied by one tenth, need
 3470/32D6 : 08                                    INR	B                    ;To increment the value in the decimal exponent storage
 3471/32D7 : F9                                    MOV	M,B                    ;Location. (This establishes decimal exponent value!)
 3472/32D8 : 44 C2 32                              JMP	DECREP             ;Repeat process as required
 3473/32DB :                            
 3474/32DB :                                                              ;The next section outputs the mantissa
 3475/32DB :                                                              ;(or fixed point number) by converting the value remaining
 3476/32DB :                                                              ;in the FPACC (after the decimal exponent equivalent has
 3477/32DB :                                                              ;been extracted from the original value if required by the
 3478/32DB :                                                              ;previous routines) to a string of decirnal digits.
 3479/32DB : 26 74                      DECOUT:    MVI	E, 164o               ;Set pointer to LSW of output working register
 3480/32DD : DD                                    MOV	D,H                    ;Set D to same page value as H
 3481/32DE : 36 54                                 MVI	L, 124o               ;Set pointer to LSW of FPACC
 3482/32E0 : 0E 03                                 MVI	B, 003                ;Set precision counter
 3483/32E2 : 46 F6 2E                              CALL	MOVEIT             ;Move value in FPACC to output working register
 3484/32E5 : 36 77                                 MVI	L, 167o               ;Set pointer to MSW plus one of output working register
 3485/32E7 : 3E 00                                 MVI	M, 000                ;Clear that location to 0
 3486/32E9 : 36 74                                 MVI	L, 164o               ;Set pointer to LSW of output working register
 3487/32EB : 0E 03                                 MVI	B, 003                ;Set precision counter
 3488/32ED : 46 6A 30                              CALL	ROTATL             ;Rotate register left once to compensate for sign bit
 3489/32F0 : 46 7E 33                              CALL	OUTX10             ;Multiply output register by 10, overflow into N4SW+ 1
 3490/32F3 : 36 57                      COMPEN:    MVI	L, 127o               ;Set pointer back to FPACC Exponent
 3491/32F5 : CF                                    MOV	B,M                    ;Compensate for any remainder in the binary exponent
 3492/32F6 : 08                                    INR	B                    ;By performing a rotate right on the output working
 3493/32F7 : F9                                    MOV	M,B                    ;Register until the binary exponent becomes zero
 3494/32F8 : 68 05 33                              JZ	OUTDIG             ;Go output decimal digits when this loop is finished
 3495/32FB : 36 77                                 MVI	L, 167o               ;Binary exponent compensating loop. Setpointe'r to
 3496/32FD : 0E 04                                 MVI	B, 004                ;Working register MSW+L. Set precision counter.
 3497/32FF : 46 74 30                              CALL	ROTATR             ;Rotate working register to the right.
 3498/3302 : 44 F3 32                              JMP	COMPEN             ;Repeat loop as required.
 3499/3305 : 36 47                      OUTDIG:    MVI	L, 107o               ;Set pointer to output digit counter storage location
 3500/3307 : 3E 07                                 MVI	M, 007                ;Initialize to value of seven
 3501/3309 : 36 77                                 MVI	L, 167o               ;Change pointer to output working register MSW+L
 3502/330B : C7                                    MOV	A,M                    ;Fetch MSW+L byte containing BCD of digit to be
 3503/330C : A0                                    ANA	A                    ;Displayed. Test the contents of this byte.
 3504/330D : 68 60 33                              JZ	ZERODG             ;If zero jump to ZERODG routine.
 3505/3310 : 36 77                      OUTDGS:    MVI	L, 167o               ;Reset pointer to working register MSW+L
 3506/3312 : C7                                    MOV	A,M                    ;Fetch BCD of digit to be outputted
 3507/3313 : A0                                    ANA	A                    ;Exercise CPU flags
 3508/3314 : 48 30 33                              JNZ	OUTDGX             ;If not zero, go display the digit
 3509/3317 : 36 48                                 MVI	L, 110o               ;If zero, change pointer to FIXED/FLOAT indicator
 3510/3319 : C7                                    MOV	A,M                    ;Fetch the indicator into the accumulator
 3511/331A : A0                                    ANA	A                    ;Test value of indicator
 3512/331B : 68 2F 33                              JZ	OUTZER             ;If in floating point mode, go display the digit
 3513/331E : 36 6F                                 MVI	L, 157o               ;Else change pointer to decimal exponent storage
 3514/3320 : D7                                    MOV	C,M                    ;Location, which, for fixed point, will have a positive
 3515/3321 : 11                                    DCR	C                    ;Value for all digits before the decimal point. Decrement
 3516/3322 : 10                                    INR	C                    ;And increment to exercise flags. See if count is positive.
 3517/3323 : 50 2F 33                              JP	OUTZER             ;If positive, must display any zero digit.
 3518/3326 : 36 76                                 MVI	L, 166o               ;If not, change pointer to MSW of working register
 3519/3328 : C7                                    MOV	A,M                    ;And test to see if any significant digits coming up
 3520/3329 : 24 E0                                 ANI	340o               ;By forming a mask and testing for presence of bits
 3521/332B : 48 2F 33                              JNZ	OUTZER             ;If more significant digits coming up soon, display the
 3522/332E : 07                                    RET                    ;Zero digit. Else, exit to calling routine. Finished.
 3523/332F : A8                         OUTZER:    XRA	A                    ;Clear the accumulator to restore zero digit value
 3524/3330 : 04 B0                      OUTDGX:    ADI	260o               ;Add 260 (octal) to BCD code in ACC to form ASCII
 3525/3332 : 46 82 21                              CALL	ECHO               ;Code and call the user's display driver subroutine
 3526/3335 : 36 48                      DECRDG:    MVI	L, 110o               ;Set pointer to FIXED/FLOAT indicator storage
 3527/3337 : C7                                    MOV	A,M                    ;Fetch the indicator to the accumulator
 3528/3338 : A0                                    ANA	A                    ;Exercise the CPU flags
 3529/3339 : 48 4A 33                              JNZ	CKDECP             ;If indicator non-zero, doing fixed point output
 3530/333C : 36 47                                 MVI	L, 107o               ;Else, get output digit counter
 3531/333E : D7                                    MOV	C,M
 3532/333F : 11                                    DCR	C                    ;Decrement the digit counter & restore to storage
 3533/3340 : FA                                    MOV	M,C
 3534/3341 : 68 AB 33                              JZ	EXPOUT             ;When digit counter is zero, go take care of exponent
 3535/3344 : 46 7E 33                   PUSHIT:    CALL	OUTX10             ;Else push next BCD digit out of working register
 3536/3347 : 44 10 33                              JMP	OUTDGS             ;And continue the outputting process
 3537/334A : 36 6F                      CKDECP:    MVI	L, 157o               ;For fixed point output, decimal exponent serves as
 3538/334C : D7                                    MOV	C,M                    ;Counter for number of digits before decimal point
 3539/334D : 11                                    DCR	C                    ;Fetch the counter and decrement it to account for
 3540/334E : FA                                    MOV	M,C                    ;Current digit being processed. Restore to storage.
 3541/334F : 48 57 33                              JNZ	NODECP             ;If count does not go to zero, jump ahead.
 3542/3352 : 06 AE                                 MVI	A, 256o               ;When count reaches zero, load ASCII code for period
 3543/3354 : 46 82 21                              CALL	ECHO               ;And call user's display driver to display decimal point
 3544/3357 : 36 47                      NODECP:    MVI	L, 107o               ;Set pointer to output digit counter storage location
 3545/3359 : D7                                    MOV	C,M                    ;Fetch the digit counter
 3546/335A : 11                                    DCR	C                    ;Decrement the value
 3547/335B : FA                                    MOV	M,C                    ;Restore to storage
 3548/335C : 2B                                    RZ                    ;If counter reaches zero, exit to caller. Finished.
 3549/335D : 44 44 33                              JMP	PUSHIT             ;Else continue to output the number.
 3550/3360 : 36 6F                      ZERODG:    MVI	L, 157o               ;If first digit of floating point number is a zero, set
 3551/3362 : D7                                    MOV	C,M                    ;Pointer to decimal exponent storage location.
 3552/3363 : 11                                    DCR	C                    ;Decrement the value to compensate for skipping
 3553/3364 : FA                                    MOV	M,C                    ;Display of first digit. Restore to storage.
 3554/3365 : 36 76                                 MVI	L, 166o               ;Change pointer to MSW of output working register
 3555/3367 : C7                                    MOV	A,M                    ;Fetch MSW of output working register
 3556/3368 : A0                                    ANA	A                    ;Test the contents
 3557/3369 : 48 35 33                              JNZ	DECRDG             ;If non-zero, continue outputting
 3558/336C : 31                                    DCR	L                    ;Else decrement pointer to next byte in working register
 3559/336D : C7                                    MOV	A,M                    ;Fetch its contents
 3560/336E : A0                                    ANA	A                    ;Test
 3561/336F : 48 35 33                              JNZ	DECRDG             ;If non-zero, continue outputting
 3562/3372 : 31                                    DCR	L                    ;Else decrement pointer to LSW of working register
 3563/3373 : C7                                    MOV	A,M                    ;Fetch its contents
 3564/3374 : A0                                    ANA	A                    ;Test
 3565/3375 : 48 35 33                              JNZ	DECRDG             ;If non-zero, continue outputting
 3566/3378 : 36 6F                                 MVI	L, 157o               ;If decimal mantissa is zero, set pointer to decirnal
 3567/337A : F8                                    MOV	M,A                    ;Exponent storage and clear it
 3568/337B : 44 35 33                              JMP	DECRDG             ;Finish outputting
 3569/337E :                            
 3570/337E :                                                              ;Following routine multiplies the binary number in the
 3571/337E :                                                              ;output working register by ten to push the most signifi-
 3572/337E :                                                              ;cant digit out to the MSW+L byte.
 3573/337E :                            
 3574/337E : 36 77                      OUTX10:    MVI	L, 167o               ;Set pointer to work ing register M SW+ 1
 3575/3380 : 3E 00                                 MVI	M, 000                ;Clear it in preparation for receiving next digit pushed
 3576/3382 : 36 74                                 MVI	L, 164o               ;Into it. Change pointer to working register LSW.
 3577/3384 : DD                                    MOV	D,H                    ;Set up register D to same page as H.
 3578/3385 : 26 70                                 MVI	E, 160o               ;Set second pointer to LSW of second working register
 3579/3387 : 0E 04                                 MVI	B, 004                ;Set precision counter
 3580/3389 : 46 F6 2E                              CALL	MOVEIT             ;Move first working register into second
 3581/338C : 36 74                                 MVI	L, 164o               ;Reset pointer to LSW of first working register
 3582/338E : 0E 04                                 MVI	B, 004                ;Set precision counter
 3583/3390 : 46 6A 30                              CALL	ROTATL             ;Rotate contents of first working register left (X 2)
 3584/3393 : 36 74                                 MVI	L, 164o               ;Reset pointer to LSW
 3585/3395 : 0E 04                                 MVI	B, 004                ;Reset precision counter
 3586/3397 : 46 6A 30                              CALL	ROTATL             ;Rotate contents left again (X 4)
 3587/339A : 36 70                                 MVI	L, 160o               ;Set pointer to LSW of original value in 2'nd register
 3588/339C : 26 74                                 MVI	E, 164o               ;Set pointer to LSW of rotated value
 3589/339E : 0E 04                                 MVI	B, 004                ;Set precision counter
 3590/33A0 : 46 42 30                              CALL	ADDER              ;Add rotated value to original value (X 5)
 3591/33A3 : 36 74                                 MVI	L, 164o               ;Reset pointer to LSW of first working register
 3592/33A5 : 0E 04                                 MVI	B, 004                ;Set precision counter
 3593/33A7 : 46 6A 30                              CALL	ROTATL             ;Rotate contents left again (X 10)
 3594/33AA : 07                                    RET                    ;Exit to calling routine
 3595/33AB :                            
 3596/33AB :                                                              ;The final group of routines in the floating point output
 3597/33AB :                                                              ;section take care of outputting the decimal exponent
 3598/33AB :                                                              ;portion of floating point numbers.
 3599/33AB :                            
 3600/33AB : 36 6F                      EXPOUT:    MVI	L, 157o               ;Set pointer to decimal exponent storage location
 3601/33AD : C7                                    MOV	A,M                    ;Fetch value to the accumulator
 3602/33AE : A0                                    ANA	A                    ;Test the value
 3603/33AF : 2B                                    RZ                    ;If zero, then no exponent portion. Exit to CALLler.
 3604/33B0 : 06 C5                                 MVI	A, 305o               ;Else, load ACC with ASCII code for letter E.
 3605/33B2 : 46 82 21                              CALL	ECHO               ;Display E for Exponent via user's display driver rtn
 3606/33B5 : C7                                    MOV	A,M                    ;Get decimal exponent value back into ACC
 3607/33B6 : A0                                    ANA	A                    ;Test again
 3608/33B7 : 70 BF 33                              JM	EXOUTN             ;If value is negative, skip ahead
 3609/33BA : 06 AB                                 MVI	A, 253o               ;If positive, load ASCII code for + sign
 3610/33BC : 44 C6 33                              JMP	AHEAD2             ;Jump to display the + sign
 3611/33BF : 2C FF                      EXOUTN:    XRI	377o               ;When decimal exponent is negative, must negate
 3612/33C1 : 04 01                                 ADI	001                ;Value for display purposes. Perform two's complement
 3613/33C3 : F8                                    MOV	M,A                    ;And restore the negated value to storage location
 3614/33C4 : 06 AD                                 MVI	A, 255o               ;Load ASCII code for minus sign
 3615/33C6 : 46 82 21                   AHEAD2:    CALL	ECHO               ;Display the ASCII character in ACC
 3616/33C9 : 0E 00                                 MVI	B, 000                ;Clear register B
 3617/33CB : C7                                    MOV	A,M                    ;Fetch the decimal exponent value back into ACC
 3618/33CC : 14 0A                      SUB12:     SUI	012o               ;Subtract 10 (decimal) from value in ACC
 3619/33CE : 70 D6 33                              JM	TOMUCH             ;Break out of loop when accumulator goes negative
 3620/33D1 : F8                                    MOV	M,A                    ;Else restore value to storage location
 3621/33D2 : 08                                    INR	B                    ;Increment register B as a counter
 3622/33D3 : 44 CC 33                              JMP	SUB12              ;Repeat loop to form tens value of decimal exponent
 3623/33D6 : 06 B0                      TOMUCH:    MVI	A, 260o               ;Load base ASCII value for digit into the accumulator
 3624/33D8 : 81                                    ADD	B                    ;Add to the count in B to forin tens digit of decimal
 3625/33D9 : 46 82 21                              CALL	ECHO               ;Exponent. Display via user's driver subroutine
 3626/33DC : C7                                    MOV	A,M                    ;Fetch remainder of decimal exponent value
 3627/33DD : 04 B0                                 ADI	260o               ;Add in ASCII base value to form final digit
 3628/33DF : 46 82 21                              CALL	ECHO               ;Display second digit of decirnal exponent
 3629/33E2 : 07                                    RET                    ;Finished outputting. Return to caller.
 3630/33E3 :                            ;;; The above RETURN SHOULD BE AT 25 367 15f7h
 3631/33E3 :                            
 3632/33E3 :                            ;;; NOW OPEN AREA UP TO 26 000 CAN BE USED FOR PATCHING...
 3633/33E3 :                            
 3634/33E3 :                            	;; THERE ARE NOW ADDRESSES AT START OF PAGE 30, NOT ASSIGNED;
 3635/33E3 :                            
 3636/33E3 :                            ;          ORG 	180bh	;030#013
 3637/33E3 : 36 64                      NEXT:      MVI	L, 144o               ;Load L with start of AUX SYMBOL BUFFER
 3638/33E5 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of AUX SYMBOL BUFFER
 3639/33E7 : 3E 00                                 MVI	M, 000                ;Initialize AUX SYMBOL BUFFER by clearing first byte
 3640/33E9 : 36 82                                 MVI	L, 202o               ;Change L to address of SCAN pointer
 3641/33EB : CF                                    MOV	B,M                    ;Fetch pointer value to CPU register B
 3642/33EC : 08                                    INR	B                    ;Add one to the current pointer value
 3643/33ED : 36 81                                 MVI	L, 201o               ;Load L with address of NEXT pointer storage location
 3644/33EF : F9                                    MOV	M,B                    ;Place the updated SCAN pointer as the NEXT pointer
 3645/33F0 : 36 81                      NEXT1:     MVI	L, 201o               ;Reset L to address of NEXT pointer storage location
 3646/33F2 : 46 A0 20                              CALL	GETCHR             ;Fetch the character pointed to by the NEXT pointer
 3647/33F5 : 68 FD 33                              JZ	NEXT2              ;If the character is a space, ignore it
 3648/33F8 : 36 64                                 MVI	L, 144o               ;Else, load L with start of AUX SYMBOL BUFFER
 3649/33FA : 46 CC 20                              CALL	CONCT1             ;Concatenate the character onto the AUX SYMBOL BF
 3650/33FD : 36 81                      NEXT2:     MVI	L, 201o               ;Reset L to address of NEXT pointer storage location
 3651/33FF : 46 03 21                              CALL	LOOP               ;Advance the NEXT pointer and see if end of line
 3652/3402 : 48 F0 33                              JNZ	NEXT1              ;Fetch next character in line if not end of line
 3653/3405 : 36 64                                 MVI	L, 144o               ;When reach end of line, should have variable name
 3654/3407 : C7                                    MOV	A,M                    ;In the AUX SYMBOL BUFFER. Fetch the (cc) for
 3655/3408 : 3C 01                                 CPI	001                ;The buffer and see if variable name is just one letter
 3656/340A : 48 11 34                              JNZ	NEXT3              ;If more than one proceed directly to look for name
 3657/340D : 36 66                                 MVI	L, 146o               ;In FOR/NEXT STACK. If have just a one letter name
 3658/340F : 3E 00                                 MVI	M, 000                ;Then set second character in buffer to zero
 3659/3411 : 36 85                      NEXT3:     MVI	L, 205o               ;Load L with address of FOR/NEXT STACK pointer
 3660/3413 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to page of FOR/NEXT STACK pointer
 3661/3415 : C7                                    MOV	A,M                    ;Fetch the FOR/NEXT STACK pointer value to ACC
 3662/3416 : 02                                    RLC                    ;Rotate value left to multiply by two. Then rotate it
 3663/3417 : 02                                    RLC                    ;Left again to multiply by four. Add base address plus
 3664/3418 : 04 5E                                 ADI	136o               ;Two to form pointer to variable name in top of stack
 3665/341A : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to page of FOR/NEXT STACK
 3666/341C : F0                                    MOV	L,A                    ;Move pointer value from ACC to CPU register L
 3667/341D : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Set register D to page of AUX SYMBOL BUFFER
 3668/341F : 26 65                                 MVI	E, 145o               ;Set register E to first character in the buffer
 3669/3421 : 0E 02                                 MVI	B, 002                ;Set B to serve as a character counter
 3670/3423 : 46 F8 20                              CALL	STRCPC             ;See if variable name in the NEXT statement same as
 3671/3426 : 68 30 34                              JZ	NEXT4              ;That stored in the top of the FOR/NEXT STACK
 3672/3429 : 06 C6                      FORNXT:    MVI	A, 306o               ;Load ACC with ASCII code for letter F
 3673/342B : 16 CE                                 MVI	C, 316o               ;Load register C with ASCII code for letter N
 3674/342D : 44 96 20                              JMP	ERROR              ;Display For/Next (FN) error message if required
 3675/3430 : 36 F0                      NEXT4:     MVI	L, 360o               ;Load L with address of user program line pointer
 3676/3432 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of user pgm line pntr storage loc.
 3677/3434 : DF                                    MOV	D,M                    ;Fetch the page portion of the line pointer into D
 3678/3435 : 30                                    INR	L                    ;Advance the memory pointer
 3679/3436 : E7                                    MOV	E,M                    ;Fetch the low portion of the line pointer into E
 3680/3437 : 30                                    INR	L                    ;Advance pntr to AUXILIARY LINE POINTER storage
 3681/3438 : FB                                    MOV	M,D                    ;Location and store value of line pointer there too (page)
 3682/3439 : 30                                    INR	L                    ;Advance pointer to second byte of AUXILIARY line
 3683/343A : FC                                    MOV	M,E                    ;Pointer and store value of line pointer (low portion)
 3684/343B : 36 85                                 MVI	L, 205o               ;Load L with address of FOR/NEXT STACK pointer
 3685/343D : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to page of FOR/NEXT STACK pointer
 3686/343F : C7                                    MOV	A,M                    ;Fetch the FOR/NEXT STACK pointer value to ACC
 3687/3440 : 02                                    RLC                    ;Rotate value left to multiply by two. Then rotate it
 3688/3441 : 02                                    RLC                    ;Left again to multiply by four. Add base address to
 3689/3442 : 04 5C                                 ADI	134o               ;Form pointer to top of FOR/NEXT STACK and place
 3690/3444 : F0                                    MOV	L,A                    ;The pointer value into CPU register L. Fetch the page
 3691/3445 : DF                                    MOV	D,M                    ;Address of the associated FOR statement line pointer
 3692/3446 : 30                                    INR	L                    ;Into register D. Advance the pointer and fetch the low
 3693/3447 : E7                                    MOV	E,M                    ;Address value into register E. Prepare to change user
 3694/3448 : 36 F0                                 MVI	L, 360o               ;Program line pointer to the FOR statement line by
 3695/344A : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Setting H & L to the user pgrn line pntr storage loc.
 3696/344C : FB                                    MOV	M,D                    ;Place the page value in the pointer storage location
 3697/344D : 30                                    INR	L                    ;Advance the memory pointer
 3698/344E : FC                                    MOV	M,E                    ;Place the low value in the pointer storage location
 3699/344F : EB                                    MOV	H,D                    ;Now set up H and L to point to the start of the
 3700/3450 : F4                                    MOV	L,E                    ;Associated FOR statement line in the user pgm buffer
 3701/3451 : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Change D to point to the line input buffer
 3702/3453 : 26 00                                 MVI	E, 000                ;And set L to the gtart of the line input buffer
 3703/3455 : 46 0F 28                              CALL	MOVEC              ;Move the associated FOR statement line into the input
 3704/3458 : 36 D5                                 MVI	L, 325o               ;Line buffer. Set L to point to start of TO string which is
 3705/345A : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Stored in a text strings storage area on this page
 3706/345C : 46 F9 28                              CALL	INSTR              ;Search the statement line for the occurrence of TO
 3707/345F : C4                                    MOV	A,E                    ;Register E will be zero if TO not found. Move E to ACC
 3708/3460 : A0                                    ANA	A                    ;To make a test. If TO found then proceed to set up for
 3709/3461 : 68 29 34                              JZ	FORNXT             ;Evaluation. If TO not found, then have error condition.
 3710/3464 : 04 02                                 ADI	002                ;Advance the pointer over the characters in TO string
 3711/3466 : 36 BE                                 MVI	L, 276o               ;Change L to point to EVAL pointer storage location
 3712/3468 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of EVAL pointer. Set up the starting
 3713/346A : F8                                    MOV	M,A                    ;Position for the EVAL subroutine (after TO string)
 3714/346B : 36 D8                                 MVI	L, 330o               ;Set L to point to start of STEP string which is stored
 3715/346D : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** In text stxings storage area on this page. Search the
 3716/346F : 46 F9 28                              CALL	INSTR              ;Statement line for the occurrence of STEP
 3717/3472 : C4                                    MOV	A,E                    ;Register E will be zero if STEP not found. Move E to
 3718/3473 : A0                                    ANA	A                    ;The accumulator to make a test. If STEP found must
 3719/3474 : 48 98 34                              JNZ	NEXT5              ;Evaluate expression after STEP to get STEP SIZE.
 3720/3477 : 36 04                                 MVI	L, 004                ;Else, have an IMPLIED STEP SIZE of 1.0. Set pointer
 3721/3479 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** To start of storage area for 1.0 in floating point
 3722/347B : 46 8F 30                              CALL	FLOAD              ;Format and call subroutine to load FPACC with 1.0
 3723/347E : 36 C4                                 MVI	L, 304o               ;Set L to start of FOR/NEXT STEP SIZE storage loc.
 3724/3480 : 46 98 30                              CALL	FSTORE             ;Store the value 1.0 in the F/N STEP SIZE registers
 3725/3483 : 36 00                                 MVI	L, 000                ;Change L to the start of the input line buffer
 3726/3485 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to the page of the input line buffer
 3727/3487 : CF                                    MOV	B,M                    ;Fetch the (cc) into CPU register B (length of FOR line)
 3728/3488 : 36 BF                                 MVI	L, 277o               ;Change L to EVAL FINISH pointer stomge location
 3729/348A : F9                                    MOV	M,B                    ;Set the EVAL FINISH pointer to the end of the line
 3730/348B : 46 94 21                              CALL	EVAL               ;Evaluate the LIMIT expression to obtain FOR LIMIT
 3731/348E : 36 C8                                 MVI	L, 310o               ;Load L with address of start of F/N LIMIT registers
 3732/3490 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with page of FOR/NEXT LIMIT registers
 3733/3492 : 46 98 30                              CALL	FSTORE  ;MGA 3/31/12 no lab here Store the FOR/NEXT LIMIT value
 3734/3495 : 44 C1 34                              JMP	NEXT6              ;Since have IMPLIED STEP jump ahead
 3735/3498 : 21                         NEXT5:     DCR	E  ;MGA 3/21/12 lab here When have STEP directive, subtract one from pointer
 3736/3499 : 36 BF                                 MVI	L, 277o               ;To get to character before S in STEP. Save this value in
 3737/349B : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** The EVAL FINISH pointer stomge location to serve
 3738/349D : FC                                    MOV	M,E                    ;As evaluation end location when obtaining TO Iiinit
 3739/349E : 46 94 21                              CALL	EVAL               ;Evaluate the LIMIT expression to obtain FOR LIMIT
 3740/34A1 : 36 C8                                 MVI	L, 310o               ;Load L with address of start of FIN LIMIT registers
 3741/34A3 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with page of FORINEXT LIMIT registers
 3742/34A5 : 46 98 30                              CALL	FSTORE             ;Store the FOR/NEXT LIMIT value
 3743/34A8 : 36 BF                                 MVI	L, 277o               ;Reset L to EVAL FINISH pointer storage location
 3744/34AA : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of EVAL FINISH pointer storage loc.
 3745/34AC : C7                                    MOV	A,M                    ;Fetch the pointer value (character before S in STEP)
 3746/34AD : 04 05                                 ADI	005                ;Add five to change pointer to character after P in STEP
 3747/34AF : 31                                    DCR	L                    ;Decrement L to point to EVAL (start) pointer
 3748/34B0 : F8                                    MOV	M,A                    ;Set up the starting position for the EVAL subroutine
 3749/34B1 : 36 00                                 MVI	L, 000                ; Load L with starting address of the line input buffer
 3750/34B3 : CF                                    MOV	B,M                    ;Fetch the (cc) for the line input buffer (line length)
 3751/34B4 : 36 BF                                 MVI	L, 277o               ;Change L to the EVAL FINISH storage location
 3752/34B6 : F9                                    MOV	M,B                    ;Set the EVAL FINISH pointer
 3753/34B7 : 46 94 21                              CALL	EVAL               ;Evaluate the STEP SIZE expression
 3754/34BA : 36 C4                                 MVI	L, 304o               ;Load L with address of start of F/N STEP registers
 3755/34BC : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of FIN STEP registers
 3756/34BE : 46 98 30                              CALL	FSTORE             ;Store the FOR/NEXT STEP SIZE value
 3757/34C1 : 36 64                      NEXT6:     MVI	L, 144o               ;Load L with address of AUX SYMBOL BUFFER
 3758/34C3 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of the AUX SYMBOL BUFFER
 3759/34C5 : 3E 00                                 MVI	M, 000                ;Initialize AUX SUMBOL BUFFER with a zero byte
 3760/34C7 : 36 1C                                 MVI	L, 034o               ;Set L to start of FOR string which is stored in the
 3761/34C9 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** KEYWORD look-up table on this page
 3762/34CB : 46 F9 28                              CALL	INSTR              ;Search the statement line for the FOR directive
 3763/34CE : C4                                    MOV	A,E                    ;Register E will be zero if FOR not found. Move E to
 3764/34CF : A0                                    ANA	A                    ;ACC and -make test to see if FOR directive located
 3765/34D0 : 36 82                                 MVI	L, 202o               ;Load L with address of SCAN pointer
 3766/34D2 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of SCAN pointer
 3767/34D4 : F8                                    MOV	M,A                    ;Set up pointer to occurrence of FOR directive in line
 3768/34D5 : 68 29 34                              JZ	FORNXT             ;If FOR not found, have an error condition
 3769/34D8 : 04 03                                 ADI	003                ;If have FOR, add three to advance pointer over FOR
 3770/34DA : 36 83                                 MVI	L, 203o               ;Set L to point to F/N pointer storage location
 3771/34DC : F8                                    MOV	M,A                    ;Set F/N pointer to character after FOR directive
 3772/34DD : 36 83                      NEXT7:     MVI	L, 203o               ;Set L to point to FIN pointer storage location
 3773/34DF : 46 A0 20                              CALL	GETCHR             ;Fetch a character from position pointed to by FIN pntr
 3774/34E2 : 68 EF 34                              JZ	NEXT8              ;If character is a space, ignore it
 3775/34E5 : 3C BD                                 CPI	275o               ;Else, test to see if character is "=" sign
 3776/34E7 : 68 FA 34                              JZ	NEXT9              ;If yes, have picked up variable name, jump ahead
 3777/34EA : 36 64                                 MVI	L, 144o               ;If not, set L to the start of the AUX SYMBOL BUFFER
 3778/34EC : 46 CC 20                              CALL	CONCT1             ;And store the character in the AUX SYMBOL BUFFER
 3779/34EF : 36 83                      NEXT8:     MVI	L, 203o               ;Load L with address of the F/N pointer
 3780/34F1 : 46 03 21                              CALL	LOOP               ;Increment the pointer and see if end of the line
 3781/34F4 : 48 DD 34                              JNZ	NEXT7              ;If not, continue fetching characters
 3782/34F7 : 44 29 34                              JMP	FORNXT             ;If end of line before "=" sign then have error condx
 3783/34FA : 36 82                      NEXT9:     MVI	L, 202o               ;Load L with address of SCAN pointer
 3784/34FC : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of SCAN pointer
 3785/34FE : C7                                    MOV	A,M                    ;Fetch pointer value to ACC (points to start of FOR
 3786/34FF : 04 03                                 ADI	003                ;Directive) and add three to move pointer over FOR
 3787/3501 : 36 BE                                 MVI	L, 276o               ;Directive. Change L to EVAL pointer storage location
 3788/3503 : F8                                    MOV	M,A                    ;Set EVAL pointer to character after FOR in line
 3789/3504 : 36 83                                 MVI	L, 203o               ;Load L with address of FIN pointer storage location
 3790/3506 : CF                                    MOV	B,M                    ;Fetch pointer to register B (points to "=" sign) and
 3791/3507 : 09                                    DCR	B                    ;Decrement the pointer (to character before "=" sign)
 3792/3508 : 36 BF                                 MVI	L, 277o               ;Load L with address of EVAL FINISH pointer
 3793/350A : F9                                    MOV	M,B                    ;Set EVAL FINISH pointer
 3794/350B : 46 94 21                              CALL	EVAL               ;Call subroutine to obtain current value of the variable
 3795/350E : 36 C4                                 MVI	L, 304o               ;Load L with address of start of F/N STEP registers
 3796/3510 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of F/N STEP registers
 3797/3512 : 46 AA 30                              CALL	FACXOP             ;Call subroutine to set up FP registers for addition
 3798/3515 : 46 70 2E                              CALL	FPADD              ;Add FIN STEP size to current VARIABLE value
 3799/3518 : 36 CC                                 MVI	L, 314o               ;Load L with address of FIN TEMP storage registers
 3800/351A : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;**Set H to page of FIN TEMP storage registers
 3801/351C : 46 98 30                              CALL	FSTORE             ;Save the result of the addition in F/N TEMP registers
 3802/351F : 36 C8                                 MVI	L, 310o               ;Load L with starting address of F/N LIMIT registers
 3803/3521 : 46 AA 30                              CALL	FACXOP             ;Call subroutine to set up FP registers for subtraction
 3804/3524 : 46 05 2F                              CALL	FPSUB              ;Subtract F/N LIMIT value from VARIABLE value
 3805/3527 : 36 C6                                 MVI	L, 306o               ;Set pointer to MSW of F/N STEP registers
 3806/3529 : C7                                    MOV	A,M                    ;Fetch this value into the ACC
 3807/352A : A0                                    ANA	A                    ;Test to see if STEP value might be zero
 3808/352B : 36 56                                 MVI	L, 126o               ;Load L with address of MSW of FPACC
 3809/352D : C7                                    MOV	A,M                    ;Fetch this value into the ACC
 3810/352E : 68 29 34                              JZ	FORNXT             ;If STEP size was zero, then endless loop, an error condx
 3811/3531 : 70 50 35                              JM	NEXT11             ;If STEP size less than zero make alternate test on limit
 3812/3534 : A0                                    ANA	A                    ;Test the contents of the MSW of the FPACC
 3813/3535 : 70 57 35                              JM	NEXT12             ;Continue FORINEXT loop if current variable value is
 3814/3538 : 68 57 35                              JZ	NEXT12             ;Less than or equal to the F/N LIMIT value
 3815/353B : 36 F3                      NEXT10:    MVI	L, 363o               ;If out of LIMIT range, load L with address of the AUX
 3816/353D : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** PGM LINE pointer. (Contains pointer to the NEXT
 3817/353F : E7                                    MOV	E,M                    ;Statement line that initiated this routine.) Fetch the
 3818/3540 : 31                                    DCR	L                    ;Low part of the address into E, decrement the memory
 3819/3541 : DF                                    MOV	D,M                    ;And get the page part of the address into CPU register
 3820/3542 : 31                                    DCR	L                    ;Decrement memory pointer to the low portion of the
 3821/3543 : FC                                    MOV	M,E                    ;User pgm buffer line pointer (regular pointer) and set it
 3822/3544 : 31                                    DCR	L                    ;With the value from the AUX line pntr, decrement the
 3823/3545 : FB                                    MOV	M,D                    ;Pointer and do the same for the page portion
 3824/3546 : 36 85                                 MVI	L, 205o               ;Set L to address of FOR/NEXT STACK pointer
 3825/3548 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to page of FOR/NEXT STACK pointer
 3826/354A : CF                                    MOV	B,M                    ;Fetch and decrement the
 3827/354B : 09                                    DCR	B                    ;FOR/NEXT STACK pointer value
 3828/354C : F9                                    MOV	M,B                    ;To perform effective popping operation
 3829/354D : 44 3D 29                              JMP	NXTLIN             ;Statement line after NEXT statement is done next
 3830/3550 : A0                         NEXT11:    ANA	A                    ;When F/N STEP is negative, reverse test so that if the
 3831/3551 : 50 57 35                              JP	NEXT12             ;Variable value is greater than or equal to the F/N LIMIT
 3832/3554 : 44 3B 35                              JMP	NEXT10             ;The FOR/NEXT loop continues. Else it is finished.
 3833/3557 : 36 CC                      NEXT12:    MVI	L, 314o               ;Load L with address of FIN TEMP storage registers
 3834/3559 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to FIN TEMP storage registers page
 3835/355B : 46 8F 30                              CALL	FLOAD              ;Transfer the updated variable value to the FPACC
 3836/355E : 46 AA 26                              CALL	RESTSY             ;Restore the variable name and value
 3837/3561 : 46 2D 26                              CALL	STOSYM             ;In the VARIABLES table. Exit routine so that
 3838/3564 : 44 3D 29                              JMP	NXTLIN             ;Statement line after FOR statement is done next
 3839/3567 :                            
 3840/3567 :                            ;;; The label BACKSP SHOULD BE AT 31 217 198fh
 3841/3567 :                            
 3842/3567 : 06 8D                      BACKSP:    MVI	A, 215o               ;Load ASCII code for carriage-return into the ACC
 3843/3569 : 46 82 21                              CALL	ECHO               ;Display the carriage-return
 3844/356C : 46 82 21                              CALL	ECHO               ;Repeat to provide extra time if TTY
 3845/356F : 36 23                                 MVI	L, 043o               ;Load L with address of COLUMN COUNTER
 3846/3571 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of COLUMN COUNTER
 3847/3573 : 3E 01                                 MVI	M, 001                ;Set COLUMN COUNTER to first column
 3848/3575 : 36 54                                 MVI	L, 124o               ;Set L to address containing desired TAB position
 3849/3577 : C7                                    MOV	A,M                    ;Fetch the desired TAB position value
 3850/3578 : A0                                    ANA	A                    ;Test to see if it is
 3851/3579 : 33                                    RM                    ;Negative or zero
 3852/357A : 2B                                    RZ                    ;In which case return to caller
 3853/357B : 44 12 26                              JMP	TAB1               ;Else, proceed to perform the TAB operation.
 3854/357E :                            
 3855/357E :                            	
 3856/357E :                            ;;; The label FOR5 SHOULD START AT 31 246 19a6h
 3857/357E :                            	
 3858/357E : 36 85                      FOR5:      MVI	L, 205o               ;Load L with address of the FOR/NEXT STACK pointer
 3859/3580 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Load H with page of the FOR/NEXT STACK pntr
 3860/3582 : C7                                    MOV	A,M                    ;Fetch the stack pointer to the ACC.
 3861/3583 : 02                                    RLC                    ;Rotate it left to multiply by two, then rotate it again to
 3862/3584 : 02                                    RLC                    ;Multiply by four. Add this value to the base address
 3863/3585 : 04 5E                                 ADI	136o               ;Plus two of the base address to point to the next part of
 3864/3587 : E0                                    MOV	E,A                    ;The FOR/NEXT STACK. Place this value in register E.
 3865/3588 : DD                                    MOV	D,H                    ;Set D to the FORINEXT STACK area page.
 3866/3589 : 36 65                                 MVI	L, 145o               ;Load L with the address of the first character in the
 3867/358B : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** AUX SYMBOL BUFFER and set up H to this page.
 3868/358D : 0E 02                                 MVI	B, 002                ;Set up register B as a number of bytes to move counter.
 3869/358F : 46 F6 2E                              CALL	MOVEIT             ;Move the variable name into the FOR/NEXT STACK.
 3870/3592 : 46 2D 26                              CALL	STOSYM             ;Store initial variable value in the VARIABLES TABLE.
 3871/3595 : 44 3D 29                              JMP	NXTLIN             ;Continue with next line in user program buffer.
 3872/3598 :                            
 3873/3598 :                            
 3874/3598 :                            ;;; The label PARSEP SHOULD START AT 31 300 19c0h
 3875/3598 : 36 7E                      PARSEP:    MVI	L, 176o               ;Load L with PARSER TOKEN storage location. Set
 3876/359A : 3E 00                                 MVI	M, 000                ;The value indicating end of expression. Call the
 3877/359C : 46 D4 22                              CALL	PARSER             ;PARSER subroutine for final time for the expression.
 3878/359F : 36 97                                 MVI	L, 227o               ;Change L to point to the ARITH STACK pointer.
 3879/35A1 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to the page of the ARITH STACK pointer.
 3880/35A3 : C7                                    MOV	A,M                    ;Fetch the ARITH STACK pointer value.
 3881/35A4 : 3C 98                                 CPI	230o               ;Should indicate only one value (answer) in stack.
 3882/35A6 : 2B                                    RZ                    ;Exit with answer in FPACC if ARITH STACK is O.K.
 3883/35A7 : 44 6A 27                              JMP	SYNERR             ;Else have a syntax error!
 3884/35AA :                            
 3885/35AA :                            ;;; THERE IS SOME BLANK ADDRESSES HERE 317-NEXT PAGE
 3886/35AA :                            
 3887/35AA :                            ;          ORG	1a00h	; 032#000
 3888/35AA : 36 0C                      SQRX:      MVI	L, 014o               ;Load L with address of FP TEMP registers
 3889/35AC : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of FP TEMP. Move contents of FPACC
 3890/35AE : 46 98 30                              CALL	FSTORE             ;[Argument of SQR(X)] into FP TEMP for storage.
 3891/35B1 : 36 56                                 MVI	L, 126o               ;Load L with MSW of FPACC
 3892/35B3 : C7                                    MOV	A,M                    ;Fetch the MSW into the accumulator
 3893/35B4 : A0                                    ANA	A                    ;Check the sign of the number in the FPACC
 3894/35B5 : 70 3F 36                              JM	SQRERR             ;If number negative, cannot take square root
 3895/35B8 : 68 A7 24                              JZ	CFALSE             ;If number is zero, return with zero value in FPACC
 3896/35BB : 36 0F                                 MVI	L, 017o               ;Load L with address of FP TEMP Exponent register
 3897/35BD : C7                                    MOV	A,M                    ;Fetch the Exponent value into the ACC
 3898/35BE : A0                                    ANA	A                    ;Check sign of the Fxponent
 3899/35BF : 70 CB 35                              JM	NEGEXP             ;If Exponent less than zero, process negative Exponent
 3900/35C2 : 1A                                    RAR                    ;If Exponent positive, rotate right to divide by two
 3901/35C3 : C8                                    MOV	B,A                    ;And save the result in CPU register B
 3902/35C4 : 06 00                                 MVI	A, 000                ;Clear the accumulator without disturbing Carry bit
 3903/35C6 : 12                                    RAL                    ;Rotate Carry bit into the ACC to save remainder
 3904/35C7 : F8                                    MOV	M,A                    ;Store the remainder back in FP TEMP Exponent reg.
 3905/35C8 : 44 DC 35                              JMP	SQREXP             ;Jump to continue processing
 3906/35CB : C8                         NEGEXP:    MOV	B,A                    ;For negative Exponent, form two Is complement by
 3907/35CC : A8                                    XRA	A                    ;Placing the positive value in CPU register B, clearing
 3908/35CD : 91                                    SUB	B                    ;The accumulator, and then subtracting B from the ACC
 3909/35CE : A0                                    ANA	A                    ;Clear the Carry bit after the complementing operation
 3910/35CF : 1A                                    RAR                    ;Rotate the value right to divide by two
 3911/35D0 : C8                                    MOV	B,A                    ;Save the result in CPU register B
 3912/35D1 : 06 00                                 MVI	A, 000                ;Clear the accumulator without disturbing Carry bit
 3913/35D3 : 88                                    ADC	A                    ;Add Carry bit to the accumulator as remainder
 3914/35D4 : F8                                    MOV	M,A                    ;Store the remainder back in FP TEMP Exponent reg
 3915/35D5 : 68 D9 35                              JZ	NOREMD             ;If remainder was zero skip ahead. If not, increment the
 3916/35D8 : 08                                    INR	B                    ;Result of the divide by two ops to compen for negative
 3917/35D9 : A8                         NOREMD:    XRA	A                    ;Clear the accumulator
 3918/35DA : 91                                    SUB	B                    ;Subtract the quotient of the divide by two op to
 3919/35DB : C8                                    MOV	B,A                    ;Form two's complement and save the result in register B
 3920/35DC : 36 0B                      SQREXP:    MVI	L, 013o               ;Load L with address of TEMP register
 3921/35DE : F9                                    MOV	M,B                    ;Store Fxponent quotient from above ops in TEMP
 3922/35DF : 36 04                                 MVI	L, 004                ;Load L with address of FP registers containing +1.0
 3923/35E1 : 26 1C                                 MVI	E, 034o               ;Load E with address of SQR APPROX working registers
 3924/35E3 : DD                                    MOV	D,H                    ;Set D to same page as H
 3925/35E4 : 0E 04                                 MVI	B, 004                ;Set up register B as a number of bytes to move counter
 3926/35E6 : 46 F6 2E                              CALL	MOVEIT             ;Transfer value +1.0 into SQR APPROX registers
 3927/35E9 : 46 A7 24                              CALL	CFALSE             ;Now clear the FPACC registers
 3928/35EC : 36 24                                 MVI	L, 044o               ;Load L with address of LAST SQR APPROX temp regs.
 3929/35EE : 46 98 30                              CALL	FSTORE             ;Initialize the LAST SQR APPROX regs to value of zero
 3930/35F1 : 36 1C                      SQRLOP:    MVI	L, 034o               ;Load L with address of SQR APPROX working registers
 3931/35F3 : 46 8F 30                              CALL	FLOAD              ;Transfer SQR APPROX into the FPACC
 3932/35F6 : 36 0C                                 MVI	L, 014o               ;Load L with address of SQR ARG storage registers
 3933/35F8 : 46 A1 30                              CALL	OPLOAD             ;Transfer SQR ARG into the FPOP
 3934/35FB : 46 BD 2F                              CALL	FPDIV              ;Divde SQR ARG by SQR APPROX (Fon-n X/A)
 3935/35FE : 36 1C                                 MVI	L, 034o               ;Load L with address of SQR APPROX registers
 3936/3600 : 46 A1 30                              CALL	OPLOAD             ;Transfer SQR APPROX into the FPOP
 3937/3603 : 46 70 2E                              CALL	FPADD              ;Add to form value (X/A + A)
 3938/3606 : 36 57                                 MVI	L, 127o               ;Load L with address of FPACC Exponent register
 3939/3608 : CF                                    MOV	B,M                    ;Fetch Exponent value into CPU register B
 3940/3609 : 09                                    DCR	B                    ;Subtract one to effectively divide FPACC by two
 3941/360A : F9                                    MOV	M,B                    ;Restore to memory. (Now have ((X/A + A) /2)
 3942/360B : 36 1C                                 MVI	L, 034o               ;Load L with address of SQR APPROX registers
 3943/360D : 46 98 30                              CALL	FSTORE             ;Store contents of FPACC as new SQR APPROX
 3944/3610 : 36 24                                 MVI	L, 044o               ;Load L with address of LAST SQR APPROX registers
 3945/3612 : 46 A1 30                              CALL	OPLOAD             ;Transfer LAST SQR APPROX into the FPOP
 3946/3615 : 46 05 2F                              CALL	FPSUB              ;Subtract (LAST SQR APPROX - SQR APPROX)
 3947/3618 : 36 57                                 MVI	L, 127o               ;Load L with address of FPACC Exponent
 3948/361A : C7                                    MOV	A,M                    ;Fetch the Exponent into the accumulator
 3949/361B : 3C F7                                 CPI	367o                ;See if difference less than 2 to the minus ninth
 3950/361D :                            ;;; The below is changed for PATCH 2
 3951/361D :                            ;;; following is the original code
 3952/361D :                            ;;;           JTS SQRCNV             ;If so, approximation has converged
 3953/361D :                            ;;; Now is the new line
 3954/361D :                            ;	   JMP	PATCH2
 3955/361D :                            ;;; following is PATCH 2
 3956/361D :                            
 3957/361D :                            ;	ORG	1af4h	; 032#364
 3958/361D : 70 33 36                   PATCH2	JM	SQRCNV
 3959/3620 : 31                         	DCR	L
 3960/3621 : C7                         	MOV	A,M
 3961/3622 : A0                         	ANA	A
 3962/3623 : 68 33 36                   	JZ	SQRCNV
 3963/3626 :                            ;	JMP	SQR1
 3964/3626 :                            ;;; The above jump should start at 32 375 1afdh
 3965/3626 :                            ;;;;           DCR L
 3966/3626 :                            ;;;;           MOV A,M
 3967/3626 :                            ;;;;           ANA A
 3968/3626 :                            ;;;;           JZ SQRCNV             ;THIS IS PATCH #2
 3969/3626 : 36 1C                      SQR1:	   MVI	L, 034o               ;Else, load L with address of SQR APPROX
 3970/3628 : DD                                    MOV	D,H                    ;Set D to same page as H
 3971/3629 : 26 24                                 MVI	E, 044o               ;And E with address of LAST SQR APPROX
 3972/362B : 0E 04                                 MVI	B, 004o               ;Set up register B as a number of bytes to move counter
 3973/362D : 46 F6 2E                              CALL	MOVEIT             ;Transfer SQR APPROX into LAST SQR APPROX
 3974/3630 : 44 F1 35                              JMP	SQRLOP             ;Continue ops until approximation converges
 3975/3633 : 36 0B                      SQRCNV:    MVI	L, 013o               ;Load L with address of TEMP register. Fetch the
 3976/3635 : C7                                    MOV	A,M                    ;Exponenent quotient store there into accumulator.
 3977/3636 : 36 1F                                 MVI	L, 037o               ;Change L to point to SQR APPROX exponent.
 3978/3638 : 87                                    ADD	M                    ;Add SQR APPROX exponent to quotient value.
 3979/3639 : F8                                    MOV	M,A                    ;Store sum back in SQR APPROX Exponent register.
 3980/363A : 36 1C                                 MVI	L, 034o               ;Load L with address of SQR APPROX. Transfer the
 3981/363C : 44 8F 30                              JMP	FLOAD              ;SQR APPROX into FPACC as answer and exit.
 3982/363F : 06 D3                      SQRERR:    MVI	A, 323o               ;Load ASCII code for letter S into the accumulator.
 3983/3641 : 16 D1                                 MVI	C, 321o               ;Load ASCII code for letter Q into CPU register C.
 3984/3643 : 44 96 20                              JMP	ERROR              ;Display the SQuare root (SQ) error message.
 3985/3646 :                            ;;; above instruction starts at 223
 3986/3646 :                            ;;; some blank addresses available here.
 3987/3646 :                            
 3988/3646 :                            ;          ORG	1aa0h              ; 032#240
 3989/3646 : 36 34                      RNDX:      MVI	L, 064o               ;Load L with address of SEED storage registers
 3990/3648 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page for floating point working registers
 3991/364A : 46 8F 30                              CALL	FLOAD              ;Transfer SEED into the FPACC
 3992/364D : 36 28                                 MVI	L, 050o               ;Load L with address of random constant A
 3993/364F : 46 A1 30                              CALL	OPLOAD             ;Transfer random constant A into the FPOP
 3994/3652 : 46 11 2F                              CALL	FPMULT             ;Multiply to form (SEED * A)
 3995/3655 : 36 30                                 MVI	L, 060o               ;Load L with address of random constant C
 3996/3657 : 46 A1 30                              CALL	OPLOAD             ;Transfer random constant C into the FPOP
 3997/365A : 46 70 2E                              CALL	FPADD              ;Add to fom (SEED * A) + C
 3998/365D : 36 34                                 MVI	L, 064o               ;Load L with address of SEED storage registers
 3999/365F : 46 98 30                              CALL	FSTORE             ;Store I (SEED * A) + C] in former SEED registers
 4000/3662 : 36 57                                 MVI	L, 127o               ;Load L with address of FPACC Exponent register
 4001/3664 : C7                                    MOV	A,M                    ;Fetch Exponent value into the accumulator
 4002/3665 : 14 10                                 SUI	020o               ;Subtract 16 (decimal) to effectively divide by 65,536
 4003/3667 : F8                                    MOV	M,A                    ;Now FPACC = [((SEED * A) + C)/65,536]
 4004/3668 : 46 E7 2D                              CALL	FPFIX              ;Convert floating to fixed point to obtain integer part
 4005/366B : 36 53                                 MVI	L, 123o               ;Load L with address of FPACC Extension register
 4006/366D : 3E 00                                 MVI	M, 000                ;Clear the FPACC Extension register
 4007/366F : 36 57                                 MVI	L, 127o               ;Load L with address of FPACC Exponent
 4008/3671 : 3E 00                                 MVI	M, 000                ;Clear the FPACC Exponent register
 4009/3673 : 46 1B 2E                              CALL	FPFLT              ;Fetch INT(((SEED * A) + C)/65,536) into the FPACC
 4010/3676 : 36 57                                 MVI	L, 127o               ;Load L with address of FPACC Exponent
 4011/3678 : C7                                    MOV	A,M                    ;Fetch FPACC Exponent into the accumulator
 4012/3679 : 04 10                                 ADI	020o               ;Add 16 (decimal) to effectively multiply by 65,536
 4013/367B : F8                                    MOV	M,A                    ;(65,536 * INT[ ((SEED * A) + C)/65,5361) in FPACC
 4014/367C : 36 34                                 MVI	L, 064o               ;Load L with address of [(SEED * A) + C]
 4015/367E : 46 A1 30                              CALL	OPLOAD             ;Transfer it into FPOP. Subtract FPACC to form
 4016/3681 : 46 05 2F                              CALL	FPSUB              ;[(SEED * A) + C] MOD 65,536
 4017/3684 : 36 34                                 MVI	L, 064o               ;Load L with address of former SEED registers
 4018/3686 : 46 98 30                              CALL	FSTORE             ;Store SEED MOD 65,536 in place of [(SEED * A) + Cl
 4019/3689 : 36 57                                 MVI	L, 127o               ;Load L with address of FPACC Exponent
 4020/368B : C7                                    MOV	A,M                    ;Fetch FPACC Exponent into the ACC and subtract
 4021/368C : 14 10                                 SUI	020o               ;16 (decimal) to form (SEED MOD 65,536)/65,536
 4022/368E : F8                                    MOV	M,A                    ;So that random number in FPACC is between
 4023/368F : 07                                    RET                    ;0.0 and +1.0 and exit to calling routine
 4024/3690 :                            ;;; THE ABOVE RETURN SHOULD BE 32 351 1ae9h
 4025/3690 :                            
 4026/3690 :                            ;;; NOTE OPEN ADDRESSES TO END OF PAGE 32
 4027/3690 :                            
 4028/3690 :                            
 4029/3690 :                            	;; PAGES 33 TO REMAINDER OF MEMORY
 4030/3690 :                            	;; OR START OF OPTIONAL ARRAY HANDLING
 4031/3690 :                            	;; ROUTINES USED AS USER PROGRAM BUFFER
 4032/3690 :                            
 4033/3690 :                            	;; OPTIONAL ARRAY ROUTINES ASSEMBLED FOR OPERATION
 4034/3690 :                            	;; IN THE UPPER 3 PAGES OF A 12K SYSTEM ARE LISTED HERE.
 4035/3690 :                            
 4036/3690 :                            ;          ORG	2d00h              ; 055#000
 4037/3690 :                            
 4038/3690 : 36 56                      PRIGH1:    MVI	L, 126o               ;Load L with address of the MSW in the FPACC
 4039/3692 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of FPACC
 4040/3694 : C7                                    MOV	A,M                    ;Fetch MSW of FPACC into the ACC.
 4041/3695 : A0                                    ANA	A                    ;Test to see if value in FPACC is positive.
 4042/3696 : 70 EE 36                              JM	OUTRNG             ;If not, go display error message.
 4043/3699 : 46 E7 2D                              CALL	FPFIX              ;If O.K. then convert floating point to fixed point
 4044/369C : 36 54                                 MVI	L, 124o               ;Load L with address of LSAL of converted value
 4045/369E : C7                                    MOV	A,M                    ;Fetch the LSW of the value into the ACC
 4046/369F : 14 01                                 SUI	001                ;Subtract one from the value to establish proper
 4047/36A1 : 02                                    RLC                    ;Origin for future ops. Now rotate the value twice
 4048/36A2 : 02                                    RLC                    ;To effectively multiply by four. Save the
 4049/36A3 : D0                                    MOV	C,A                    ;Calculated result in CPU register C
 4050/36A4 : 36 83                                 MVI	L, 203o               ;Load L with address of F/A STACK TEMP
 4051/36A6 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Load H with page of F/A STACK TEMP
 4052/36A8 : C7                                    MOV	A,M                    ;Fetch the value into the accumulator
 4053/36A9 : 2C FF                                 XRI	377o               ;Complement the value
 4054/36AB : 02                                    RLC                    ;Rotate the value twice to multiply by four (the number
 4055/36AC : 02                                    RLC                    ;Of bytes per entry in the ARRAY VARIABLES table).
 4056/36AD : 04 50                                 ADI	120o               ;Add the starting address of the ARRAY VARIABLES
 4057/36AF : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** TABLE to forin pointer. Set page address in H.
 4058/36B1 : F0                                    MOV	L,A                    ;Point to the name in the ARRAY VARIABLES
 4059/36B2 : 30                                    INR	L                    ;Increment the pointer value twice to move over the
 4060/36B3 : 30                                    INR	L                    ;Name in the table and point to starting address for the
 4061/36B4 : C7                                    MOV	A,M                    ;Array values in the ARRAY VALUES table. Fetch this
 4062/36B5 : 82                                    ADD	C                    ;Address to the ACC. Now add in the figure calculated
 4063/36B6 : F0                                    MOV	L,A                    ;To reach desired subscripted data storage location. Set
 4064/36B7 : 2E 05                                 MVI	H,PG57 ;\HB\OLDPG57   ;tt The pointer to that location. Load the floating point
 4065/36B9 : 44 8F 30                              JMP	FLOAD              ;Value stored there into the FPACC and exit to caller.
 4066/36BC :                            
 4067/36BC :                            
 4068/36BC :                            ;;; The label FUNAR2 SHOULD START AT 55-054 2d2ch
 4069/36BC : 36 82                      FUNAR2:    MVI	L, 202o               ;Load L with address of TEMP COUNTER
 4070/36BE : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Load H with page of counter
 4071/36C0 : CF                                    MOV	B,M                    ;Fetch the counter value
 4072/36C1 : 08                                    INR	B                    ;Increment the value
 4073/36C2 : F9                                    MOV	M,B                    ;Restore the value to memory
 4074/36C3 : 16 02                                 MVI	C, 002                ;Initialize register C to a value of two for future ops
 4075/36C5 : 36 4C                                 MVI	L, 114o               ;Load L with address of start of ARRAY VARIABLES
 4076/36C7 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** TABLE (less four). Set H to page of the table.
 4077/36C9 : 46 98 25                              CALL	TABADR             ;Calculate address of start of next narne in table.
 4078/36CC : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Load D with page of the SYMBOL BUFFER
 4079/36CE : 26 50                                 MVI	E, 120o               ;Set E to starting address of the SYMBOL BUFFER
 4080/36D0 : 46 DA 20                              CALL	STRCP              ;Compare name in ARRAY VARIABLES table to the
 4081/36D3 : 68 E4 36                              JZ	FUNAR3             ;Contents of the SYMBOL BUFFER. If match, go set up
 4082/36D6 : 36 82                                 MVI	L, 202o               ;Array token value. Else, reset L to address of TEMP
 4083/36D8 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** COUNTER. Set H to page of TEMP COUNTER.
 4084/36DA : C7                                    MOV	A,M                    ;Fetch the counter value into the accumulator.
 4085/36DB : 36 3D                                 MVI	L, 075o               ;Change L to number of arrays storage location.
 4086/36DD : BF                                    CMP	M                    ;Compare number of entries checked against number
 4087/36DE : 48 BC 36                              JNZ	FUNAR2             ;Possible. Keep searching table if not finished.
 4088/36E1 : 44 7A 25                              JMP	FAERR              ;If finished and no match than have F/A error condx.
 4089/36E4 : 36 82                      FUNAR3:    MVI	L, 202o               ;Load L with address of TEMP COUNTER
 4090/36E6 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Load H with page of counter.
 4091/36E8 : A8                                    XRA	A                    ;Clear the accumulator. Subtract the value in the TEMP
 4092/36E9 : 9F                                    SBB	M                    ;COUNTER from zero to obtain two's complement.
 4093/36EA : F8                                    MOV	M,A                    ;Place this back in counter location as ARRAY TOKEN
 4094/36EB : 44 87 25                              JMP	FUNAR4             ;VALUE (negative). Go place the value on F/A STACK.
 4095/36EE :                            
 4096/36EE :                            
 4097/36EE :                            ;;; The label OUTRNG STARTS AT 55 136 2d5eh
 4098/36EE : 06 CF                      OUTRNG:    MVI	A, 317o               ;Load the ASCII code for letter 0 into the accumulator
 4099/36F0 : 16 D2                                 MVI	C, 322o               ;Load the ASCII code for letter R into register C
 4100/36F2 : 44 96 20                              JMP	ERROR              ;Go display Out of Range (OR) error message.
 4101/36F5 :                            
 4102/36F5 :                            
 4103/36F5 :                            
 4104/36F5 :                            
 4105/36F5 : 46 AA 26                   ARRAY:     CALL	RESTSY             ;Transfer contents of AUX SYMBOL BUFFER into the
 4106/36F8 : 44 00 37                              JMP	ARRAY2             ;SYMBOL BUFFER. (Entry when have actual LET)
 4107/36FB : 36 82                      ARRAY1:    MVI	L, 202o               ;Load L with address of SCAN pointer
 4108/36FD : 44 02 37                              JMP	ARRAY3             ;Proceed to process. (Entry point for IMPLIED LET)
 4109/3700 : 36 83                      ARRAY2:    MVI	L, 203o               ;Load L with address of LET pointer
 4110/3702 : 2E 03                      ARRAY3:    MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to pointer page
 4111/3704 : CF                                    MOV	B,M                    ;Fetch pointer to location where "(" found in statement
 4112/3705 : 08                                    INR	B                    ;Line. Increment it to point to next character in the line.
 4113/3706 : 36 BE                                 MVI	L, 276o               ;Load L with address of EVAL pointer and load it with
 4114/3708 : F9                                    MOV	M,B                    ;The starting address for the EVAL routine
 4115/3709 : 36 86                                 MVI	L, 206o               ;Change L to address of ARRAY SETUP pointer
 4116/370B : F9                                    MOV	M,B                    ;And also store address in that location
 4117/370C : 36 86                      ARRAY4:    MVI	L, 206o               ;Load L with address of ARRAY SETUP pointer
 4118/370E : 46 A0 20                              CALL	GETCHR             ;Fetch character pointed to by ARRAY SETUP pntr
 4119/3711 : 3C A9                                 CPI	251o               ;See if character is ")" ? If so, then have located
 4120/3713 : 68 25 37                              JZ	ARRAY5             ;End of the subscript. If not, reset
 4121/3716 : 36 86                                 MVI	L, 206o               ;to the ARRAY SETUP pointer. Increment the
 4122/3718 : 46 03 21                              CALL	LOOP               ;Pointer and test for the end of the statement line.
 4123/371B : 48 0C 37                              JNZ	ARRAY4             ;If not end of line, continue looking for right paren.
 4124/371E : 06 C1                                 MVI	A, 301o               ;If reach end of line before right parenthesis than load
 4125/3720 : 16 C6                                 MVI	C, 306o               ;ASCII code for letters A and F and display message
 4126/3722 : 44 96 20                              JMP	ERROR              ;Indicating Array Forrnat (AF) error condition
 4127/3725 : 36 86                      ARRAY5:    MVI	L, 206o               ;Load L with address of ARRAY SETUP pointer
 4128/3727 : CF                                    MOV	B,M                    ;Fetch pointer (pointing to ")"sign) into register B
 4129/3728 : 09                                    DCR	B                    ;Decrement it to move back to end of subscript number
 4130/3729 : 36 BF                                 MVI	L, 277o               ;Load L with address of EVAL FINISH pointer location
 4131/372B : F9                                    MOV	M,B                    ;Place the pointer value in the EVAL FINISH pointer
 4132/372C : 36 87                                 MVI	L, 207o               ;Load L with address of LOOP COUNTER
 4133/372E : 3E 00                                 MVI	M, 000                ;Initialize LOOP COUNTER to value of zero
 4134/3730 : 36 87                      ARRAY6:    MVI	L, 207o               ;Load L with address of LOOP COUNTER
 4135/3732 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of LOOP COUNTER
 4136/3734 : CF                                    MOV	B,M                    ;Fetch the counter value
 4137/3735 : 08                                    INR	B                    ;Increment it
 4138/3736 : F9                                    MOV	M,B                    ;Restore the counter value to memory
 4139/3737 : 16 02                                 MVI	C, 002                ;Set up counter in register C for future ops
 4140/3739 : 36 4C                                 MVI	L, 114o               ;Load L with address of start of ARRAY VARIABLES
 4141/373B : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Table less four). Set H to page of the table.
 4142/373D : 46 98 25                              CALL	TABADR             ;Calculate the address of next entry in the table
 4143/3740 : 26 50                                 MVI	E, 120o               ;Load register E with starting address of SYMBOL BUFF
 4144/3742 : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Set D to page of SYMBOL BUFFER
 4145/3744 : 46 DA 20                              CALL	STRCP              ;Compare entry in table against contents of SYMBOL BF
 4146/3747 : 68 5A 37                              JZ	ARRAY7             ;If match, have found array naine in the table.
 4147/374A : 36 87                                 MVI	L, 207o               ;Else, set L to address of the LOOP COUNTER
 4148/374C : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of the LOOP COUNTER
 4149/374E : C7                                    MOV	A,M                    ;Fetch the counter value to the ACC
 4150/374F : 36 3D                                 MVI	L, 075o               ;Change L to the counter containing number of arrays
 4151/3751 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to the proper page
 4152/3753 : BF                                    CMP	M                    ;Compare number of arrays to count in LOOP CNTR
 4153/3754 : 48 30 37                              JNZ	ARRAY6             ;If more entries in the table, continue looking for match
 4154/3757 : 44 7A 25                              JMP	FAERR              ;If no matching name in table then have an error condx.
 4155/375A : 46 94 21                   ARRAY7:    CALL	EVAL               ;Call subroutine to evaluate subscript expression
 4156/375D : 46 E7 2D                              CALL	FPFIX              ;Convert the subscript value obtained to fixed forrnat
 4157/3760 : 36 87                                 MVI	L, 207o               ;Load L with address of LOOP COUNTER
 4158/3762 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of the LOOP COUNTER
 4159/3764 : CF                                    MOV	B,M                    ;Fetch the value in the LOOP COUNTER into the ACC
 4160/3765 : 16 02                                 MVI	C, 002                ;Set up counter in register C future ops
 4161/3767 : 36 4C                                 MVI	L, 114o               ;Load L with address of ARRAY VARIABLES
 4162/3769 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Table less four). Set H to page of the table.
 4163/376B : 46 98 25                              CALL	TABADR             ;Calculate the address of entry in the table
 4164/376E : 30                                    INR	L                    ;Advance the ARRAY VARIABLES table pointer twice
 4165/376F : 30                                    INR	L                    ;To advance pointer over array name.
 4166/3770 : D7                                    MOV	C,M                    ;Fetch array base address in ARRAY VALUES table
 4167/3771 : 36 54                                 MVI	L, 124o               ;Load L with address of subscript value
 4168/3773 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of subscript value
 4169/3775 : C7                                    MOV	A,M                    ;Fetch the subscript value into the accumulator
 4170/3776 : 14 01                                 SUI	001                ;Subtract one from subscript value to allow for zero
 4171/3778 : 02                                    RLC                    ;Origin. Now multiply by four
 4172/3779 : 02                                    RLC                    ;Using rotates (number of bytes required for each entry
 4173/377A : 82                                    ADD	C                    ;In the ARRAY VALUES table). Add in base address to
 4174/377B : 36 84                                 MVI	L, 204o               ;The calculated value to form final address in the
 4175/377D : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** ARRAY VALUES table. Now set H & L to TEMP
 4176/377F : F8                                    MOV	M,A                    ;ARRAY ELEMENT storage location & store the addr.
 4177/3780 : 36 81                                 MVI	L, 201o               ;Change L to point to ARRAY FLAG
 4178/3782 : 3E FF                                 MVI	M, 377o               ;Set the ARRAY FLAG for future use
 4179/3784 : 07                                    RET                    ;Exit to calling routine
 4180/3785 :                            
 4181/3785 :                            
 4182/3785 :                            ;;; The label DIM SHOULD START AT 55 365 2df5h
 4183/3785 : 46 AD 20                   DIM:       CALL	CLESYM             ;Initialize the SYMBOL BUFFER to cleared condition
 4184/3788 : 36 82                                 MVI	L, 202o               ;Load L with address of SCAN pointer
 4185/378A : CF                                    MOV	B,M                    ;Fetch SCAN pointer value into register B
 4186/378B : 08                                    INR	B                    ;Add one to the SCAN pointer value
 4187/378C : 36 83                                 MVI	L, 203o               ;Change L to DIM pointer (formerly TOKEN) storage
 4188/378E : F9                                    MOV	M,B                    ;Store the updated SCAN pointer as the DIM pointer
 4189/378F : 36 83                      DIM1:      MVI	L, 203o               ;Load L with the address of DIM pointer storage location
 4190/3791 : 46 A0 20                              CALL	GETCHR             ;Fetch a character from the line input buffer
 4191/3794 : 68 9F 37                              JZ	DIM2               ;If character fetched is a space, ignore it
 4192/3797 : 3C A8                                 CPI	250o               ;Else see if character is "(" left parenthesis
 4193/3799 : 68 AA 37                              JZ	DIM3               ;If so, should have ARRAY VARIABLE naine in buffer
 4194/379C : 46 C8 20                              CALL	CONCTS             ;If not, append the character to the SYMBOL BUFFER
 4195/379F : 36 83                      DIM2:      MVI	L, 203o               ;Load L with the address of DIM pointer stomge location
 4196/37A1 : 46 03 21                              CALL	LOOP               ;Increment the pointer and see if end of line
 4197/37A4 : 48 8F 37                              JNZ	DIM1               ;If not end of line, fetch next character
 4198/37A7 : 44 6F 38                              JMP	DIMERR             ;Else have a DIMension error condition
 4199/37AA : 36 86                      DIM3:      MVI	L, 206o               ;Load L with address of ARRAY pointer storage loc
 4200/37AC : 3E 00                                 MVI	M, 000                ;Initialize ARRAY pointer to starting value of zero
 4201/37AE : 36 86                      DIM4:      MVI	L, 206o               ;Load L with address of ARRAY pointer storage loc
 4202/37B0 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of ARRAY pointer storage location
 4203/37B2 : C7                                    MOV	A,M                    ;Fetch value in ARRAY pointer to ACC (effectively
 4204/37B3 : 02                                    RLC                    ;Represents number of arrays defined in pgm). Rotate
 4205/37B4 : 02                                    RLC                    ;Left twice to multiply by four (niunber of bytes per
 4206/37B5 : 04 4C                                 ADI	114o               ;entry in ARRAY VARIABLES table). Add to base
 4207/37B7 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Address to form pointer to ARRAY VARIA.BLES
 4208/37B9 : F0                                    MOV	L,A                    ;Table and set up H & L as the memory pointer.
 4209/37BA : 26 50                                 MVI	E, 120o               ;Load E with starting address of the SYMBOL BUFFER
 4210/37BC : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Load D with the page address of the SYMBOL BUFF
 4211/37BE : 46 DA 20                              CALL	STRCP              ;Compare contents of SYMBOL BF to entry in ARRAY
 4212/37C1 : 68 51 38                              JZ	DIM9               ;VARIABLES table. If same, have duplicate array name.
 4213/37C4 : 36 86                                 MVI	L, 206o               ;Else, load L with address of ARRAY pointer storage
 4214/37C6 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of ARRAY pointer storage
 4215/37C8 : CF                                    MOV	B,M                    ;Fetch the ARRAY pointer value to register B
 4216/37C9 : 08                                    INR	B                    ;Increment the value
 4217/37CA : F9                                    MOV	M,B                    ;Restore it to ARRAY pointer storage location
 4218/37CB : 36 3D                                 MVI	L, 075o               ;Change L to number of arrays storage location
 4219/37CD : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to page of the number of arrays stomge loc
 4220/37CF : C7                                    MOV	A,M                    ;Fetch the number of arrays value to the ACC
 4221/37D0 : 09                                    DCR	B                    ;Restore B to previous count
 4222/37D1 : B9                                    CMP	B                    ;Compare number of arrays tested against nr defined
 4223/37D2 : 48 AE 37                              JNZ	DIM4               ;If not equal, continue searching ARRAY VARIABLES
 4224/37D5 : 36 3D                                 MVI	L, 075o               ;Table. When table searched with no match, then must
 4225/37D7 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Append naine to table. First set pointer to number
 4226/37D9 : CF                                    MOV	B,M                    ;Of arrays storage location. Fetch that value and
 4227/37DA : 08                                    INR	B                    ;Add one to account for new name being added.
 4228/37DB : F9                                    MOV	M,B                    ;Restore the updated value back to memory.
 4229/37DC : 36 3E                                 MVI	L, 076o               ;Change pointer to ARRAY TEMP pointer storage
 4230/37DE : F9                                    MOV	M,B                    ;Store pointer to current array in ARRAY TEMP too.
 4231/37DF : 36 86                                 MVI	L, 206o               ;Load L with address of ARRAY pointer stomge loc.
 4232/37E1 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of ARRAY pointer storage location
 4233/37E3 : F9                                    MOV	M,B                    ;And update it also for new array being added.
 4234/37E4 : C7                                    MOV	A,M                    ;Fetch the current ARRAY pointer value to the ACC
 4235/37E5 : 02                                    RLC                    ;Multiply it times four by performing two rotate left
 4236/37E6 : 02                                    RLC                    ;Operations and add it to base value to form address in
 4237/37E7 : 04 4C                                 ADI	114o               ;The ARRAY VARIABLES table. Place the low part
 4238/37E9 : E0                                    MOV	E,A                    ;Of this calculated address value into register E.
 4239/37EA : 1E 04                                 MVI	D,PG27 ;\HB\OLDPG27   ;** Set register D to the page of the table.
 4240/37EC : 36 50                                 MVI	L, 120o               ;Load L with the start of the SYMBOL BUFFER
 4241/37EE : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with the page of the SYMBOL BUFFER
 4242/37F0 : 46 0F 28                              CALL	MOVEC              ;Move the array name from the SYMBOL BUFFER to
 4243/37F3 : 46 AD 20                              CALL	CLESYM             ;The ARRAY VARIABLES table. Then clear the
 4244/37F6 : 36 83                                 MVI	L, 203o               ;SYMBOL BUFFER. Reset L to the DIM pointer storage
 4245/37F8 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Location. Set H to the DIM pointer page.
 4246/37FA : CF                                    MOV	B,M                    ;Fetch the pointer value (points to "(" part of DIM
 4247/37FB : 08                                    INR	B                    ;Statement). Increment the pointer to next character in
 4248/37FC : 36 84                                 MVI	L, 204o               ;The line input buffer. Cbange L to DIMEN pointer.
 4249/37FE : F9                                    MOV	M,B                    ;Store the updated DIM pointer in DIMEN storage loc.
 4250/37FF : 36 84                      DIM5:      MVI	L, 204o               ;Set L to DIMEN pointer storage location
 4251/3801 : 46 A0 20                              CALL	GETCHR             ;Fetch character in line input buffer
 4252/3804 : 68 19 38                              JZ	DIM6               ;Ignore character for space
 4253/3807 : 3C A9                                 CPI	251o               ;If not space, see if character is right parenthesis
 4254/3809 : 68 24 38                              JZ	DIM7               ;If yes, process DIMension size (array length)
 4255/380C : 3C B0                                 CPI	260o               ;If not, see if character is a valid decimal number
 4256/380E : 70 6F 38                              JM	DIMERR             ;If not valid number, have DIMension error condition
 4257/3811 : 3C BA                                 CPI	272o               ;Continue testing for valid decitnal number
 4258/3813 : 50 6F 38                              JP	DIMERR             ;If not valid number, then DIMension error condition
 4259/3816 : 46 C8 20                              CALL	CONCTS             ;If valid decirnal number, append digit to SYMBOL BF
 4260/3819 : 36 84                      DIM6:      MVI	L, 204o               ;Set L to DIMEN pointer storage location
 4261/381B : 46 03 21                              CALL	LOOP               ;Advance the pointer value and check for end of the line
 4262/381E : 48 FF 37                              JNZ	DIM5               ;If not end of line, continue fetching DIMension size
 4263/3821 : 44 6F 38                              JMP	DIMERR             ;If end of line before right parenthesis, have error condx.
 4264/3824 : 36 50                      DIM7:      MVI	L, 120o               ;Load L with address of start of SYMBOL BUFFER
 4265/3826 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of SYMBOL BUFFER. (Now
 4266/3828 : 46 0F 31                              CALL	DINPUT             ;Contains DIMension size.) Convert buffer to floating
 4267/382B : 46 E7 2D                              CALL	FPFIX              ;Point number and then reformat to fixed point.
 4268/382E : 36 54                                 MVI	L, 124o               ;Load L with address of LSW of fixed point number
 4269/3830 : C7                                    MOV	A,M                    ; And fetch the low order byte of the nr into the ACC
 4270/3831 : 02                                    RLC                    ;Rotate it left two tirnes to multiply it by four (the
 4271/3832 : 02                                    RLC                    ;Number of bytes required to store a floating point nr).
 4272/3833 : D0                                    MOV	C,A                    ;Store this value in CPU register C temporarily
 4273/3834 : 36 3E                                 MVI	L, 076o               ;Set L to ARRAY TEMP storage location.
 4274/3836 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to ARRAY TEMP pointer page.
 4275/3838 : C7                                    MOV	A,M                    ;Fetch the value in ARRAY TEMP (points to ARRAY
 4276/3839 : 14 01                                 SUI	001                ;VARIABLES table). Subtract one from the pointer
 4277/383B : 02                                    RLC                    ;Value and multiply the result by four using rotate left
 4278/383C : 02                                    RLC                    ;Instructions. Add this value to a base address
 4279/383D : 04 52                                 ADI	122o               ;(Augmented by two) to point to ARRAY VALUES
 4280/383F : F0                                    MOV	L,A                    ;Pointer storage location in the ARRAY VARIABLES
 4281/3840 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;Table and set the pointer up in registers H & L.
 4282/3842 : CF                                    MOV	B,M                    ;Fetch the starting address in the ARRAY VALUES
 4283/3843 : 04 04                                 ADI	004                ;Table for the previous array into register B. Now add
 4284/3845 : F0                                    MOV	L,A                    ;Four to the ARRAY VARIABLES table pointer to
 4285/3846 : C1                                    MOV	A,B                    ;Point to curront ARRAY VALUES starting address.
 4286/3847 : 82                                    ADD	C                    ;Add the previous array starting address plus number of
 4287/3848 : F8                                    MOV	M,A                    ;Bytes required and store as starting loc for next array
 4288/3849 : 36 84                      DIM8:      MVI	L, 204o               ;Set L to address of DIMEN pointer storage location
 4289/384B : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of DIMEN pointer
 4290/384D : CF                                    MOV	B,M                    ;Fetch pointer value (points to ") " in line)
 4291/384E : 36 83                                 MVI	L, 203o               ;Change L to DIM pointer storage location
 4292/3850 : F9                                    MOV	M,B                    ;Store former DIMEN value back in DIM pointer
 4293/3851 : 36 83                      DIM9:      MVI	L, 203o               ;Load L with address of DIM pointer storage location
 4294/3853 : 46 A0 20                              CALL	GETCHR             ;Fetch a character from the line input buffer
 4295/3856 : 3C AC                                 CPI	254o               ;See if character is a comma (,) sign
 4296/3858 : 68 66 38                              JZ	DIM10              ;If yes, have another array being defined on the line
 4297/385B : 36 83                                 MVI	L, 203o               ;If not, reset L to the DIM pointer
 4298/385D : 46 03 21                              CALL	LOOP               ;Increment the pointer and see if end of the line
 4299/3860 : 48 51 38                              JNZ	DIM9               ;If not end of the line, keep looking for a comma
 4300/3863 : 44 3D 29                              JMP	NXTLIN             ;Else exit the DIM statement routine to continue pgm
 4301/3866 : 36 83                      DIM10:     MVI	L, 203o               ;Set L to DIM pointer storage location
 4302/3868 : CF                                    MOV	B,M                    ;Fetch pointer value (points to comma sign just found)
 4303/3869 : 36 82                                 MVI	L, 202o               ;Load L with address of SCAN pointer storage location
 4304/386B : F9                                    MOV	M,B                    ;Place DIM pointer into the-SCAN pointer
 4305/386C : 44 85 37                              JMP	DIM                ;Continue processing DIM statement line for next array
 4306/386F : 06 C4                      DIMERR:    MVI	A, 304o               ;On error condition, load ASCII code for letter D in ACC
 4307/3871 : 16 C5                                 MVI	C, 305o               ;And ASCII code for letter E in CPU register C
 4308/3873 : 44 96 20                              JMP	ERROR              ;Go display the Dirnension Error (DE) message.
 4309/3876 :                            
 4310/3876 :                            ;##################################################################################################
 4311/3876 :                            
 4312/3876 :                            
 4313/3876 :                            
 AS V1.42 Beta [Bld 290] - Source File sc1.asm - Page 3 - 7/26/2025 11:40:27


  Symbol Table (* = unused):
  --------------------------

 ABSX :                                  25E6 C |  ACCSET :                                2E5D C |
 ACNONZ :                                2E4A C |  ACZERT :                                2E37 C |
 AD4DE :                                 24AE C |  ADBDE :                                 28AE C |
 ADDER :                                 3042 C | *ADDEXP :                                2F14 C |
 ADDMOR :                                3043 C |  ADOPPP :                                2FA3 C |
 ADV :                                   20FF C |  ADVDE :                                 2923 C |
 AHEAD1 :                                327B C |  AHEAD2 :                                33C6 C |
*ARCHITECTURE :          "i386-unknown-win32" - |  ARRAY :                                 36F5 C |
 ARRAY1 :                                36FB C |  ARRAY2 :                                3700 C |
 ARRAY3 :                                3702 C |  ARRAY4 :                                370C C |
 ARRAY5 :                                3725 C |  ARRAY6 :                                3730 C |
 ARRAY7 :                                375A C |  BACKSP :                                3567 C |
 BGNPGRAM :                                 6 - |  BIGERR :                                2092 C |
*BRING1 :                                2EF2 C | *CASESENSITIVE :                            0 - |
 CFALSE :                                24A7 C |  CHRX :                                  25FF C |
 CINP :                                   15E C |  CINPUT :                                2191 C |
 CINP_BS :                                16E C |  CKDECP :                                334A C |
*CKEQEX :                                2E89 C |  CKSIGN :                                2F61 C |
 CLESYM :                                20AD C |  CLRNEX :                                2F68 C |
 CLRNX1 :                                2F72 C |  CLRNX2 :                                3118 C |
 CLRNX3 :                                3122 C | *CLROPL :                                2F6E C |
 CODE_START :                            2000 - |  COMPEN :                                32F3 C |
 COMPLM :                                3053 C |  CONCT1 :                                20CC C |
*CONCTA :                                20B4 C |  CONCTE :                                20D7 C |
 CONCTN :                                20BE C |  CONCTS :                                20C8 C |
*CONSTPI :                  3.141592653589793 - |  CONTIN :                                2824 C |
 CPHLDE :                                28A8 C |  CPRINT :                                 171 C |
 CPRINT_1 :                               188 C |  CP_BS :                                  191 C |
 CP_BS2 :                                 19A C |  CP_BS3 :                                 1A3 C |
 CP_NO :                                  190 C |  CP_OK :                                  187 C |
 CRLF :                                  2161 C |  CROUND :                                2FB2 C |
 CTRLC :                                 28B4 C |  CTRUE :                                 24A2 C |
*DATE :                           "7/26/2025" - |  DEC :                                   2174 C |
 DECBIN :                                3219 C |  DECEXD :                                32C9 C |
 DECEXT :                                32AA C |  DECNO :                                 217A C |
 DECOUT :                                32DB C |  DECRDG :                                3335 C |
 DECREP :                                32C2 C |  DIM :                                   3785 C |
 DIM1 :                                  378F C |  DIM10 :                                 3866 C |
 DIM2 :                                  379F C |  DIM3 :                                  37AA C |
 DIM4 :                                  37AE C |  DIM5 :                                  37FF C |
 DIM6 :                                  3819 C |  DIM7 :                                  3824 C |
*DIM8 :                                  3849 C |  DIM9 :                                  3851 C |
 DIMERR :                                386F C |  DINPUT :                                310F C |
 DIRECT :                                2978 C |  DIVIDE :                                2FD4 C |
 DVERR :                                 28DE C |  DVEXIT :                                3023 C |
 DVLOOP :                                24F2 C |  ECHO :                                  2182 C |
 ENDINP :                                31B4 C |  ENDPGRAM :                                1F - |
 ENTRY_SCR :                             270A C |  EQ :                                    245E C |
 ERROR :                                 2096 C |  EVAL :                                  2194 C |
 EXEC :                                  26B6 C |  EXEC1 :                                 26BD C |
 EXMLDV :                                2F51 C |  EXOUTN :                                33BF C |
 EXPINP :                                318C C |  EXPOK :                                 31EB C |
 EXPOUT :                                33AB C |  FACXOP :                                30AA C |
 FAERR :                                 257A C | *FALSE :                                    0 - |
 FINER1 :                                28D2 C |  FINERR :                                28BB C |
 FININP :                                31C2 C |  FIXERR :                                28E5 C |
 FLOAD :                                 308F C | *FLOATMAX :                1.797693134866E308 - |
 FNDEXP :                                317C C |  FOR :                                   2D63 C |
 FOR1 :                                  2D99 C |  FOR2 :                                  2DA5 C |
 FOR3 :                                  2DB7 C |  FOR4 :                                  2DC2 C |
 FOR5 :                                  357E C |  FORERR :                                2D92 C |
 FORNXT :                                3429 C |  FP0 :                                   2D5E C |
 FPADD :                                 2E70 C |  FPCOMP :                                2E69 C |
 FPD10 :                                 3206 C |  FPDIV :                                 2FBD C |
 FPFIX :                                 2DE7 C |  FPFIXL :                                2E02 C |
 FPFLT :                                 2E1B C |  FPMULT :                                2F11 C |
 FPNORM :                                2E1D C |  FPONE :                                 24A2 C |
 FPOPER :                                23F4 C |  FPOUT :                                 3260 C |
 FPSUB :                                 2F05 C |  FPX10 :                                 31F3 C |
 FPZERO :                                2E10 C |  FRAC :                                  2AD7 C |
*FSHIFT :                                2EED C |  FSTORE :                                3098 C |
 FUNAR1 :                                254D C |  FUNAR2 :                                36BC C |
 FUNAR3 :                                36E4 C |  FUNAR4 :                                2587 C |
 FUNARR :                                2540 C |  GE :                                    248B C |
 GETAU0 :                                2789 C |  GETAU1 :                                27A2 C |
 GETAU2 :                                27B7 C |  GETAUX :                                277F C |
 GETCHP :                                283C C |  GETCHR :                                20A0 C |
 GETINP :                                30E0 C |  GOSERR :                                2CD6 C |
 GOSUB :                                 2C8D C |  GOSUB1 :                                2C9C C |
 GOTO :                                  2B6B C |  GOTO1 :                                 2B78 C |
 GOTO2 :                                 2B8F C |  GOTO3 :                                 2B97 C |
 GOTO4 :                                 2BA0 C |  GOTO5 :                                 2BA7 C |
 GOTO6 :                                 2BBC C |  GOTO7 :                                 2BCF C |
*GOTOER :                                2BFF C |  GT :                                    246B C |
 HAJIME :                                 150 C | *HAS64 :                                    1 - |
 IF :                                    2C06 C |  IF1 :                                   2C31 C |
 IF2 :                                   2C52 C |  IF3 :                                   2C65 C |
 IF4 :                                   2C6F C |  IFERR :                                 2C2A C |
*INCLIN :                                2896 C |  INDEXB :                                217C C |
 INDEXC :                                3109 C |  INPUT :                                 2CE4 C |
 INPUT1 :                                2CEE C |  INPUT2 :                                2D0E C |
 INPUT3 :                                2D11 C |  INPUT4 :                                2D22 C |
 INPUTN :                                2D4F C |  INPUTX :                                2D33 C |
 INSER1 :                                2882 C |  INSER3 :                                2896 C |
 INSERT :                                286E C |  INSTR :                                 28F9 C |
 INSTR1 :                                28FD C |  INSTR2 :                                2920 C |
 INT1 :                                  25D7 C |  INT2 :                                  25E1 C |
 INTEXP :                                24B3 C |  INTX :                                  25A3 C |
 INT_PTR :                                 41 - |  IN_DATA :                                  1 - |
 IN_DIGIT_CC_L :                           45 - | *IN_DIGIT_CC_L0 :                         245 C |
 IN_STATUS :                                0 - |  LE :                                    247B C |
 LET :                                   2B08 C |  LET0 :                                  2AFA C |
 LET1 :                                  2B11 C |  LET2 :                                  2B1A C |
 LET3 :                                  2B3A C |  LET4 :                                  2B41 C |
 LET5 :                                  2B50 C | *LETERR :                                2B49 C |
 LINEUP :                                2EAA C |  LIST :                                  26DB C |
*LISTON :                                   1 - |  LOAD :                                   15A C |
 LOOK0 :                                 2E3B C |  LOOKU1 :                                2331 C |
 LOOKU2 :                                2349 C |  LOOKU4 :                                2381 C |
 LOOKUP :                                231B C |  LOOP :                                  2103 C |
 LT :                                    2451 C | *MACEXP :                                   7 - |
 MINEXP :                                3206 C | *MOMCPU :                               8008E - |
*MOMCPUNAME :                       "8008NEW" - |  MORACC :                                2EB2 C |
 MORCOM :                                3058 C |  MOROP :                                 2EBF C |
 MOVEC :                                 280F C |  MOVECP :                                26B1 C |
 MOVEIT :                                2EF6 C |  MOVEPG :                                2811 C |
 MOVOP :                                 2E79 C |  MROUND :                                2FAD C |
 MULOOP :                                24E1 C |  MULTIP :                                2F21 C |
 NE :                                    2498 C |  NEGEXP :                                35CB C |
 NEGFPA :                                2F94 C | *NESTMAX :                                100 - |
 NEXT :                                  33E3 C |  NEXT1 :                                 33F0 C |
 NEXT10 :                                353B C |  NEXT11 :                                3550 C |
 NEXT12 :                                3557 C |  NEXT2 :                                 33FD C |
 NEXT3 :                                 3411 C |  NEXT4 :                                 3430 C |
 NEXT5 :                                 3498 C |  NEXT6 :                                 34C1 C |
 NEXT7 :                                 34DD C |  NEXT8 :                                 34EF C |
 NEXT9 :                                 34FA C |  NINPUT :                                3138 C |
 NODECP :                                3357 C |  NOEXC0 :                                2E27 C |
 NOEXPO :                                2305 C |  NOEXPS :                                318F C |
 NOGO :                                  2FE9 C |  NOLIST :                                26EC C |
 NONZAC :                                2E84 C |  NOREMD :                                35D9 C |
 NOSAME :                                27EE C |  NOSCR :                                 2739 C |
 NOT0 :                                  30F3 C |  NOTDEL :                                2125 C |
 NOTEND :                                27C7 C |  NOTPLM :                                313B C |
 NUMERR :                                28EC C |  NXTLIN :                                293D C |
 OPLOAD :                                30A1 C |  OPN :                                    100 C |
 OPN_MSG :                                101 C |  OPN_MSG1 :                               14F C |
 OPSGNT :                                2F83 C |  OUTDGS :                                3310 C |
 OUTDGX :                                3330 C |  OUTDIG :                                3305 C |
 OUTFIX :                                32A4 C |  OUTFLT :                                3296 C |
 OUTNEG :                                3272 C |  OUTRNG :                                36EE C |
 OUTX10 :                                337E C |  OUTZER :                                332F C |
 OUT_DATA :                                10 - |  PARNER :                                2444 C |
 PARNUM :                                22EE C |  PARSE :                                 2399 C |
 PARSE1 :                                23C7 C |  PARSE2 :                                23DA C |
 PARSEP :                                3598 C |  PARSER :                                22D4 C |
*PATCH1 :                                2EC8 C | *PATCH2 :                                361D C |
*PATCH3 :                                28D5 C |  PCOM1 :                                 2AF2 C |
 PCOMMA :                                2ADE C |  PERIOD :                                316C C |
 PFPOUT :                                2ABB C |  PG01 :                                     2 - |
 PG26 :                                     3 - |  PG27 :                                     4 - |
 PG57 :                                     5 - |  POSEXP :                                31E0 C |
 PRIGH1 :                                3690 C |  PRIGHT :                                2503 C |
 PRINT :                                 29D4 C |  PRINT1 :                                29E5 C |
 PRINT2 :                                29F1 C |  PRINT3 :                                2A12 C |
 PRINT4 :                                2A2C C | *PRINT5 :                                2A3B C |
 PRINT6 :                                2A44 C |  PUSHIT :                                3344 C |
 QUOROT :                                2FEA C |  QUOTE :                                 2A72 C |
 QUOTE1 :                                2A7F C |  QUOTE2 :                                2AA2 C |
*QUOTER :                                2A95 C | *RELAXED :                                  0 - |
 REMOV1 :                                2860 C |  REMOVE :                                284D C |
 RESIGN :                                2E64 C |  RESTHL :                                30CA C |
 RESTSY :                                26AA C |  RETERR :                                2CDD C |
 RETURN :                                2CB3 C |  RNDX :                                  3646 C |
 ROTATL :                                306A C |  ROTATR :                                3074 C |
 ROTL :                                  306B C |  ROTR :                                  3075 C |
 RUN :                                   2927 C |  SAMLIN :                                295D C |
 SAVE :                                   15A C |  SAVEHL :                                30BA C |
 SAVESY :                                26A0 C |  SCAN1 :                                 21AC C |
 SCAN10 :                                22C1 C |  SCAN11 :                                2263 C |
 SCAN12 :                                2286 C |  SCAN13 :                                22A9 C |
 SCAN14 :                                22B0 C |  SCAN15 :                                22B7 C |
 SCAN16 :                                22BE C |  SCAN2 :                                 21C0 C |
 SCAN3 :                                 21E5 C |  SCAN4 :                                 21EF C |
 SCAN5 :                                 21FB C |  SCAN6 :                                 2207 C |
 SCAN7 :                                 221B C |  SCAN8 :                                 2234 C |
 SCAN9 :                                 2240 C |  SCANFN :                                21E9 C |
 SCRLOP :                                2730 C | *SETDCT :                                2FD0 C |
 SETIT :                                 30A5 C | *SETMCT :                                2F1D C |
 SETSUB :                                302C C |  SGNX :                                  25F0 C |
 SHACOP :                                2EC8 C |  SHIFT0 :                                2EBE C |
 SHLOOP :                                2EE7 C |  SKPNEG :                                2E9B C |
*SQR1 :                                  3626 C |  SQRCNV :                                3633 C |
 SQRERR :                                363F C |  SQREXP :                                35DC C |
 SQRLOP :                                35F1 C |  SQRX :                                  35AA C |
 STOSY1 :                                2640 C |  STOSY2 :                                2656 C |
 STOSY3 :                                266E C |  STOSY5 :                                2697 C |
 STOSYM :                                262D C |  STRCP :                                 20DA C |
 STRCPC :                                20F8 C |  STRCPE :                                20EE C |
 STRCPL :                                20E4 C |  STRIN :                                 210C C |
 STRIN1 :                                210E C |  STRINF :                                2142 C |
 SUB12 :                                 33CC C |  SUBBER :                                307E C |
*SUBEXP :                                2FC7 C |  SUBHL :                                 214B C |
 SUBTRA :                                307F C |  SWITCH :                                30D9 C |
 SYNERR :                                276A C |  SYNTAX :                                2000 C |
 SYNTOK :                                2771 C |  SYNTX1 :                                200D C |
 SYNTX2 :                                2024 C |  SYNTX3 :                                2031 C |
 SYNTX4 :                                2037 C |  SYNTX5 :                                205C C |
 SYNTX6 :                                2054 C |  SYNTX7 :                                2088 C |
 SYNTX8 :                                208D C |  SYNTXL :                                2067 C |
 TAB1 :                                  2612 C |  TABAD1 :                                2599 C |
 TABADR :                                2598 C | *TABC :                                  2622 C |
 TABLOP :                                2625 C |  TABX :                                  260F C |
 TEXTC :                                 2151 C |  TEXTCL :                                2155 C |
*TIME :                            "11:40:27" - |  TOMUCH :                                33D6 C |
*TRUE :                                     1 - |  UDEFX :                                  15B C |
*VERSION :                               142F - | *Z80SYNTAX :                                0 - |
 ZERO :                                  2ACD C |  ZERODG :                                3360 C |

    416 symbols
     38 unused symbols

 AS V1.42 Beta [Bld 290] - Source File sc1.asm - Page 4 - 7/26/2025 11:40:27


  Code Pages:
  ----------

STANDARD (0 changed characters)

1 code page

0.19 seconds assembly time

   4313 lines source file
      2 passes
      0 errors
      0 warnings
