 AS V1.42 Beta [Bld 290] - Source File sc1.asm - Page 1 - 8/12/2025 11:1:30


    1/   0 :                            ;	SCELBAL BASIC for EMU8008
    2/   0 :                            ;
    3/   0 :                            ;Gazelle states the copyright about;
    4/   0 :                            ;Converted old 8008 mnemonics to new 8008 mnemonics.
    5/   0 :                            ;Relocate code for ROM start at 2000h and RAM at lower address.
    6/   0 :                            ;Added IO routines to match the specifications of the DOS loader.
    7/   0 :                            ;
    8/   0 :                            ;	Copyright (C) 2025 by Gazelle
    9/   0 :                            ;
   10/   0 :                            ;Permission is hereby granted, free of charge, to any person
   11/   0 :                            ;obtaining a copy of this software and associated documentation
   12/   0 :                            ;files (the "Software"), to deal in the Software without
   13/   0 :                            ;restriction, including without limitation the rights to use,
   14/   0 :                            ;copy, modify, merge, publish, distribute, sublicense, and/or sell
   15/   0 :                            ;copies of the Software, and to permit persons to whom the
   16/   0 :                            ;Software is furnished to do so, subject to the following
   17/   0 :                            ;conditions:
   18/   0 :                            ;
   19/   0 :                            ;The above copyright notice and this permission notice shall be
   20/   0 :                            ;included in all copies or substantial portions of the Software.
   21/   0 :                            ;
   22/   0 :                            ;THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   23/   0 :                            ;EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
   24/   0 :                            ;OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   25/   0 :                            ;NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
   26/   0 :                            ;HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
   27/   0 :                            ;WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   28/   0 :                            ;FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   29/   0 :                            ;OTHER DEALINGS IN THE SOFTWARE.
   30/   0 :                            ;
   31/   0 :                            ;Repository https://github.com/Gazelle8087/EMU8008
   32/   0 :                            ;
   33/   0 :                            ;original source for SELBAL is available here under
   34/   0 :                            ;https://www.willegal.net/scelbi/the8008andScelbi.html
   35/   0 :                            ;
   36/   0 :                            ;2025/07/26 Rev. 1.00 Initial release
   37/   0 :                            ;2025/08/11 Rev. 1.10 remove SAVE LOAD command
   38/   0 :                            ;                     EXIT command implement (Return to DOS if run on emulator)
   39/   0 :                            ;                     MON  command implement (switch to Serial monitor)
   40/   0 :                            ;
   41/   0 :                            ;;; This is the Scelbi Basic Program from 1974 known as
   42/   0 :                            ;;; SCELBAL by Mark G. Arnold (MGA) and Nat Wadsworth  
   43/   0 :                            ;;;
   44/   0 :                            ;;;  Copyright 1975 Scelbi Computer Consulting, Inc.
   45/   0 :                            ;;;  All rights reserved
   46/   0 :                            ;;;
   47/   0 :                            ;;; MGA gives permission to use SCELBAL for 
   48/   0 :                            ;;; educational, historical, non-commercial purposes.
   49/   0 :                            ;;; Versions of this have been circulating on the web since
   50/   0 :                            ;;; about 2000; this version is authorized by MGA (Mar 2012)
   51/   0 :                            ;;; with the understanding no warranty is expressed or implied.
   52/   0 :                            ;;; As stated in the original, "no responsibility is assumed for
   53/   0 :                            ;;; for inaccuracies or for the success or failure of
   54/   0 :                            ;;; various applications to which the information herein
   55/   0 :                            ;;; may be applied."
   56/   0 :                            ;;; 
   57/   0 :                            ;;; SCELBAL is the only open-source, floating-point 
   58/   0 :                            ;;; high-level language ever implemented on Intel's first
   59/   0 :                            ;;; general-purpose microprocessor, the 8008.  It was
   60/   0 :                            ;;; published in book form:
 AS V1.42 Beta [Bld 290] - Source File sc1.asm - Page 2 - 8/12/2025 11:1:30


   61/   0 :                            ;;;
   62/   0 :                            ;;;  SCELBAL: A Higher-Level Language for 8008/8080 Systems
   63/   0 :                            ;;;
   64/   0 :                            ;;; (Tiny BASIC only used 16-bit integers; the MCM\70
   65/   0 :                            ;;; was a closed system; calculators implemented with 8008
   66/   0 :                            ;;; were floating-point, but not high-level.)
   67/   0 :                            ;;;
   68/   0 :                            ;;; This version is modified to assemble with the
   69/   0 :                            ;;; as8 assembler (using the -octal option) 
   70/   0 :                            ;;; for the Intel 8008 by Thomas E. Jones.
   71/   0 :                            ;;; This current form is made up non-relocatable so that
   72/   0 :                            ;;; locations of all code and data is identical to the
   73/   0 :                            ;;; original SCELBAL documents and patches.  It should be
   74/   0 :                            ;;; reasonable after debugging code to convert this to a
   75/   0 :                            ;;; relocatable and ROMable code with variables in RAM.
   76/   0 :                            ;;; This code originates from a version made by 
   77/   0 :                            ;;;
   78/   0 :                            ;;;    Steve Loboyko in 2001.
   79/   0 :                            ;;;
   80/   0 :                            ;;; This version has all 3 patches for SCELBAL (the two
   81/   0 :                            ;;; pasted in the original manual, and a third which was
   82/   0 :                            ;;; written in SCELBAL UPDATE publication, as well as
   83/   0 :                            ;;; a couple changes to constants which didn't actually
   84/   0 :                            ;;; require a patch, just changes to bytes of data or
   85/   0 :                            ;;; arguments to an instruction--one of these (Tucker) was 
   86/   0 :                            ;;; incorrect and restored to original by MGA March 2012).
   87/   0 :                            ;;; 
   88/   0 :                            ;;; This comment must be incorporated with any version of SCELBAL
   89/   0 :                            ;;; downloaded, distributed, posted or disemenated.
   90/   0 :                            
   91/   0 :                            		CPU	8008new
   92/   0 :                            		page	0
   93/   0 :                            
   94/   0 :                            hi		FUNCTION hex4, hex4/256		;midified by Gazelle
   95/   0 :                            lo		FUNCTION hex4, hex4&0ffh	;modified by Gazelle
   96/   0 :                            
   97/   0 :                            
   98/   0 : =1EH                       ENDPGRAM	EQU	1eh	;055o	;MGA 4/10/12 as in orig; for his ROMable Loboyko said 077       [077]
   99/   0 : =6H                        BGNPGRAM	EQU	6h	;033o	;MGA 4/10/12 as in orig; for his ROMable Loboyko said 044       [044]
  100/   0 : =2000H                     code_start	EQU	2000h
  101/   0 : =41H                       INT_PTR		EQU	41h	; DO NOT change, Should match to PIC firmware
  102/   0 : =0H                        IN_STATUS	EQU 	00h	; DO NOT change, Should match to PIC firmware
  103/   0 : =1H                        IN_DATA		EQU	01h	; DO NOT change, Should match to PIC firmware
  104/   0 : =10H                       OUT_DATA	EQU 	10h	; DO NOT change, Should match to PIC firmware
  105/   0 :                            
  106/   0 :                            ;;; Here are labels originally attempting to make the code
  107/   0 :                            ;;; relocatable.  These 4 pages contain variable data
  108/   0 :                            ;;; which needs to be relocated from ROM to RAM.
  109/   0 :                            ;;; I can't vouch for ALL references to these pages in
  110/   0 :                            ;;; the code being switched to these labels, but they
  111/   0 :                            ;;; seem to be.
  112/   0 :                            
  113/   0 : =2H                        PG01		EQU	2	;OLDPG1:	EQU	001#000
  114/   0 : =3D00H                     ORG_PG01	EQU	3D00H
  115/   0 : =3H                        PG26		EQU	3	;OLDPG26:	EQU	026#000
  116/   0 : =3E00H                     ORG_PG26	EQU	3E00H
  117/   0 : =4H                        PG27		EQU	4	;OLDPG27:	EQU	027#000
  118/   0 : =3F00H                     ORG_PG27	EQU	3F00H
  119/   0 : =5H                        PG57		EQU	5	;OLDPG57:	EQU	057#000
  120/   0 :                            
  121/   0 :                            ;;; Page zero will contain the I/O Routines.  These are actually
  122/   0 :                            ;;; just as suggested by Scelbal Manual for Serial I/O.
  123/   0 :                            
  124/2000 :                            		org	code_start
  125/2000 :                            
  126/2000 : 44 80 20                   		JMP	HAJIME
  127/2003 : 7B                         OPN:		db	OPN_MSG1 - OPN_MSG
  128/2004 : 46 61 73 74 65 72 20 53 43 OPN_MSG:	db	"Faster SCELBAL (2012)",0dh,0ah
      200D : 45 4C 42 41 4C 20 28 32 30
      2016 : 31 32 29 0D 0A            
  129/201B : 43 6F 64 65 20 52 65 6C 6F 		db	"Code Relocation, IO and start up code by Gazelle 2025",0dh,0ah
      2024 : 63 61 74 69 6F 6E 2C 20 49
      202D : 4F 20 61 6E 64 20 73 74 61
      2036 : 72 74 20 75 70 20 63 6F 64
      203F : 65 20 62 79 20 47 61 7A 65
      2048 : 6C 6C 65 20 32 30 32 35 0D
      2051 : 0A                        
  130/2052 : 52 65 76 2E 20 31 2E 31 30 		db	"Rev. 1.10 Assembled on ",DATE," at ",TIME,0dh,0ah
      205B : 20 41 73 73 65 6D 62 6C 65
      2064 : 64 20 6F 6E 20 38 2F 31 32
      206D : 2F 32 30 32 35 20 61 74 20
      2076 : 31 31 3A 31 3A 33 30 0D 0A
  131/207F : 00                         OPN_MSG1:	db	0
  132/2080 :                            
  133/2080 : 2E 20                      HAJIME:		MVI	H,OPN / 256
  134/2082 : 36 03                      		MVI	L,OPN - OPN/256*256
  135/2084 : 46 6C 22                   		CALL	TEXTC
  136/2087 :                            
  137/2087 : 1E 3D                      		MVI	D,ORG_PG01/256
  138/2089 : 26 02                      		MVI	E,PG01
  139/208B : 36 00                      		MVI	L,0
  140/208D : EB                         LOOP_PG01:	MOV	H,D
  141/208E : C7                         		MOV	A,M
  142/208F : EC                         		MOV	H,E
  143/2090 : F8                         		MOV	M,A
  144/2091 : 30                         		INR	L
  145/2092 : 48 8D 20                   		JNZ	LOOP_PG01
  146/2095 :                            
  147/2095 : 1E 3E                      		MVI	D,ORG_PG26/256
  148/2097 : 26 03                      		MVI	E,PG26
  149/2099 : 36 00                      		MVI	L,0
  150/209B : EB                         LOOP_PG26:	MOV	H,D
  151/209C : C7                         		MOV	A,M
  152/209D : EC                         		MOV	H,E
  153/209E : F8                         		MOV	M,A
  154/209F : 30                         		INR	L
  155/20A0 : 48 9B 20                   		JNZ	LOOP_PG26
  156/20A3 :                            
  157/20A3 : 1E 3F                      		MVI	D,ORG_PG27/256
  158/20A5 : 26 04                      		MVI	E,PG27
  159/20A7 : 36 00                      		MVI	L,0
  160/20A9 : EB                         LOOP_PG27:	MOV	H,D
  161/20AA : C7                         		MOV	A,M
  162/20AB : EC                         		MOV	H,E
  163/20AC : F8                         		MOV	M,A
  164/20AD : 30                         		INR	L
  165/20AE : 48 A9 20                   		JNZ	LOOP_PG27
  166/20B1 :                            
  167/20B1 : 44 25 28                   		JMP	ENTRY_SCR
  168/20B4 :                            ;---------------------------------------------------------------------
  169/20B4 :                            ;		HARDWARE DEPENDENT ROUTINE
  170/20B4 :                            EXIT:
  171/20B4 : 7F                         		OUT	1FH	; Exit from emulator.
  172/20B5 :                            
  173/20B5 :                            ;;; no user defined functions yet, stop here if we see one.
  174/20B5 : 44 D1 27                   UDEFX		JMP	exec
  175/20B8 :                            
  176/20B8 : =1EFCH                     JMP_ADDR	equ 1EFCH
  177/20B8 :                            
  178/20B8 : 2E 1E                      MON:		MVI H,hi(JMP_ADDR)
  179/20BA : 36 FC                      		MVI L,lo(JMP_ADDR)
  180/20BC : 3E 55                      		MVI M,55H	; store "OUT 10" instruction at 'jmp_addr'  
  181/20BE : 30                         		INR L
  182/20BF : 3E 44                      		MVI M,44H	; store "JMP" instruction at 'jmp_addr'+1
  183/20C1 : 30                         		INR L
  184/20C2 : 3E 00                      		MVI M,00H	; store "00H" (the lo byte of address 2000H) at 'jmp_addr'+2
  185/20C4 : 30                         		INR L
  186/20C5 : 3E 20                      		MVI M,20H	; store "20H" (the hi byte of address 2000H) at 'jmp_addr'+3
  187/20C7 : 06 00                      		MVI A,00H	; ROM access offset(=00) for first 8K of ROM area
  188/20C9 : 44 FC 1E                   		JMP JMP_ADDR 	; jump to the beginning monitor the first bank 8K of ROM
  189/20CC :                            
  190/20CC : 41                         CINP:		IN	IN_STATUS
  191/20CD : 24 01                      		ANI	1
  192/20CF : 68 CC 20                   		JZ	CINP
  193/20D2 :                            
  194/20D2 : 43                         		IN	IN_DATA
  195/20D3 : 3C 08                      		CPI	08H
  196/20D5 : 68 DC 20                   		JZ	CINP_BS
  197/20D8 : 61                         		OUT	OUT_DATA
  198/20D9 : 34 80                      		ORI	80H
  199/20DB : 07                         		RET
  200/20DC :                            
  201/20DC : 06 FF                      CINP_BS:	MVI	A,0FFH
  202/20DE : 07                         		RET
  203/20DF :                            
  204/20DF : 3C DC                      CPRINT:		CPI	0DCH
  205/20E1 : 68 FF 20                   		JZ	CP_BS
  206/20E4 : 24 7F                      		ANI	7Fh
  207/20E6 : 3C 0D                      		CPI	0DH
  208/20E8 : 68 F5 20                   		JZ	CP_OK
  209/20EB : 3C 0A                      		CPI	0AH
  210/20ED : 68 F5 20                   		JZ	CP_OK
  211/20F0 : 3C 20                      		CPI	20H
  212/20F2 : 60 FE 20                   		JC	CP_NO
  213/20F5 :                            
  214/20F5 : E8                         CP_OK:		MOV	H,A
  215/20F6 : 41                         CPRINT_1:	IN	IN_STATUS
  216/20F7 : 24 02                      		ANI	2
  217/20F9 : 68 F6 20                   		JZ	CPRINT_1
  218/20FC : C5                         		MOV	A,H
  219/20FD : 61                         		OUT	OUT_DATA
  220/20FE : 07                         CP_NO:		RET
  221/20FF :                            
  222/20FF : 41                         CP_BS:		IN	IN_STATUS
  223/2100 : 24 02                      		ANI	2
  224/2102 : 68 FF 20                   		JZ	CP_BS
  225/2105 : 06 08                      		MVI	A,08H
  226/2107 : 61                         		OUT	OUT_DATA
  227/2108 :                            
  228/2108 : 41                         CP_BS2:		IN	IN_STATUS
  229/2109 : 24 02                      		ANI	2
  230/210B : 68 08 21                   		JZ	CP_BS2
  231/210E : 06 20                      		MVI	A,20H
  232/2110 : 61                         		OUT	OUT_DATA
  233/2111 :                            
  234/2111 : 41                         CP_BS3:		IN	IN_STATUS
  235/2112 : 24 02                      		ANI	2
  236/2114 : 68 11 21                   		JZ	CP_BS3
  237/2117 : 06 08                      		MVI	A,08H
  238/2119 : 61                         		OUT	OUT_DATA
  239/211A : 07                         		RET
  240/211B :                            
  241/211B :                            ;           ORG	code_start	;002#000		; START PAGE 02, THE CODE
  242/211B :                            
  243/211B : 46 C8 21                   SYNTAX:    CALL	CLESYM		;Clear the SYMBOL BUFFER area
  244/211E : 36 E0                                 MVI	L,0e0h	;340o	;Set L to start of LINE NUMBER BUFFER
  245/2120 : 2E 03                                 MVI	H,PG26	;	;** Set H to page of LINE NUMBER BUFFER
  246/2122 : 3E 00                                 MVI	M,0	;000o	;Initialize line number buff by placing zero as (cc)
  247/2124 : 36 81                                 MVI	L, 201o		;Change pointer to syntax counter/pointer storage loc.
  248/2126 : 3E 01                                 MVI	M, 001o		;Set pointer to first character (after cc) in line buffer
  249/2128 : 36 81                      SYNTX1:    MVI	L, 201o		;Set pointer to syntax cntr/pntr storage location
  250/212A : 46 BB 21                              CALL	GETCHR		;Fetch the character pointed to by contents of syntax
  251/212D : 68 3F 21                              JZ	SYNTX2		;Cntr/pntr from the line input buffer. If character was
  252/2130 : 3C B0                                 CPI	260o		;A space, ignore. Else, test to see if character was ASCII
  253/2132 : 70 4C 21                              JM	SYNTX3		;Code for a decimal digit. If not a decimal digit, consider
  254/2135 : 3C BA                                 CPI	272o		;Line number to have been processed by jumping
  255/2137 : 50 4C 21                              JP	SYNTX3		;Over the remainder of this SYNTX1 section.
  256/213A : 36 E0                                 MVI	L, 340o		;If have decimal digit, set pointer to start of LINE
  257/213C : 46 E7 21                              CALL	CONCT1		;NUMBER BUFFER and append incoming digit there.
  258/213F : 36 81                      SYNTX2:    MVI	L, 201o		;Reset L to syntax cntr/pntr storage location. Call sub-
  259/2141 : 46 1E 22                              CALL	LOOP		;Routine to advance pntr and test for end of inr)ut buffer
  260/2144 : 48 28 21                              JNZ	SYNTX1		;If not end of input buffer, go back for next digit
  261/2147 : 36 83                                 MVI	L, 203o		;If end of buffer, only had a line number in the line.
  262/2149 : 3E 00                                 MVI	M, 000o		;Set pntr to TOKEN storage location. Set TOKEN = 000.
  263/214B : 07                                    RET			;Return to caller.
  264/214C : 36 81                      SYNTX3:    MVI	L, 201o		;Reset pointer to syntax cntr/pntr and fetch
  265/214E : CF                                    MOV	B,M		;Position of next character after the line number
  266/214F : 36 82                                 MVI	L, 202o		;Change pntr to SCAN pntr storage location
  267/2151 : F9                                    MOV	M,B		;Store address when SCAN takes up after line number
  268/2152 : 36 82                      SYNTX4:    MVI	L, 202o		;Set pntr to SCAN pntr stomge location
  269/2154 : 46 BB 21                              CALL	GETCHR		;Fetch the character pointed to by contents of the SCAN
  270/2157 : 68 6F 21                              JZ	SYNTX6		;Pointer storage location. If character was ASCII code
  271/215A : 3C BD                                 CPI	275o		;For space, ignore. Else, compare character with "=" sign
  272/215C : 68 A3 21                              JZ	SYNTX7		;If is an equal sign, go set TOKEN for IMPLIED LET.
  273/215F : 3C A8                                 CPI	250o		;Else, compare character with left parenthesis " ( "
  274/2161 : 68 A8 21                              JZ	SYNTX8		;If left parenthesis, go set TOKEN for implied array LET
  275/2164 : 46 E3 21                              CALL	CONCTS		;Otherwise, concatenate the character onto the string
  276/2167 :                            				; MGA 4/2012 begin "fast SYNTX5" patch: 
  277/2167 :                            				; the following patch doubles the overall speed of execution.  
  278/2167 :                            				; It is similar to the approach taken on 8080 SCELBAL II in 1978 
  279/2167 :                            				; it adhears to the rules for patches in issue 1 of SCELBAL update 
  280/2167 :                            				;SYNTX6:   these four lines moved up w/o label
  281/2167 : 36 82                                 MVI	L, 202o		;Set L to SCAN pointer storage location
  282/2169 :                            				;LHI \HB\OLDPG26       ;** Set H to page of SCAN pointer stomge location
  283/2169 :                            				;MGA 4/2012 except LHI needed at original place, not here 
  284/2169 : 46 1E 22                              CALL	LOOP		;Call routine to advance pntr & test for end of In buffer
  285/216C : 48 52 21                              JNZ	SYNTX4		;Go back and add another character to SYMBOL BUFF
  286/216F :                            SYNTX6:   			; MGA 4/2012 label here 
  287/216F : 36 83                                 MVI	L, 203o		;Being constructed in the SYMBOL BUFFER. Now set
  288/2171 : 3E 01                                 MVI	M, 001o		;Up TOKEN storage location to an initial value of 001.
  289/2173 : 2E 04                                 MVI	H,PG27		;\HB\OLDPG27   ;** Set H to point to start of KEYWORD TABLE.
  290/2175 : 36 00                                 MVI	L, 000o		;Set L to point to start of KEYWORD TABLE.
  291/2177 : 1E 03                      SYNTX5:    MVI	D,PG26		;\HB\OLDPG26   ;** Set D to page of SYMBOL BUFFER
  292/2179 : 26 50                                 MVI	E, 120o		;Set E to start of SYMBOL BUFFER
  293/217B : 46 F5 21                              CALL	STRCP		;Compare char string presently in SYMBOL BUFFER
  294/217E : 2B                                    RZ			;With entry in KEYWORD TABLE. Exit if match.
  295/217F : 46 F4 31                              CALL	SWITCH		;TOKEN will be set to keyword found. Else, switch
  296/2182 : 30                         SYNTXL:    INR	L		;Pointers to get table address back and advance pntr to
  297/2183 : C7                                    MOV	A,M		;KEYWORD TABLE. Now look for start of next entry
  298/2184 : 24 C0                                 ANI	300o		;In KEYWORD TABLE by looking for (cc) byte which
  299/2186 : 48 82 21                              JNZ	SYNTXL             ;Will NOT have a one in the two most sig. bits. Advance
  300/2189 : 46 F4 31                              CALL	SWITCH             ;Pntr til next entry found. Then switch pointers apin so
  301/218C : 36 83                                 MVI	L, 203o               ;Table pointer is in D&E. Put addr of TOKEN in L.
  302/218E : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** And page of TOKEN in H. Fetch the value currently
  303/2190 : CF                                    MOV	B,M                    ;In TOKEN and advance it to account for going on to
  304/2191 : 08                                    INR	B                    ;The next entry in the KEYWORD TABLE.
  305/2192 : F9                                    MOV	M,B                    ;Restore the updated TOKEN value back to storage.
  306/2193 : 46 F4 31                              CALL	SWITCH             ;Restore the keyword table pointer back to H&L.
  307/2196 : C1                                    MOV	A,B                    ;Put TOKEN count in ACC.
  308/2197 : 3C 0D                                 CPI	015o               ;See if have tested all entries in the keyword table.
  309/2199 : 48 77 21                              JNZ	SYNTX5             ;If not, continue checking the keyword table.
  310/219C :                            				;MGA 4/2012 3 of 4 lines removed below (keep LHI)
  311/219C : 2E 16                                 MVI	H, 26o	;\HB\OLDPG26        ;** Set H to page of SCAN pointer stomge location
  312/219E :                            				; MGA 4/2012 end of "fast SYNTX5" patch: 
  313/219E : 36 83                                 MVI	L, 203o               ;And search table for KEYWORD again. Unless reach
  314/21A0 : 3E FF                                 MVI	M, 377o               ;End of line input buffer. In which case set TOKEN=377
  315/21A2 : 07                                    RET                    ;As an error indicator and exit to caMVI L,ng routine.
  316/21A3 : 36 83                      SYNTX7:    MVI	L, 203o               ;Set pointer to TOKEN storage register. Set TOKEN
  317/21A5 : 3E 0D                                 MVI	M, 015o               ;Equal to 015 when "=" sign found for IMPLIED LET.
  318/21A7 : 07                                    RET                    ;Exit to caMVI L,ng routine.
  319/21A8 : 36 83                      SYNTX8:    MVI	L, 203o               ;Set pointer to TOKEN storage register. Set TOKEN
  320/21AA : 3E 0E                                 MVI	M, 016o               ;Equal to 016 when "(" found for IMPLIED array LET.
  321/21AC : 07                                    RET                    ;Exit to calling routine.
  322/21AD :                            
  323/21AD :                                                              ;The following are subroutines used by SYNTAX and
  324/21AD :                                                              ;other routines in SCELBAL.
  325/21AD :                            
  326/21AD : 06 C2                      BIGERR:    MVI	A, 302o               ;Load ASCII code for letters B and G to indicate BIG
  327/21AF : 16 C7                                 MVI	C, 307o               ;ERROR (for when buffer, stack,etc., overflows).
  328/21B1 : 46 9D 22                   ERROR:     CALL	ECHO               ;Call user provided display routine to print ASCII code
  329/21B4 : C2                                    MOV	A,C                    ;In accumulator. Transfer ASCII code from C to ACC
  330/21B5 : 46 9D 22                              CALL	ECHO               ;And repeat to display error codes.
  331/21B8 : 44 D6 29                              JMP	FINERR             ;Go cpmplete error message (AT LINE) as required.
  332/21BB : C7                         GETCHR:    MOV	A,M                    ;Get pointer from memory location pointed to by H&L
  333/21BC : 3C 50                                 CPI	120o               ;See if within range of line input buffer.
  334/21BE : 50 AD 21                              JP	BIGERR             ;If not then have an overflow condition = error.
  335/21C1 : F0                                    MOV	L,A                    ;Else can use it as addr of character to fetch from the
  336/21C2 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** LINE INPUT BUFFER by setting up H too.
  337/21C4 : C7                                    MOV	A,M                    ;Fetch the character from the line input buffer.
  338/21C5 : 3C A0                                 CPI	240o               ;See if it is ASCII code for space.
  339/21C7 : 07                                    RET                    ;Return to caller with flags set according to comparison.
  340/21C8 : 36 50                      CLESYM:    MVI	L, 120o               ;Set L to start of SYMBOL BUFFER.
  341/21CA : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of SYMBOL BUFFER.
  342/21CC : 3E 00                                 MVI	M, 000o               ;Place a zero byte at start of SYMBOL BUFFER.
  343/21CE : 07                                    RET                    ;To effectively clear the buffer. Then exit to caller.
  344/21CF :                            
  345/21CF :                            
  346/21CF :                                                              ;Subroutine to concatenate (append) a character to the
  347/21CF :                                                              ;SYMBOL BUFFER. Character must be alphanumeric.
  348/21CF :                            
  349/21CF : 3C C1                      CONCTA:    CPI	301o               ;See if character code less than that for letter A.
  350/21D1 : 70 D9 21                              JM	CONCTN             ;If so, go see if it is numeric.
  351/21D4 : 3C DB                                 CPI	333o               ;See if character code greater than that for letter Z.
  352/21D6 : 70 E3 21                              JM	CONCTS             ;If not, have valid alphabetical character.
  353/21D9 : 3C B0                      CONCTN:    CPI	260o               ;Else, see if character in valid numeric range.
  354/21DB : 70 F2 21                              JM	CONCTE             ;If not, have an error condition.
  355/21DE : 3C BA                                 CPI	272o               ;Continue to check for valid number.
  356/21E0 : 50 F2 21                              JP	CONCTE             ;If not, have an error condition.
  357/21E3 : 36 50                      CONCTS:    MVI	L, 120o               ;If character alphanumeric, can concatenate. Set pointer
  358/21E5 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** To starting address of SYMBOL BUFFER.
  359/21E7 : D7                         CONCT1:    MOV	C,M                    ;Fetch old character count in SYMBOL BUFFER.
  360/21E8 : 10                                    INR	C                    ;Increment the value to account for adding new
  361/21E9 : FA                                    MOV	M,C                    ;Character to the buffer. Restore updated (cc).
  362/21EA : C8                                    MOV	B,A                    ;Save character to be appended in register B.
  363/21EB : 46 24 32                              CALL	INDEXC             ;Add (cc) to address in H & L to get new end of buffer
  364/21EE : F9                                    MOV	M,B                    ;Address and append the new character to buffer
  365/21EF : 06 00                                 MVI	A, 000o               ;Clear the accumulator
  366/21F1 : 07                                    RET                    ;Exit to caller
  367/21F2 : 44 85 28                   CONCTE:    JMP	SYNERR             ;If character to be appended not alphanumeric, ERROR!
  368/21F5 :                            
  369/21F5 :                                                              ;Subroutine to compare
  370/21F5 :                                                              ;character strings pointed to by
  371/21F5 :                                                              ;register pairs D & E and H & L.
  372/21F5 :                            
  373/21F5 : C7                         STRCP:     MOV	A,M                    ;Fetch (cc) of first string.
  374/21F6 : 46 F4 31                              CALL	SWITCH             ;Switch pointers and fetch length of second string (cc)
  375/21F9 : CF                                    MOV	B,M                    ;Into register B. Compare the lengths of the two strings.
  376/21FA : B9                                    CMP	B                    ;If they are not the same
  377/21FB : 0B                                    RNZ                    ;Return to caller with flags set to non-zero condition
  378/21FC : 46 F4 31                              CALL	SWITCH             ;Else, exchange the pointers back to first string.
  379/21FF : 46 1A 22                   STRCPL:    CALL	ADV                ;Advance the pointer to string number 1 and fetch a
  380/2202 : C7                                    MOV	A,M                    ;Character from that string into the accumulator.
  381/2203 : 46 F4 31                              CALL	SWITCH             ;Now switch the pointers to string number 2.
  382/2206 : 46 1A 22                              CALL	ADV                ;Advance the pointer in line number 2.
  383/2209 : BF                         STRCPE:    CMP	M                    ;Compare char in stxing 1 (ACC) to string 2 (memory)
  384/220A : 0B                                    RNZ                    ;If not equal, return to cauer with flags set to non-zero
  385/220B : 46 F4 31                              CALL	SWITCH             ;Else, exchange pointers to restore pntr to string 1
  386/220E : 09                                    DCR	B                    ;Decrement the string length counter in register B
  387/220F : 48 FF 21                              JNZ	STRCPL             ;If not finiahed, continue testing entire string
  388/2212 : 07                                    RET                    ;If complete match, return with flag in zero condition
  389/2213 : C7                         STRCPC:    MOV	A,M                    ;Fetch character pointed to by pointer to string 1
  390/2214 : 46 F4 31                              CALL	SWITCH             ;Exchange pointer to examine string 2
  391/2217 : 44 09 22                              JMP	STRCPE             ;Continue the string comparison loop
  392/221A :                            
  393/221A :                                                              ;Subroutine to advance the two byte
  394/221A :                                                              ;value in CPU registers H and L.
  395/221A :                            
  396/221A : 30                         ADV:       INR	L                    ;Advance value in register L.
  397/221B : 0B                                    RNZ                    ;If new value not zero, return to caller.
  398/221C : 28                                    INR	H                    ;Else must increment value in H
  399/221D : 07                                    RET                    ;Before retuming to caller
  400/221E :                            
  401/221E :                                                              ;Subroutine to advance a buffer pointer
  402/221E :                                                              ;and test to see if the end of the buffer
  403/221E :                                                              ;has been reached.
  404/221E :                            
  405/221E : CF                         LOOP:      MOV	B,M                    ;Fetch memory location pointed to by H & L into B.
  406/221F : 08                                    INR	B                    ;Increment the value.
  407/2220 : F9                                    MOV	M,B                    ;Restore it back to memory.
  408/2221 : 36 00                                 MVI	L, 000                ;Change pointer to start of INPUT LINE BUFFER
  409/2223 : C7                                    MOV	A,M                    ;Fetch buffer length (cc) value into the accumulator
  410/2224 : 09                                    DCR	B                    ;Make value in B original value
  411/2225 : B9                                    CMP	B                    ;See if buffer length same as that in B
  412/2226 : 07                                    RET                    ;Return with flags yielding results of the comparison
  413/2227 :                            
  414/2227 :                                                              ;The following subroutine is used to
  415/2227 :                                                              ;input characters from the system's
  416/2227 :                                                              ;input device (such as a keyboard)
  417/2227 :                                                              ;into the LINE INPUT BUFFER. Routine has limited
  418/2227 :                                                              ;editing capability included.
  419/2227 :                                                              ;(Rubout = delete previous character(s) entered.)
  420/2227 :                            ;;; This label, STRIN:	should be location 03 014 030ch
  421/2227 : 16 00                      STRIN:     MVI	C, 000                ;Initialize register C to zero.
  422/2229 : 46 AC 22                   STRIN1:    CALL	CINPUT             ;Call user provided device input subroutine to fetch one
  423/222C : 3C FF                                 CPI	0FFH	;modifiedby gazelle 2025/6/1 ;377o  ;Character from the input device. Is it ASCII code for
  424/222E : 48 40 22                              JNZ	NOTDEL             ;Rubout? Skip to next section if not rubout.
  425/2231 :                            ;          MVI	A, 0DCH	;modified by Gazelle 2025/6/1 ;334o ;Else, load ASCII code for backslash into ACC.
  426/2231 :                            ;          CALL	ECHO	;modified by gazelle 2025/6/1 ;Call user display driver to present backslash as a delete
  427/2231 : 11                                    DCR	C                    ;Indicator. Now decrement the input character counter.
  428/2232 : 70 27 22                              JM	STRIN              ;If at beginning of line do NOT decrement H and L.
  429/2235 : 46 8F 22                              CALL	DEC                ;Else, decrement H & L line pointer to erase previous
  430/2238 : 06 DC                                 MVI	A, 0DCH	;modified by gazelle 2025/6/1
  431/223A : 46 9D 22                              CALL	ECHO	;modified by gazelle 2025/6/1
  432/223D :                            
  433/223D : 44 29 22                              JMP	STRIN1             ;Entry, then go back for a new input.
  434/2240 : 3C 83                      NOTDEL:    CPI	203o               ;See if character inputted was'CONTROL C'
  435/2242 : 68 CF 29                              JZ	CTRLC              ;If so, stop inputting and go back to the EXECutive
  436/2245 : 3C 8D                                 CPI	215o               ;If not, see if character was carriage-return
  437/2247 : 68 5D 22                              JZ	STRINF             ;If so, have end of line of input
  438/224A : 3C 8A                                 CPI	212o               ;If not, see if character was line-feed
  439/224C : 68 29 22                              JZ	STRIN1             ;If so, ignore the input, get another character
  440/224F : 46 1A 22                              CALL	ADV                ;If none of the above, advance contents of H & L
  441/2252 : 10                                    INR	C                    ;Increment the character counter
  442/2253 : F8                                    MOV	M,A                    ;Store the new character in the line input buffer
  443/2254 : C2                                    MOV	A,C                    ;Put new character count in the accumulator
  444/2255 : 3C 50                                 CPI	120o               ;Make sure maximum buffer size not exceeded
  445/2257 : 50 AD 21                              JP	BIGERR             ;If buffer size exceeded, go display BG error message
  446/225A : 44 29 22                              JMP	STRIN1             ;Else can go back to look for next input
  447/225D : CA                         STRINF:    MOV	B,C                    ;Transfer character count from C to B
  448/225E : 46 66 22                              CALL	SUBHL              ;Subtract B from H & L to get starting address of
  449/2261 : FA                                    MOV	M,C                    ;The string and place the character count (cc) there
  450/2262 : 46 7C 22                              CALL	CRLF               ;Provide a line ending CR & LF combination on the
  451/2265 : 07                                    RET                    ;Display device. Then exit to caller.
  452/2266 :                            
  453/2266 :                                                              ;Subroutine to subtract contents of CPU register B from
  454/2266 :                                                              ;the two byte value in CPU registers H & L.
  455/2266 :                            
  456/2266 : C6                         SUBHL:     MOV	A,L                    ;Load contents of register L into the accumulator
  457/2267 : 91                                    SUB	B                    ;Subtract the contents of register B
  458/2268 : F0                                    MOV	L,A                    ;Restore the new value back to L
  459/2269 : 03                                    RNC                    ;If no carry, then no underflow. Exit to caller.
  460/226A : 29                                    DCR	H                    ;Else must also decrement contents of H.
  461/226B : 07                                    RET                    ;Before retuming to caller.
  462/226C :                            
  463/226C :                                                              ;Subroutine to display a character string on the system's
  464/226C :                                                              ;display device.
  465/226C :                            
  466/226C : D7                         TEXTC:     MOV	C,M                    ;Fetch (cc) from the first location in the buffer (H & L
  467/226D : C7                                    MOV	A,M                    ;Pointing there upon entry) into register B and ACC.
  468/226E : A0                                    ANA	A                    ;Test the character count value.
  469/226F : 2B                                    RZ                    ;No display if (cc) is zero.
  470/2270 : 46 1A 22                   TEXTCL:    CALL	ADV                ;Advance pointer to next location in buffer
  471/2273 : C7                                    MOV	A,M                    ;Fetch a character from the buffer into ACC
  472/2274 : 46 9D 22                              CALL	ECHO               ;Call the user's display driver subroutine
  473/2277 : 11                                    DCR	C                    ;Decrement the (cc)
  474/2278 : 48 70 22                              JNZ	TEXTCL             ;If character counter not zero, continue display
  475/227B : 07                                    RET                    ;Exit to caller when (cc) is zero.
  476/227C :                            
  477/227C :                                                              ;Subroutine to provide carriage-return and line-feed
  478/227C :                                                              ;combination to system's display device. Routine also
  479/227C :                                                              ;initializes a column counter to zero. Column counter
  480/227C :                                                              ;is used by selected output routines to count the num-
  481/227C :                                                              ;ber of characters that have been displayed on a line.
  482/227C :                            
  483/227C : 06 8D                      CRLF:      MVI	A, 215o               ;Load ASCII code for carriage-return into ACC
  484/227E : 46 9D 22                              CALL	ECHO               ;Call user provided display driver subroutine
  485/2281 : 06 8A                                 MVI	A, 212o               ;Load ASCII code for line-feed into ACC
  486/2283 : 46 9D 22                              CALL	ECHO               ;Call user provided display driver subroutine
  487/2286 : 36 23                                 MVI	L, 043o               ;Set L to point to COLUMN COUNTER storage location
  488/2288 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of COLUMN COUNTER
  489/228A : 3E 01                                 MVI	M, 001o               ;Initialize COLUMN COUNTER to a value of one
  490/228C : EB                                    MOV	H,D                    ;Restore H from D (saved by ECHO subroutine)
  491/228D : F4                                    MOV	L,E                    ;Restore L from E (saved by ECHO subroutine)
  492/228E : 07                                    RET                    ;Then exit to calling routine
  493/228F :                            
  494/228F :                                                              ;Subroutine to decrement double-byte value in CPU
  495/228F :                                                              ;registers H and L.
  496/228F :                            
  497/228F : 31                         DEC:       DCR	L                    ;Decrement contents of L
  498/2290 : 30                                    INR	L                    ;Now increment to exercise CPU flags
  499/2291 : 48 95 22                              JNZ	DECNO              ;If L not presently zero, skip decrementing H
  500/2294 : 29                                    DCR	H                    ;Else decrement H
  501/2295 : 31                         DECNO:     DCR	L                    ;Do the actual decrement of L
  502/2296 : 07                                    RET                    ;Return to caller
  503/2297 :                            
  504/2297 :                            
  505/2297 :                                                              ;Subroutine to index the value in CPU registers H and L
  506/2297 :                                                              ;by the contents of CPU register B.
  507/2297 :                            
  508/2297 : C6                         INDEXB:    MOV	A,L                    ;Load L into the accumulator
  509/2298 : 81                                    ADD	B                    ;Add B to that value
  510/2299 : F0                                    MOV	L,A                    ;Restore the new value to L
  511/229A : 03                                    RNC                    ;If no carry,  return to caller
  512/229B : 28                                    INR	H                    ;Else, increment value in H
  513/229C : 07                                    RET                    ;Before returning to caller
  514/229D :                            
  515/229D :                                                              ;The following subroutine is used to
  516/229D :                                                              ;display the ASCII encoded character in the ACC on the
  517/229D :                                                              ;system's display device. This routine calls a routine
  518/229D :                                                              ;labeled CINPUT which must be provided by the user to
  519/229D :                                                              ;actually drive the system's output device. The subroutine
  520/229D :                                                              ;below also increments an output column counter each time
  521/229D :                                                              ;it is used.
  522/229D :                            
  523/229D : DD                         ECHO:      MOV	D,H                    ;Save entry value of H in register D
  524/229E : E6                                    MOV	E,L                    ;And save entry value of L in register E
  525/229F : 36 23                                 MVI	L, 043o               ;Set L to point to COLUMN COUNTER storage location
  526/22A1 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of COLUMN COUNTER
  527/22A3 : CF                                    MOV	B,M                    ;Fetch the value in the COLUMN COUNTER
  528/22A4 : 08                                    INR	B                    ;And increment it for each character displayed
  529/22A5 : F9                                    MOV	M,B                    ;Restore the updated count in memory
  530/22A6 : 46 DF 20                              CALL	CPRINT             ;tt Call the user's device driver subroutine
  531/22A9 : EB                                    MOV	H,D                    ;Restore entry value of H from D
  532/22AA : F4                                    MOV	L,E                    ;Restore entry value of L from E
  533/22AB : 07                                    RET                    ;Return to calling routine
  534/22AC : 44 CC 20                   CINPUT:	   JMP	CINP               ;Reference to user defined input subroutine
  535/22AF :                            
  536/22AF :                            ;;; The label EVAL: SHOULD BE AT 03 224 0394h
  537/22AF : 36 97                      EVAL:      MVI	L, 227o               ;Load L with address of ARITHMETIC STACK pointer
  538/22B1 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of ARITHMETIC STACK pointer
  539/22B3 : 3E 94                                 MVI	M, 224o               ;Initialize ARITH STACK pointer value to addr minus 4
  540/22B5 : 30                                    INR	L                    ;Advance memory pointer to FUN/ARRAY STACK pntr
  541/22B6 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of FUN/ARRAY STACK pointer
  542/22B8 : 3E 00                                 MVI	M, 000o               ;Initialize FUNIARRAY STACK pointer to start of stack
  543/22BA : 46 C8 21                              CALL	CLESYM             ;Initialize the SYMBOL BUFFER to empty condition
  544/22BD : 36 88                                 MVI	L, 210o               ;Load L with address of OPERATOR STACK pointer
  545/22BF : 3E 00                                 MVI	M, 000                ;Initialize OPERATOR STACK pointer value
  546/22C1 : 36 BE                                 MVI	L, 276o               ;Set L to address of EVAL pointer (start of expression)
  547/22C3 : CF                                    MOV	B,M                    ;Fetch the EVAL pointer value into register B
  548/22C4 : 36 80                                 MVI	L, 200o               ;Set up a working pointer register in this location
  549/22C6 : F9                                    MOV	M,B                    ;And initialize EVAL CURRENT pointer
  550/22C7 : 36 80                      SCAN1:     MVI	L, 200o               ;Load L with address of EVAL CURRENT pointer
  551/22C9 : 46 BB 21                              CALL	GETCHR             ;Fetch a character in the expression being evaluated
  552/22CC : 68 DC 23                              JZ	SCAN10             ;If character is a space, jump out of this section
  553/22CF : 3C AB                                 CPI	253o               ;See if character is a "+" sign
  554/22D1 : 48 DB 22                              JNZ	SCAN2              ;If not, continue checking for an operator
  555/22D4 : 36 7E                                 MVI	L, 176o               ;If yes, set pointer to PARSER TOKEN storage location
  556/22D6 : 3E 01                                 MVI	M, 001                ;Place TOKEN value for "+" sign in PARSER TOKEN
  557/22D8 : 44 04 23                              JMP	SCANFN             ;Go to PARSER subroutine entry point
  558/22DB : 3C AD                      SCAN2:     CPI	255o               ;See if character is a minus ("-") sign
  559/22DD : 48 0A 23                              JNZ	SCAN4              ;If not, continue checking for an operator
  560/22E0 : 36 50                                 MVI	L, 120o               ;If yes, check the length of the symbol stored in the
  561/22E2 : C7                                    MOV	A,M                    ;SYMBOL BUFFER by fetching the (cc) byte
  562/22E3 : A0                                    ANA	A                    ;And testing to see if (cc) is zero
  563/22E4 : 48 00 23                              JNZ	SCAN3              ;If length not zero, then not a unary minus indicator
  564/22E7 : 36 7E                                 MVI	L, 176o               ;Else, check to see if last operator was a right parenthesi
  565/22E9 : C7                                    MOV	A,M                    ;By fetching the value in the PARSER TOKEN storage
  566/22EA : 3C 07                                 CPI	007                ;Location and seeing if it is token value for ")"
  567/22EC : 68 00 23                              JZ	SCAN3              ;If last operator was I')" then do not have a unary minus
  568/22EF : 3C 03                                 CPI	003                ;Check to see if last operator was C4*~2
  569/22F1 : 68 85 28                              JZ	SYNERR             ;If yes, then have a syntax error
  570/22F4 : 3C 05                                 CPI	005                ;Check to see if last operator was exponentiation
  571/22F6 : 68 85 28                              JZ	SYNERR             ;If yes, then have a syntax error
  572/22F9 : 36 50                                 MVI	L, 120o               ;If none of the above, then minus sign is unary, put
  573/22FB : 3E 01                                 MVI	M, 001                ;Character string representing the
  574/22FD : 30                                    INR	L                    ;Value zero in the SYMBOL BUFFER in string format
  575/22FE : 3E B0                                 MVI	M, 260o               ;(Character count (cc) followed by ASCII code for zero)
  576/2300 : 36 7E                      SCAN3:     MVI	L, 176o               ;Set L to address of PARSER TOKEN storage location
  577/2302 : 3E 02                                 MVI	M, 002                ;Set PARSER TOKEN value for minus operator
  578/2304 : 46 EF 23                   SCANFN:    CALL	PARSER             ;Call the PARSER subroutine to process current symbol
  579/2307 : 44 DC 23                              JMP	SCAN10             ;And operator. Then jump to continue processing.
  580/230A : 3C AA                      SCAN4:     CPI	252o               ;See if character fetched from expression is
  581/230C : 48 16 23                              JNZ	SCAN5              ;If not, continue checking for an operator
  582/230F : 36 7E                                 MVI	L, 176o               ;If yes, set pointer to PARSER TOKEN storage location
  583/2311 : 3E 03                                 MVI	M, 003                ;Place TOKEN value for "*" (multiplication) operator in
  584/2313 : 44 04 23                              JMP	SCANFN             ;PARSER TOKEN and go to PARSER subroutine entry
  585/2316 : 3C AF                      SCAN5:     CPI	257o               ;See if character fetched from expression is
  586/2318 : 48 22 23                              JNZ	SCAN6              ;If not, continue checking for an operator
  587/231B : 36 7E                                 MVI	L, 176o               ;If yes, set pointer to PARSER TOKEN storage location
  588/231D : 3E 04                                 MVI	M, 004                ;Place TOKEN value for "/" (division) operator in
  589/231F : 44 04 23                              JMP	SCANFN             ;PARSER TOKEN and go to PARSER subroutine entry
  590/2322 : 3C A8                      SCAN6:     CPI	250o               ;See if character fetched from expression is
  591/2324 : 48 36 23                              JNZ	SCAN7              ;If not, continue checking for an operator
  592/2327 : 36 98                                 MVI	L, 230o               ;If yes, load L with address of FUN/ARRAY STACK
  593/2329 : CF                                    MOV	B,M                    ;Pointer. Fetch the value in the stack pointer. Increment
  594/232A : 08                                    INR	B                    ;It to indicate number of "(" operators encountered.
  595/232B : F9                                    MOV	M,B                    ;Restore the updated stack pointer back to memory
  596/232C : 46 5B 26                              CALL	FUNARR             ;Call subroutine to process possible FUNCTION or
  597/232F : 36 7E                                 MVI	L, 176o               ;ARRAY variable subscript. Ihen set pointer to
  598/2331 : 3E 06                                 MVI	M, 006                ;PARSER TOKEN storage and set value for operator
  599/2333 : 44 04 23                              JMP	SCANFN             ;Go to PARSER subroutine entry point.
  600/2336 : 3C A9                      SCAN7:     CPI	251o               ;See if character fetched from expression is
  601/2338 : 48 4F 23                              JNZ	SCAN8              ;If not, continue checking for an operator
  602/233B : 36 7E                                 MVI	L, 176o               ;If yes, load L with address of PARSER TOKEN
  603/233D : 3E 07                                 MVI	M, 007                ;Set PARSER TOKEN value to reflect ")"
  604/233F : 46 EF 23                              CALL	PARSER             ;Call the  PARSER subroutine to process current symbol
  605/2342 :                            
  606/2342 : 46 1E 26                              CALL	PRIGHT             ;Call subroutine to handle FUNCTION or ARRAY
  607/2345 : 36 98                                 MVI	L, 230o               ;Load L with address of FUN/ARRAY STACK pointer
  608/2347 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of FUN/ARRAY STACK pointer
  609/2349 : CF                                    MOV	B,M                    ;Fetch the value in the stack pointer. Decrement it
  610/234A : 09                                    DCR	B                    ;To account for left parenthesis just processed.
  611/234B : F9                                    MOV	M,B                    ;Restore the updated value back to memory.
  612/234C : 44 DC 23                              JMP	SCAN10             ;Jump to continue processing expression.
  613/234F : 3C DE                      SCAN8:     CPI	336o               ;See if character fetched from expression is " t
  614/2351 : 48 5B 23                              JNZ	SCAN9              ;If not, continue checking for an operator
  615/2354 : 36 7E                                 MVI	L, 176o               ;If yes, load L with address of PARSER TOKEN
  616/2356 : 3E 05                                 MVI	M, 005                ;Put in value for exponentiation
  617/2358 : 44 04 23                              JMP	SCANFN             ;Go to PARSER subroutine entry point.
  618/235B : 3C BC                      SCAN9:     CPI	274o               ;See if character fetched is the "less than" sign
  619/235D : 48 7E 23                              JNZ	SCAN11             ;If not, continue checking for an operator
  620/2360 : 36 80                                 MVI	L, 200o               ;If yes, set L to the EVAL CURRENT pointer
  621/2362 : CF                                    MOV	B,M                    ;Fetch the pointer
  622/2363 : 08                                    INR	B                    ;Increment it to point to the next character
  623/2364 : F9                                    MOV	M,B                    ;Restore the updated pointer value
  624/2365 : 46 BB 21                              CALL	GETCHR             ;Fetch the next character in the expression
  625/2368 : 3C BD                                 CPI	275o               ;Is the character the "= 9 $ sign?
  626/236A : 68 C4 23                              JZ	SCAN13             ;If so, have 'less than or equal" combination
  627/236D : 3C BE                                 CPI	276o               ;Is the character the "greater than" sign?
  628/236F : 68 D2 23                              JZ	SCAN15             ;If so, have "less than or greater than" combination
  629/2372 : 36 80                                 MVI	L, 200o               ;Else character is not part of the operator. Set L back
  630/2374 : CF                                    MOV	B,M                    ;To the EVAL CURRENT pointer. Fetch the pointer
  631/2375 : 09                                    DCR	B                    ;Value and decriment it back one character in the
  632/2376 : F9                                    MOV	M,B                    ;Expression. Restore the original pointer value.
  633/2377 : 36 7E                                 MVI	L, 176o               ;Have just the 'less than" operator. Set L to the
  634/2379 : 3E 09                                 MVI	M, 011o               ;PARSER TOKEN storage location and set the value for
  635/237B : 44 04 23                              JMP	SCANFN             ;The 'less than" sign then go to PARSER entry point.
  636/237E : 3C BD                      SCAN11:    CPI	275o               ;See if character fetched is the "= " sign
  637/2380 : 48 A1 23                              JNZ	SCAN12             ;If not, continue checking for an operator
  638/2383 : 36 80                                 MVI	L, 200o               ;If yes, set L to the EVAL CURRENT pointer
  639/2385 : CF                                    MOV	B,M                    ;Fetch the pointer
  640/2386 : 08                                    INR	B                    ;Increment it to point to the next character
  641/2387 : F9                                    MOV	M,B                    ;Restore the updated pointer value
  642/2388 : 46 BB 21                              CALL	GETCHR             ;Fetch the next character in the expression
  643/238B : 3C BC                                 CPI	274o               ;Is the character the "less than" sign?
  644/238D : 68 C4 23                              JZ	SCAN13             ;If so, have "less than or equal" combination
  645/2390 : 3C BE                                 CPI	276o               ;Is the character the "greater than" sign?
  646/2392 : 68 CB 23                              JZ	SCAN14             ;If so, have "equal or greater than" combination
  647/2395 : 36 80                                 MVI	L, 200o               ;Else character is not part of the operator. Set L back
  648/2397 : CF                                    MOV	B,M                    ;To the EVAL CURRENT pointer. Fetch the pointer
  649/2398 : 09                                    DCR	B                    ;Value and decrement it back one character in the
  650/2399 : F9                                    MOV	M,B                    ;Expression. Restore the original pointer value.
  651/239A : 36 7E                                 MVI	L, 176o               ;Just have '~-- " operator. Set L to the PARSER TOKEN
  652/239C : 3E 0A                                 MVI	M, 012o               ;Storage location and set the value for the sign.
  653/239E : 44 04 23                              JMP	SCANFN             ;Go to the PARSER entry point.
  654/23A1 : 3C BE                      SCAN12:    CPI	276o               ;See if character fetched is the "greater than" sign
  655/23A3 : 48 D9 23                              JNZ	SCAN16             ;If not, go append the character to the SYMBOL BUFF
  656/23A6 : 36 80                                 MVI	L, 200o               ;If so, set L to the EVAL CURRENT pointer
  657/23A8 : CF                                    MOV	B,M                    ;Fetch the pointer
  658/23A9 : 08                                    INR	B                    ;Increment it to point to the next character
  659/23AA : F9                                    MOV	M,B                    ;Restore the updated pointer value
  660/23AB : 46 BB 21                              CALL	GETCHR             ;Fetch the next character in the expression
  661/23AE : 3C BC                                 CPI	274o               ;Is the character the "less than" sign?
  662/23B0 : 68 D2 23                              JZ	SCAN15             ;If so, have "less than or greater than" combination
  663/23B3 : 3C BD                                 CPI	275o               ;Is the character the "= " sign?
  664/23B5 : 68 CB 23                              JZ	SCAN14             ;If so, have the "equal to or greater than " combination
  665/23B8 : 36 80                                 MVI	L, 200o               ;Else character is not part of the operator. Set L back
  666/23BA : CF                                    MOV	B,M                    ;To the EVAL CURRENT pointer. Fetch the pointer
  667/23BB : 09                                    DCR	B                    ;Value and decrement it back one character in the
  668/23BC : F9                                    MOV	M,B                    ;Expression. Restore the original pointer value.
  669/23BD : 36 7E                                 MVI	L, 176o               ;Have just the "greater than" operator. Set L to the
  670/23BF : 3E 0B                                 MVI	M, 013o               ;PARSER TOKEN storage location and set the value for
  671/23C1 : 44 04 23                              JMP	SCANFN             ;The "greater than" sign then go to PARSER entry
  672/23C4 : 36 7E                      SCAN13:    MVI	L, 176o               ;When have 'less than or equal" combination set L to
  673/23C6 : 3E 0C                                 MVI	M, 014o               ;PARSER TOKEN storage location and set the value.
  674/23C8 : 44 04 23                              JMP	SCANFN             ;Then go to the PARSER entry point.
  675/23CB : 36 7E                      SCAN14:    MVI	L, 176o               ;When have "equal to or greater than" combination set L
  676/23CD : 3E 0D                                 MVI	M, 015o               ;To PARSER TOKEN storage location and set the value.
  677/23CF : 44 04 23                              JMP	SCANFN             ;Then go to the PARSER entry point.
  678/23D2 : 36 7E                      SCAN15:    MVI	L, 176o               ;When have 'less than or greater than" combination set
  679/23D4 : 3E 0E                                 MVI	M, 016o               ;L to PARSER TOKEN storage location and set value.
  680/23D6 : 44 04 23                              JMP	SCANFN             ;Then go to the PARSER entry point.
  681/23D9 : 46 E3 21                   SCAN16:    CALL	CONCTS             ;Concatenate the character to the SYMBOL BUFFER
  682/23DC : 36 80                      SCAN10:    MVI	L, 200o               ;Set L to the EVAL CURRENT pointer storage location
  683/23DE : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of EVAL CURRENT pointer
  684/23E0 : CF                                    MOV	B,M                    ;Fetch the EVAL CURRENT pointer value into B
  685/23E1 : 08                                    INR	B                    ;Increment the pointer value to point to next character
  686/23E2 : F9                                    MOV	M,B                    ;In the expression and restore the updated value.
  687/23E3 : 36 BF                                 MVI	L, 277o               ;Set L to EVAL FINISH storage location.
  688/23E5 : C7                                    MOV	A,M                    ;Fetch the EVAL FINISH value into the accumulator.
  689/23E6 : 09                                    DCR	B                    ;Set B to last character processed in the expression.
  690/23E7 : B9                                    CMP	B                    ;See if last character was at EVAL FINISH location.
  691/23E8 : 48 C7 22                              JNZ	SCAN1              ;If not, continue processing the expression. Else, jump
  692/23EB : 44 B3 36                              JMP	PARSEP             ;To final evaluation procedure and test.  (Directs routine
  693/23EE : 00                                    HLT             ;To a dislocated section.) Safety Halt in unused byte.
  694/23EF : 36 50                      PARSER:    MVI	L, 120o               ;Load L with starting address of SYMBOL BUFFER
  695/23F1 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of SYMBOL BUFFER
  696/23F3 : C7                                    MOV	A,M                    ;Fetch the (cc) for  contents of SYMBOL BUFFER
  697/23F4 : A0                                    ANA	A                    ;Into the ACC and see if buffer is  empty
  698/23F5 : 68 B4 24                              JZ	PARSE              ;If empty then no need to convert contents
  699/23F8 : 30                                    INR	L                    ;If not empty, advance buffer pointer
  700/23F9 : C7                                    MOV	A,M                    ;Fetch the first character in the buffer
  701/23FA : 3C AE                                 CPI	256o               ;See if it is ASCII code for decimal sign
  702/23FC : 68 09 24                              JZ	PARNUM             ;If yes, consider contents of buffer to be a number
  703/23FF : 3C B0                                 CPI	260o               ;If not decimal sign, see if first character represents
  704/2401 : 70 36 24                              JM	LOOKUP             ;A deciinal digit, if not, should have a variable
  705/2404 : 3C BA                                 CPI	272o               ;Continue to test for a decimal digit
  706/2406 : 50 36 24                              JP	LOOKUP             ;If not, go look up the variable nwne
  707/2409 : 31                         PARNUM:    DCR	L                    ;If SYMBOL BUFFER contains number, decrement
  708/240A : C7                                    MOV	A,M                    ;Buffer pointer back to (cc) and fetch it to ACC
  709/240B : 3C 01                                 CPI	001o               ;See if length of string in buffer is just one
  710/240D : 68 20 24                              JZ	NOEXPO             ;If so, cannot have number with scientific notation
  711/2410 : 86                                    ADD	L                    ;If not, add length to buffer pointer to
  712/2411 : F0                                    MOV	L,A                    ;Point to last character in the buffer
  713/2412 : C7                                    MOV	A,M                    ;Fetch the last character in buffer and see if it
  714/2413 : 3C C5                                 CPI	305o               ;Represents letter E for Exponent
  715/2415 : 48 20 24                              JNZ	NOEXPO             ;If not, cannot have number with scientific notation
  716/2418 : 36 80                                 MVI	L, 200o               ;If yes, have part of a scientific number, set pointer to
  717/241A : 46 BB 21                              CALL	GETCHR             ;Get the operator that follows the E and append it to
  718/241D : 44 E3 21                              JMP	CONCTS             ;The SYMBOL BUFFER and return to EVAL routine
  719/2420 : 36 97                      NOEXPO:    MVI	L, 227o               ;Load L with address of ARITHMETIC STACK pointer
  720/2422 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with page of ARITHMETIC STACK pointer
  721/2424 : C7                                    MOV	A,M                    ;Fetch AS pointer value to ACC and add four to account
  722/2425 : 04 04                                 ADI	004o               ;For the number of bytes required to store a number in
  723/2427 : F8                                    MOV	M,A                    ;Floating point format. Restore pointer to mernory.
  724/2428 : F0                                    MOV	L,A                    ;Then, change L to point to entry position in the AS
  725/2429 : 46 B3 31                              CALL	FSTORE             ;Place contents of the FPACC onto top of the AS
  726/242C : 36 50                                 MVI	L, 120o               ;Change L to point to start of the SYMBOL BUFFER
  727/242E : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of the SYMBOL BUFFER
  728/2430 : 46 2A 32                              CALL	DINPUT             ;Convert number in the buffer to floating point format
  729/2433 : 44 B4 24                              JMP	PARSE              ;In the FPACC then jump to check operator sign.
  730/2436 : 36 F8                      LOOKUP:    MVI	L, 370o               ;Load L with address of LOOK-UP COUNTER
  731/2438 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of the counter
  732/243A : 3E 00                                 MVI	M, 000                ;Initialize the counter to zero
  733/243C : 36 50                                 MVI	L, 120o               ;Load L with starting address of the SYMBOL BUFFER
  734/243E : 1E 04                                 MVI	D,PG27 ;\HB\OLDPG27   ;** Load D with page of the VARIABLES TABLE
  735/2440 : 26 88                                 MVI	E, 210o               ;Load E with start of the VARL433LES TABLE
  736/2442 : C7                                    MOV	A,M                    ;Fetch the (cc) for the string in the SYMBOL BUFFER
  737/2443 : 3C 01                                 CPI	001                ;See if the name length is just one character. If not,
  738/2445 : 48 4C 24                              JNZ	LOOKU1             ;Should be two so proceed to look-up routine. Else,
  739/2448 : 36 52                                 MVI	L, 122o               ;Change L to second character byte in the buffer and set
  740/244A : 3E 00                                 MVI	M, 000                ;It to zero to provide compatibility with entries in table
  741/244C : 36 51                      LOOKU1:    MVI	L, 121o               ;Load L with addr of first character in the SYMBOL
  742/244E : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** BUFFER. Set H to page of the SYMBOL BUFFER.
  743/2450 : 46 F4 31                              CALL	SWITCH             ;Exchange contents of D&E with H&L so that can
  744/2453 : C7                                    MOV	A,M                    ;Fetch the first character of a name in the VARIABLES
  745/2454 : 30                                    INR	L                    ;TABLE. Advance the table pointer and save the
  746/2455 : CF                                    MOV	B,M                    ;Second byte of name in B. Then advance the pointer
  747/2456 : 30                                    INR	L                    ;Again to reach first bvte of floating point forrnatted
  748/2457 : 46 F4 31                              CALL	SWITCH             ;Number in table. Now exchange D&E with H&L and
  749/245A : BF                                    CMP	M                    ;Compare first byte in table against first char in buffer
  750/245B : 48 64 24                              JNZ	LOOKU2             ;If not the same, go try next entry in table. If same,
  751/245E : 30                                    INR	L                    ;Advance pointer to next char in buffer. Transfer the
  752/245F : C1                                    MOV	A,B                    ;Character in B (second byte in table entry) to the ACC
  753/2460 : BF                                    CMP	M                    ;Compare it against second character in the buffer.
  754/2461 : 68 9C 24                              JZ	LOOKU4             ;If match, have found the name in the VARIABLES tbl.
  755/2464 : 46 C9 25                   LOOKU2:    CALL	AD4DE              ;Call subroutine to add four to the pointer in D&E to
  756/2467 : 36 F8                                 MVI	L, 370o               ;Advance the table pointer over value bytes. Then set
  757/2469 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Up H and L to point to LOOK-UP COUNTER.
  758/246B : CF                                    MOV	B,M                    ;Fetch counter value (counts number of entries tested
  759/246C : 08                                    INR	B                    ;In the VARIABLES TABLE), increment it
  760/246D : F9                                    MOV	M,B                    ;And restore it back to meynory
  761/246E : 36 3F                                 MVI	L, 077o               ;Load L with address of SYMBOL VARIABLES counter
  762/2470 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Do same for H. (Counts number of names in table.)
  763/2472 : C1                                    MOV	A,B                    ;Place LOOK-UP COUNTER value in the accumulator.
  764/2473 : BF                                    CMP	M                    ;Compare it with number of entries in the table.
  765/2474 : 48 4C 24                              JNZ	LOOKU1             ;If have not reached end of table, keep looking for name.
  766/2477 : 36 3F                                 MVI	L, 077o               ;If reach end of table without match, need to add name
  767/2479 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** To table. First set H & L to the SYMBOL
  768/247B : CF                                    MOV	B,M                    ;VARIABLES counter. Fetch the counter value and
  769/247C : 08                                    INR	B                    ;Increment to account for new name being added to the
  770/247D : F9                                    MOV	M,B                    ;Table. Restore the updated count to meinory. Also,
  771/247E : C1                                    MOV	A,B                    ;Move the new counter value to the accumulator and
  772/247F : 3C 15                                 CPI	025o               ;Check to see that table size is not exceeded. If try to
  773/2481 : 50 AD 21                              JP	BIGERR             ;Go over 20 (decirnal) entries then have BIG error.
  774/2484 : 36 51                                 MVI	L, 121o               ;Else, set L to point to first character in the SYMBOL
  775/2486 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** BUFFER and set H to proper page. Set the number
  776/2488 : 0E 02                                 MVI	B, 002                ;Of bytes to be transferred into register B as a counter.
  777/248A : 46 11 30                              CALL	MOVEIT             ;Move the symbol name from the buffer to the
  778/248D : F4                                    MOV	L,E                    ;VARIABLES TABLE. Now set up H & L with value
  779/248E : EB                                    MOV	H,D                    ;Contained in D & E after moving ops (points to first
  780/248F : A8                                    XRA	A                    ;Byte of the value to be associated with the symbol
  781/2490 : F8                                    MOV	M,A                    ;Name.) Clear the accumulator and place zero in all four
  782/2491 : 30                                    INR	L                    ;Bytes associated with the variable name entered
  783/2492 : F8                                    MOV	M,A                    ;In the VARIABLES TABLE
  784/2493 : 30                                    INR	L                    ;In order to
  785/2494 : F8                                    MOV	M,A                    ;Assign an
  786/2495 : 30                                    INR	L                    ;Initial value
  787/2496 : F8                                    MOV	M,A                    ;To the variable narne
  788/2497 : C6                                    MOV	A,L                    ;Then transfer the address in L to the acc'umulator
  789/2498 : 14 04                                 SUI	004                ;Subtract four to reset the pointer to start of zeroing ops
  790/249A : E0                                    MOV	E,A                    ;Restore the address in D & E to be in same state as if
  791/249B : DD                                    MOV	D,H                    ;Name was found in the table in the LOOKUP routine
  792/249C : 46 D5 31                   LOOKU4:    CALL	SAVEHL             ;Save current address to VARIABLES TABLE
  793/249F : 36 97                                 MVI	L, 227o               ;Load L with address of ARITHMETIC STACK pointer
  794/24A1 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with page of the pointer
  795/24A3 : C7                                    MOV	A,M                    ;Fetch the AS pointer value to the accumulator
  796/24A4 : 04 04                                 ADI	004                ;Add four to account for next floating point forrnatted
  797/24A6 : F8                                    MOV	M,A                    ;Number to be stored in the stack. Restore the stack
  798/24A7 : F0                                    MOV	L,A                    ;Pointer to memory and set it up in register L too.
  799/24A8 : 46 B3 31                              CALL	FSTORE             ;Place the value in the FPACC on the top of the
  800/24AB : 46 E5 31                              CALL	RESTHL             ;ARITHMETIC STACK. Restore the VARIABLES
  801/24AE : 46 F4 31                              CALL	SWITCH             ;TABLE pointer to H&L and move it to D&E. Now load
  802/24B1 : 46 AA 31                              CALL	FLOAD              ;The VARIABLE value from the table to the FPACC.
  803/24B4 : 46 C8 21                   PARSE:     CALL	CLESYM             ;Clear the SYMBOL BUFFER
  804/24B7 : 36 7E                                 MVI	L, 176o               ;Load L with address of PARSER TOKEN VALUE
  805/24B9 : C7                                    MOV	A,M                    ;And fetch the token value into the accumulator
  806/24BA : 3C 07                                 CPI	007                ;Is it token value for right parenthesis ")" ? If so, have
  807/24BC : 68 F5 24                              JZ	PARSE2             ;Special case where must perforin ops til find a "(" !
  808/24BF : 04 A0                                 ADI	240o               ;Else, fon-n address to HEIRARCHY IN table and
  809/24C1 : F0                                    MOV	L,A                    ;Set L to point to HEIRARCHY IN VALUE in the table
  810/24C2 : CF                                    MOV	B,M                    ;Fetch the heirarchy value from the table to register B
  811/24C3 : 36 88                                 MVI	L, 210o               ;Set L to OPERATOR STACK pointer storage location
  812/24C5 : D7                                    MOV	C,M                    ;Fetch the OS pointer into CPU register C
  813/24C6 : 46 24 32                              CALL	INDEXC             ;Add OS pointer to address of OS pointer storage loc
  814/24C9 : C7                                    MOV	A,M                    ;Fetch the token value for the operator at top of the OS
  815/24CA : 04 AF                                 ADI	257o               ;And form address to HEIRARCHY OUT table
  816/24CC : F0                                    MOV	L,A                    ;Set L to point to HEIRARCHY OUT VALUE in the
  817/24CD : C1                                    MOV	A,B                    ;Table. Move the HEIRARCHY IN value to the ACC.
  818/24CE : BF                                    CMP	M                    ;Compare the HEIRARCHY IN with the HEIRARCHY
  819/24CF : 68 E2 24                              JZ	PARSE1             ;OUT value. If heirarchy of current operator equal to or
  820/24D2 : 70 E2 24                              JM	PARSE1             ;Less than operator on top of OS stack, perfo
  821/24D5 : 36 7E                                 MVI	L, 176o               ;Operation indicated in top of OS stack. Else, fetch the
  822/24D7 : CF                                    MOV	B,M                    ;Current operator token value into register B.
  823/24D8 : 36 88                                 MVI	L, 210o               ;Load L with address of the OPERATOR STACK pntr
  824/24DA : D7                                    MOV	C,M                    ;Fetch the stack pointer value
  825/24DB : 10                                    INR	C                    ;Increment it to account for new entry on the stack
  826/24DC : FA                                    MOV	M,C                    ;Restore the stack pointer value to memory
  827/24DD : 46 24 32                              CALL	INDEXC             ;For in pointer to next entry in OPERATOR STACK
  828/24E0 : F9                                    MOV	M,B                    ;Place the current operator token value on top of the OS
  829/24E1 : 07                                    RET                    ;Exit back to the EVAL routine.
  830/24E2 : 36 88                      PARSE1:    MVI	L, 210o               ;Load L with address of the OPERATOR STACK pntr
  831/24E4 : C7                                    MOV	A,M                    ;Fetch the stack pointer value to the accumulator
  832/24E5 : 86                                    ADD	L                    ;Add in the value of the stack pointer address to form
  833/24E6 : F0                                    MOV	L,A                    ;Address that points to top entry in the OS
  834/24E7 : C7                                    MOV	A,M                    ;Fetch the token value at the top of the OS to the ACC
  835/24E8 : A0                                    ANA	A                    ;Check to see if the token value is zero for end of stack
  836/24E9 : 2B                                    RZ                    ;Exit back to the EVAL routine if stack empty
  837/24EA : 36 88                                 MVI	L, 210o               ;Else, reset L to the OS pointer storage location
  838/24EC : D7                                    MOV	C,M                    ;Fetch the pointer value
  839/24ED : 11                                    DCR	C                    ;Decrement it to account for operator rernoved from
  840/24EE : FA                                    MOV	M,C                    ;The OPERATOR STACK and restore the pointer value
  841/24EF : 46 0F 25                              CALL	FPOPER             ;Perform the operation obtained from the top of the OS
  842/24F2 : 44 B4 24                              JMP	PARSE              ;Continue to compare current operator against top of OS
  843/24F5 : 36 88                      PARSE2:    MVI	L, 210o               ;Load L with address of the OPERATOR STACK pntr
  844/24F7 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of the pointer
  845/24F9 : C7                                    MOV	A,M                    ;Fetch the stack pointer value to the accumulator
  846/24FA : 86                                    ADD	L                    ;Add in the value of the stack pointer address to form
  847/24FB : F0                                    MOV	L,A                    ;Address that points to top entry in the OS
  848/24FC : C7                                    MOV	A,M                    ;Fetch the token value at the top of the 0 S to the ACC
  849/24FD : A0                                    ANA	A                    ;Check to see if the token value is zero for end of stack
  850/24FE : 68 5F 25                              JZ	PARNER             ;If end of stack, then have a parenthesis error condx
  851/2501 : 36 88                                 MVI	L, 210o               ;Else, reset L to the OS pointer storage location
  852/2503 : D7                                    MOV	C,M                    ;Fetch the pointer value
  853/2504 : 11                                    DCR	C                    ;Decrement it to account for operator removed from
  854/2505 : FA                                    MOV	M,C                    ;The OPERATOR STACK and restore the pointer value
  855/2506 : 3C 06                                 CPI	006                ;Check to see if token value is "(" to close parenthesis
  856/2508 : 2B                                    RZ                    ;If so, exit back to EVAL routine.
  857/2509 : 46 0F 25                              CALL	FPOPER             ;Else, perforin the op obtained from the top of the OS
  858/250C : 44 F5 24                              JMP	PARSE2             ;Continue to process data in parenthesis
  859/250F : 36 F9                      FPOPER:    MVI	L, 371o               ;Load L with address of TEMP OP storage location
  860/2511 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of TEMP OP storage location
  861/2513 : F8                                    MOV	M,A                    ;Store OP (from top of OPERATOR STACK)
  862/2514 : 36 97                                 MVI	L, 227o               ;Change L to address of ARff HMETIC STACK pointer
  863/2516 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with page of AS pointer
  864/2518 : C7                                    MOV	A,M                    ;Fetch AS pointer value into ACC
  865/2519 : F0                                    MOV	L,A                    ;Set L to top of ARITHMETIC STACK
  866/251A : 46 BC 31                              CALL	OPLOAD             ;Transfer number from ARffHMETIC STACK to FPOP
  867/251D : 36 97                                 MVI	L, 227o               ;Restore pointer to AS pointer
  868/251F : C7                                    MOV	A,M                    ;Fetch the pointer value to the ACC and subtract four
  869/2520 : 14 04                                 SUI	004                ;To remove top value from the ARITHMETIC STACK
  870/2522 : F8                                    MOV	M,A                    ;Restore the updated AS pointer to memory
  871/2523 : 36 F9                                 MVI	L, 371o               ;Set L to address of TEMP OP storage location
  872/2525 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of TEMP OP storage location
  873/2527 : C7                                    MOV	A,M                    ;Fetch the operator token value to the ACC
  874/2528 : 3C 01                                 CPI	001                ;Find out which kind of operation indicated
  875/252A : 68 8B 2F                              JZ	FPADD              ;Perforn addition if have plus operator
  876/252D : 3C 02                                 CPI	002                ;If not plus, see if minus
  877/252F : 68 20 30                              JZ	FPSUB              ;Perform subtraction if have minus operator
  878/2532 : 3C 03                                 CPI	003                ;If not minus, see if multiplication
  879/2534 : 68 2C 30                              JZ	FPMULT             ;Perform multiplication if have multiplication operator
  880/2537 : 3C 04                                 CPI	004                ;If not multiplication, see if division
  881/2539 : 68 D8 30                              JZ	FPDIV              ;Perform division if have division operator
  882/253C : 3C 05                                 CPI	005                ;If not division, see if exponentiation
  883/253E : 68 CE 25                              JZ	INTEXP             ;Perform exponentiation if have exponentiation operator
  884/2541 : 3C 09                                 CPI	011o               ;If not exponentiation, see if "less than" operator
  885/2543 : 68 6C 25                              JZ	LT                 ;Perform compaison for "less than" op if indicated
  886/2546 : 3C 0A                                 CPI	012o               ;If not 'less than" see if have "equal" operator
  887/2548 : 68 79 25                              JZ	EQ                 ;Perforin comparison for "equal" op if indicated
  888/254B : 3C 0B                                 CPI	013o               ;If not "equal" see if have "greater than" operator
  889/254D : 68 86 25                              JZ	GT                 ;Perform comparison for "greater than" op if indicated
  890/2550 : 3C 0C                                 CPI	014o               ;If not "'greater than" see if have 'less than or equal" op
  891/2552 : 68 96 25                              JZ	LE                 ;Perform comparison for the combination op if indicated
  892/2555 : 3C 0D                                 CPI	015o               ;See if have "equal to or greater than" operator
  893/2557 : 68 A6 25                              JZ	GE                 ;Perform comparison for the combination op if indicated
  894/255A : 3C 0E                                 CPI	016o               ;See if have "less than or greater than" operator
  895/255C : 68 B3 25                              JZ	NE                 ;Perform comparison for the combination op if indicated
  896/255F : 36 98                      PARNER:    MVI	L, 230o               ;If cannot find operator, expression is not balanced
  897/2561 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H and L to address of F/A STACK pointer
  898/2563 : 3E 00                                 MVI	M, 000                ;Clear the F/A STACK pointer to re-initialize
  899/2565 : 06 C9                                 MVI	A, 311o               ;Load ASCII code for letter I into the accumulator
  900/2567 : 16 A8                                 MVI	C, 250o               ;And code for "(" character into register C
  901/2569 : 44 B1 21                              JMP	ERROR              ;Go display 1( for "Imbalanced Parenthesis") error msg
  902/256C : 46 20 30                   LT:        CALL	FPSUB              ;Subtract contents of FPACC from FPOP to compare
  903/256F : 36 56                                 MVI	L, 126o               ;Set L to point to the MSW of the FPACC (Contains
  904/2571 : C7                                    MOV	A,M                    ;Result of the subtraction.) Fetch the MSW of the
  905/2572 : A0                                    ANA	A                    ;FPACC to the accumulator and test to see if result is
  906/2573 : 70 BD 25                              JM	CTRUE              ;Positive or negative. Set up the FPACC as a function
  907/2576 : 44 C2 25                              JMP	CFALSE             ;Of the result obtained.
  908/2579 : 46 20 30                   EQ:        CALL	FPSUB              ;Subtract contents of FPACC from FPOP to compare
  909/257C : 36 56                                 MVI	L, 126o               ;Set L to point to the MSW of the FPACC (Contains
  910/257E : C7                                    MOV	A,M                    ;Result of the subtraction.) Fetch the MSW of the
  911/257F : A0                                    ANA	A                    ;FPACC to the accumulator and test to see if result is
  912/2580 : 68 BD 25                              JZ	CTRUE              ;Equal. Set up the FPACC as a function
  913/2583 : 44 C2 25                              JMP	CFALSE             ;Of the result obtained.
  914/2586 : 46 20 30                   GT:        CALL	FPSUB              ;Subtract contents of FPACC from FPOP to compare
  915/2589 : 36 56                                 MVI	L, 126o               ;Set L to point to the MSW of the FPACC (Contains
  916/258B : C7                                    MOV	A,M                    ;Result of the subtraction.) Fetch the MSW of the
  917/258C : A0                                    ANA	A                    ;FPACC to the accumulator and test to see if result is
  918/258D : 68 C2 25                              JZ	CFALSE             ;Positive, Negative, or Equal. Set up the FPACC
  919/2590 : 50 BD 25                              JP	CTRUE              ;As a function
  920/2593 : 44 C2 25                              JMP	CFALSE             ;Of the result obtained.
  921/2596 : 46 20 30                   LE:        CALL	FPSUB              ;Subtract contents of FPACC from FPOP to compare
  922/2599 : 36 56                                 MVI	L, 126o               ;Set L to point to the MSW of the FPACC (Contains
  923/259B : C7                                    MOV	A,M                    ;Result of the subtraction.) Fetch the MSW of the
  924/259C : A0                                    ANA	A                    ;FPACC to the accumulator and test to see if result is
  925/259D : 68 BD 25                              JZ	CTRUE              ;Positive, Negative, or Equal. Set up the FPACC
  926/25A0 : 70 BD 25                              JM	CTRUE              ;As a function
  927/25A3 : 44 C2 25                              JMP	CFALSE             ;Of the result obtained
  928/25A6 : 46 20 30                   GE:        CALL	FPSUB              ;Submit contents of FPACC from FPOP to compare
  929/25A9 : 36 56                                 MVI	L, 126o               ;Set L to point to the MSW of the FPACC (Contains
  930/25AB : C7                                    MOV	A,M                    ;Result of the subtraction.) Fetch the MSW of the
  931/25AC : A0                                    ANA	A                    ;FPACC to the accumulator and test to see if result is
  932/25AD : 50 BD 25                              JP	CTRUE              ;Positive or Negative. Set up the FPACC
  933/25B0 : 44 C2 25                              JMP	CFALSE             ;As a function of the result obtained
  934/25B3 : 46 20 30                   NE:        CALL	FPSUB              ;Subtract contents of FPACC from FPOP to compare
  935/25B6 : 36 56                                 MVI	L, 126o               ;Set L to point to the MSW of the FPACC (Contains
  936/25B8 : C7                                    MOV	A,M                    ;Result of the subtraction.) Fetch the MSW of the
  937/25B9 : A0                                    ANA	A                    ;FPACC to the accumulator and test to see if result is
  938/25BA : 68 C2 25                              JZ	CFALSE             ;Equal. Set up the FPACC as a function of the result.
  939/25BD :                            CTRUE:
  940/25BD : 36 04                      FPONE:     MVI	L, 004                ;Load L with address of floating point value +1.0
  941/25BF : 44 AA 31                              JMP	FLOAD              ;Load FPACC with value +1.0 and exit to caller
  942/25C2 : 36 57                      CFALSE:    MVI	L, 127o               ;Load L with address of FPACC Exponent register
  943/25C4 : 3E 00                                 MVI	M, 000                ;Set the FPACC Exponent to zero and then set the
  944/25C6 : 44 2B 2F                              JMP	FPZERO             ;Mantissa portion of the FPACC to zero. Exit to caller.
  945/25C9 : C4                         AD4DE:     MOV	A,E                    ;Subroutine to add four to the value in register E.
  946/25CA : 04 04                                 ADI	004                ;Move contents of E to the ACC and add four.
  947/25CC : E0                                    MOV	E,A                    ;Restore the updated value back to register E.
  948/25CD : 07                                    RET                    ;Return to the caMVI L,ng routine.
  949/25CE : 36 56                      INTEXP:    MVI	L, 126o               ;Load L with address of WSW of FPACC (Floating Point
  950/25D0 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** ACCumulator). Load H with page of FPACC.
  951/25D2 : C7                                    MOV	A,M                    ;Fetch MSW of the FPACC into the accumulator.
  952/25D3 : 36 03                                 MVI	L, 003                ;Load L with address of EXP TEMP storage location
  953/25D5 : F8                                    MOV	M,A                    ;Store the FPACC MSW value in EXP TEMP location
  954/25D6 : A0                                    ANA	A                    ;Test contents of the MSW of the FPACC. ff zero, then
  955/25D7 : 68 BD 25                              JZ	FPONE              ;Set FPACC equal to +1.0 (any nr to zero power = 1.0!)
  956/25DA : 72 84 2F                              CM	 FPCOMP             ;If MSW indicates negative number, complement
  957/25DD : 46 02 2F                              CALL	FPFIX              ;The FPACC. Then convert floating point number to
  958/25E0 : 36 54                                 MVI	L, 124o               ;Fixed point. Load L with address of LSW of fixed nr
  959/25E2 : CF                                    MOV	B,M                    ;Fetch the LSW into CPU register B.
  960/25E3 : 36 0B                                 MVI	L, 013o               ;Set L to address of EXPONENT COUNTER
  961/25E5 : F9                                    MOV	M,B                    ;Place the fixed value in the EXP CNTR to indicate
  962/25E6 : 36 5C                                 MVI	L, 134o               ;Number of multiplications needed (power). Now set L
  963/25E8 : 26 0C                                 MVI	E, 014o               ;To LSW of FPOP and E to address of FP TEMP (LSW)
  964/25EA : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to floating point working area page.
  965/25EC : DD                                    MOV	D,H                    ;Set D to same page address.
  966/25ED : 0E 04                                 MVI	B, 004o               ;Set transfer (precision) counter. Call subroutine to move
  967/25EF : 46 11 30                              CALL	MOVEIT             ;Contents of FPOP into FP TEMP registers to save
  968/25F2 : 46 BD 25                              CALL	FPONE              ;Original value of FPOP. Now set FPACC to +1.0.
  969/25F5 : 36 03                                 MVI	L, 003                ;Load L with pointer to original value of FPACC
  970/25F7 : C7                                    MOV	A,M                    ;(Stored in FP TEMP) MSW and fetch contents to ACC.
  971/25F8 : A0                                    ANA	A                    ;Test to see if raising to a negative power. If so, divide
  972/25F9 : 70 0D 26                              JM	DVLOOP             ;Instead of multiply!
  973/25FC : 36 0C                      MULOOP:    MVI	L, 014o               ;Load L with address of LSW of FP TEMP (original
  974/25FE : 46 C5 31                              CALL	FACXOP             ;Value in FPOP). Move FP TEMP into FPOP.
  975/2601 : 46 2C 30                              CALL	FPMULT             ;Multiply FPACC by FPOP. Result left in FPACC.
  976/2604 : 36 0B                                 MVI	L, 013o               ;Load L with address of EXPONENT COUNTER.
  977/2606 : CF                                    MOV	B,M                    ;Fetch the counter value
  978/2607 : 09                                    DCR	B                    ;Decrement it
  979/2608 : F9                                    MOV	M,B                    ;Restore it to memory
  980/2609 : 48 FC 25                              JNZ	MULOOP             ;If counter not zero, continue exponentiation process
  981/260C : 07                                    RET                    ;When have raised to proper power, return to caller.
  982/260D : 36 0C                      DVLOOP:    MVI	L, 014o               ;Load L with address of LSW of FP TEMP (original
  983/260F : 46 C5 31                              CALL	FACXOP             ;Value in FPOP). Move FP TEMP into FPOP.
  984/2612 : 46 D8 30                              CALL	FPDIV              ;Divide FPACC by FPOP. Result left in FPACC.
  985/2615 : 36 0B                                 MVI	L, 013o               ;Load L with address of EXPONENT COUNTER
  986/2617 : CF                                    MOV	B,M                    ;Fetch the counter value
  987/2618 : 09                                    DCR	B                    ;Decrement it
  988/2619 : F9                                    MOV	M,B                    ;Restore to memory
  989/261A : 48 0D 26                              JNZ	DVLOOP             ;If counter not zero, continue exponentiation process
  990/261D : 07                                    RET                    ;When have raised to proper power, return to caller.
  991/261E :                            
  992/261E :                            ;;; The label PRIGHT: SHOULD BE UP TO 07 003 0703h
  993/261E : 36 98                      PRIGHT:    MVI	L, 230o               ;Load L with address of F/A STACK pointer
  994/2620 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of F/A STACK pointer
  995/2622 : C7                                    MOV	A,M                    ;Fetch the pointer value into the ACC
  996/2623 : 86                                    ADD	L                    ;Form pointer to top of the F/A STACK
  997/2624 : F0                                    MOV	L,A                    ;Set L to point to top of the F/A STACK
  998/2625 : C7                                    MOV	A,M                    ;Fetch the contents of the top of the F/A STACK into
  999/2626 : 3E 00                                 MVI	M, 000                ;The ACC then clear the top of the F/A STACK
 1000/2628 : 36 83                                 MVI	L, 203o               ;Load L with address of F /A STACK TEMP storage
 1001/262A : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Location. Set H to page of F/A STACK TEMP
 1002/262C : F8                                    MOV	M,A                    ;Store value from top of F/A STACK into temp loc.
 1003/262D : A0                                    ANA	A                    ;Test to see if token value in top of stack was zero
 1004/262E : 2B                                    RZ                    ;If so, just had simple grouping parenthesis!
 1005/262F : 70 AB 37                              JM	PRIGH1             ;@@ If token value minus, indicates array subscript
 1006/2632 : 3C 01                                 CPI	001                ;For positive token value, look for appropriate function
 1007/2634 : 68 BE 26                              JZ	INTX               ;If token value for INTeger function, go do it.
 1008/2637 : 3C 02                                 CPI	002                ;Else, see if token value for SIGN function.
 1009/2639 : 68 0B 27                              JZ	SGNX               ;If so, go do it.
 1010/263C : 3C 03                                 CPI	003                ;Else, see if token value for ABSolute function
 1011/263E : 68 01 27                              JZ	ABSX               ;If so, go do it.
 1012/2641 : 3C 04                                 CPI	004                ;If not, see if token value for SQuare Root function
 1013/2643 : 68 C5 36                              JZ	SQRX               ;If so, go do it.
 1014/2646 : 3C 05                                 CPI	005                ;If not, see if token value for TAB function
 1015/2648 : 68 2A 27                              JZ	TABX               ;If so, go do it.
 1016/264B : 3C 06                                 CPI	006                ;If not, see if token value for RaNDom function
 1017/264D : 68 61 37                              JZ	RNDX               ;If so, go find a random number.
 1018/2650 : 3C 07                                 CPI	007                ;If not, see if token value for CHaRacter function
 1019/2652 : 68 1A 27                              JZ	CHRX               ;If so, go perform the function.
 1020/2655 : 3C 08                                 CPI	010o               ;Else, see if token for user defined machine language
 1021/2657 : 68 B5 20                              JZ	UDEFX              ;# Function. If so, perform the User DEfined Function
 1022/265A : 00                                    HLT             ;Safety halt. Program should not reach this location!
 1023/265B :                            
 1024/265B :                            ;;; The label FUNARR SHOULD BE AT 07 100 0740h
 1025/265B : 36 50                      FUNARR:    MVI	L, 120o               ;Load L with starting address of SYMBOL BUFFER
 1026/265D : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of SYMBOL BUFFER
 1027/265F : C7                                    MOV	A,M                    ;Fetch the (cc) for contents of buffer to the ACC
 1028/2660 : A0                                    ANA	A                    ;See if (cc) is zero, if so buffer is empty, return to
 1029/2661 : 2B                                    RZ                    ;Caller as have simple grouping parenthesis sign
 1030/2662 : 36 82                                 MVI	L, 202o               ;Else set L to TEMP COUNTER location
 1031/2664 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to TEMP COUNTER page
 1032/2666 : 3E 00                                 MVI	M, 000                ;Initialize TEMP COUNTER to zero
 1033/2668 : 36 82                      FUNAR1:    MVI	L, 202o               ;Load L with address of TEMP COUNTER
 1034/266A : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Load H with page of TEMP COUNTER
 1035/266C : CF                                    MOV	B,M                    ;Fetch the counter value to register B
 1036/266D : 08                                    INR	B                    ;Increment the counter
 1037/266E : F9                                    MOV	M,B                    ;Restore the updated value to memory
 1038/266F : 16 02                                 MVI	C, 002                ;Initialize C to a value of two for future ops
 1039/2671 : 36 BC                                 MVI	L, 274o               ;Load L with starting address (less four) of FUNCTION
 1040/2673 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** LOOK-UP TABLE. Set H to table page.
 1041/2675 : 46 B3 26                              CALL	TABADR             ;Find address of next entry in the table
 1042/2678 : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Load D with page of SYMBOL BUFFER
 1043/267A : 26 50                                 MVI	E, 120o               ;Load E with starting address of SYMBOL BUFFER
 1044/267C : 46 F5 21                              CALL	STRCP              ;Compare entry in FUNCTION LOOK-UP TABLE with
 1045/267F : 68 A2 26                              JZ	FUNAR4             ;Contents of SYMBOL BUFFER. If find match, go set
 1046/2682 : 36 82                                 MVI	L, 202o               ;Up the function token value. Else, set L to the TEMP
 1047/2684 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** COUNTER and set H to the proper page. Fetch the
 1048/2686 : C7                                    MOV	A,M                    ;Current counter value and see if have tried all eight
 1049/2687 : 3C 08                                 CPI	010o               ;Possible functions in the table.
 1050/2689 : 48 68 26                              JNZ	FUNAR1             ;If not, go back and check the next entry.
 1051/268C : 36 82                                 MVI	L, 202o               ;If have tried all of the entries in the table, set L
 1052/268E : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** As well as H to the address of the TEMP COUI,.7ER
 1053/2690 : 3E 00                                 MVI	M, 000                ;And reset it to zero. Now go see if have subscripted
 1054/2692 : 44 D7 37                              JMP	FUNAR2             ;@@ Array (unless array capability not in program).
 1055/2695 : 36 98                      FAERR:     MVI	L, 230o               ;Load L with address of F/A STACK pointer
 1056/2697 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of F/A STACK pointer
 1057/2699 : 3E 00                                 MVI	M, 000                ;Clear the F/A STACK pointer to reset on an error
 1058/269B : 06 C6                                 MVI	A, 306o               ;Load the ASCII code for letter F into the ACC
 1059/269D : 16 C1                                 MVI	C, 301o               ;Load the ASCII code for letter A into register C
 1060/269F : 44 B1 21                              JMP	ERROR              ;Go display the FA error message
 1061/26A2 : 36 82                      FUNAR4:    MVI	L, 202o               ;Load L with address of TEMP COUNTER
 1062/26A4 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to page of TEMP COUNTER
 1063/26A6 : CF                                    MOV	B,M                    ;Load value in counter to register B. This is FUNCTION
 1064/26A7 : 36 98                                 MVI	L, 230o               ;TOKEN VALUE. Cbange- L to F/A STACK pointer.
 1065/26A9 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of F/A STACK pointer.
 1066/26AB : D7                                    MOV	C,M                    ;Fetch the F/A STACK pointer value into register C.
 1067/26AC : 46 24 32                              CALL	INDEXC             ;Form the address to the top of the F/A STACK.
 1068/26AF : F9                                    MOV	M,B                    ;Store the FUNCTION TOKEN VALUE in the F/A
 1069/26B0 : 44 C8 21                              JMP	CLESYM             ;STACK. Then exit by clearing the SYMBOL BUFFER.
 1070/26B3 : C1                         TABADR:    MOV	A,B                    ;Move the TEMP COUNTER value from B to ACC
 1071/26B4 : 02                         TABAD1:    RLC                    ;Multiply by four using this loop to form value equal
 1072/26B5 : 11                                    DCR	C                    ;To number of bytes per entry (4) times current entry
 1073/26B6 : 48 B4 26                              JNZ	TABAD1             ;In the FUNCTION LOOK-UP TABLE.
 1074/26B9 : 86                                    ADD	L                    ;Add this value to the starting address of the table.
 1075/26BA : F0                                    MOV	L,A                    ;Form pointer to next entry in table
 1076/26BB : 03                                    RNC                    ;If no carry return to caller
 1077/26BC : 28                                    INR	H                    ;Else, increment H before
 1078/26BD : 07                                    RET                    ;Returning to caller
 1079/26BE :                            
 1080/26BE :                            ;;; The label INTX SHOULD BE AT 07 243 07a3h
 1081/26BE : 36 56                      INTX:      MVI	L, 126o               ;Load L with address of MSW of the FPACC
 1082/26C0 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with the page of the PPACC
 1083/26C2 : C7                                    MOV	A,M                    ;Fetch the MSW of the FPACC into the accumulator
 1084/26C3 : A0                                    ANA	A                    ;Test the sign of the number in the FPACC. If
 1085/26C4 : 50 F2 26                              JP	INT1               ;Positive jump ahead to integerize
 1086/26C7 : 36 0C                                 MVI	L, 014o               ;If negative, load L with address of FP TEMP registers
 1087/26C9 : 46 B3 31                              CALL	FSTORE             ;Store the value in the FPACC in FP TEMP
 1088/26CC : 46 02 2F                              CALL	FPFIX              ;Convert the value in FPACC from floating point to
 1089/26CF : 36 53                                 MVI	L, 123o               ;Fixed point. Load L with address of FPACC
 1090/26D1 : 3E 00                                 MVI	M, 000                ;Extension register and clear it.
 1091/26D3 : 46 36 2F                              CALL	FPFLT              ;Convert fixed binary back to FP to integerize
 1092/26D6 : 36 0C                                 MVI	L, 014o               ;Load L with address of FP TEMP registers
 1093/26D8 : 46 BC 31                              CALL	OPLOAD             ;Load the value in FP TEMP into FPOP
 1094/26DB : 46 20 30                              CALL	FPSUB              ;Subtract integerized value from original
 1095/26DE : 36 56                                 MVI	L, 126o               ;Set L to address of MSW of FPACC
 1096/26E0 : C7                                    MOV	A,M                    ;Fetch the MSW of the FPACC into the accumulator
 1097/26E1 : A0                                    ANA	A                    ;See if original value and integerized value the same
 1098/26E2 : 68 FC 26                              JZ	INT2               ;If so, have integer value in FP TEMP
 1099/26E5 : 36 0C                                 MVI	L, 014o               ;Else, load L with address of FP TEMP registers
 1100/26E7 : 46 AA 31                              CALL	FLOAD              ;Restore FPACC to original (non-integerized) value
 1101/26EA : 36 14                                 MVI	L, 024o               ;Set L to register containing small value
 1102/26EC : 46 C5 31                              CALL	FACXOP             ;Set up to add small value to original value in FPACC
 1103/26EF : 46 8B 2F                              CALL	FPADD              ;Perform the addition
 1104/26F2 : 46 02 2F                   INT1:      CALL	FPFIX              ;Convert the number in FPACC from floating point
 1105/26F5 : 36 53                                 MVI	L, 123o               ;To fixed point. Load L with address of FPACC
 1106/26F7 : 3E 00                                 MVI	M, 000                ;Extension register and clear it. Now convert the number
 1107/26F9 : 44 36 2F                              JMP	FPFLT              ;Back to floating point to integerize it and exit to caller
 1108/26FC : 36 0C                      INT2:      MVI	L, 014o               ;Load L with address of FP TEMP registers. Transfer
 1109/26FE : 44 AA 31                              JMP	FLOAD              ;Number from FP TEMP (orig) to FPACC and return.
 1110/2701 : 36 56                      ABSX:      MVI	L, 126o               ;Load L with address of MSW of the FPACC
 1111/2703 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of the FPACC
 1112/2705 : C7                                    MOV	A,M                    ;Fetch the MSW of the FPACC into the accumulator
 1113/2706 : A0                                    ANA	A                    ;Test the sign of the number to see if it is positive.
 1114/2707 : 70 84 2F                              JM	FPCOMP             ;If negative, complement the number before returning.
 1115/270A : 07                                    RET                    ;Else, just return with absolute value in the FPACC.
 1116/270B : 36 56                      SGNX:      MVI	L, 126o               ;Load L with address of MSW of the FPACC
 1117/270D : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with the page of the FPACC
 1118/270F : C7                                    MOV	A,M                    ;Fetch the MSW of the FPACC into the accumulator
 1119/2710 : A0                                    ANA	A                    ;Test to see if the FPACC is zero
 1120/2711 : 2B                                    RZ                    ;Return to caller if FPACC is zero
 1121/2712 : 50 BD 25                              JP	FPONE              ;If FPACC is positive, load +1.0 into FPACC and exit
 1122/2715 : 36 14                                 MVI	L, 024o               ;If FPACC is negative, set up to load -1.0 into the
 1123/2717 : 44 AA 31                              JMP	FLOAD              ;FPACC and exit to caller
 1124/271A : 46 02 2F                   CHRX:      CALL	FPFIX              ;Convert contents of FPACC from floating point to
 1125/271D : 36 54                                 MVI	L, 124o               ;Fixed point. Load L with address of LSW of fixed
 1126/271F : C7                                    MOV	A,M                    ;Value. Fetch this byte into the accumulator.
 1127/2720 : 46 9D 22                              CALL	ECHO               ;Display the value.
 1128/2723 : 36 7F                                 MVI	L, 177o               ;Set L to address of the TAB FLAG
 1129/2725 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of the TAB FLAG
 1130/2727 : 3E FF                                 MVI	M, 377o               ;Set TAB FLAG (to inhibit display of FP value)
 1131/2729 : 07                                    RET                    ;Exit to caller.
 1132/272A : 46 02 2F                   TABX:      CALL	FPFIX              ;Convert contents of FPACC from floating point to
 1133/272D : 36 54                      TAB1:      MVI	L, 124o               ;Fixed point. Load L with address of 1,SW of fixed
 1134/272F : C7                                    MOV	A,M                    ;Value. Fetch this byte into the accumulator.
 1135/2730 : 36 23                                 MVI	L, 043o               ;Load L with address of COLUMN COUNTER
 1136/2732 : 97                                    SUB	M                    ;Subtract value in C-OLUMN COUNTER from desired
 1137/2733 : 36 7F                                 MVI	L, 177o               ;TAB position. Load L with address of the TAB FLAG.
 1138/2735 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of the TAB FLAG.
 1139/2737 : 3E FF                                 MVI	M, 377o               ;Set TAB FLAG (to inhibit display of FP value)
 1140/2739 : 70 82 36                              JM	BACKSP             ;If beyond TAB point desired, simulate back spacing
 1141/273C : 2B                                    RZ                    ;Return to caller if at desired TAB location
 1142/273D : D0                         TABC:      MOV	C,A                    ;Else, put difference count in register C
 1143/273E : 06 A0                                 MVI	A, 240o               ;Place ASCII code for space in ACC
 1144/2740 : 46 9D 22                   TABLOP:    CALL	ECHO               ;Display space on output device
 1145/2743 : 11                                    DCR	C                    ;Decrement displacement counter
 1146/2744 : 48 40 27                              JNZ	TABLOP             ;If have not reached TAB position, continue to space
 1147/2747 : 07                                    RET                    ;Else, return to calling routine.
 1148/2748 :                            
 1149/2748 :                            ;;; The label STOSYM should be AT 10 055 082dh
 1150/2748 : 36 81                      STOSYM:    MVI	L, 201o               ;Load L with address of ARRAY FLAG
 1151/274A : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Load H with page of ARRAY FLAG
 1152/274C : C7                                    MOV	A,M                    ;Fetch the value of the ARRAY FLAG into the ACC
 1153/274D : A0                                    ANA	A                    ;Check to see if the flag is set indicating processing an
 1154/274E : 68 5B 27                              JZ	STOSY1             ;Array variable value. Jump ahead if flag not set.
 1155/2751 : 3E 00                                 MVI	M, 000                ;If ARRAY FLAG was set, clear it for next time.
 1156/2753 : 36 84                                 MVI	L, 204o               ;Then load L with address of array address storage loc
 1157/2755 : F7                                    MOV	L,M                    ;Fetch the array storage address as new pointer
 1158/2756 : 2E 05                                 MVI	H,PG57 ;\HB\OLDPG57   ;tt Set H to ARRAY VALUES page   ****************
 1159/2758 : 44 B3 31                              JMP	FSTORE             ;Store the array variable value and exit to caller.
 1160/275B : 36 F8                      STOSY1:    MVI	L, 370o               ;Load L with address of TEMP CNTR
 1161/275D : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of TEMP CNTR
 1162/275F : 3E 00                                 MVI	M, 000                ;Initialize the TEMP CNTR by clearing it
 1163/2761 : 36 50                                 MVI	L, 120o               ;Load L with starting address of SYMBOL BUFFER
 1164/2763 : 1E 04                                 MVI	D,PG27 ;\HB\OLDPG27   ;** Load D with page of VARIABLES LOOK-UP table
 1165/2765 : 26 88                                 MVI	E, 210o               ;Load E with starting addr of VARIABLES LOOK-UP
 1166/2767 : C7                                    MOV	A,M                    ;Table. Fetch the (cc) for the SYMBOL BUFFER into
 1167/2768 : 3C 01                                 CPI	001                ;The ACC and see if length of variable name is just one
 1168/276A : 48 71 27                              JNZ	STOSY2             ;Character. If not, skip next couple of instructions.
 1169/276D : 36 52                                 MVI	L, 122o               ;Else, set pointer to second character location in the
 1170/276F : 3E 00                                 MVI	M, 000                ;SYMBOL BUFFER and set it to zero
 1171/2771 : 36 51                      STOSY2:    MVI	L, 121o               ;load L with address of first character in the SYMBOL
 1172/2773 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** BUFFER. Load H with page of the buffer.
 1173/2775 : 46 F4 31                              CALL	SWITCH             ;Exchange pointer to buffer for pointer to VARIABLES
 1174/2778 : C7                                    MOV	A,M                    ;LOOK-UP table. Fetch first char in a name from the
 1175/2779 : 30                                    INR	L                    ;Table. Advance the pointer to second char in a name.
 1176/277A : CF                                    MOV	B,M                    ;Fetch the second character into register B.
 1177/277B : 30                                    INR	L                    ;Advance the pointer to first byte of a value in the table.
 1178/277C : 46 F4 31                              CALL	SWITCH             ;Exchange table pointer for pointer to SYMBOL BUFF
 1179/277F : BF                                    CMP	M                    ;Compare first character in buffer against first character
 1180/2780 : 48 89 27                              JNZ	STOSY3             ;In table entry. If no match, try next entry in the table.
 1181/2783 : 30                                    INR	L                    ;If match, advance pointer to second character in buffer.
 1182/2784 : C1                                    MOV	A,B                    ;Move second character obtained from table into ACC.
 1183/2785 : BF                                    CMP	M                    ;Compare second characters in table and buffer.
 1184/2786 : 68 B2 27                              JZ	STOSY5             ;If same, have found the variable name in the table.
 1185/2789 : 46 C9 25                   STOSY3:    CALL	AD4DE              ;Add four to pointer in registers D&E to skip over value
 1186/278C : 36 F8                                 MVI	L, 370o               ;Portion of entry in table. Load L with address of TEMP
 1187/278E : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** CNTR. Load H with page of TEMP CNTR.
 1188/2790 : CF                                    MOV	B,M                    ;Fetch the counter
 1189/2791 : 08                                    INR	B                    ;Increment the counter
 1190/2792 : F9                                    MOV	M,B                    ;Restore it to storage
 1191/2793 : 36 3F                                 MVI	L, 077o               ;Set L to address of VARIABLES CNTR (indicates
 1192/2795 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Number of variables currently in table.) Set H too
 1193/2797 : C1                                    MOV	A,B                    ;Move the TEMP CNTR value into the ACC. (Number of
 1194/2798 : BF                                    CMP	M                    ;Entries checked.) Compare with number of entries in
 1195/2799 : 48 71 27                              JNZ	STOSY2             ;The table. If have not checked all entries, try next one.
 1196/279C : 36 3F                                 MVI	L, 077o               ;If have checked all entries, load L with address of the
 1197/279E : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** VARIABLES CNTR. Set H too. Fetch the counter
 1198/27A0 : CF                                    MOV	B,M                    ;Value and incrernent it to account for
 1199/27A1 : 08                                    INR	B                    ;New variable nwne that will now be
 1200/27A2 : F9                                    MOV	M,B                    ;Added to the table. Save the new value.
 1201/27A3 : C1                                    MOV	A,B                    ;Place the new counter value into the accumulator
 1202/27A4 : 3C 15                                 CPI	025o               ;And check to see that adding new variable name to the
 1203/27A6 : 50 AD 21                              JP	BIGERR             ;Table will not cause table overflow. Big Error if it does!
 1204/27A9 : 36 51                                 MVI	L, 121o               ;If room available in table, set L to address of first
 1205/27AB : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Caracter in the SYMBOL BUFFER. Set H too.
 1206/27AD : 0E 02                                 MVI	B, 002                ;Set a counter for number of characters to transfer.
 1207/27AF : 46 11 30                              CALL	MOVEIT             ;Move the variable name from buffer to table.
 1208/27B2 : 46 F4 31                   STOSY5:    CALL	SWITCH             ;Exchange buffer pointer for table pointer.
 1209/27B5 : 46 B3 31                              CALL	FSTORE             ;Transfer new mathematical value into the table.
 1210/27B8 : 44 C8 21                              JMP	CLESYM             ;Clear the SYMBOL BUFFER and exit to calling routine.
 1211/27BB :                            
 1212/27BB :                                                              ;The subroutines below are used by some of the routines
 1213/27BB :                                                              ;in this chapter as well as other parts of the program.
 1214/27BB :                            
 1215/27BB : 36 50                      SAVESY:    MVI	L, 120o               ;Load L with the address of the start of the SYMBOL
 1216/27BD : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** BUFFER. Load H with the page of the buffer.
 1217/27BF : DD                                    MOV	D,H                    ;Load register D with the page of the AUX SYMBOL
 1218/27C0 : 26 64                                 MVI	E, 144o               ;BUFFER and set register E to start of that buffer.
 1219/27C2 : 44 CC 27                              JMP	MOVECP             ;Transfer SYMBOL BF contents to AUX SYMBOL BF
 1220/27C5 :                            
 1221/27C5 : 36 64                      RESTSY:    MVI	L, 144o               ;Load L with address of start of AUX SYMBOL BUFF
 1222/27C7 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of AUX SYMBOL BUFFER
 1223/27C9 : DD                                    MOV	D,H                    ;Set D to page of SYMBOL BUFFER (same as H)
 1224/27CA : 26 50                                 MVI	E, 120o               ;Load E with start of SYMBOL BUFFER
 1225/27CC : CF                         MOVECP:    MOV	B,M                    ;Load (cc) for source string (first byte in source buffer)
 1226/27CD : 08                                    INR	B                    ;Add one to (cc) to include (cc) byte itself
 1227/27CE : 44 11 30                              JMP	MOVEIT             ;Move the source string to destination buffer
 1228/27D1 :                            
 1229/27D1 :                            ;;; The label Exec SHOULD BE AT 10 266 (This is the start of the code) 08b6h
 1230/27D1 : 36 EA                      EXEC:      MVI	L, 352o               ;Load L with address of READY message
 1231/27D3 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with page of READY message
 1232/27D5 : 46 6C 22                              CALL	TEXTC              ;Call subroutine to display the READY message
 1233/27D8 :                            
 1234/27D8 : 36 00                      EXEC1:     MVI	L, 000                ;Load L with starting address of INPUT LINE BUFFER
 1235/27DA : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of INPUT LINE BUFFER
 1236/27DC : 46 27 22                              CALL	STRIN              ;Call subroutine to input a line into the buffer
 1237/27DF : C7                                    MOV	A,M                    ;The STRIN subroutine will exit with pointer set to the
 1238/27E0 : A0                                    ANA	A                    ;CHARACTER COUNT for the line inputted. Fetch the
 1239/27E1 : 68 D8 27                              JZ	EXEC1              ;Value of the counter, if it is zero then line was blank.
 1240/27E4 : 36 DD                                 MVI	L, 335o               ;Load L with address of LIST in look up table
 1241/27E6 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;Load H with address of LIST in look up table
 1242/27E8 : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;Load D with page of line input buffer
 1243/27EA : 26 00                                 MVI	E, 000                ;Load E with start of line input buffer
 1244/27EC : 46 F5 21                              CALL	STRCP              ;Call string compare subroutine to see if first word in
 1245/27EF : 48 07 28                              JNZ	NOLIST             ;Input buffer is LIST. Jump 3 ahead if not LIST.
 1246/27F2 : 36 00                                 MVI	L, 000                ;If LIST, set up pointers to start of USER PROGRAM
 1247/27F4 : 2E 06                                 MVI	H, BGNPGRAM           ;BUFFER. (Note user could alter this starting addr)   *****
 1248/27F6 :                            
 1249/27F6 :                                                              ;Next portion of program will LIST the contents of the
 1250/27F6 :                                                              ;USER PROGRAM BUFFER until an end of buffer
 1251/27F6 :                                                              ;(zero byte) indicator is detected.
 1252/27F6 :                            
 1253/27F6 : C7                         LIST:      MOV	A,M                    ;Fetch the first byte of a line in the USER PROGRAM
 1254/27F7 : A0                                    ANA	A                    ;BUFFER and see if it is zero. If so, have finished LIST
 1255/27F8 : 68 D1 27                              JZ	EXEC               ;So go back to start of Executive and display READY.
 1256/27FB : 46 6C 22                              CALL	TEXTC              ;Else call subroutine to display a line of information
 1257/27FE : 46 1A 22                              CALL	ADV                ;Now call subroutine to advance buffer pointer to
 1258/2801 : 46 7C 22                              CALL	CRLF               ;Character count in next line. Also display a CR & LF.
 1259/2804 : 44 F6 27                              JMP	LIST               ;Continue LISTing process
 1260/2807 :                            
 1261/2807 :                                                              ;If line inputted by operator did not contain a LIST comman
 1262/2807 :                                                              ;continue program to see if RUN or SCRatch command.
 1263/2807 :                            
 1264/2807 : 36 E2                      NOLIST:    MVI	L, 342o               ;Load L with address of RUN in look up table
 1265/2809 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with address of RUN in look up table
 1266/280B : 26 00                                 MVI	E, 000                ;Load E with start of line input buffer
 1267/280D : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Load D with page of line input buffer
 1268/280F : 26 00                                 MVI	E, 000                ;(Reserve 2 locs in case of patching by duplicating above)
 1269/2811 : 46 F5 21                              CALL	STRCP              ;Call string compare subroutine to see if first word in
 1270/2814 : 68 42 2A                              JZ	RUN                ;Input buffer is RUN. Go to RUN routine if match.
 1271/2817 : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;** If not RUN command, reset address pointers back
 1272/2819 : 26 00                                 MVI	E, 000                ;To the start of the line input buffer
 1273/281B : 36 E6                                 MVI	L, 346o               ;Load L with address of SCR in look up table
 1274/281D : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with page of SCR in look up table
 1275/281F : 46 F5 21                              CALL	STRCP              ;Call string compare subroutine to see if first word in
 1276/2822 : 48 54 28                              JNZ	NOSCR              ;Input buffer is SCR. If not then jump ahead.
 1277/2825 : 2E 03                      ENTRY_SCR: MVI	H,PG26 ;\HB\OLDPG26   ;** If found SCR command then load memory pointer
 1278/2827 : 36 F4                                 MVI	L, 364o               ;With address of a pointer storage location. Set that
 1279/2829 : 3E 06                                 MVI	M, BGNPGRAM           ;tt Storage location to page of start of USER PRO-  *******
 1280/282B : 30                                    INR	L                    ;GRAM BUFFER. (Buffer start loc may be altered).
 1281/282C : 3E 00                                 MVI	M, 000                ;Then adv pntr and do same for low addr portion of pntr
 1282/282E : 36 3F                                 MVI	L, 077o               ;Now set pointer to address of VARIABLES counter
 1283/2830 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Storage location. Initialize this counter by placing
 1284/2832 : 3E 01                                 MVI	M, 001                ;The count of one into it. Now change the memory pntr
 1285/2834 :                            ;MGA 3/31/12 put it back to 001; solves nested FOR/NEXT, but limits vars to 19
 1286/2834 :                            ;   as the letter from James Tucker (1/77) mentioned
 1287/2834 :                            ;   apparently, James didn't test FOR/NEXT; original Loboyko didn't have this
 1288/2834 :                            ;;;           LMI 001                ;The count of one into it. Now change the memory pntr
 1289/2834 :                            ;;; Apparently, in Page 3 of Issue 4 of Scelbal update (1/77) they say the above should change.
 1290/2834 :                            ;;; This makes the SCR command clear the whole variable space, otherwise one space is lost.  
 1291/2834 : 36 3D                                 MVI	L, 075o               ;To storage location for number of dimensioned arrays
 1292/2836 : 3E 00                                 MVI	M, 000                ;@@ And initialize to zero. (@@ = Substitute NOPs if
 1293/2838 : 36 50                                 MVI	L, 120o               ;@@ DIMension capability not used in package.) Also
 1294/283A : 3E 00                                 MVI	M, 000                ;@@ Initialize l'st byte of array name table to zero.
 1295/283C : 36 88                                 MVI	L, 210o               ;Set pointer to storage location for the first byte of the
 1296/283E : 3E 00                                 MVI	M, 000                ;VARIABLES symbol table. Initialize it to zero too.
 1297/2840 : 30                                    INR	L                    ;Advance the pointer and zero the second location
 1298/2841 : 3E 00                                 MVI	M, 000                ;In the Variables table also.
 1299/2843 : 2E 06                                 MVI	H, BGNPGRAM           ;tt Load H with page of start of USER PROGRAM    **********
 1300/2845 : 36 00                                 MVI	L, 000                ;BUFFER. (Buffer start location could be altered.)
 1301/2847 : 3E 00                                 MVI	M, 000                ;Clear first location to indicate end of user program.
 1302/2849 : 2E 05                                 MVI	H,PG57 ;\HB\OLDPG57   ;@@ Load H with page of ARRAYS storage
 1303/284B : 3E 00                      SCRLOP:    MVI	M, 000                ;@@ And form a loop to clear out all the locations
 1304/284D : 30                                    INR	L                    ;@@ On the ARRAYS storage page. (@@ These become
 1305/284E : 48 4B 28                              JNZ SCRLOP             ;@@ NOPs if DIMension capability deleted fm package.)
 1306/2851 : 44 D1 27                              JMP EXEC               ;SCRatch operations completed, go back to EXEC.
 1307/2854 :                            
 1308/2854 :                                                              ;If line inputted did not contain RUN or SCRatch com-
 1309/2854 :                                                              ;mand, program continues by testing for SAVE or LOAD
 1310/2854 :                                                              ;commands. If it does not find either of these com-
 1311/2854 :                                                              ;mands, then operator did not input an executive com-
 1312/2854 :                                                              ;mand. Program then sets up to see if the first entry in
 1313/2854 :                                                              ;the line inputted is a LINE NUMBER.
 1314/2854 :                            
 1315/2854 : 26 BA                      NOSCR:     MVI	E, 272o               ;Load E with address of SAVE in look up table
 1316/2856 : 1E 02                                 MVI	D,PG01 ;\HB\OLDPG1    ;Load D with page of look up table
 1317/2858 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;Load H with page of input line buffer
 1318/285A : 36 00                                 MVI	L, 000                ;Set L to start of input line buffer
 1319/285C : 46 F5 21                              CALL	STRCP              ;Call string compare subroutine to see if first word in
 1320/285F : 68 B4 20                              JZ	EXIT               ;tt Input buffer is SAVE. If so, go to user's SAVE rtn
 1321/2862 : 36 BF                                 MVI	L, 277o               ;If not SAVE then load L with address of LOAD in look
 1322/2864 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;Up table and load H with page of look up table
 1323/2866 : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;Load D with page of input line buffer
 1324/2868 : 26 00                                 MVI	E, 000                ;And L to start of input line buffer
 1325/286A : 46 F5 21                              CALL	STRCP              ;Call string compare subroutine to see if first word in
 1326/286D : 68 B8 20                              JZ	MON                ;tt Input buffer is LOAD. If so, go to user's LOAD rtn
 1327/2870 : 36 F0                                 MVI	L, 360o               ;If not LOAD then set pointer to address of storage loc
 1328/2872 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** For USER PROGRAM BUFFER pointer. Initialize this
 1329/2874 : 3E 06                                 MVI	M, BGNPGRAM           ;tt Pointer to the starting address of the program buffer.
 1330/2876 : 30                                    INR	L                    ;Advance memory pntr. Since pointer storage requires
 1331/2877 : 3E 00                                 MVI	M, 000                ;Two locations, initialize the low addr portion also.
 1332/2879 : 46 1B 21                              CALL	SYNTAX             ;Call the SYNTAX subroutine to obtain a TOKEN indi-
 1333/287C : 36 83                                 MVI	L, 203o               ;Cator which will be stored in this location. Upon return
 1334/287E : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** From SYNTAX subroutine set memory pointer to
 1335/2880 : C7                                    MOV	A,M                    ;The TOKEN indicator storage location and fetch the
 1336/2881 : A0                                    ANA	A                    ;Value of the TOKEN. If the value of the syntax TOKEN
 1337/2882 : 50 8C 28                              JP	SYNTOK             ;Is positive then have a valid entry.
 1338/2885 : 06 D3                      SYNERR:    MVI	A, 323o               ;However, if SYNTAX returns a negative value TOKEN
 1339/2887 : 16 D9                                 MVI	C, 331o               ;Then have an error condition. Set up the letters SY in
 1340/2889 : 44 B1 21                              JMP	ERROR              ;ASCII code and go to display error message to operator.
 1341/288C : 36 E0                      SYNTOK:    MVI	L, 340o               ;Set pointer to start of LINE NUMBER storage area
 1342/288E : C7                                    MOV	A,M                    ;First byte there will contain the length of the line
 1343/288F : A0                                    ANA	A                    ;Number character string. Fetch that value (cc).
 1344/2890 : 68 93 2A                              JZ	DIRECT             ;DIRECT If line number blank, have a DIRECT statement!
 1345/2893 : 36 F0                                 MVI	L, 360o               ;If have a line number must get line in input buffer into
 1346/2895 : 3E 06                                 MVI	M, BGNPGRAM           ;tt User program buffer. Initialize pointer to user buffer.
 1347/2897 : 30                                    INR	L                    ;This is a two byte pointer so after initializing page addr
 1348/2898 : 3E 00                                 MVI	M, 000                ;Advance pointer and initialize location on page address
 1349/289A :                            
 1350/289A :                                                              ;If the line in the LINE INPUT BUFFER has a line num-
 1351/289A :                                                              ;ber then the line is to be placed in the USER PRO-
 1352/289A :                                                              ;GRAM BUFFER. It is now necessary to determine
 1353/289A :                                                              ;where the new line is to be placed in the USER PRO-
 1354/289A :                                                              ;GRAM BUFFER. This is dictated by the value of the
 1355/289A :                                                              ;new line number in relation to the line numbers cur-
 1356/289A :                                                              ;rently in the program buffer. The next portion of the
 1357/289A :                                                              ;program goes through the contents of the USER PRO-
 1358/289A :                                                              ;GRAM BUFFER comparing the values of the line num-
 1359/289A :                                                              ;bers already stored against the value of the line number
 1360/289A :                                                              ;currently being held in the LINE INPUT BUFFER.
 1361/289A :                                                              ;Appropriate action is then taken to Insert or Append,
 1362/289A :                                                              ;Change, or Delete a line in the program buffer.
 1363/289A :                            
 1364/289A : 36 81                      GETAUX:    MVI	L, 201o               ;Set memory pointer to line character pointer storage
 1365/289C : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Location and then initialize that storage location
 1366/289E : 3E 01                                 MVI	M, 001                ;To point to the 1'st character in a line
 1367/28A0 : 36 E8                                 MVI	L, 350o               ;Set memory pointer to addr of start of auxiliary line
 1368/28A2 : 3E 00                                 MVI	M, 000                ;Number storage area and initialize first byte to zero
 1369/28A4 : 36 81                      GETAU0:    MVI	L, 201o               ;Set memory pointer to line character pointer storage loc
 1370/28A6 : 46 57 29                              CALL	GETCHP             ;Fetch a char in line pointed to by line pointer
 1371/28A9 : 68 BD 28                              JZ	GETAU1             ;If character is a space, skip it by going to advance pntrs
 1372/28AC : 3C B0                                 CPI	260o               ;If not a space check to see if character represents a
 1373/28AE : 70 D2 28                              JM	GETAU2             ;Valid decimal digit in the range 0 to 9 by testing the
 1374/28B1 : 3C BA                                 CPI	272o               ;ASCII code value obtained. If not a deciznal digit then
 1375/28B3 : 50 D2 28                              JP	GETAU2             ;Assume have obtained the line number. Go process.
 1376/28B6 : 36 E8                                 MVI	L, 350o               ;If valid decimal digit want to append the digit to the
 1377/28B8 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Current string being built up in the auxiliary line
 1378/28BA : 46 E7 21                              CALL	CONCT1             ;Number storage area so call sub to concat a character.
 1379/28BD : 36 81                      GETAU1:    MVI	L, 201o               ;Reset memory pointer to line character pntr storage loc
 1380/28BF : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;On the appropriate page.
 1381/28C1 : CF                                    MOV	B,M
 1382/28C2 : 08                                    INR	B                    ;Fetch the pointer, increment it, and restore new value
 1383/28C3 : F9                                    MOV	M,B
 1384/28C4 : 36 F0                                 MVI	L, 360o               ;Set memory pointer to pgm buff line pntr storage loc
 1385/28C6 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   
 1386/28C8 : D7                                    MOV	C,M                    ;Bring the high order byte of this double byte pointer
 1387/28C9 : 30                                    INR	L                    ;Into CPU register C. Then advance the memory pntr
 1388/28CA : F7                                    MOV	L,M                    ;And bring the low order byte into register L. Now trans-
 1389/28CB : EA                                    MOV	H,C                    ;Fer the higher order portion into memory pointer H.
 1390/28CC : C7                                    MOV	A,M                    ;Obtain the char cntr (cc) which indicates the length of
 1391/28CD : 09                                    DCR	B                    ;The line being pointed to by the user program line pntr
 1392/28CE : B9                                    CMP	B                    ;Compare this with the value of the chars processed so
 1393/28CF : 48 A4 28                              JNZ	GETAU0             ;Far in current line. If not equal, continue getting line n
 1394/28D2 : 36 F0                      GETAU2:    MVI	L, 360o               ;Reset mem pntr to pgm buffer line pntr storage
 1395/28D4 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** On this page and place the high order byte
 1396/28D6 : DF                                    MOV	D,M                    ;Of this pointer into CPU register D
 1397/28D7 : 30                                    INR	L                    ;Advance the memory pointer, fetch the second
 1398/28D8 : F7                                    MOV	L,M                    ;Byte of the pgm buffer line pointer into register L
 1399/28D9 : EB                                    MOV	H,D                    ;Now make the memory pointer equal to this value
 1400/28DA : C7                                    MOV	A,M                    ;Fetch the first byte of a line in the program buffer
 1401/28DB : A0                                    ANA	A                    ;Test to see if end of contents of pgm buff (zero byte)
 1402/28DC : 48 E2 28                              JNZ	NOTEND             ;If not zero continue processing. If zero have reached
 1403/28DF : 44 09 29                              JMP	NOSAME             ;End of buffer contents so go APPEND line to buffer.
 1404/28E2 :                            ;;; there are some open addresses here.  Above JUMP starts at 11-304;
 1405/28E2 :                            
 1406/28E2 :                            ;          ORG	09deh              ;011#336
 1407/28E2 : 36 E8                      NOTEND:    MVI	L, 350o               ;Load L with addr of auxiliary line number storage loc
 1408/28E4 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;Load H with addr of aux line number storage loc
 1409/28E6 : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;Load D with addr of line number buffer location
 1410/28E8 : 26 E0                                 MVI	E, 340o               ;Load E with address of line number buffer location
 1411/28EA : 46 F5 21                              CALL	STRCP              ;Compare line nr in input buffer with line number in
 1412/28ED : 70 3F 29                              JM	CONTIN             ;User program buffer. If lesser in value keep looking.
 1413/28F0 : 48 09 29                              JNZ	NOSAME             ;If greater in value then go to Insert line in pgm buffer
 1414/28F3 : 36 F0                                 MVI	L, 360o               ;If same values then must remove the line with the same
 1415/28F5 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Line number from the user program buffer. Set up
 1416/28F7 : D7                                    MOV	C,M                    ;The CPU memory pointer to point to the current
 1417/28F8 : 30                                    INR	L                    ;Position in the user program buffer by retrieving that
 1418/28F9 : F7                                    MOV	L,M                    ;Pointer from its storage location. Then obtain the first
 1419/28FA : EA                                    MOV	H,C                    ;Byte of data pointed to which will be the character
 1420/28FB : CF                                    MOV	B,M                    ;Count for that line (cc). Add one to the cc value to take
 1421/28FC : 08                                    INR	B                    ;Account of the (cc) byte itself and then remove that
 1422/28FD : 46 68 29                              CALL	REMOVE             ;Many bytes to effectively delete the line fm the user
 1423/2900 : 36 83                                 MVI	L, 203o               ;Program buffer. Now see if line in input buffer consists
 1424/2902 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Only of a line number by checking SYNTAX
 1425/2904 : C7                                    MOV	A,M                    ;TOKEN value. Fetch the TOKEN value from its
 1426/2905 : A0                                    ANA	A                    ;Storage location. If it is zero then input buffer only
 1427/2906 : 68 D1 27                              JZ	EXEC               ;Contains a line number. Action is a pure Delete.
 1428/2909 : 36 F0                      NOSAME:    MVI	L, 360o               ;Reset memory pointer to program buffer
 1429/290B : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;Line pointer storage location
 1430/290D : DF                                    MOV	D,M                    ;Load high order byte into CPU register D
 1431/290E : 30                                    INR	L                    ;Advance memory pointer
 1432/290F : E7                                    MOV	E,M                    ;Load low order byte into CPU register E
 1433/2910 : 36 00                                 MVI	L, 000                ;Load L with address of start of line input buffer
 1434/2912 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Do same for CPU register H
 1435/2914 : CF                                    MOV	B,M                    ;Get length of line input buffer
 1436/2915 : 08                                    INR	B                    ;Advance length by one to include (cc) byte
 1437/2916 : 46 89 29                              CALL	INSERT             ;Go make room to insert line into user program buffer
 1438/2919 : 36 F0                                 MVI	L, 360o               ;Reset memory pointer to program buffer
 1439/291B : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Line pointer storage location
 1440/291D : DF                                    MOV	D,M                    ;Load higher byte into CPU register D
 1441/291E : 30                                    INR	L                    ;Advance memory pointer
 1442/291F : E7                                    MOV	E,M                    ;Load low order byte into CPU register E
 1443/2920 : 36 00                                 MVI	L, 000                ;Load L with address of start of line input buffer
 1444/2922 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Do same for CPU register H
 1445/2924 : 46 2A 29                              CALL	MOVEC              ;Call subroutine to Insert line in input buffer into the
 1446/2927 : 44 D8 27                              JMP	EXEC1              ;User program buffer then go back to start of EXEC.
 1447/292A : CF                         MOVEC:     MOV	B,M                    ;Fetch length of string in line input buffer
 1448/292B : 08                                    INR	B                    ;Increment that value to provide for (cc)
 1449/292C : C7                         MOVEPG:    MOV	A,M                    ;Fetch character from line input buffer
 1450/292D : 46 1A 22                              CALL	ADV                ;Advance pointer for line input buffer
 1451/2930 : 46 F4 31                              CALL	SWITCH             ;Switch memory pointer to point to user pgm buffer
 1452/2933 : F8                                    MOV	M,A                    ;Deposit character fm input buff into user pgm buff
 1453/2934 : 46 1A 22                              CALL	ADV                ;Advance pointer for user program buffer
 1454/2937 : 46 F4 31                              CALL	SWITCH             ;Switch memory pntr back to point to input buffer
 1455/293A : 09                                    DCR	B                    ;Decrement character counter stored in CPU register B
 1456/293B : 48 2C 29                              JNZ	MOVEPG             ;If counter does not go to zero continue transfer ops
 1457/293E : 07                                    RET                    ;When counter equals zero return to caMVI L,ng routine
 1458/293F : 36 F0                      CONTIN:    MVI	L, 360o               ;Reset memory pointer to program buffer
 1459/2941 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Line pointer storage location
 1460/2943 : DF                                    MOV	D,M                    ;Load high order byte into CPU register D
 1461/2944 : 30                                    INR	L                    ;Advance memory pointer
 1462/2945 : E7                                    MOV	E,M                    ;Load low order byte into CPU register E
 1463/2946 : EB                                    MOV	H,D                    ;Now set CPU register H to high part of address
 1464/2947 : F4                                    MOV	L,E                    ;And set CPU register L to low part of address
 1465/2948 : CF                                    MOV	B,M                    ;Fetch the character counter (cc) byte fm line in
 1466/2949 : 08                                    INR	B                    ;Program buffer and add one to compensate for (cc)
 1467/294A : 46 C9 29                              CALL	ADBDE              ;Add length of line value to old value to get new pointer
 1468/294D : 36 F0                                 MVI	L, 360o               ;Reset memory pointer to program buffer
 1469/294F : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Line pointer storage location
 1470/2951 : FB                                    MOV	M,D                    ;Restore new high portion
 1471/2952 : 30                                    INR	L                    ;Advance memory pointer
 1472/2953 : FC                                    MOV	M,E                    ;And restore new low portion
 1473/2954 : 44 9A 28                              JMP	GETAUX             ;Continue til find point at which to enter new line
 1474/2957 : 2E 03                      GETCHP:    MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with pointer page (low portion set upon
 1475/2959 : CF                                    MOV	B,M                    ;Entry). Now fetch pointer into CPU register B.
 1476/295A : 36 F0                                 MVI	L, 360o               ;Reset pntr to pgm buffer line pointer storage location
 1477/295C : DF                                    MOV	D,M                    ;Load high order byte into CPU register D
 1478/295D : 30                                    INR	L                    ;Advance memory pointer
 1479/295E : E7                                    MOV	E,M                    ;Load low order byte into CPU register E
 1480/295F : 46 C9 29                              CALL	ADBDE              ;Add pointer to pgm buffer pointer to obtain address of
 1481/2962 : EB                                    MOV	H,D                    ;Desired character. Place high part of new addr in H.
 1482/2963 : F4                                    MOV	L,E                    ;And low part of new address in E.
 1483/2964 : C7                                    MOV	A,M                    ;Fetch character from position in line in user pgm buffer
 1484/2965 : 3C A0                                 CPI	240o               ;See if it is the ASCII code for space
 1485/2967 : 07                                    RET                    ;Return to caller with flags set to indicate result
 1486/2968 : 46 97 22                   REMOVE:    CALL	INDEXB             ;Add (cc) plus one to addr of start of line
 1487/296B : D7                                    MOV	C,M                    ;Obtain byte from indexed location and
 1488/296C : 46 66 22                              CALL	SUBHL              ;Subtract character count to obtain old location
 1489/296F : FA                                    MOV	M,C                    ;Put new byte in old location
 1490/2970 : C2                                    MOV	A,C                    ;As well as in the Accumulator
 1491/2971 : A0                                    ANA	A                    ;Test to see if zero byte to indicate end of user pgm buff
 1492/2972 : 68 7B 29                              JZ	REMOV1             ;If it is end of user pgm buffer, go complete process
 1493/2975 : 46 1A 22                              CALL	ADV                ;Otherwise add one to the present pointer value
 1494/2978 : 44 68 29                              JMP	REMOVE             ;And continue removing chamcters from the user pgm bf
 1495/297B : 36 F4                      REMOV1:    MVI	L, 364o               ;Load L with end of user pgm buffer pointer storage loc
 1496/297D : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of that pointer storage location
 1497/297F : DF                                    MOV	D,M                    ;Get page portion of end of pgm buffer address
 1498/2980 : 30                                    INR	L                    ;Advance memory pointer
 1499/2981 : C7                                    MOV	A,M                    ;And get low portion of end of pgm buffer address into
 1500/2982 : 91                                    SUB	B                    ;Accumulator then subtract displacement value in B
 1501/2983 : F8                                    MOV	M,A                    ;Restore new low portion of end of pgm buffer address
 1502/2984 : 03                                    RNC                    ;If subtract did not cause carry can return now
 1503/2985 : 31                                    DCR	L                    ;Otherwise decrement memory pointer back to page
 1504/2986 : 19                                    DCR	D                    ;Storage location, decrement page value to give new page
 1505/2987 : FB                                    MOV	M,D                    ;And store new page value back in buffer pntr storage loc
 1506/2988 : 07                                    RET                    ;Then return to calling routine
 1507/2989 : 36 F4                      INSERT:    MVI	L, 364o               ;Load L with end of user pgm buffer pointer storage loc
 1508/298B : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of that pointer storage location
 1509/298D : C7                                    MOV	A,M                    ; Get page portion of end of program buffer address
 1510/298E : 30                                    INR	L                    ;Advance memory pointer
 1511/298F : F7                                    MOV	L,M                    ;Load low portion of end of program buffer address
 1512/2990 : E8                                    MOV	H,A                    ;Into L and finish setting up memory pointer
 1513/2991 : 46 97 22                              CALL	INDEXB             ;Add (cc) of line in input buffer to form new end of
 1514/2994 : C5                                    MOV	A,H                    ;Program buffer address. Fetch new end of buffer page
 1515/2995 : 3C 1E                                 CPI	ENDPGRAM           ;tt Address and see if this value would exceed user's
 1516/2997 : 50 AD 21                              JP	BIGERR             ;System capabilit'y. Go display error message if so!
 1517/299A : 46 66 22                              CALL	SUBHL              ;Else restore original value of end of buffer address
 1518/299D : D7                         INSER1:    MOV	C,M                    ;Bring byte pointed to by H & L into CPU register C
 1519/299E : 46 97 22                              CALL	INDEXB             ;Add displacement value to current memory pointer
 1520/29A1 : FA                                    MOV	M,C                    ;Store the byte in the new location
 1521/29A2 : 46 66 22                              CALL	SUBHL              ;Now subtract displacement value from H & L
 1522/29A5 : 46 C3 29                              CALL	CPHLDE             ;Compare this with the address stored in D & E
 1523/29A8 : 68 B1 29                              JZ	INSER3             ;If same then go finish up Insert operation
 1524/29AB : 46 8F 22                              CALL	DEC                ;Else set pointer to the byte before the byte just
 1525/29AE : 44 9D 29                              JMP	INSER1             ;Processed and continue the Insert operation
 1526/29B1 :                            INSER3:
 1527/29B1 : 36 00                      INCLIN:    MVI	L, 000                ;Load L with start of line input buffer
 1528/29B3 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of start of line input buffer
 1529/29B5 : CF                                    MOV	B,M                    ;Fetch length of the line in line input buffer
 1530/29B6 : 08                                    INR	B                    ;Increment value by one to include (cc) byte
 1531/29B7 : 36 F4                                 MVI	L, 364o               ;Set memory pointer to end of user pgrn buffer pointer
 1532/29B9 : DF                                    MOV	D,M                    ;Storage location on same page and fetch page address
 1533/29BA : 30                                    INR	L                    ;Of this pointer into D. Then advance memory pointer
 1534/29BB : E7                                    MOV	E,M                    ;And get low part of this pointer into CPU register E.
 1535/29BC : 46 C9 29                              CALL	ADBDE              ;Now add displacement (cc) of line in input buffer to
 1536/29BF : FC                                    MOV	M,E                    ;The end of program buffer pointer. Replace the updated
 1537/29C0 : 31                                    DCR	L                    ;Low portion of the new pointer value back in stomge
 1538/29C1 : FB                                    MOV	M,D                    ;And restore the new page value back into storage
 1539/29C2 : 07                                    RET                    ;Then return to calling routine
 1540/29C3 : C5                         CPHLDE:    MOV	A,H                    ;Subroutine to compare if the contents of CPU registers
 1541/29C4 : BB                                    CMP	D                    ;H & L are equal to registers D & E. First compare
 1542/29C5 : 0B                                    RNZ                    ;Register H to D. Return with flags set if not equal. If
 1543/29C6 : C6                                    MOV	A,L                    ;Equal continue by comparing register L to E.
 1544/29C7 : BC                                    CMP	E                    ;IF L equals E then H & L equal to D & E so return to
 1545/29C8 : 07                                    RET                    ;Calling routines with flags set to equality status
 1546/29C9 : C4                         ADBDE:     MOV	A,E                    ;Subroutine to add the contents of CPU register B (single
 1547/29CA : 81                                    ADD	B                    ;Byte value) to the double byte value in registers D & E.
 1548/29CB : E0                                    MOV	E,A                    ;First add B to E to form new least significant byte
 1549/29CC : 03                                    RNC                    ;Restore new value to E and exit if no carry resulted
 1550/29CD : 18                                    INR	D                    ;If had a carry then must increment most significant byte
 1551/29CE : 07                                    RET                    ;In register D before returning to calling routine
 1552/29CF : 06 DE                      CTRLC:     MVI	A, 336o               ;Set up ASCII code for t (up arrow) in Accumulator.
 1553/29D1 : 16 C3                                 MVI	C, 303o               ;Set up ASCII code for letter 'C' in CPU register C.
 1554/29D3 : 44 B1 21                              JMP	ERROR              ;Go display the 'Control C' condition message.
 1555/29D6 : 36 E0                      FINERR:    MVI	L, 340o               ;Load L with starting address of line number storage area
 1556/29D8 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of line number storage area
 1557/29DA : C7                                    MOV	A,M                    ;Get (cc) for line number string. If length is zero meaning
 1558/29DB : A0                                    ANA	A                    ;There is no line number stored in the buffer then jump
 1559/29DC : 68 ED 29                              JZ	FINER1             ;Ahead to avoid displaying "AT LINE" message
 1560/29DF : 36 F6                                 MVI	L, 366o               ;Else load L with address of start of "AT LINE" message
 1561/29E1 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Stored on this page
 1562/29E3 : 46 6C 22                              CALL	TEXTC              ;Call subroutine to display the "AT LINE" message
 1563/29E6 : 36 E0                                 MVI	L, 340o               ;Now reset L to starting address of line number storage
 1564/29E8 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Area and do same for CPU register H
 1565/29EA : 46 6C 22                              CALL	TEXTC              ;Call subroutine to display the line number
 1566/29ED : 46 7C 22                   FINER1:    CALL	CRLF               ;Call subroutine to provide a carriage-return and line-feed
 1567/29F0 :                            ;	   JMP	PATCH3 
 1568/29F0 :                            ;;; The below label patch3 should start at 11 307 09c7h
 1569/29F0 : 36 81                      PATCH3:	   MVI	L, 201o               ; ptr to A/V storage
 1570/29F2 : 2E 04                      	   MVI	H,PG27 ;\HB\OLDPG27   ; MGA 3/31/12 make relocatable; prev: LHI 027
 1571/29F4 : 3E 00                      	   MVI	M, 000o               ; clear A/V flag
 1572/29F6 : 44 D1 27                   	   JMP	EXEC
 1573/29F9 :                            ;;; The following is the old code, before patch 3
 1574/29F9 :                            ;;;        JMP	EXEC               ;To the display device then return to EXECUTIVE.
 1575/29F9 : 06 C4                      DVERR:     MVI	A, 304o               ;Set up ASCII code for letter 'D' in Accumulator
 1576/29FB : 16 DA                                 MVI	C, 332o               ;Set up ASCII code for letter 'Z' in CPU register C
 1577/29FD : 44 B1 21                              JMP	ERROR              ;Go display the 'DZ' (divide by zero) error message
 1578/2A00 : 06 C6                      FIXERR:    MVI	A, 306o               ;Set up ASCII code for letter 'F' in Accumulator
 1579/2A02 : 16 D8                                 MVI	C, 330o               ;Set up ASCII code for letter 'X' in CPU register C
 1580/2A04 : 44 B1 21                              JMP	ERROR              ;Go display the 'FX' (FiX) error message
 1581/2A07 : 06 C9                      NUMERR:    MVI	A, 311o               ;Set up ASCII code for letter 'I' in Accumulator
 1582/2A09 : 16 CE                                 MVI	C, 316o               ;Set up ASCII code for letter 'N' in CPU register C
 1583/2A0B : 36 90                                 MVI	L, 220o               ;Load L with address of pointer used by DINPUT
 1584/2A0D : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Routine. Do same for register H.
 1585/2A0F : 3E 00                                 MVI	M, 000                ;Clear the location
 1586/2A11 : 44 B1 21                              JMP	ERROR              ;Go display the'IN'(Illegal Number) error message
 1587/2A14 :                            
 1588/2A14 :                                                              ;The following subroutine, used by various sections of
 1589/2A14 :                                                              ;SCELBAL, will search the LINE INPUT BUGGER for
 1590/2A14 :                                                              ;a character string which is contained in a buffer starting
 1591/2A14 :                                                              ;at the address pointed to by CPU registers H & L when
 1592/2A14 :                                                              ;the subroutine is entered.
 1593/2A14 :                            
 1594/2A14 : 1E 03                      INSTR:     MVI	D,PG26 ;\HB\OLDPG26   ;**Set D to starting page of LINE INPUT BUFFER
 1595/2A16 : 26 00                                 MVI	E, 000                ;Load E with starting location of LINE INPUT BUFFER
 1596/2A18 : 46 3E 2A                   INSTR1:    CALL	ADVDE              ;Advancer D & E pointer to the next location (input
 1597/2A1B : 46 D5 31                              CALL	SAVEHL             ;Buffer). Now save contents of d, E, H & L vefore the
 1598/2A1E : CF                                    MOV	B,M                    ;Compare operations. Get length of TEST buffer in B.
 1599/2A1F : 46 1A 22                              CALL	ADV                ;Advance H & L buffer to first char in TEST buffer.
 1600/2A22 : 46 13 22                              CALL	STRCPC             ;Compare contents of TEST buffer against input buffer
 1601/2A25 : 68 E5 31                              JZ	RESTHL             ;For length B. If match, restore pntrs and exit to caller.
 1602/2A28 : 46 E5 31                              CALL	RESTHL             ;If no match, restore pointers for loop test.
 1603/2A2B : 36 00                                 MVI	L, 000                ;Load L with start of input buffer (to get the char cntr).
 1604/2A2D : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;**Load H with page of input buffer.
 1605/2A2F : C7                                    MOV	A,M                    ;Get length of buffer (cc) into the accumulator.
 1606/2A30 : BC                                    CMP	E                    ;Compare with current input buffer pointer value.
 1607/2A31 : 68 3B 2A                              JZ	INSTR2             ;If at end of buffer, jump ahead.
 1608/2A34 : 46 E5 31                              CALL	RESTHL             ;Else restore test string address (H&L) and input buffer
 1609/2A37 : 44 18 2A                              JMP	INSTR1             ;Address (D&E). Look gor occurrence of test string in ln.
 1610/2A3A : 00                                    HLT             ;Safety halt. If program reaches here have system failure.
 1611/2A3B : 26 00                      INSTR2:    MVI	E, 000                ;If reach end of input buffer without finding a match
 1612/2A3D : 07                                    RET                    ;Load E with 000 as an indicator and return to caller.
 1613/2A3E : 20                         ADVDE:     INR	E                    ;Subroutine to advance the pointer in the register
 1614/2A3F : 0B                                    RNZ                    ;Pair D & E. Advance contents of E. Return if not zero.
 1615/2A40 : 18                                    INR	D                    ;If register E goes to 0 when advanced, then advance
 1616/2A41 : 07                                    RET                    ;Register D too. Exit to calling routine.
 1617/2A42 :                            
 1618/2A42 :                            ;;; The label RUN should start at 13-170 0b78h
 1619/2A42 : 36 3B                      RUN:       MVI	L, 073o               ;Load L with addr of GOSUB/RETURN stack pointer
 1620/2A44 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Load H with page of same pointer
 1621/2A46 : 3E 00                                 MVI	M, 000                ;Initialize the GOSUB/RETURN stack pointer to zero
 1622/2A48 : 36 85                                 MVI	L, 205o               ;Load L with addr of FOR/NEXT stack pointer
 1623/2A4A : 3E 00                                 MVI	M, 000                ;Initialize the FOR/NEXT stack pointer to zero
 1624/2A4C : 36 F0                                 MVI	L, 360o               ;Load L with addr of user pgm buffer line pointer
 1625/2A4E : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of user pgm buffer line pointer
 1626/2A50 : 3E 06                                 MVI	M, BGNPGRAM           ;tt Initialize pointer (may be altered by user)   *******
 1627/2A52 : 30                                    INR	L                    ;Advance memory pointer to low portion of user pgm
 1628/2A53 : 3E 00                                 MVI	M, 000                ;Buffer pointer and initialize to start of buffer
 1629/2A55 : 44 78 2A                              JMP	SAMLIN             ;Start executing user program with first line in buffer
 1630/2A58 : 36 F0                      NXTLIN:    MVI	L, 360o               ;Load L with addr of user program buffer line pointer
 1631/2A5A : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of user pgm buffer line pointer
 1632/2A5C : DF                                    MOV	D,M                    ;Place page addr of pgm buffer line pointer in D
 1633/2A5D : 30                                    INR	L                    ;Advance the memory pointer
 1634/2A5E : E7                                    MOV	E,M                    ;Place low addr of pgm buffer line pointer in E
 1635/2A5F : EB                                    MOV	H,D                    ;Also put page addr of pgm buffer line pointer in H
 1636/2A60 : F4                                    MOV	L,E                    ;And low addr of pgm buffer line pointer in L
 1637/2A61 : CF                                    MOV	B,M                    ;Now fetch the (cc) of current line into register B
 1638/2A62 : 08                                    INR	B                    ;Add one to account for (cc) byte itself
 1639/2A63 : 46 C9 29                              CALL	ADBDE              ;Add value in B to D&E to point to next line in
 1640/2A66 : 36 F0                                 MVI	L, 360o               ;User program buffer. Reset L to addr of user logrn
 1641/2A68 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Buffer pointer storage location. Store the new
 1642/2A6A : FB                                    MOV	M,D                    ;Updated user pgm line pointer in pointer storage
 1643/2A6B : 30                                    INR	L                    ;Location. Store both the high portion
 1644/2A6C : FC                                    MOV	M,E                    ;And low portion. (Now points to next line to be
 1645/2A6D : 36 E0                                 MVI	L, 340o               ;Processed from user program buffer.) Change pointer
 1646/2A6F : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** To address of line number buffer. Fetch the last
 1647/2A71 : C7                                    MOV	A,M                    ;Line number (length) processed. Test to see if it was
 1648/2A72 : A0                                    ANA	A                    ;Blank. If it was blank
 1649/2A73 : 68 D1 27                              JZ	EXEC               ;Then stop processing and return to the Executive
 1650/2A76 : C0                                    MOV	A,A                    ;Insert two effective NOPs here
 1651/2A77 : C0                                    MOV	A,A                    ;In case of patching
 1652/2A78 : 36 F0                      SAMLIN:    MVI	L, 360o               ;Load L with addr of user program buffer line pointer
 1653/2A7A : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of same pointer
 1654/2A7C : D7                                    MOV	C,M                    ;Fetch the high portion of the pointer into register C
 1655/2A7D : 30                                    INR	L                    ;Advance the memory pointer
 1656/2A7E : F7                                    MOV	L,M                    ;Fetch the low portion of the pointer into register L
 1657/2A7F : EA                                    MOV	H,C                    ;Now move the high portion into register H
 1658/2A80 : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Set D to page of line input buffer
 1659/2A82 : 26 00                                 MVI	E, 000                ;Set E to address of start of line input buffer
 1660/2A84 : 46 2A 29                              CALL	MOVEC              ;Move the line ftom the user program buffer into the
 1661/2A87 : 36 00                                 MVI	L, 000                ;Line input buffer. Now reset the pointer to the start
 1662/2A89 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Of the line input buffer.
 1663/2A8B : C7                                    MOV	A,M                    ;Fetch the first byte of the line input buffer (cc)
 1664/2A8C : A0                                    ANA	A                    ;Test (cc) value to see if fetched a blank line
 1665/2A8D : 68 D1 27                              JZ	EXEC               ;If fetched a blank line, return to the Executive
 1666/2A90 : 46 1B 21                              CALL	SYNTAX             ;Else call subrtn to strip off line nr & set statement toke
 1667/2A93 :                            
 1668/2A93 : 36 83                      DIRECT:    MVI	L, 203o               ;Load L with address of syntax TOKEN storage location
 1669/2A95 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of syntax TOKEN location
 1670/2A97 : C7                                    MOV	A,M                    ;Fetch the TOKEN value into the accumulator
 1671/2A98 : 3C 01                                 CPI	001                ;Is it token value for REM statement? If so, ignore the
 1672/2A9A : 68 58 2A                              JZ	NXTLIN             ;Current line and go on to the next line in pgm buffer.
 1673/2A9D : 3C 02                                 CPI	002                ;Is it token value for IF statement?
 1674/2A9F : 68 21 2D                              JZ	IF                 ;If yes, then go to the IF statement routine.
 1675/2AA2 : 3C 03                                 CPI	003                ;Is it token value for LET statement? (Using keyword)
 1676/2AA4 : 68 23 2C                              JZ	LET                ;If yes, then go to the LET statement routine.
 1677/2AA7 : 3C 04                                 CPI	004                ;Is it token value for GOTO statement?
 1678/2AA9 : 68 86 2C                              JZ	GOTO               ;If yes, then go to the GOTO statement routine.
 1679/2AAC : 3C 05                                 CPI	005                ;Is it token value for PRINT statement?
 1680/2AAE : 68 EF 2A                              JZ	PRINT              ;If yes, then go to the PRINT statement routine.
 1681/2AB1 : 3C 06                                 CPI	006                ;Is it token value for INPUT statement?
 1682/2AB3 : 68 FF 2D                              JZ	INPUT              ;If yes, then go to the INPUT statement routine.
 1683/2AB6 : 3C 07                                 CPI	007                ;Is it token value for FOR statement?
 1684/2AB8 : 68 7E 2E                              JZ	FOR                ;If yes, then go to the FOR statement routine.
 1685/2ABB : 3C 08                                 CPI	010o               ;Is it token value for NEXT statement?
 1686/2ABD : 68 FE 34                              JZ	NEXT               ;If yes, then go to the NEXT statement routine.
 1687/2AC0 : 3C 09                                 CPI	011o               ;Is it token value for GOSUB statement?
 1688/2AC2 : 68 A8 2D                              JZ	GOSUB              ;If yes, then go to the GOSUB statement routine.
 1689/2AC5 : 3C 0A                                 CPI	012o               ;Is it token value for RETURN statement?
 1690/2AC7 : 68 CE 2D                              JZ	RETURN             ;If yes, then go to the RETURN statement routine.
 1691/2ACA : 3C 0B                                 CPI	013o               ;Is it token value for DIM statement?
 1692/2ACC : 68 A0 38                              JZ	DIM                ;If yes, then go to the DIM statement routine.
 1693/2ACF : 3C 0C                                 CPI	014o               ;Is it token value for END statement?
 1694/2AD1 : 68 D1 27                              JZ	EXEC               ;If yes, then go back to the Executive, user pgm finished!
 1695/2AD4 : 3C 0D                                 CPI	015o               ;Is it token value for IMPLIED LET statement?
 1696/2AD6 : 68 15 2C                              JZ	LET0               ;If yes, then go to special LET entry point.
 1697/2AD9 : 3C 0E                                 CPI	016o               ;@@ Is it token value for ARRAY IMPLIED LET?
 1698/2ADB : 48 85 28                              JNZ	SYNERR             ;If not, then assume a syntax error condition.
 1699/2ADE : 46 16 38                              CALL	ARRAY1             ;@@ Else, perform array storage set up subroutine.
 1700/2AE1 : 36 86                                 MVI	L, 206o               ;@@ Set L to array pointer storage location.
 1701/2AE3 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;@@ * * Set H to array pointer storage location.
 1702/2AE5 : CF                                    MOV	B,M                    ;@@ Fetch array pointer to register B.
 1703/2AE6 : 36 82                                 MVI	L, 202o               ;@@ Change memory pointer to syntax pntr storage loc.
 1704/2AE8 : F9                                    MOV	M,B                    ;@@ Save array pointer value there.
 1705/2AE9 : 46 BB 27                              CALL	SAVESY             ;@@ Save array name in auxiliary symbol buffer
 1706/2AEC : 44 2C 2C                              JMP	LET1
 1707/2AEF : 36 82                      PRINT:     MVI	L, 202o               ;Load L with address of SCAN pointer storage location
 1708/2AF1 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of SCAN pointer
 1709/2AF3 : C7                                    MOV	A,M                    ;Fetch the pointer value (last character scanned by the
 1710/2AF4 : 36 00                                 MVI	L, 000                ;SYNTAX routine). Change pointer to line buffer (cc).
 1711/2AF6 : BF                                    CMP	M                    ;Compare pointer value to buffer length. If not equal
 1712/2AF7 : 70 00 2B                              JM	PRINT1             ;Then line contains more than stand alone PRINT state-
 1713/2AFA : 46 7C 22                              CALL	CRLF               ;Ment. However, if just have PRINT statement then issue
 1714/2AFD : 44 58 2A                              JMP	NXTLIN             ;A carriage-return & line-feed combination, then exit.
 1715/2B00 : 46 C8 21                   PRINT1:    CALL	CLESYM             ;Initialize the SYMBOL buffer for new entry.
 1716/2B03 : 36 82                                 MVI	L, 202o               ;Load L with address of SCAN buffer pointer
 1717/2B05 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of SCAN pointer
 1718/2B07 : CF                                    MOV	B,M                    ;Pointer points to last char scanned by SYNTAX. Need
 1719/2B08 : 08                                    INR	B                    ;To increment it to point to next char in statement line.
 1720/2B09 : 36 83                                 MVI	L, 203o               ;Load L with address of former TOKEN value. Use it as
 1721/2B0B : F9                                    MOV	M,B                    ;Storage location for a PRINT statement pointer.
 1722/2B0C : 36 83                      PRINT2:    MVI	L, 203o               ;Set memory pointer to PRINT pointer storage location
 1723/2B0E : 46 BB 21                              CALL	GETCHR             ;Fetch character in input buffer pointed to by PRINT
 1724/2B11 : 3C A7                                 CPI	247o               ;Pointer. See if it is ASCII code for single quote mark.
 1725/2B13 : 68 8D 2B                              JZ	QUOTE              ;If so, go to QUOTE section to process text string.
 1726/2B16 : 3C A2                                 CPI	242o               ;If not, see if it is ASCII code for double quote mark.
 1727/2B18 : 68 8D 2B                              JZ	QUOTE              ;If so, go to QUOTE section to process text string.
 1728/2B1B : 3C AC                                 CPI	254o               ;If not, see if it is ASCII code for comma sign.
 1729/2B1D : 68 2D 2B                              JZ	PRINT3             ;If so, go evaluate expression.
 1730/2B20 : 3C BB                                 CPI	273o               ;If not, see if it is ASCII code for semi-colon sign.
 1731/2B22 : 68 2D 2B                              JZ	PRINT3             ;If so, go evaluate expression.
 1732/2B25 : 36 83                                 MVI	L, 203o               ;Load L with address of PRINT pointer storage location.
 1733/2B27 : 46 1E 22                              CALL	LOOP               ;Increment pointer and test for end of line.
 1734/2B2A : 48 0C 2B                              JNZ	PRINT2             ;If not end of line, fetch the next character.
 1735/2B2D : 36 82                      PRINT3:    MVI	L, 202o               ;Load L with address of SCAN pointer storage location
 1736/2B2F : CF                                    MOV	B,M                    ;Fetch value of the pointer (last letter of KEYWORD)
 1737/2B30 : 08                                    INR	B                    ;Add one to point to first character of expression
 1738/2B31 : 36 BE                                 MVI	L, 276o               ;Load L with addr of EVAL pointer storage location
 1739/2B33 : F9                                    MOV	M,B                    ;Store addr at which EVAL should start scanning
 1740/2B34 : 36 83                                 MVI	L, 203o               ;Load L with address of PRINT pointer
 1741/2B36 : CF                                    MOV	B,M                    ;Which points to field terminator
 1742/2B37 : 09                                    DCR	B                    ;Decrement pointer value to last character of expression
 1743/2B38 : 36 BF                                 MVI	L, 277o               ;Load L with address of EVAL FINISH pntr storage loc.
 1744/2B3A : F9                                    MOV	M,B                    ;Place address value of last char in PRINT field there
 1745/2B3B : 36 F7                                 MVI	L, 367o               ;Load L with address of QUOTE flag
 1746/2B3D : C7                                    MOV	A,M                    ;Fetch the value of the QUOTE flag into the ACC
 1747/2B3E : A0                                    ANA	A                    ;Test the QUOTE flag status
 1748/2B3F : 68 47 2B                              JZ	PRINT4             ;If field not quoted, proceed to evaluate expression
 1749/2B42 : 3E 00                                 MVI	M, 000                ;If field quoted, then clear the QUOTE flag for next field
 1750/2B44 : 44 5F 2B                              JMP	PRINT6             ;And skip the evaluation procedure
 1751/2B47 : 46 AF 22                   PRINT4:    CALL	EVAL               ;Evaluate the current PRINT field
 1752/2B4A : 36 7F                                 MVI	L, 177o               ;Then load L,with address of the TAB flag
 1753/2B4C : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with the page of the TAB flag
 1754/2B4E : C7                                    MOV	A,M                    ;Fetch the value of the TAB flag into the accumulator
 1755/2B4F : A0                                    ANA	A                    ;Test the TAB flag
 1756/2B50 : 36 48                                 MVI	L, 110o               ;Change L to the FIXED/FLOAT flag location
 1757/2B52 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Change H to the FIXED/FLOAT flag page
 1758/2B54 : 3E FF                                 MVI	M, 377o               ;Set FIXED/FLOAT flag to fixed point
 1759/2B56 : 6A D6 2B                   PRINT5:    CZ	PFPOUT             ;If TAB flag not set, display value of expression
 1760/2B59 : 36 7F                                 MVI	L, 177o               ;Load L with address of TAB flag
 1761/2B5B : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of TAB flag
 1762/2B5D : 3E 00                                 MVI	M, 000                ;Reset TAB flag for next PRINT field
 1763/2B5F : 36 83                      PRINT6:    MVI	L, 203o               ;Load L with address of PRINT pointer stomge location
 1764/2B61 : 46 BB 21                              CALL	GETCHR             ;Fetch the character pointed to by the PRINT pointer
 1765/2B64 : 3C AC                                 CPI	254o               ;See if the last character scanned was a comma sign
 1766/2B66 : 6A F9 2B                              CZ	PCOMMA             ;If so, then display spaces to next TA.B location
 1767/2B69 : 36 83                                 MVI	L, 203o               ;Reset L to address of PRINT pointer storage location
 1768/2B6B : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Reset H to page of PRINT pointer stomge location
 1769/2B6D : CF                                    MOV	B,M                    ;Fetch the value of the pointer into register B
 1770/2B6E : 36 82                                 MVI	L, 202o               ;Change L to SCAN pointer storage location
 1771/2B70 : F9                                    MOV	M,B                    ;Place end of last field processed into SCAN pointer
 1772/2B71 : 36 00                                 MVI	L, 000                ;Change pointer to start of line input buffer
 1773/2B73 : C1                                    MOV	A,B                    ;Place pntr to last char scanned into the accumulator
 1774/2B74 : BF                                    CMP	M                    ;Compare this value to the (cc) for the line buffer
 1775/2B75 : 70 00 2B                              JM	PRINT1             ;If not end of line, continue to process next field
 1776/2B78 : 36 00                                 MVI	L, 000                ;If end of line, fetch the last character in the line
 1777/2B7A : 46 BB 21                              CALL	GETCHR             ;And check to see if it
 1778/2B7D : 3C AC                                 CPI	254o               ;Was a comma. If it was, go on to the next line in the
 1779/2B7F : 68 58 2A                              JZ	NXTLIN             ;User program buffer without displaying a CR & LF.
 1780/2B82 : 3C BB                                 CPI	273o               ;If not a comma, check to see if it was a semi-colon.
 1781/2B84 : 68 58 2A                              JZ	NXTLIN             ;If so, do not provide a CR & LF combination.
 1782/2B87 : 46 7C 22                              CALL	CRLF               ;If not comma or semi-colon, provide CR & LF at end
 1783/2B8A : 44 58 2A                              JMP	NXTLIN             ;Of a PRINT statement. Go process next line of pgrm.
 1784/2B8D : 36 F7                      QUOTE:     MVI	L, 367o               ;Load L with address of QUOTE flag
 1785/2B8F : F8                                    MOV	M,A                    ;Store type of quote in flag storage location
 1786/2B90 : 46 C8 21                              CALL	CLESYM             ;Initialize the SYMBOL buffer for new entry
 1787/2B93 : 36 83                                 MVI	L, 203o               ;Load L with address of PRINT pointer
 1788/2B95 : CF                                    MOV	B,M                    ;Fetch the PRINT pointer into register B
 1789/2B96 : 08                                    INR	B                    ;Add one to advance over quote character
 1790/2B97 : 36 84                                 MVI	L, 204o               ;Load L with address of QUOTE pointer
 1791/2B99 : F9                                    MOV	M,B                    ;Store the beginning of the QUOTE field pointer
 1792/2B9A : 36 84                      QUOTE1:    MVI	L, 204o               ;Load L with address of QUOTE pointer
 1793/2B9C : 46 BB 21                              CALL	GETCHR             ;Fetch the next character in the TEXT field
 1794/2B9F : 36 F7                                 MVI	L, 367o               ;Load L with the QUOTE flag (type of quote)
 1795/2BA1 : BF                                    CMP	M                    ;Compare to see if latest character this quote mark
 1796/2BA2 : 68 BD 2B                              JZ	QUOTE2             ;If so, finish up this quote field
 1797/2BA5 : 46 9D 22                              CALL	ECHO               ;If not, display the character as part of TEXT
 1798/2BA8 : 36 84                                 MVI	L, 204o               ;Reset L to QUOTE pointer storage location
 1799/2BAA : 46 1E 22                              CALL	LOOP               ;Increment QUOTE pointer and test for end of line
 1800/2BAD : 48 9A 2B                              JNZ	QUOTE1             ;If not end of line, continue processing TEXT field
 1801/2BB0 : 06 C9                      QUOTER:    MVI	A, 311o               ;If end of line before closing quote mark have an error
 1802/2BB2 : 16 D1                                 MVI	C, 321o               ;So load ACC with I and register C with Q
 1803/2BB4 : 36 F7                                 MVI	L, 367o               ;Load L with the address of the QUOTE flag
 1804/2BB6 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with the page of the QUOTE flag
 1805/2BB8 : 3E 00                                 MVI	M, 000                ;Clear the QUOTE flag for future use
 1806/2BBA : 44 B1 21                              JMP	ERROR              ;Go display the IQ (Illegal Quote) error message
 1807/2BBD : 36 84                      QUOTE2:    MVI	L, 204o               ;Load L with address of QUOTE pointer
 1808/2BBF : CF                                    MOV	B,M                    ;Fetch the QUOTE pointer into register B
 1809/2BC0 : 36 82                                 MVI	L, 202o               ;Load L with address of SCAN pointer storage location
 1810/2BC2 : F9                                    MOV	M,B                    ;Store former QUOTE vointer as start of next field
 1811/2BC3 : C1                                    MOV	A,B                    ;Place QUOTE pointer into the accumulator
 1812/2BC4 : 36 00                                 MVI	L, 000                ;Change L to point to start of the input line buffer
 1813/2BC6 : BF                                    CMP	M                    ;Compare QUOTE pointer value with (cc) value
 1814/2BC7 : 48 00 2B                              JNZ	PRINT1             ;If not end of line, process next PRINT field
 1815/2BCA : 46 7C 22                              CALL	CRLF               ;Else display a CR & LF combination at the end of line
 1816/2BCD : 36 F7                                 MVI	L, 367o               ;Load L with the address of the TAB flag
 1817/2BCF : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with the page of the TAB flag
 1818/2BD1 : 3E 00                                 MVI	M, 000                ;Clear the TAB flag for future use
 1819/2BD3 : 44 58 2A                              JMP	NXTLIN             ;Go process next line of the program.
 1820/2BD6 :                            
 1821/2BD6 :                                                              ;The following subroutines are utilized by the PRINT
 1822/2BD6 :                                                              ;routine.
 1823/2BD6 :                            ;;; The label PFPOUT SHOULD BE AT 14 314 0ccch
 1824/2BD6 : 36 56                      PFPOUT:    MVI	L, 126o               ;Load L with the address of the FPACC MSW (Floating
 1825/2BD8 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Point ACC). Load H with page of the FPACC MSW.
 1826/2BDA : C7                                    MOV	A,M                    ;Fetch the FPACC MSW into the accumulator. Test to
 1827/2BDB : A0                                    ANA	A                    ;See if the FPACC MSW is zero. If so, then simply go and
 1828/2BDC : 68 E8 2B                              JZ	ZERO               ;Display the value "0"
 1829/2BDF : 30                                    INR	L                    ;Else advance the pointer to the FPACC Exponent
 1830/2BE0 : C7                                    MOV	A,M                    ;Fetch the FPACC Exponent into the accumulator
 1831/2BE1 : A0                                    ANA	A                    ;See if any exponent value. If not, mantissa is in range
 1832/2BE2 : 68 F2 2B                              JZ	FRAC               ;0.5 to 1.0. Treat number as a fraction.
 1833/2BE5 : 44 7B 33                              JMP	FPOUT              ;Else perform regular numerical output routine.
 1834/2BE8 : 06 A0                      ZERO:      MVI	A, 240o               ;Load ASCII code for space into the ACC
 1835/2BEA : 46 9D 22                              CALL	ECHO               ;Display the space
 1836/2BED : 06 B0                                 MVI	A, 260o               ;Load ASCII code for 0 into the ACC
 1837/2BEF : 44 9D 22                              JMP	ECHO               ;Display 0 and exit to calling routine
 1838/2BF2 : 36 48                      FRAC:      MVI	L, 110o               ;Load L with address of FIXED/FLOAT flag
 1839/2BF4 : 3E 00                                 MVI	M, 000                ;Reset it to indicate floating point mode
 1840/2BF6 : 44 7B 33                              JMP	FPOUT              ;Display floating point number and return to caller
 1841/2BF9 : 36 00                      PCOMMA:    MVI	L, 000                ;Load L with address of (cc) in line input buffer
 1842/2BFB : C7                                    MOV	A,M                    ;Fetch the (cc) for the line into the ACC
 1843/2BFC : 36 83                                 MVI	L, 203o               ;Change pointer to PRINT pointer storage location
 1844/2BFE : 97                                    SUB	M                    ;Subtract value of PRINT pointer from line (cc)
 1845/2BFF : 33                                    RM                    ;If at end of buffer, do not TAB
 1846/2C00 : 36 23                                 MVI	L, 043o               ;If not end, load L with address of COLUMN COUNTER
 1847/2C02 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of COLUMN COUNTER
 1848/2C04 : C7                                    MOV	A,M                    ;Fetch COLUMN COUNTER into the accumulator
 1849/2C05 : 24 F0                                 ANI	360o               ;Find the last TAB position (multiple of 16 decimal)
 1850/2C07 : 04 10                                 ADI	020o               ;Add 16 (decimal) to get new TAB position
 1851/2C09 : 97                                    SUB	M                    ;Subtract current position from next TAB position
 1852/2C0A : D0                                    MOV	C,A                    ;Store this value in register C as a counter
 1853/2C0B : 06 A0                                 MVI	A, 240o               ;Load the ACC with the ASCII code for space
 1854/2C0D : 46 9D 22                   PCOM1:     CALL	ECHO               ;Display the space
 1855/2C10 : 11                                    DCR	C                    ;Decrement the loop counter
 1856/2C11 : 48 0D 2C                              JNZ	PCOM1              ;Continue displaying spaces until loop counter is zero
 1857/2C14 : 07                                    RET                    ;Then return to calling routine
 1858/2C15 : 46 BB 27                   LET0:      CALL	SAVESY             ;Entry point for IMPLIED LET statement. Save the
 1859/2C18 : 36 82                                 MVI	L, 202o               ;Variable (to left of the equal sign). Set L to the SCAN
 1860/2C1A : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Pointer. Set H to the page of the SCAN pointer.
 1861/2C1C : CF                                    MOV	B,M                    ;Fetch value of SCAN pointer. (Points to = sign in In bf)
 1862/2C1D : 36 83                                 MVI	L, 203o               ;Change pointer to LET pointer (was TOKEN value)
 1863/2C1F : F9                                    MOV	M,B                    ;Place the SCAN pointer value into the LET pointer
 1864/2C20 : 44 6B 2C                              JMP	LET5               ;Continue processing the LET statement line
 1865/2C23 : 46 C8 21                   LET:       CALL	CLESYM             ;Initialize the SYMBOL BUFFER for new entry
 1866/2C26 : 36 64                                 MVI	L, 144o               ;Load L with address of start of AUX SYMBOL BUFF
 1867/2C28 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of AUX SYMBOL BUFFER
 1868/2C2A : 3E 00                                 MVI	M, 000                ;Initialize AUX SYMBOL BUFFER
 1869/2C2C : 36 82                      LET1:      MVI	L, 202o               ;Entry point for ARRAY IMPLIED LET statement.
 1870/2C2E : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set pointer to SCAN pointer storage location
 1871/2C30 : CF                                    MOV	B,M                    ;Fetch the SCAN pointer value (last letter scanned by
 1872/2C31 : 08                                    INR	B                    ;SYNTAX subroutine) and add one to next character
 1873/2C32 : 36 83                                 MVI	L, 203o               ;Change L to LET pointer storage location
 1874/2C34 : F9                                    MOV	M,B                    ;Store former SCAN value (updated) in LET pointer
 1875/2C35 : 36 83                      LET2:      MVI	L, 203o               ;Set L to gtorage location of LET pointer
 1876/2C37 : 46 BB 21                              CALL	GETCHR             ;Fetch the character pointed to by the LET pointer
 1877/2C3A : 68 5C 2C                              JZ	LET4               ;If character is a space, ignore it
 1878/2C3D : 3C BD                                 CPI	275o               ;See if character is the equal (=) sign
 1879/2C3F : 68 6B 2C                              JZ	LET5               ;If so, go process other side of the statement (after
 1880/2C42 : 3C A8                                 CPI	250o               ;@@ If not, see if character is a right parenthesis
 1881/2C44 : 48 55 2C                              JNZ	LET3               ;If not, continue looking for equal sign
 1882/2C47 : 46 10 38                              CALL	ARRAY              ;@@ If so, have subscript. Call array set up subroutine.
 1883/2C4A : 36 86                                 MVI	L, 206o               ;@@ Load L with address of ARRAY pointer
 1884/2C4C : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;@@ ** Load H with page of ARRAY pointer
 1885/2C4E : CF                                    MOV	B,M                    ;@@ Fetch value (points to ")" character of subscript)
 1886/2C4F : 36 83                                 MVI	L, 203o               ;@@ Load L with address of LET pointer
 1887/2C51 : F9                                    MOV	M,B                    ;@@ Place ARRAY pointer value as new LET pointer
 1888/2C52 : 44 5C 2C                              JMP	LET4               ;@@ Continue to look for = sign in statement line
 1889/2C55 : 36 64                      LET3:      MVI	L, 144o               ;Reset L to start of AUX SYMBOL BUFFER
 1890/2C57 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ** Load H with page of AUX SYMBOL BUFFER
 1891/2C59 : 46 E7 21                              CALL	CONCT1             ;Concatenate character to the AUX SYMBOL BUFFER
 1892/2C5C : 36 83                      LET4:      MVI	L, 203o               ;Load L with address of LET pointer storage location
 1893/2C5E : 46 1E 22                              CALL	LOOP               ;Add one to pointer and test for end of line input buffer
 1894/2C61 : 48 35 2C                              JNZ	LET2               ;If not end of line, continue looking for the equal sign
 1895/2C64 : 06 CC                      LETERR:    MVI	A, 314o               ;If do not find an equal sign in the LET statement line
 1896/2C66 : 16 C5                                 MVI	C, 305o               ;Then have a LE (Let Error). Load the code for L and E
 1897/2C68 : 44 B1 21                              JMP	ERROR              ;Into registers ACC and C and go display the error msg.
 1898/2C6B : 36 83                      LET5:      MVI	L, 203o               ;When find the equal sign, reset L to point to the LET
 1899/2C6D : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Pointer and H to the proper page. Fetch the pointer
 1900/2C6F : CF                                    MOV	B,M                    ;Value into register B and add one to advance pointer
 1901/2C70 : 08                                    INR	B                    ;Over the equal sign to first char in the expression.
 1902/2C71 : 36 BE                                 MVI	L, 276o               ;Set L to point to the address of the EVAL pointer
 1903/2C73 : F9                                    MOV	M,B                    ;Set EVAL pointer to start evaluating right after the
 1904/2C74 : 36 00                                 MVI	L, 000                ;Equal sign. Now change L to start of line input buffer.
 1905/2C76 : CF                                    MOV	B,M                    ;Fetch the (cc) value into register B. (Length of line.)
 1906/2C77 : 36 BF                                 MVI	L, 277o               ;Load L with EVAL FINISH pointer storage location.
 1907/2C79 : F9                                    MOV	M,B                    ;Set it to stop evaluating at end of the line.
 1908/2C7A : 46 AF 22                              CALL	EVAL               ;Call the subroutine to evaluate the expression.
 1909/2C7D : 46 C5 27                              CALL	RESTSY             ;Restore the name of the variable to receive new value.
 1910/2C80 : 46 48 27                              CALL	STOSYM             ;Store the new value for the variable in variables table.
 1911/2C83 : 44 58 2A                              JMP	NXTLIN             ;Go process next line of the program.
 1912/2C86 : 36 E8                      GOTO:      MVI	L, 350o               ;Load L with start of AUX LINE NR BUFFER
 1913/2C88 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of AUX LINE NR BUFFER
 1914/2C8A : 3E 00                                 MVI	M, 000                ;Initialize the AUX LINE NR BUFFER to zero
 1915/2C8C : 36 82                                 MVI	L, 202o               ;Load L with address of SCAN pointer storage location
 1916/2C8E : CF                                    MOV	B,M                    ;Fetch pointer value (last char scanned by SYNTAX)
 1917/2C8F : 08                                    INR	B                    ;Add one to skip over the last 0 in GOTO keyword
 1918/2C90 : 36 83                                 MVI	L, 203o               ;Change pointer to GOTO pointer (formerly TOKEN)
 1919/2C92 : F9                                    MOV	M,B                    ;Store the updated SCAN pointer as the GOTO pointer
 1920/2C93 : 36 83                      GOTO1:     MVI	L, 203o               ;Load L with address of GOTO pointer
 1921/2C95 : 46 BB 21                              CALL	GETCHR             ;Fetch the character pointed to by the GOTO pointer
 1922/2C98 : 68 AA 2C                              JZ	GOTO2              ;If character was a space, ignore it
 1923/2C9B : 3C B0                                 CPI	260o               ;See if character is in the range of a decimal digit
 1924/2C9D : 70 B2 2C                              JM	GOTO3              ;If not, must have end of the line number digit string
 1925/2CA0 : 3C BA                                 CPI	272o               ;Continue to test for decitnal digit
 1926/2CA2 : 50 B2 2C                              JP	GOTO3              ;If not, mugt have end of the line number digit string
 1927/2CA5 : 36 E8                                 MVI	L, 350o               ;If valid decimal digit, load L with addr of AUX LINE
 1928/2CA7 : 46 E7 21                              CALL	CONCT1             ;NR BUFFER and concatenate digit to the buffer.
 1929/2CAA : 36 83                      GOTO2:     MVI	L, 203o               ;Reset pointer to GOTO pointer storage location
 1930/2CAC : 46 1E 22                              CALL	LOOP               ;Advance the pointer value and test for end of line
 1931/2CAF : 48 93 2C                              JNZ	GOTO1              ;If not end of line, fetch next digit in GOTO line number
 1932/2CB2 : 36 F0                      GOTO3:	   MVI	L, 360o               ;Set L to user program buffer pointer storage location
 1933/2CB4 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of program buffer pointer
 1934/2CB6 : 3E 06                                 MVI	M, BGNPGRAM           ;Initialize high part of pointer to start of pgm buffer
 1935/2CB8 : 30                                    INR	L                    ;Advance the memory point
 1936/2CB9 : 3E 00                                 MVI	M, 000                ;Initialize the low part of pointer to start of pgm buffer
 1937/2CBB : 46 C8 21                   GOTO4:     CALL	CLESYM             ;Clear the SYMBOL BUFFER
 1938/2CBE : 36 84                                 MVI	L, 204o               ;Load L with address of GOTO SEARCH pointer
 1939/2CC0 : 3E 01                                 MVI	M, 001                ;Initialize to one for first char of line
 1940/2CC2 : 36 84                      GOTO5:     MVI	L, 204o               ;Load L with address of GOTO SEARCH pointer
 1941/2CC4 : 46 57 29                              CALL	GETCHP             ;Fetch character pointed to by GOTO SEARCH pointer
 1942/2CC7 : 68 D7 2C                              JZ	GOTO6              ;From line pointed to in user program buffer. Ignore
 1943/2CCA : 3C B0                                 CPI	260o               ;Spaces. Check to see if character is a decirnal digit.
 1944/2CCC : 70 EA 2C                              JM	GOTO7              ;If not, then have processed line number at the start of
 1945/2CCF : 3C BA                                 CPI	272o               ;The current line. Continue the check for a valid decimal
 1946/2CD1 : 50 EA 2C                              JP	GOTO7              ;Digit. If have a decirnal digit then concatenate the digit
 1947/2CD4 : 46 E3 21                              CALL	CONCTS             ;Onto the current string in the SYMBOL BUFFER,
 1948/2CD7 : 36 84                      GOTO6:     MVI	L, 204o               ;Change L to the address of the GOTO SEARCH pointer
 1949/2CD9 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** And H to the proper page of the pointer
 1950/2CDB : CF                                    MOV	B,M                    ;Fetch the GOTO SEARCH pointer value
 1951/2CDC : 08                                    INR	B                    ;Increment the GOTO SEARCH pointer
 1952/2CDD : F9                                    MOV	M,B                    ;And restore it back to memory
 1953/2CDE : 36 F0                                 MVI	L, 360o               ;Change L to address of user program buffer pointer
 1954/2CE0 : D7                                    MOV	C,M                    ;Save the high part of this pointer value in register C
 1955/2CE1 : 30                                    INR	L                    ;Advance L to the low part of the pgrn buffer pointer
 1956/2CE2 : F7                                    MOV	L,M                    ;Now load it into L
 1957/2CE3 : EA                                    MOV	H,C                    ;And transfer C into H to point to start of the line
 1958/2CE4 : C7                                    MOV	A,M                    ;Fetch the (cc) of the current line being pointed to in the
 1959/2CE5 : 09                                    DCR	B                    ;User pgm buff. Decrernent B to previous value. Compare
 1960/2CE6 : B9                                    CMP	B                    ;GOTO SEARCH pointer value to length of current line.
 1961/2CE7 : 48 C2 2C                              JNZ	GOTO5              ;If not end of line then continue getting current line nr.
 1962/2CEA : 36 50                      GOTO7:     MVI	L, 120o               ;Load L with address of start of the SYMBOL BUFFER
 1963/2CEC : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;Set H to the page of the SYMBOL BUFFER
 1964/2CEE : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;Set D to the page of the AUX LINE NR BUFFER
 1965/2CF0 : 26 E8                                 MVI	E, 350o               ;Set E to the start of the AUX LINE NR BUFFER
 1966/2CF2 : 46 F5 21                              CALL	STRCP              ;Compare GOTO line number against current line nr.
 1967/2CF5 : 68 78 2A                              JZ	SAMLIN             ;If they match, found GOTO line. Pick up ops there!
 1968/2CF8 : 36 F0                                 MVI	L, 360o               ;Else, set L to user program buffer pntr storage location
 1969/2CFA : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of user program buffer pointer
 1970/2CFC : DF                                    MOV	D,M                    ;Fetch the high part of this pointer into register D
 1971/2CFD : 30                                    INR	L                    ;Advance the memory pointer
 1972/2CFE : E7                                    MOV	E,M                    ;Fetch the low part into register E
 1973/2CFF : EB                                    MOV	H,D                    ;Transfer the pointer to H
 1974/2D00 : F4                                    MOV	L,E                    ;And L. Fetch the (cc) of the current line into register
 1975/2D01 : CF                                    MOV	B,M                    ;B and then add one to account for the (cc) byte to get
 1976/2D02 : 08                                    INR	B                    ;Total length of the current line in the user pgm buffer
 1977/2D03 : 46 C9 29                              CALL	ADBDE              ;Add the total length to the pointer value in D & E
 1978/2D06 : 36 F0                                 MVI	L, 360o               ;To get the starting address of the next line in the user
 1979/2D08 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** User program buffer. Place the new value for the user
 1980/2D0A : FB                                    MOV	M,D                    ;Program buffer pointer back into the user program
 1981/2D0B : 30                                    INR	L                    ;Buffer pointer storage locations so that it points to the
 1982/2D0C : FC                                    MOV	M,E                    ;Next line to be processed in the user program buffer.
 1983/2D0D : 36 F4                                 MVI	L, 364o               ;Load L with address of end of user pgm buffer storage
 1984/2D0F : C3                                    MOV	A,D                    ;Location (page address) and fetch end of buffer page.
 1985/2D10 : BF                                    CMP	M                    ;Compare this with next line pointer (updated).
 1986/2D11 : 48 BB 2C                              JNZ	GOTO4              ;If not end of buffer, keep looking for the specified line
 1987/2D14 : 30                                    INR	L                    ;If have same page addresses, check the low address
 1988/2D15 : C4                                    MOV	A,E                    ;Portions to see if
 1989/2D16 : BF                                    CMP	M                    ;Have reached end of user program buffer
 1990/2D17 : 48 BB 2C                              JNZ	GOTO4              ;If not, continue looking. If end of buffer without
 1991/2D1A : 06 D5                      GOTOER:    MVI	A, 325o               ;Finding specified line, then have an error condition.
 1992/2D1C : 16 CE                                 MVI	C, 316o               ;Load ACC and register C with code for "UN" and go
 1993/2D1E : 44 B1 21                              JMP	ERROR              ;Display "Undefined Line" error message.
 1994/2D21 : 36 82                      IF:        MVI	L, 202o               ;Set L to SCAN pointer storage location.
 1995/2D23 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H to page of SCAN pointer storage location.
 1996/2D25 : CF                                    MOV	B,M                    ;Fetch the SCAN pointer value to register B.
 1997/2D26 : 08                                    INR	B                    ;Add one to advance pointer over last char scanned.
 1998/2D27 : 36 BE                                 MVI	L, 276o               ;Change L to address of EVAL pointer. Set up EVAL
 1999/2D29 : F9                                    MOV	M,B                    ;Pointer to begin evaluation with next char in the line.
 2000/2D2A : 46 C8 21                              CALL	CLESYM             ;Clear the SYMBOL BUFFER.
 2001/2D2D : 36 D0                                 MVI	L, 320o               ;Set L to starting address of THEN in look-up table.
 2002/2D2F : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of the look-up table.
 2003/2D31 : 46 14 2A                              CALL	INSTR              ;Search for occurrence of THEN in the line input buffer.
 2004/2D34 : C4                                    MOV	A,E                    ;Transfer register E to ACC. If THEN not found
 2005/2D35 : A0                                    ANA	A                    ;The value in E will be zero.
 2006/2D36 : 48 4C 2D                              JNZ	IF1                ;If THEN found, can evaluate the IF expression.
 2007/2D39 : 36 0B                                 MVI	L, 013o               ;If THEN not found, set L to Auting address of GOTO
 2008/2D3B : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** In the KEYWORD look-up table. Set H to table
 2009/2D3D : 46 14 2A                              CALL	INSTR              ;Search for occurrence of GOTO in the line input buffer.
 2010/2D40 : C4                                    MOV	A,E                    ;Transfer E to ACC. If GOTO not found
 2011/2D41 : A0                                    ANA	A                    ;The value in E will be zero.
 2012/2D42 : 48 4C 2D                              JNZ	IF1                ;If GOTO found, can evaluate the IF expression.
 2013/2D45 : 06 C9                      IFERR:     MVI	A, 311o               ;Set ASCII code for letter I in ACC
 2014/2D47 : 16 C6                                 MVI	C, 306o               ;And code for letter F in register C
 2015/2D49 : 44 B1 21                              JMP	ERROR              ;Go display the IF error message
 2016/2D4C : 36 BF                      IF1:       MVI	L, 277o               ;Load L with addr of EVAL FINISH pointer storage loc
 2017/2D4E : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of storage location
 2018/2D50 : 21                                    DCR	E                    ;Subtract one from pointer in E and set the EVAL
 2019/2D51 : FC                                    MOV	M,E                    ;FINISH pointer so that it will evaluate up to the THEN
 2020/2D52 : 46 AF 22                              CALL	EVAL               ;Or GOTO directive. Evaluate the expression.
 2021/2D55 : 36 56                                 MVI	L, 126o               ;Load L with address of FPACC Most Significant Word
 2022/2D57 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with page of FPACC MSW
 2023/2D59 : C7                                    MOV	A,M                    ;Fetch the FPACC MSW into the accumulator
 2024/2D5A : A0                                    ANA	A                    ;Test the value of the FPACC MSW
 2025/2D5B : 68 58 2A                              JZ	NXTLIN             ;If it is zero, IF condition failed, ignore rest of line.
 2026/2D5E : 36 BF                                 MVI	L, 277o               ;If not, load L with addr of EVAL FINISH pointer
 2027/2D60 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to the appmpriate page
 2028/2D62 : C7                                    MOV	A,M                    ;Fetch the value in the EVAL FINISH pointer
 2029/2D63 : 04 05                                 ADI	005                ;Add five to skip over THEN or GOTO directive
 2030/2D65 : 36 82                                 MVI	L, 202o               ;Change L to SCAN pointer stomge location
 2031/2D67 : F8                                    MOV	M,A                    ;Set up the SCAN pointer to location after THEN or
 2032/2D68 : C8                                    MOV	B,A                    ;GOTO directive. Also put this value in register B.
 2033/2D69 : 08                                    INR	B                    ;Add one to the value in B to point to next character
 2034/2D6A : 36 84                                 MVI	L, 204o               ;After THEN or GOTO. Change L to addr of THEN pntr
 2035/2D6C : F9                                    MOV	M,B                    ;Storage location and store the pointer value.
 2036/2D6D : 36 84                      IF2:       MVI	L, 204o               ;Load L with the address of the THEN pointer
 2037/2D6F : 46 BB 21                              CALL	GETCHR             ;Fetch the character pointed to by the THEN pointer
 2038/2D72 : 48 80 2D                              JNZ	IF3                ;If character is not a space, exit this loop
 2039/2D75 : 36 84                                 MVI	L, 204o               ;If fetch a space, ignore. Reset L to the THEN pointer
 2040/2D77 : 46 1E 22                              CALL	LOOP               ;Add one to the THEN pointer and test for end of line
 2041/2D7A : 48 6D 2D                              JNZ	IF2                ;If not end of line, keep looking for a character other
 2042/2D7D : 44 45 2D                              JMP	IFERR              ;Than a space. If reach end of line first, then error
 2043/2D80 : 3C B0                      IF3:       CPI	260o               ;When find a character see if it is numeric.
 2044/2D82 : 70 8A 2D                              JM	IF4                ;If not numeric, then should have a new type of
 2045/2D85 : 3C BA                                 CPI	272o               ;Statement. If numeric, then should have a line number.
 2046/2D87 : 70 86 2C                              JM	GOTO               ;So process as though have a GOTO statement!
 2047/2D8A : 36 00                      IF4:       MVI	L, 000                ;Load L with addr of start of line input buffer.
 2048/2D8C : C7                                    MOV	A,M                    ;Fetch the (cc) byte to get length of line value.
 2049/2D8D : 36 84                                 MVI	L, 204o               ;Change L to current value of THEN pointer (where first
 2050/2D8F : 97                                    SUB	M                    ;Non-space char. found after THEN or GOTO). Subtract
 2051/2D90 : C8                                    MOV	B,A                    ;This value from length of line to get remainder. Now
 2052/2D91 : 08                                    INR	B                    ;Have length of second statement portion. Add one for
 2053/2D92 : D7                                    MOV	C,M                    ;(cc) count. Save THEN pointer value in register C.
 2054/2D93 : 36 00                                 MVI	L, 000                ;Reset L to start of line input buffer. Now put length of
 2055/2D95 : F9                                    MOV	M,B                    ;Second statement into (cc) position of input buffer.
 2056/2D96 : F2                                    MOV	L,C                    ;Set L to where second statement starts.
 2057/2D97 : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Set D to page of line input buffer.
 2058/2D99 : 26 01                                 MVI	E, 001                ;Set E to first character position of line input buffer.
 2059/2D9B : 46 11 30                              CALL	MOVEIT             ;Move the second statement up in line to become first!
 2060/2D9E : 36 82                                 MVI	L, 202o               ;Load L with address of new SCAN pointer. Load
 2061/2DA0 : 3E 01                                 MVI	M, 001                ;It with starting position for SYNTAX scan.
 2062/2DA2 : 46 52 21                              CALL	SYNTX4             ;Use special entry to SYNTAX to get new TOKEN value.
 2063/2DA5 : 44 93 2A                              JMP	DIRECT             ;Process the second statement in the original line.
 2064/2DA8 : 36 E0                      GOSUB:     MVI	L, 340o               ;Load L with start of LINE NUMBER BUFFER
 2065/2DAA : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;Fetch (cc) of cuffent line number into register D
 2066/2DAC : DF                                    MOV	D,M                    ;Fetch high value (page) of pgm line pointer to D
 2067/2DAD : 18                                    INR	D                    ;Test contents of register by first incrementing
 2068/2DAE : 19                                    DCR	D                    ;And then decrementing the value in the register
 2069/2DAF : 68 B7 2D                              JZ	GOSUB1             ;If no line number, then processing a DIRECT statement
 2070/2DB2 : 36 F0                                 MVI	L, 360o               ;Else, load L with address of user pgm buff line pointer
 2071/2DB4 : DF                                    MOV	D,M                    ;Fetch high value (page) of pgm line pointer to D
 2072/2DB5 : 30                                    INR	L                    ;Advance the memory pointer
 2073/2DB6 : E7                                    MOV	E,M                    ;Fetch the low part of pgm line pointer to E
 2074/2DB7 : 36 3B                      GOSUB1:    MVI	L, 073o               ;Set L to address of GOSUB STACK POINTER
 2075/2DB9 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to page of GOSUB STACK POINTER
 2076/2DBB : C7                                    MOV	A,M                    ;Fetch value in GOSUB stack pointer to ACC
 2077/2DBC : 04 02                                 ADI	002                ;Add two to current stack pointer for new data to be
 2078/2DBE : 3C 11                                 CPI	021o               ;Placed on the stack and see if stack overflows
 2079/2DC0 : 50 F1 2D                              JP	GOSERR             ;If stack filled, have an error condition
 2080/2DC3 : F8                                    MOV	M,A                    ;Else, store updated stack pointer
 2081/2DC4 : 36 3E                                 MVI	L, 076o               ;Load L with address of start of stack less offset (2)
 2082/2DC6 : 86                                    ADD	L                    ;Add GOSUB stack pointer to base address
 2083/2DC7 : F0                                    MOV	L,A                    ;To get pointer to top of stack (page byte)
 2084/2DC8 : FB                                    MOV	M,D                    ;Store page part of pgm buffer line pointer in stack
 2085/2DC9 : 30                                    INR	L                    ;Advance pointer to next byte in stack
 2086/2DCA : FC                                    MOV	M,E                    ;Store low part of pgm buffer line pointer in stack
 2087/2DCB : 44 86 2C                              JMP	GOTO               ;Proceed from here as though processing a GOTO
 2088/2DCE : 36 3B                      RETURN:    MVI	L, 073o               ;Set L to address of GOSUB STACK POINTER
 2089/2DD0 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to page of GOSUB STACK POINTER
 2090/2DD2 : C7                                    MOV	A,M                    ;Fetch the value of GOSUB stack pointer to ACC
 2091/2DD3 : 14 02                                 SUI	002                ;Subtract two for data to be removed from stack
 2092/2DD5 : 70 F8 2D                              JM	RETERR             ;If stack underflow, then have an error condition
 2093/2DD8 : F8                                    MOV	M,A                    ;Restore new stack pointer to memory
 2094/2DD9 : 04 02                                 ADI	002                ;Add two to point to previous top of stack
 2095/2DDB : 36 3E                                 MVI	L, 076o               ;Load L with address of start of GOSUB stack less two
 2096/2DDD : 86                                    ADD	L                    ;Add address of previous top of stack to base value
 2097/2DDE : F0                                    MOV	L,A                    ;Set pointer to high address value in the stack
 2098/2DDF : DF                                    MOV	D,M                    ;Fetch the high address value from stack to register D
 2099/2DE0 : 18                                    INR	D                    ;Exercise the register contents to see if high address
 2100/2DE1 : 19                                    DCR	D                    ;Obtained is zero. If so, original GOSUB statement was
 2101/2DE2 : 68 D1 27                              JZ	EXEC               ;A DIRECT statement. Must return to Executive!
 2102/2DE5 : 30                                    INR	L                    ;Else, advance pointer to get low address value from the
 2103/2DE6 : E7                                    MOV	E,M                    ;Stack into CPU register E.
 2104/2DE7 : 36 F0                                 MVI	L, 360o               ;Load L with address of user pgm line pointer storage
 2105/2DE9 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Location. Load H with page of user pgm line pntr.
 2106/2DEB : FB                                    MOV	M,D                    ;Put high address from stack into pgm line pointer.
 2107/2DEC : 30                                    INR	L                    ;Advance the memory pointer
 2108/2DED : FC                                    MOV	M,E                    ;Put low address from stack into pgrn line pointer.
 2109/2DEE : 44 58 2A                              JMP	NXTLIN             ;Execute the next line after originating GOSUB line!
 2110/2DF1 : 06 C7                      GOSERR:    MVI	A, 307o               ;Load ASCII code for letter G into accumulator
 2111/2DF3 : 16 D3                                 MVI	C, 323o               ;Load ASCII code for letter S into register C
 2112/2DF5 : 44 B1 21                              JMP	ERROR              ;Go display GoSub (GS) error message.
 2113/2DF8 : 06 D2                      RETERR:    MVI	A, 322o               ;Load ASCII code for letter R into accumulator
 2114/2DFA : 16 D4                                 MVI	C, 324o               ;Load ASCII code for letter T into register C
 2115/2DFC : 44 B1 21                              JMP	ERROR              ;Go display ReTurn (RT) error message.
 2116/2DFF : 46 C8 21                   INPUT:     CALL	CLESYM             ;Clear the SYMBOL BUFFER
 2117/2E02 : 36 82                                 MVI	L, 202o               ;Load L with address of SCAN pointer storage location
 2118/2E04 : CF                                    MOV	B,M                    ;Fetch value of SCAN pointer to register B
 2119/2E05 : 08                                    INR	B                    ;Increment value to point to next chamcter
 2120/2E06 : 36 83                                 MVI	L, 203o               ;Change L to point to INPUT pointer (formerly TOKEN)
 2121/2E08 : F9                                    MOV	M,B                    ;Updated SCAN pointer becomes INPUT pointer
 2122/2E09 : 36 83                      INPUT1:    MVI	L, 203o               ;Load L with address of INPUT pointer
 2123/2E0B : 46 BB 21                              CALL	GETCHR             ;Fetch a character from the line input buffer
 2124/2E0E : 68 2C 2E                              JZ	INPUT3             ;If character is a space, ignore it. Else,
 2125/2E11 : 3C AC                                 CPI	254o               ;See if character is a comma. If so, process the
 2126/2E13 : 68 3D 2E                              JZ	INPUT4             ;Variable that preceeds the comma.
 2127/2E16 : 3C A8                                 CPI	250o               ;If not, see if character is a left parenthesis.
 2128/2E18 : 48 29 2E                              JNZ	INPUT2             ;If not, continue processing to build up symbolic variable
 2129/2E1B : 46 1B 38                              CALL	ARRAY2             ;@@ If so, call array subscripting subroutine
 2130/2E1E : 36 86                                 MVI	L, 206o               ;@@ Load L with address of array set up pointer
 2131/2E20 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;@@ ** Load H with page of array set up pointer
 2132/2E22 : CF                                    MOV	B,M                    ;@@ Fetch pointer value (point to ")" of subscript)
 2133/2E23 : 36 83                                 MVI	L, 203o               ;@@ Change pointer to address of INPUT pointer
 2134/2E25 : F9                                    MOV	M,B                    ;@@ Update INPUT pointer
 2135/2E26 : 44 2C 2E                              JMP	INPUT3             ;@@ Jump over concatenate instruction below
 2136/2E29 : 46 E3 21                   INPUT2:    CALL	CONCTS             ;Concatenate character to SYMBOL BUFFER
 2137/2E2C : 36 83                      INPUT3:    MVI	L, 203o               ;Load L with address of INPUT pointer
 2138/2E2E : 46 1E 22                              CALL	LOOP               ;Increment INPUT pointer and test for end of line
 2139/2E31 : 48 09 2E                              JNZ	INPUT1             ;If not end of line, go get next character
 2140/2E34 : 46 4E 2E                              CALL	INPUTX             ;If end of buffer, get input for variable in the SYMBOL
 2141/2E37 : 46 48 27                              CALL	STOSYM             ;BUFFER and store the value in the VARIABLES table
 2142/2E3A : 44 58 2A                              JMP	NXTLIN             ;Then continue to interpret next statement line
 2143/2E3D : 46 4E 2E                   INPUT4:    CALL	INPUTX             ;Get input from user for variable in SYMBOL BUFFER
 2144/2E40 : 46 48 27                              CALL	STOSYM             ;Store the inputted value in the VARIABLES table
 2145/2E43 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of INPUT pointer
 2146/2E45 : 36 83                                 MVI	L, 203o               ;Set L to location of INPUT pointer
 2147/2E47 : CF                                    MOV	B,M                    ;Fetch pointer value for last character examined
 2148/2E48 : 36 82                                 MVI	L, 202o               ;Change L to point to SCAN pointer storage location
 2149/2E4A : F9                                    MOV	M,B                    ;Update the SCAN pointer
 2150/2E4B : 44 FF 2D                              JMP	INPUT              ;Continue processing statement line for next variable
 2151/2E4E : 36 50                      INPUTX:    MVI	L, 120o               ;Load L with start of SYMBOL BUFFER (contains cc)
 2152/2E50 : C7                                    MOV	A,M                    ;Fetch the (cc) (length of symbol in the buffer) to ACC
 2153/2E51 : 86                                    ADD	L                    ;Add (cc) to base address to set up
 2154/2E52 : F0                                    MOV	L,A                    ;Pointer to last character in the SYMBOL BUFFER
 2155/2E53 : C7                                    MOV	A,M                    ;Fetch the last character in the SYMBOL BUFFER
 2156/2E54 : 3C A4                                 CPI	244o               ;See if the last chamcter was a $ sign
 2157/2E56 : 48 6A 2E                              JNZ	INPUTN             ;If not a $ sign, get variable value as a numerical entry
 2158/2E59 : 36 50                                 MVI	L, 120o               ;If $ sign, reset L to start of the SYMBOL BUFFER
 2159/2E5B : CF                                    MOV	B,M                    ;Fetch the (cc) for the variable in the SYMBOL BUFF
 2160/2E5C : 09                                    DCR	B                    ;Subtract one from (cc) to chop off the $ sign
 2161/2E5D : F9                                    MOV	M,B                    ;Restore the new (cc) for the SYMBOL BUFFER
 2162/2E5E : 46 79 2E                              CALL	FP0                ;Call subroutine to zero the floating point accumulator
 2163/2E61 : 46 AC 22                              CALL	CINPUT             ;Input one character from system input device
 2164/2E64 : 36 54                                 MVI	L, 124o               ;Load L with address of the LSW of the FPACC
 2165/2E66 : F8                                    MOV	M,A                    ;Place the ASCII code for the character inputted there
 2166/2E67 : 44 36 2F                              JMP	FPFLT              ;Convert value to floating point format in FPACC
 2167/2E6A : 36 64                      INPUTN:    MVI	L, 144o               ;Load L with address of start of AUX SYMBOL BUFF
 2168/2E6C : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of AUX SYMBOL BUFFER
 2169/2E6E : 06 BF                                 MVI	A, 277o               ;Load accumulator with ASCII code for ? mark
 2170/2E70 : 46 9D 22                              CALL	ECHO               ;Call output subroutine to display the ? mark
 2171/2E73 : 46 27 22                              CALL	STRIN              ;Input string of characters (number) fm input device
 2172/2E76 : 44 2A 32                              JMP	DINPUT             ;Convert decimal string into binary floating point nr.
 2173/2E79 : 2E 02                      FP0:       MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with floating point working registers page
 2174/2E7B : 44 C2 25                              JMP	CFALSE             ;Zero the floating point accumulator & exit to caller
 2175/2E7E : 36 64                      FOR:       MVI	L, 144o               ;Load L with address of AUX SYMBOL BUFFER
 2176/2E80 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of AUX SYMBOL BUFFER
 2177/2E82 : 3E 00                                 MVI	M, 000                ;Initialize buffer by clearing first byte
 2178/2E84 : 36 66                                 MVI	L, 146o               ;Load L with location of second character in buffer
 2179/2E86 : 3E 00                                 MVI	M, 000                ;Clear that location in case of single character variable
 2180/2E88 : 36 85                                 MVI	L, 205o               ;Load L with address of FOR/NEXT STACK pointer
 2181/2E8A : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Load H with page of FOR/NEXT STACK pointer
 2182/2E8C : CF                                    MOV	B,M                    ;Fetch the FOR/NEXT STACK pointer
 2183/2E8D : 08                                    INR	B                    ;Increment it in preparation for pushing operation
 2184/2E8E : F9                                    MOV	M,B                    ;Restore it back to its storage location
 2185/2E8F : 36 F0                                 MVI	L, 360o               ;Load L with address of user pgrn buffer line pointer
 2186/2E91 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of line pointer
 2187/2E93 : DF                                    MOV	D,M                    ;Fetch page address of pgm buffer line pntr into D
 2188/2E94 : 30                                    INR	L                    ;Advance the memory pointer to pick up low part
 2189/2E95 : E7                                    MOV	E,M                    ;Fetch low address of pgm buffer line pntr into E
 2190/2E96 : C1                                    MOV	A,B                    ;Restore updated FOR/NEXT STACK pointer to ACC
 2191/2E97 : 02                                    RLC                    ;Rotate it left to multiply by two, then rotate it again to
 2192/2E98 : 02                                    RLC                    ;Multiply by four. Add this value to the base address of
 2193/2E99 : 04 5C                                 ADI	134o               ;The FOR/NEXT STACK to point to the new top of
 2194/2E9B : F0                                    MOV	L,A                    ;The FOR/NEXT STACK and set up to point to stack
 2195/2E9C : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H for page of the FOR/NEXT STACK
 2196/2E9E : FB                                    MOV	M,D                    ;Store the page portion of the user pgrn buffer line pntr
 2197/2E9F : 30                                    INR	L                    ;In the FORINEXT STACK, advance register 4 then
 2198/2EA0 : FC                                    MOV	M,E                    ;Store the low portion of the pgrn line pntr on the stack
 2199/2EA1 : 36 D5                                 MVI	L, 325o               ;Change L to point to start of TO string which is stored
 2200/2EA3 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** In a text strings storage area on this page
 2201/2EA5 : 46 14 2A                              CALL	INSTR              ;Search the statement line for the occurrence of TO
 2202/2EA8 : C4                                    MOV	A,E                    ;Register E wiU be zero if TO not found. Move E to ACC
 2203/2EA9 : A0                                    ANA	A                    ;To make a test
 2204/2EAA : 48 B4 2E                              JNZ	FOR1               ;If TO found then proceed with FOR statement
 2205/2EAD : 06 C6                      FORERR:    MVI	A, 306o               ;Else have a For Error. Load ACC with ASCII code for
 2206/2EAF : 16 C5                                 MVI	C, 305o               ;Letter F and register C with code for letter E.
 2207/2EB1 : 44 B1 21                              JMP	ERROR              ;Then go display the FE message.
 2208/2EB4 : 36 82                      FOR1:      MVI	L, 202o               ;Load L with address of SCAN pointer storage location
 2209/2EB6 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of the SCAN pointer
 2210/2EB8 : CF                                    MOV	B,M                    ;Fetch pointer value to ACC (points to letter R in the
 2211/2EB9 : 08                                    INR	B                    ;For directive). Increment it to point to next character
 2212/2EBA : 36 84                                 MVI	L, 204o               ;In the line. Change register L and set this value up
 2213/2EBC : F9                                    MOV	M,B                    ;As an updated FOR pointer.
 2214/2EBD : 36 83                                 MVI	L, 203o               ;Set L to address of TO pointer (formerly TOKEN)
 2215/2EBF : FC                                    MOV	M,E                    ;Save pointer to TO in the TO pointer!
 2216/2EC0 : 36 84                      FOR2:      MVI	L, 204o               ;Load L with address of the FOR pointer
 2217/2EC2 : 46 BB 21                              CALL	GETCHR             ;Fetch a character from the statement line
 2218/2EC5 : 68 D2 2E                              JZ	FOR3               ;If it is a space, ignore it
 2219/2EC8 : 3C BD                                 CPI	275o               ;Test to see if character is the "=" sign
 2220/2ECA : 68 DD 2E                              JZ	FOR4               ;If so, variable name is in the AUX SYMBOLBUFFER
 2221/2ECD : 36 64                                 MVI	L, 144o               ;If not, then set L to point to start of the AUX SYMBOL
 2222/2ECF : 46 E7 21                              CALL	CONCT1             ;BUFFER and concatenate the character onto the buffer
 2223/2ED2 : 36 84                      FOR3:      MVI	L, 204o               ;Reset L to address of the FOR pointer
 2224/2ED4 : 46 1E 22                              CALL	LOOP               ;Increment the pointer and see if end of line
 2225/2ED7 : 48 C0 2E                              JNZ	FOR2               ;If not end of line, continue looking for the "=" sign
 2226/2EDA : 44 AD 2E                              JMP	FORERR             ;If reach end of line before "=" sign, then have error
 2227/2EDD : 36 84                      FOR4:      MVI	L, 204o               ;Set L with address of the FOR pointer
 2228/2EDF : CF                                    MOV	B,M                    ;Fetch pointer value to ACC (pointing to sign)
 2229/2EE0 : 08                                    INR	B                    ;Increment it to skip over the "=" sign
 2230/2EE1 : 36 BE                                 MVI	L, 276o               ;Set L to address of the EVAL pointer
 2231/2EE3 : F9                                    MOV	M,B                    ;Restore the updated pointer to storage
 2232/2EE4 : 36 83                                 MVI	L, 203o               ;Set L to the address of the TO pointer
 2233/2EE6 : CF                                    MOV	B,M                    ;Fetch pointer value to ACC (pointing to letter T in TO)
 2234/2EE7 : 09                                    DCR	B                    ;Decrement it to point to character before the T in TO
 2235/2EE8 : 36 BF                                 MVI	L, 277o               ;Set L to EVAL FINISH pointer storage location
 2236/2EEA : F9                                    MOV	M,B                    ;Store the EVAL FINISH pointer value
 2237/2EEB : 46 AF 22                              CALL	EVAL               ;Evaluate the expression between the "=" sign and TO
 2238/2EEE : 46 C5 27                              CALL	RESTSY             ;Directive. Place the variable name in the variables table.
 2239/2EF1 : 36 64                                 MVI	L, 144o               ;Load L with starting address of the AUX SYMBOL BF
 2240/2EF3 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with the page of the AUX SYMBOL BUFF
 2241/2EF5 : C7                                    MOV	A,M                    ;Fetch the (cc) for the name in the buffer
 2242/2EF6 : 3C 01                                 CPI	001o               ;See if the symbol (name) length is just one character
 2243/2EF8 : 48 99 36                              JNZ	FOR5               ;If not, go directly to place name in FOR/NEXT STACK
 2244/2EFB : 36 66                                 MVI	L, 146o               ;If so, set L to point to second character location in the
 2245/2EFD : 3E 00                                 MVI	M, 000                ;AUX SYMBOL BUFFER and set it equal to zero.
 2246/2EFF : 44 99 36                              JMP	FOR5               ;This jump directs program over ontrs/cntrs/table area
 2247/2F02 :                            ;;; LAST LINE SHOULD START AT 17 365 0ff5h
 2248/2F02 :                            ;;; PATCH AREA FOLLOWS THIS
 2249/2F02 :                            
 2250/2F02 :                            ;          ORG	1000h              ;020#000
 2251/2F02 :                            
 2252/2F02 : 36 56                      FPFIX:     MVI	L, 126o               ;Set L to point to MSW of FPACC
 2253/2F04 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to point to page of FPACC
 2254/2F06 : C7                                    MOV	A,M                    ;Fetch MSW of FPACC
 2255/2F07 : 36 40                                 MVI	L, 100o               ;Change pointer to SIGN indicator on same page
 2256/2F09 : F8                                    MOV	M,A                    ;Place MSW of FPACC into SIGN indicator
 2257/2F0A : A0                                    ANA	A                    ;Now test sign bit of MSW of FPACC
 2258/2F0B : 72 84 2F                              CM	FPCOMP             ;Two's complement value in FPACC if negative
 2259/2F0E : 36 57                                 MVI	L, 127o               ;Change pointer to FPACC Exponent register
 2260/2F10 : 06 17                                 MVI	A, 027o               ;Set accumulator to 23 (decimal) for number of bits
 2261/2F12 : CF                                    MOV	B,M                    ;Load FPACC Exponent into CPU register B
 2262/2F13 : 08                                    INR	B                    ;Exercise the value in register B
 2263/2F14 : 09                                    DCR	B                    ;To set CPU flags
 2264/2F15 : 70 2B 2F                              JM	FPZERO             ;If FPACC Exponent is negative set FPACC to zero
 2265/2F18 : 91                                    SUB	B                    ;Subtract value of FPACC Exponent from 23 decimal
 2266/2F19 : 70 00 2A                              JM	FIXERR             ;If Exp larger than 23 decimal cannot convert
 2267/2F1C : D0                                    MOV	C,A                    ;Else place result in register C as counter for number
 2268/2F1D : 36 56                      FPFIXL:    MVI	L, 126o               ;Of rotate ops. Set pointer to MSW of FPACC
 2269/2F1F : 0E 03                                 MVI	B, 003                ;Set precision counter (number of bytes in mantissa)
 2270/2F21 : 46 8F 31                              CALL	ROTATR             ;Rotate FPACC right the number of places indicated
 2271/2F24 : 11                                    DCR	C                    ;By count in register C to effectively rotate all the
 2272/2F25 : 48 1D 2F                              JNZ	FPFIXL             ;Significant bits to the left of the floating point decimal
 2273/2F28 : 44 7F 2F                              JMP	RESIGN             ;Point. Go check original sign & negate answer if req'd.
 2274/2F2B :                            
 2275/2F2B :                                                              ;Following subroutine clears the FPACC to the zero
 2276/2F2B :                                                              ;condition.
 2277/2F2B :                            
 2278/2F2B : 36 56                      FPZERO:    MVI	L, 126o               ;Set L to point to MSW of FPACC
 2279/2F2D : A8                                    XRA	A                    ;Clear the accumulator
 2280/2F2E : F8                                    MOV	M,A                    ;Set the MSW of FPACC to zero
 2281/2F2F : 31                                    DCR	L                    ;Decrement the pointer
 2282/2F30 : F8                                    MOV	M,A                    ;Set the next significant word of FPACC to zero
 2283/2F31 : 31                                    DCR	L                    ;Decrement the pointer
 2284/2F32 : F8                                    MOV	M,A                    ;Set the LSW of FPACC to zero
 2285/2F33 : 31                                    DCR	L                    ;Decrement the pointer
 2286/2F34 : F8                                    MOV	M,A                    ;Set the auxiliary FPACC byte to zero
 2287/2F35 : 07                                    RET                    ;Exit to calling routine
 2288/2F36 :                            
 2289/2F36 :                                                              ;The next instruction is a special entry point to
 2290/2F36 :                                                              ;the FPNORM subroutine that is used when a number is
 2291/2F36 :                                                              ;converted from fixed to floating point. The FPNORM
 2292/2F36 :                                                              ;label is the entry point when a number already in float-
 2293/2F36 :                                                              ;ing point fonnat is to be normalized.
 2294/2F36 :                            
 2295/2F36 : 0E 17                      FPFLT:     MVI	B, 027o               ;For fixed to float set CPU register B to 23 decimal
 2296/2F38 : C1                         FPNORM:    MOV	A,B                    ;Get CPU register B into ACC to check for special case
 2297/2F39 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of FPACC
 2298/2F3B : 36 57                                 MVI	L, 127o               ;Set L to FPACC Exponent byte
 2299/2F3D : A0                                    ANA	A                    ;Set CPU flags to test what was in CPU register B
 2300/2F3E : 68 42 2F                              JZ	NOEXC0             ;If B was zero then do standard normalization
 2301/2F41 : F9                                    MOV	M,B                    ;Else set Exponent of FPACC to 23 decimal
 2302/2F42 : 31                         NOEXC0:    DCR	L                    ;Change pointer to MSW of FPACC
 2303/2F43 : C7                                    MOV	A,M                    ;Fetch MSW of FPACC into accumulator
 2304/2F44 : 36 40                                 MVI	L, 100o               ;Change pointer to SIGN indicator storage location
 2305/2F46 : F8                                    MOV	M,A                    ;Place the MSW of FPACC there for future reference
 2306/2F47 : A0                                    ANA	A                    ;Set CPU flags to test MSW of FPACC
 2307/2F48 : 50 52 2F                              JP	ACZERT             ;If sign bit not set then jump ahead to do next test
 2308/2F4B : 0E 04                                 MVI	B, 004                ;If sign bit set, number in FPACC is negative. Set up
 2309/2F4D : 36 53                                 MVI	L, 123o               ;For two's complement operation
 2310/2F4F : 46 6E 31                              CALL	COMPLM             ;And negate the value in the FPACC to make it positive
 2311/2F52 : 36 56                      ACZERT:    MVI	L, 126o               ;Reset pointer to MSW of FPACC
 2312/2F54 : 0E 04                                 MVI	B, 004                ;Set precision counter to number of bytes in FPACC
 2313/2F56 : C7                         LOOK0:     MOV	A,M                    ;Plus one. Fetch a byte of the FPACC.
 2314/2F57 : A0                                    ANA	A                    ;Set CPU flags
 2315/2F58 : 48 65 2F                              JNZ	ACNONZ             ;If find anything then FPACC is not zero
 2316/2F5B : 31                                    DCR	L                    ;Else decrement pointer to NSW of FPACC
 2317/2F5C : 09                                    DCR	B                    ;Decrement precision counter
 2318/2F5D : 48 56 2F                              JNZ	LOOK0              ;Continue checking to see if FPACC contains anything
 2319/2F60 : 36 57                                 MVI	L, 127o               ;Until precision counter is zero. If reach here then
 2320/2F62 : A8                                    XRA	A                    ;Reset pointer to FPACC Exponent. Clear the ACC and
 2321/2F63 : F8                                    MOV	M,A                    ;Clear out the FPACC Exponent. Value of FPACC is zip!
 2322/2F64 : 07                                    RET                    ;Exit to calling routine
 2323/2F65 : 36 53                      ACNONZ:    MVI	L, 123o               ;If FPACC has any value set pointer to LSW minus one
 2324/2F67 : 0E 04                                 MVI	B, 004                ;Set precision counter to number of bytes in FPACC
 2325/2F69 : 46 85 31                              CALL	ROTATL             ;Plus one for special cases. Rotate the contents of the
 2326/2F6C : C7                                    MOV	A,M                    ;FPACC to the LEFT. Pointer will be set to MSW after
 2327/2F6D : A0                                    ANA	A                    ;Rotate ops. Fetch MSW and see if have anything in
 2328/2F6E : 70 78 2F                              JM	ACCSET             ;Most significant bit position. If so, have rotated enough
 2329/2F71 : 30                                    INR	L                    ;If not, advance pointer to FPACC Exponent. Fetch
 2330/2F72 : CF                                    MOV	B,M                    ;The value of the Exponent and decrement it by one
 2331/2F73 : 09                                    DCR	B                    ;To compensate for the rotate left of the mantissa
 2332/2F74 : F9                                    MOV	M,B                    ;Restore the new value of the Exponent
 2333/2F75 : 44 65 2F                              JMP	ACNONZ             ;Continue rotating ops to normalize the FPACC
 2334/2F78 : 36 56                      ACCSET:    MVI	L, 126o               ;Set pntr to FPACC MSW. Now must provide room for
 2335/2F7A : 0E 03                                 MVI	B, 003                ;Sign bit in nonnalized FPACC. Set precision counter.
 2336/2F7C : 46 8F 31                              CALL	ROTATR             ;Rotate the FPACC once to the right now.
 2337/2F7F : 36 40                      RESIGN:    MVI	L, 100o               ;Set the pointer to SIGN indicator storage location
 2338/2F81 : C7                                    MOV	A,M                    ;Fetch the original sign of the FPACC
 2339/2F82 : A0                                    ANA	A                    ;Set CPU flags
 2340/2F83 : 13                                    RP                    ;If original sign of FPACC was positive, can exit now.
 2341/2F84 :                            
 2342/2F84 : 36 54                      FPCOMP:    MVI	L, 124o               ; However, if original sign was negative, must now restore
 2343/2F86 : 0E 03                                 MVI	B, 003                ;The FPACC to negative by performing two's comple-
 2344/2F88 : 44 6E 31                              JMP	COMPLM             ;Ment on FPACC. Return to caring rtn via COMPLM.
 2345/2F8B :                            
 2346/2F8B :                                                              ;Floating point ADDITION. Adds contents of FPACC to
 2347/2F8B :                                                              ;FPOP and leaves result in FPACC. Routine first checks
 2348/2F8B :                                                              ;to see if either register contains zero. If so addition
 2349/2F8B :                                                              ;result is already present!
 2350/2F8B :                            
 2351/2F8B : 36 56                      FPADD:     MVI	L, 126o               ;Set L to point to MSW of FPACC
 2352/2F8D : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Do same for register H
 2353/2F8F : C7                                    MOV	A,M                    ;Fetch MSW of FPACC to accumulator
 2354/2F90 : A0                                    ANA	A                    ;Set CPU flags after loading op
 2355/2F91 : 48 9F 2F                              JNZ	NONZAC             ;If accumulator non-zero then FPACC has some value
 2356/2F94 : 36 54                      MOVOP:     MVI	L, 124o               ;But, if accumulator was zero then normalized FPACC
 2357/2F96 : DD                                    MOV	D,H                    ;Must also be zero. Thus answer to addition is simply the
 2358/2F97 : E6                                    MOV	E,L                    ;Value in FPOP. Set up pointers to transfer contents of
 2359/2F98 : 36 5C                                 MVI	L, 134o               ;FPOP to FPACC by pointing to the LSW of both
 2360/2F9A : 0E 04                                 MVI	B, 004                ;Registers and perform the transfer. Then exit to calling
 2361/2F9C : 44 11 30                              JMP	MOVEIT             ;Routine with answer in FPACC via MOVEIT.
 2362/2F9F : 36 5E                      NONZAC:    MVI	L, 136o               ;If FPACC was non-zero then check to see if FPOP has
 2363/2FA1 : C7                                    MOV	A,M                    ;Some value by obtaining MSW of FPOP
 2364/2FA2 : A0                                    ANA	A                    ;Set CPU flags after loading op. If MSW zero then
 2365/2FA3 : 2B                                    RZ                    ;Normalized FPOP must be zero. Answer is in FPACC!
 2366/2FA4 :                            
 2367/2FA4 :                                                              ;If neither FPACC or FPOP was zero then must perform
 2368/2FA4 :                                                              ;addition operation. Must first check to see if two num-
 2369/2FA4 :                                                              ;bers are within significant mnge. If not, largest number
 2370/2FA4 :                                                              ;is answer. If numbers within range, then must align ex-
 2371/2FA4 :                                                              ;ponents before perforrning the addition of the man-
 2372/2FA4 :                                                              ;tissa.
 2373/2FA4 :                            
 2374/2FA4 : 36 57                      CKEQEX:    MVI	L, 127o               ;Set pointer to FPACC Exponent storage location.
 2375/2FA6 : C7                                    MOV	A,M                    ;Fetch the Exponent value to the accumulator.
 2376/2FA7 : 36 5F                                 MVI	L, 137o               ;Change the pointer to the FPOP Exponent
 2377/2FA9 : BF                                    CMP	M                    ;Compare the values of the exponents. If they are the
 2378/2FAA : 68 E3 2F                              JZ	SHACOP             ;Same then can immediately proceed to add operations.
 2379/2FAD : C8                                    MOV	B,A                    ;If not the same, store FPACC Exponent size in regis B
 2380/2FAE : C7                                    MOV	A,M                    ;Fetch the FPOP Exponent size into the ACC
 2381/2FAF : 99                                    SBB	B                    ;Subtract the FPACC Exponent from the FPOP Exp.
 2382/2FB0 : 50 B6 2F                              JP	SKPNEG             ;If result is positive jump over the next few instructions
 2383/2FB3 : C8                                    MOV	B,A                    ;If result was negative, store the result in B
 2384/2FB4 : A8                                    XRA	A                    ;Clear the accumulator
 2385/2FB5 : 99                                    SBB	B                    ;Subtract register B to negate the original value
 2386/2FB6 : 3C 18                      SKPNEG:    CPI	030o               ;See if difference is less than 24 decimal.
 2387/2FB8 : 70 C5 2F                              JM	LINEUP             ;If so, can align exponents. Go do it.
 2388/2FBB : C7                                    MOV	A,M                    ;If not, find out which number is largest. Fetch FPOP
 2389/2FBC : 36 57                                 MVI	L, 127o               ;Exponent into ACC. Change pointer to FPACC Exp.
 2390/2FBE : 97                                    SUB	M                    ;Subtract FPACC from FPOP. If result is negative then
 2391/2FBF : 33                                    RM                    ;was larger. Return with answer in FPACC.
 2392/2FC0 : 36 54                                 MVI	L, 124o               ;If result was positive, larger value in FPOP. Set pointers
 2393/2FC2 : 44 94 2F                              JMP	MOVOP              ;To transfer FPOP into FPACC and then exit to caller.
 2394/2FC5 : C7                         LINEUP:    MOV	A,M                    ;Fetch FPOP Exponent into accumulator.
 2395/2FC6 : 36 57                                 MVI	L, 127o               ;Change pointer to FPACC Exponent.
 2396/2FC8 : 97                                    SUB	M                    ;Subtract FPACC Exponent from FPOP Exponent. If
 2397/2FC9 : 70 D9 2F                              JM	SHIFT0             ;Result is negative FPACC is larger. Go shift FPOP.
 2398/2FCC : D0                                    MOV	C,A                    ;If result positive FPOP larger, must shift FPACC. Store
 2399/2FCD : 36 57                      MORACC:    MVI	L, 127o               ;Difference count in C. Reset pointer to FPACC Exp
 2400/2FCF : 46 02 30                              CALL	SHLOOP             ;Call the SHift LOOP to rotate FPACC mantissa RIGHT
 2401/2FD2 : 11                                    DCR	C                    ;And INCREMENT Exponent. Decr difference counter
 2402/2FD3 : 48 CD 2F                              JNZ	MORACC             ;Continue rotate operations until diff counter is zero
 2403/2FD6 : 44 E3 2F                              JMP	SHACOP             ;Go do final alignment and perform addition process
 2404/2FD9 : D0                         SHIFT0:    MOV	C,A                    ;Routine to shift FPOP. Set difference count into reg. C
 2405/2FDA : 36 5F                      MOROP:     MVI	L, 137o               ;Set pointer to FPOP Exponent.
 2406/2FDC : 46 02 30                              CALL	SHLOOP             ;Call the SHift LOOP to rotate FPOP mantissa RIGHT
 2407/2FDF : 10                                    INR	C                    ;And INCREMENT Exponent. Then incr difference cntr
 2408/2FE0 : 48 DA 2F                              JNZ	MOROP              ;Continue rotate opemtions until diff counter is zero
 2409/2FE3 :                            ;;; The below two instructions are changed by PATCH NR.1
 2410/2FE3 :                            ;;;SHACOP:    LLI 123                ;Set pointer to FPACC LSW minus one to provide extra
 2411/2FE3 :                            ;;;           LMI 000                ;Byte for addition ops. Clear that location to zero.
 2412/2FE3 :                            SHACOP:
 2413/2FE3 :                            ;	   CALL	PATCH1		; patch 1 inserts a few lines at 30-000
 2414/2FE3 :                            
 2415/2FE3 :                            ;;; The following is PATCH NR.1
 2416/2FE3 :                            ;          ORG	1800h	;030#000
 2417/2FE3 : 36 53                      PATCH1:    MVI	L, 123o
 2418/2FE5 : 3E 00                                 MVI	M, 000
 2419/2FE7 : 36 5B                                 MVI	L, 133o
 2420/2FE9 : 3E 00                                 MVI	M, 000
 2421/2FEB :                            ;          RET
 2422/2FEB :                            ;	   MOV	A,A
 2423/2FEB :                            ;;;        MVI L, 133
 2424/2FEB :                            ;;;        LMI 000                ;THIS IS PATCH #1
 2425/2FEB : 36 57                                 MVI	L, 127o               ;Change pointer to FPACC Exponent
 2426/2FED : 46 02 30                              CALL	SHLOOP             ;Rotate FPACC mantissa RIGHT & Increment Exponent
 2427/2FF0 : 36 5F                                 MVI	L, 137o               ;Change pointer to FPOP Exponent
 2428/2FF2 : 46 02 30                              CALL	SHLOOP             ;Rotate FPOP mantissa RIGHT & Increment Exponent
 2429/2FF5 : DD                                    MOV	D,H                    ;Rotate ops provide room for overflow. Now set up
 2430/2FF6 : 26 53                                 MVI	E, 123o               ;Pointers to LSW minus one for both FPACC & FPOP
 2431/2FF8 : 0E 04                                 MVI	B, 004                ;(FPOP already set after SHLOOP). Set precision counter
 2432/2FFA : 46 5D 31                              CALL	ADDER              ;Call quad precision ADDITION subroutine.
 2433/2FFD : 0E 00                                 MVI	B, 000                ;Set CPU register B to indicate standard normalization
 2434/2FFF : 44 38 2F                              JMP	FPNORM             ;Go normalize the result and exit to caller.
 2435/3002 : CF                         SHLOOP:    MOV	B,M                    ;Shifting loop. First fetch Exponent currently being
 2436/3003 : 08                                    INR	B                    ;Pointed to and Increment the value by one.
 2437/3004 : F9                                    MOV	M,B                    ;Return the updated Exponent value to memory.
 2438/3005 : 31                                    DCR	L                    ;Decrement the pointer to mantissa portion MSW
 2439/3006 : 0E 04                                 MVI	B, 004                ;Set precision counter
 2440/3008 : C7                         FSHIFT:    MOV	A,M                    ;Fetch MSW of mantissa
 2441/3009 : A0                                    ANA	A                    ;Set CPU flags after load ops
 2442/300A : 50 8F 31                              JP	ROTATR             ;If MSB not a one can do normal rotate ops
 2443/300D : 12                         BRING1:    RAL                    ;If MSB is a one need to set up carrv bit for the negative
 2444/300E : 44 90 31                              JMP	ROTR               ;Number case. Then make special entry to ROTATR sub
 2445/3011 :                            
 2446/3011 :                                                              ;The following subroutine moves the contents of a string
 2447/3011 :                                                              ;of memory locations from the address pointed to by
 2448/3011 :                                                              ;CPU registers H & L to the address specified by the con-
 2449/3011 :                                                              ;tents of registers D & E when the routine is entered. The
 2450/3011 :                                                              ;process continues until the counter in register B is zero.
 2451/3011 :                            
 2452/3011 : C7                         MOVEIT:    MOV	A,M                    ;Fetch a word from memory string A
 2453/3012 : 30                                    INR	L                    ;Advance A string pointer
 2454/3013 : 46 F4 31                              CALL	SWITCH             ;Switch pointer to string B
 2455/3016 : F8                                    MOV	M,A                    ;Put word from string A into string B
 2456/3017 : 30                                    INR	L                   ;Advance B string pointer
 2457/3018 : 46 F4 31                              CALL	SWITCH             ;Switch pointer back to string A
 2458/301B : 09                                    DCR	B                    ;Decrement loop counter
 2459/301C : 2B                                    RZ                    ;Return to calling routine when counter reaches zero
 2460/301D : 44 11 30                              JMP	MOVEIT             ;Else continue transfer operations
 2461/3020 :                            
 2462/3020 :                                                              ;The following subroutine SUBTRACTS the
 2463/3020 :                                                              ;contents of the FLOATING POINT ACCUMULATOR from the
 2464/3020 :                                                              ;contents of the FLOATING POINT OPERAND and
 2465/3020 :                                                              ;leaves the result in the FPACC. The routine merely
 2466/3020 :                                                              ;negates the value in the FPACC and then goes to the
 2467/3020 :                                                              ;FPADD subroutine just presented.
 2468/3020 :                            
 2469/3020 : 36 54                      FPSUB:     MVI	L, 124o               ;Set L to address of LSW of FPACC
 2470/3022 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of FPACC
 2471/3024 : 0E 03                                 MVI	B, 003                ;Set precision counter
 2472/3026 : 46 6E 31                              CALL	COMPLM             ;Two's complement the value in the FPACC
 2473/3029 : 44 8B 2F                              JMP	FPADD              ;Now go add the negated value to perform subtraction!
 2474/302C :                            
 2475/302C :                                                              ;The first part of the FLOATING POINT MULTIPLI-
 2476/302C :                                                              ;CATION subroutine calls a subroutine to check the
 2477/302C :                                                              ;original signs of the numbers that are to be multi-
 2478/302C :                                                              ;plied and perform working register clearing functions.
 2479/302C :                                                              ;Next the exponents of the numbers to be multiplied
 2480/302C :                                                              ;are added together.
 2481/302C :                            
 2482/302C : 46 7C 30                   FPMULT:    CALL	CKSIGN             ;Call routine to set up registers & ck signs of numbers
 2483/302F : 36 5F                      ADDEXP:    MVI	L, 137o               ;Set pointer to FPOP Exponent
 2484/3031 : C7                                    MOV	A,M                    ;Fetch FPOP Exponent into the accumulator
 2485/3032 : 36 57                                 MVI	L, 127o               ;Change pointer to FPACC Exponent
 2486/3034 : 87                                    ADD	M                    ;Add FPACC Exponent to FPOP Exponent
 2487/3035 : 04 01                                 ADI	001                ;Add one more to total for algorithm compensation
 2488/3037 : F8                                    MOV	M,A                    ;Store result in FPACC Exponent location
 2489/3038 : 36 42                      SETMCT:    MVI	L, 102o               ;Change pointer to bit counter storage location
 2490/303A : 3E 17                                 MVI	M, 027o               ;Initialize bit counter to 23 decimal
 2491/303C :                            
 2492/303C :                                                              ;Next portion of the FPMULT routine is the iinplernen-
 2493/303C :                                                              ;tation of the algorithm illustrated in the flow chart
 2494/303C :                                                              ;above. This portion multiplies the values of the two
 2495/303C :                                                              ;mantissas. The final value is rounded off to leave the
 2496/303C :                                                              ;23 most significant bits as the answer that is stored
 2497/303C :                                                              ;back in the FPACC.
 2498/303C :                            
 2499/303C : 36 56                      MULTIP:    MVI	L, 126o                ;Set pointer to MSW of FPACC mantissa
 2500/303E : 0E 03                                 MVI	B, 003                ;Set precision counter
 2501/3040 : 46 8F 31                              CALL	ROTATR             ;Rotate FPACC (multiplier) RIGHT into carry bit
 2502/3043 : 62 BE 30                              CC	ADOPPP             ;If carry is a one, add multiplicand to partial-product
 2503/3046 : 36 66                                 MVI	L, 146o                ;Set pointer to partial-product most significant byte
 2504/3048 : 0E 06                                 MVI	B, 006                ;Set precision counter (p-p register is double length)
 2505/304A : 46 8F 31                              CALL	ROTATR             ;Shift partial-product RIGHT
 2506/304D : 36 42                                 MVI	L, 102o                ;Set pointer to bit counter storage location
 2507/304F : D7                                    MOV	C,M                    ;Fetch current value of bit counter
 2508/3050 : 11                                    DCR	C                    ;Decrement the value of the bit counter
 2509/3051 : FA                                    MOV	M,C                    ;Restore the updated bit counter to its storage location
 2510/3052 : 48 3C 30                              JNZ	MULTIP             ;If have not multiplied for 23 (deciinal) bits, keep going
 2511/3055 : 36 66                                 MVI	L, 146o                ;If have done 23 (decimal) bits, set pntr to p-p MSW
 2512/3057 : 0E 06                                 MVI	B, 006                ;Set precision counter (for double length)
 2513/3059 : 46 8F 31                              CALL	ROTATR             ;Shift partial-product once more to the RIGHT
 2514/305C : 36 63                                 MVI	L, 143o                ;Set pointer to access 24'th bit in partial-product
 2515/305E : C7                                    MOV	A,M                    ;Fetch the byte containing the 24'th bit
 2516/305F : 12                                    RAL                    ;Position the 24'th bit to be MSB in the accumulator
 2517/3060 : A0                                    ANA	A                    ;Set the CPU flags after to rotate operation and test to
 2518/3061 : 72 C8 30                              CM	MROUND             ;See if 24'th bit of p-p is a ONE. If so, must round-off
 2519/3064 : 36 53                                 MVI	L, 123o                ;Now set up pointers
 2520/3066 : E6                                    MOV	E,L                    ;To perform transfer
 2521/3067 : DD                                    MOV	D,H                    ;Of the multiplication results
 2522/3068 : 36 63                                 MVI	L, 143o                ;From the partial-product location
 2523/306A : 0E 04                                 MVI	B, 004                ;To the FPACC
 2524/306C :                            
 2525/306C :                            	
 2526/306C : 46 11 30                   EXMLDV:    CALL	MOVEIT             ;Perform the transfer from p-p to FPACC
 2527/306F : 0E 00                                 MVI	B, 000                ;Set up CPU register B to indicate regular normalization
 2528/3071 : 46 38 2F                              CALL	FPNORM             ;Normalize the result of multiplication
 2529/3074 : 36 41                                 MVI	L, 101o               ;Now set the pointer to the original SIGNS indicator
 2530/3076 : C7                                    MOV	A,M                    ;Fetch the indicator
 2531/3077 : A0                                    ANA	A                    ;Exercise the CPU flags
 2532/3078 : 0B                                    RNZ                    ;If indicator is non-zero, answer is positive, can exit her
 2533/3079 : 44 84 2F                              JMP	FPCOMP             ;If not, answer must be negated, exit via 2's complement.
 2534/307C :                            
 2535/307C :                                                              ;The following portions of the FPMULT
 2536/307C :                                                              ;routine set up working locations in memory by clearing
 2537/307C :                                                              ;locations for an expanded FPOP area and the partial-produc
 2538/307C :                                                              ;area. Next, the signs of the two numbers to be multiplied
 2539/307C :                                                              ;are examined. Negative numbers are negated
 2540/307C :                                                              ;in preparation for the multiplication
 2541/307C :                                                              ;algorithm. A SIGNS indicator register is set up during
 2542/307C :                                                              ;this process to indicate whether the final result of the
 2543/307C :                                                              ;multiplication should be positive or negative. (Negative
 2544/307C :                                                              ;if original signs of the two numbers to be multiplied are
 2545/307C :                                                              ;different.)
 2546/307C :                            
 2547/307C : 36 60                      CKSIGN:    MVI	L, 140o               ;Set pointer to start of partial-product working area
 2548/307E : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to proper page
 2549/3080 : 0E 08                                 MVI	B, 010o               ;Set up a loop counter in CPU register B
 2550/3082 : A8                                    XRA	A                    ;Clear the accumulator
 2551/3083 :                            
 2552/3083 : F8                         CLRNEX:    MOV	M,A                    ;Now clear out locations for the partial-product
 2553/3084 : 30                                    INR	L                    ;Working registers
 2554/3085 : 09                                    DCR	B                    ;Until the loop counter
 2555/3086 : 48 83 30                              JNZ	CLRNEX             ;Is zero
 2556/3089 : 0E 04                      CLROPL:    MVI	B, 004                ;Set a loop counter
 2557/308B : 36 58                                 MVI	L, 130o               ;Set up pointer
 2558/308D : F8                         CLRNX1:    MOV	M,A                    ;Clear out some extra registers so that the
 2559/308E : 30                                    INR	L                    ;FPOP may be extended in length
 2560/308F : 09                                    DCR	B                    ;Perform clearing ops until loop counter
 2561/3090 : 48 8D 30                              JNZ	CLRNX1             ;Is zero
 2562/3093 : 36 41                                 MVI	L, 101o               ;Set pointer to M/D SIGNS indicator storage location
 2563/3095 : 3E 01                                 MVI	M, 001                ;Set initial value of SIGNS indicator to plus one
 2564/3097 : 36 56                                 MVI	L, 126o               ;Change pointer to MSW of FPACC
 2565/3099 : C7                                    MOV	A,M                    ;Fetch MSW of mantissa into accumulator
 2566/309A : A0                                    ANA	A                    ;Test flags
 2567/309B : 70 AF 30                              JM	NEGFPA             ;If MSB in MSW of FPACC is a one, number is negative
 2568/309E : 36 5E                      OPSGNT:    MVI	L, 136o               ;Set pointer to MSW of FPOP
 2569/30A0 : C7                                    MOV	A,M                    ;Fetch MSW of mantissa into accumulator
 2570/30A1 : A0                                    ANA	A                    ;Test flags
 2571/30A2 : 13                                    RP                    ;Return to caller if number in FPOP is positive
 2572/30A3 : 36 41                                 MVI	L, 101o               ;Else change pointer to M/D SIGNS indicator
 2573/30A5 : D7                                    MOV	C,M                    ;Fetch the value in the SIGNS indicator
 2574/30A6 : 11                                    DCR	C                    ;Decrement the value by one
 2575/30A7 : FA                                    MOV	M,C                    ;Restore the new value back to storage location
 2576/30A8 : 36 5C                                 MVI	L, 134o               ;Set pointer to LSW of FPOP
 2577/30AA : 0E 03                                 MVI	B, 003                ;Set precision counter
 2578/30AC : 44 6E 31                              JMP	COMPLM             ;Two's complement value of FPOP & return to caller
 2579/30AF : 36 41                      NEGFPA:    MVI	L, 101o               ;Set pointer to M/D SIGNS indicator
 2580/30B1 : D7                                    MOV	C,M                    ;Fetch the value in the SIGNS indicator
 2581/30B2 : 11                                    DCR	C                    ;Decrement the value by one
 2582/30B3 : FA                                    MOV	M,C                    ;Restore the new value back to storage location
 2583/30B4 : 36 54                                 MVI	L, 124o               ;Set pointer to LSW of FPACC
 2584/30B6 : 0E 03                                 MVI	B, 003                ;Set precision counter
 2585/30B8 : 46 6E 31                              CALL	COMPLM             ;Two's complement value of FPACC
 2586/30BB : 44 9E 30                              JMP	OPSGNT             ;Proceed to check sign of FPOP
 2587/30BE :                            
 2588/30BE :                                                              ;The following subroutine adds the double length (six regis
 2589/30BE :                                                              ;multiplicand in FPOP to the partial-product register when
 2590/30BE :                                                              ;called on by the multiplication algorithm.
 2591/30BE :                            
 2592/30BE : 26 61                      ADOPPP:    MVI	E, 141o               ;Pointer to LSW of partial-product
 2593/30C0 : DD                                    MOV	D,H                    ;On same page as FPOP
 2594/30C1 : 36 59                                 MVI	L, 131o               ;LSIV of FPOP which contains extended multiplicand
 2595/30C3 : 0E 06                                 MVI	B, 006                ;Set precision counter (double length working registers)
 2596/30C5 : 44 5D 31                              JMP	ADDER              ;Add multiplicand to partial-product & return to caller
 2597/30C8 :                            
 2598/30C8 : 0E 03                      MROUND:    MVI	B, 003                ;Set up precision counter
 2599/30CA : 06 40                                 MVI	A, 100o               ;Prepare to add one to 24'th bit of partial-product
 2600/30CC : 87                                    ADD	M                    ;Add one to the 24'th bit of the partial-product
 2601/30CD : F8                         CROUND:    MOV	M,A                    ;Restore the updated byte to memory
 2602/30CE : 30                                    INR	L                    ;Advance the memory pointer to next most significant
 2603/30CF : 06 00                                 MVI	A, 000                ;Byte of partial-product, then clear ACC without
 2604/30D1 : 8F                                    ADC	M                    ;Disturbing carry bit. Now perform add with carry to
 2605/30D2 : 09                                    DCR	B                    ;Propagate any rounding in the partial-product registers.
 2606/30D3 : 48 CD 30                              JNZ	CROUND             ;If cotinter is not zero continue propagating any carry
 2607/30D6 : F8                                    MOV	M,A                    ;Restore final byte to memory
 2608/30D7 : 07                                    RET                    ;Exit to CALLling routine
 2609/30D8 :                            
 2610/30D8 : 46 7C 30                   FPDIV:     CALL	CKSIGN             ;Call routine to set up registers & ck signs of numbers
 2611/30DB : 36 56                                 MVI	L, 126o               ;Set pointer to MSW of FPACC (divisor)
 2612/30DD : C7                                    MOV	A,M                    ;Fetch MSW of FPACC to accumulator
 2613/30DE : A0                                    ANA	A                    ;Exercise CPU flags
 2614/30DF : 68 F9 29                              JZ	DVERR              ;If MSW of FPACC is zero go display 'DZ' error message
 2615/30E2 : 36 5F                      SUBEXP:    MVI	L, 137o               ;Set pointer to FPOP (dividend) Exponent
 2616/30E4 : C7                                    MOV	A,M                    ;Get FPOP Exponent into accumulator
 2617/30E5 : 36 57                                 MVI	L, 127o               ;Change pointer to FPACC (divisor) Exponent
 2618/30E7 : 97                                    SUB	M                    ;Subtract divisor exponent from dividend exponent
 2619/30E8 : 04 01                                 ADI	001                ;Add one for algorithm compensation
 2620/30EA : F8                                    MOV	M,A                    ;Place result in FPACC Exponent
 2621/30EB : 36 42                      SETDCT:    MVI	L, 102o               ;Set pointer to bit counter storage location
 2622/30ED : 3E 17                                 MVI	M, 027o               ;Initialize bit counter to 23 decimal
 2623/30EF :                            
 2624/30EF :                                                              ;Main division algorithm for mantissas
 2625/30EF :                            
 2626/30EF : 46 47 31                   DIVIDE:    CALL	SETSUB             ;Go subtmct divisor from dividend
 2627/30F2 : 70 04 31                              JM	NOGO               ;If result is negative then place a zero bit in quotient
 2628/30F5 : 26 5C                                 MVI	E, 134o               ;If result zero or positive then move remainder after
 2629/30F7 : 36 59                                 MVI	L, 131o               ;Subtraction from working area to become new dividend
 2630/30F9 : 0E 03                                 MVI	B, 003                ;Set up moving pointers and initialize precision counter
 2631/30FB : 46 11 30                              CALL	MOVEIT             ;Perform the transfer
 2632/30FE : 06 01                                 MVI	A, 001                ;Place a one into least significant bit of accumulator
 2633/3100 : 1A                                    RAR                    ;And rotate it out into the carry bit
 2634/3101 : 44 05 31                              JMP	QUOROT             ;Proceed to rotate the carry bit into the current quotient
 2635/3104 : A8                         NOGO:      XRA	A                    ;When result is negative, put a zero in the carry bit, then
 2636/3105 : 36 64                      QUOROT:    MVI	L, 144o               ;Set up pointer to LSW of quotient register
 2637/3107 : 0E 03                                 MVI	B, 003                ;Set precision counter
 2638/3109 : 46 86 31                              CALL	ROTL               ;Rotate carry bit into quotient by using special entry to
 2639/310C : 36 5C                                 MVI	L, 134o               ;ROTATL subroutine. Now set up pointer to dividend
 2640/310E : 0E 03                                 MVI	B, 003                ;LSW and set precision counter
 2641/3110 : 46 85 31                              CALL	ROTATL             ;Rotate the current dividend to the left
 2642/3113 : 36 42                                 MVI	L, 102o               ;Set pointer to bit counter storage location
 2643/3115 : D7                                    MOV	C,M                    ;Fetch the value of the bit counter
 2644/3116 : 11                                    DCR	C                    ;Decrement the value by one
 2645/3117 : FA                                    MOV	M,C                    ;Restore the new counter value to storage
 2646/3118 : 48 EF 30                              JNZ	DIVIDE             ;If bit counter is not zero, continue division process
 2647/311B : 46 47 31                              CALL	SETSUB             ;After 23 (decimal) bits, do subtraction once more for
 2648/311E : 70 3E 31                              JM	DVEXIT             ;Possible rounding. Jump ahead if no rounding required.
 2649/3121 : 36 64                                 MVI	L, 144o               ;If rounding required set pointer to LSW of quotient
 2650/3123 : C7                                    MOV	A,M                    ;Fetch LSW of quotient to accumulator
 2651/3124 : 04 01                                 ADI	001                ;Add one to 23rd bit of quotient
 2652/3126 : F8                                    MOV	M,A                    ;Restore updated LSW of quotient
 2653/3127 : 06 00                                 MVI	A, 000                ;Clear accumulator without disturbing carry bit
 2654/3129 : 30                                    INR	L                    ;Advance pointer to next significant byte of quotient
 2655/312A : 8F                                    ADC	M                    ;Propagate any carry as part of rounding process
 2656/312B : F8                                    MOV	M,A                    ;Restore the updated byte of quotient
 2657/312C : 06 00                                 MVI	A, 000                ;Clear ACC again without disturbing carry bit
 2658/312E : 30                                    INR	L                    ;Advance pointer to MSW of quotient
 2659/312F : 8F                                    ADC	M                    ;Propagate any carry to finish rounding process
 2660/3130 : F8                                    MOV	M,A                    ;Restore the updated byte of quotient
 2661/3131 : 50 3E 31                              JP	DVEXIT             ;If most significant bit of quotient is zero, go finish up
 2662/3134 : 0E 03                                 MVI	B, 003                ;If not, set precision counter
 2663/3136 : 46 8F 31                              CALL	ROTATR             ;And rotate quotient to the right to clear the sign bit
 2664/3139 : 36 57                                 MVI	L, 127o               ;Set pointer to FPACC Exponent
 2665/313B : CF                                    MOV	B,M                    ;Fetch FPACC exponent
 2666/313C : 08                                    INR	B                    ;Increment the value to compensate for the rotate right
 2667/313D : F9                                    MOV	M,B                    ;Restore the updated exponent value
 2668/313E : 36 63                      DVEXIT:    MVI	L, 143o               ;Set up pointers
 2669/3140 : 26 53                                 MVI	E, 123o               ;To transfer the quotient into the FPACC
 2670/3142 : 0E 04                                 MVI	B, 004                ;Set precision counter
 2671/3144 :                                                              ;THIS IS A CORRECTION FOUND IN THE NOTES
 2672/3144 : 44 6C 30                              JMP	EXMLDV             ;And exit through FPMULT routine at EXMLDV
 2673/3147 :                            
 2674/3147 :                                                              ;Subroutine to subtract divisor from dividend. Used by
 2675/3147 :                                                              ;main DIVIDE subroutine.
 2676/3147 :                            
 2677/3147 : 26 59                      SETSUB:    MVI	E, 131o               ;Set pointer to LSW of working area
 2678/3149 : DD                                    MOV	D,H                    ;On same page as FPACC
 2679/314A : 36 54                                 MVI	L, 124o               ;Set pointer to LSW of FPACC (divisor)
 2680/314C : 0E 03                                 MVI	B, 003                ;Set precision counter
 2681/314E : 46 11 30                              CALL	MOVEIT             ;Perform transfer
 2682/3151 : 26 59                                 MVI	E, 131o               ;Reset pointer to LSW of working area (now divisor)
 2683/3153 : 36 5C                                 MVI	L, 134o               ;Reset pointer to LSW of FPOP (dividend)
 2684/3155 : 0E 03                                 MVI	B, 003                ;Set precision counter
 2685/3157 : 46 99 31                              CALL	SUBBER             ;Subtract divisor from dividend
 2686/315A : C7                                    MOV	A,M                    ;Get MSW of the result of the subtraction operations
 2687/315B : A0                                    ANA	A                    ;Exercise CPU flags
 2688/315C : 07                                    RET                    ;Return to caller with status
 2689/315D : A0                         ADDER:     ANA	A                    ;Initialize the carry bit to zero upon entry
 2690/315E : C7                         ADDMOR:    MOV	A,M                    ;Fetch byte from register group A
 2691/315F : 46 F4 31                              CALL	SWITCH             ;Switch memory pointer to register group B
 2692/3162 : 8F                                    ADC	M                    ;Add byte from A to byte from B with carry
 2693/3163 : F8                                    MOV	M,A                    ;Leave result in register group B
 2694/3164 : 09                                    DCR	B                    ;Decrement number of bytes (precision) counter
 2695/3165 : 2B                                    RZ                    ;Return to caller when all bytes in group processed
 2696/3166 : 30                                    INR	L                    ;Else advance pointer for register group B
 2697/3167 : 46 F4 31                              CALL	SWITCH             ;Switch memory pointer back to register group A
 2698/316A : 30                                    INR	L                    ;Advance the pointer for register group A
 2699/316B : 44 5E 31                              JMP	ADDMOR             ;Continue the multi-byte addition operation
 2700/316E :                            
 2701/316E :                                                              ;N'th precision two's complement (negate)
 2702/316E :                                                              ;subroutine. Performs a two's complement on the multi-byte
 2703/316E :                                                              ;registers tarting at the address pointed
 2704/316E :                                                              ; to by H & L (least significant byte) upon entry.
 2705/316E :                            
 2706/316E : C7                         COMPLM:    MOV	A,M                    ;Fetch the least significant byte of the number to ACC
 2707/316F : 2C FF                                 XRI	377o               ;Exclusive OR to complement the byte
 2708/3171 : 04 01                                 ADI	001                ;Add one to form two's complement of byte
 2709/3173 : F8                         MORCOM:    MOV	M,A                    ;Restore the negated byte to memory
 2710/3174 : 1A                                    RAR                   ;Save the carry bit
 2711/3175 : D8                                    MOV	D,A                    ;In CPU register D
 2712/3176 : 09                                    DCR	B                    ;Decrement number of bytes (precision) counter
 2713/3177 : 2B                                    RZ                    ;Return to caller when all bytes in number processed
 2714/3178 : 30                                    INR	L                    ;Else advance the pointer
 2715/3179 : C7                                    MOV	A,M                    ;Fetch the next byte of the number to ACC
 2716/317A : 2C FF                                 XRI	377o               ;Exclusive OR to complement the byte
 2717/317C : E0                                    MOV	E,A                    ;Save complemented value in register E temporarily
 2718/317D : C3                                    MOV	A,D                    ;Restore previous carry status to ACC
 2719/317E : 12                                    RAL                    ;And rotate it out to the carry bit
 2720/317F : 06 00                                 MVI	A, 000                ;Clear ACC without disturbing carry status
 2721/3181 : 8C                                    ADC	E                    ;Add in any carry to complemented value
 2722/3182 : 44 73 31                              JMP	MORCOM             ;Continue the two's complement procedure as req'd
 2723/3185 :                            
 2724/3185 :                                                              ;N'th precision rotate left subroutine. Rotates a multi-
 2725/3185 :                                                              ;byte number left starting at the address initially
 2726/3185 :                                                              ;specified by the contents of CPU registers H & L upon
 2727/3185 :                                                              ;subroutine entry (LSW). First entry point will clear
 2728/3185 :                                                              ;the carry bit before beginning rotate operations. Second
 2729/3185 :                                                              ;entry point does not clear the carry bit.
 2730/3185 :                            
 2731/3185 : A0                         ROTATL:    ANA	A                    ;Clear the carry bit at this entry point
 2732/3186 : C7                         ROTL:      MOV	A,M                    ;Fetch a byte from memory
 2733/3187 : 12                                    RAL                    ;Rotate it left (bring carry into LSB, push MSB to carry)
 2734/3188 : F8                                    MOV	M,A                    ;Restore rotated word to memory
 2735/3189 : 09                                    DCR	B                    ;Decrement precision counter
 2736/318A : 2B                                    RZ                    ;Exit to caller when finished
 2737/318B : 30                                    INR	L                    ;Else advance pointer to next byte
 2738/318C : 44 86 31                              JMP	ROTL               ;Continue rotate left operations
 2739/318F :                            
 2740/318F :                            
 2741/318F :                                                              ;N'th precision rotate
 2742/318F :                                                              ;right subroutine. Opposite of
 2743/318F :                                                              ;above subroutine.
 2744/318F :                            
 2745/318F : A0                         ROTATR:    ANA	A                    ;Clear the carry bit at this entry point
 2746/3190 : C7                         ROTR:      MOV	A,M                    ;Fetch a byte from memory
 2747/3191 : 1A                                    RAR                    ;Rotate it right (carry into MSB, LSB to carry)
 2748/3192 : F8                                    MOV	M,A                    ;Restore rotated word to memory
 2749/3193 : 09                                    DCR	B                    ;Decrement precision counter
 2750/3194 : 2B                                    RZ                    ;Exit to caller when finished
 2751/3195 : 31                                    DCR	L                    ;Else decrement pointer to next byte
 2752/3196 : 44 90 31                              JMP	ROTR               ;Continue rotate right operations
 2753/3199 :                            
 2754/3199 :                                                              ;N'th precision subtraction subroutine.
 2755/3199 :                                                              ;Number starting at location pointed to by D & E (least
 2756/3199 :                                                              ;significant byte) is subtracted from number starting at
 2757/3199 :                                                              ;address specified by contents of H & L.
 2758/3199 :                            
 2759/3199 : A0                         SUBBER:    ANA	A                    ;Initialize the carry bit to zero upon entry
 2760/319A : C7                         SUBTRA:    MOV	A,M                    ;Fetch byte from register group A
 2761/319B : 46 F4 31                              CALL	SWITCH             ;Switch memory pointer to register group B
 2762/319E : 9F                                    SBB	M                    ;Subtract byte from group B ftom that in group A
 2763/319F : F8                                    MOV	M,A                    ;Leave result in register group B
 2764/31A0 : 09                                    DCR	B                    ;Decrement number of bytes (precision) counter
 2765/31A1 : 2B                                    RZ                    ;Return to caller when all bytes in group processed
 2766/31A2 : 30                                    INR	L                    ;Else advance pointer for register group B
 2767/31A3 : 46 F4 31                              CALL	SWITCH             ;Switch memory pointer back to register group A
 2768/31A6 : 30                                    INR	L                    ;Advance the pointer for register group A
 2769/31A7 : 44 9A 31                              JMP	SUBTRA             ;Continue the multi-byte subtraction operation
 2770/31AA :                            
 2771/31AA :                                                              ;The next subroutine will transfer the four byte
 2772/31AA :                                                              ;register string (generally a number in floating point
 2773/31AA :                                                              ;format) from the starting address pointed to by CPU
 2774/31AA :                                                              ;registers H & L when the subroutine is entered to
 2775/31AA :                                                              ;the FPACC (floating point accumulator registers).
 2776/31AA :                            
 2777/31AA : 1E 02                      FLOAD:     MVI	D,PG01 ;\HB\OLDPG1    ;** Set page address of FPACC
 2778/31AC : 26 54                                 MVI	E, 124o               ;Set address of least signficant byte of FPACC
 2779/31AE : 0E 04                                 MVI	B, 004                ;Set precision counter to four bytes (mantissa bytes
 2780/31B0 : 44 11 30                              JMP	MOVEIT             ;Plus Exponent) and exit via the transfer routine
 2781/31B3 :                            
 2782/31B3 :                                                              ;The next several subroutines are used to perform
 2783/31B3 :                                                              ;floating pojnt register loading and transfer operations.
 2784/31B3 :                            
 2785/31B3 : E6                         FSTORE:    MOV	E,L                    ;Transfer contents of register L to E
 2786/31B4 : DD                                    MOV	D,H                    ;Transfer contents of register H to D
 2787/31B5 : 36 54                                 MVI	L, 124o               ;Set L to least significant byte of FPACC mantissa
 2788/31B7 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set page to FPACC storage area
 2789/31B9 : 44 C0 31                              JMP	SETIT              ;Go transfer FPACC contents to area pointed to by D&E
 2790/31BC : 1E 02                      OPLOAD:    MVI	D,PG01 ;\HB\OLDPG1    ;** Set page to FPOP storage area
 2791/31BE : 26 5C                                 MVI	E, 134o               ;Set pointer to least significant byte of FPOP
 2792/31C0 : 0E 04                      SETIT:     MVI	B, 004                ;Set precision counter. Transfer from H & L area to
 2793/31C2 : 44 11 30                              JMP	MOVEIT             ;Locations pointed to by D & E
 2794/31C5 :                            
 2795/31C5 :                                                              ;The next subroutine perforins a double transfer opera-
 2796/31C5 :                                                              ;tion. It first transfers the contents of the FPACC into
 2797/31C5 :                                                              ;the FPOP. It then transfers new data (as pointed to by
 2798/31C5 :                                                              ;H & L upon entry to the subroutine) into the FPACC.
 2799/31C5 :                            
 2800/31C5 : 46 D5 31                   FACXOP:    CALL	SAVEHL             ;Save contents of H & L upon entry to subroutine
 2801/31C8 : 36 54                                 MVI	L, 124o               ;Set pointer to FPACC LSW
 2802/31CA : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set pointer to page of FPACC
 2803/31CC : 46 BC 31                              CALL	OPLOAD             ;Transfer FPACC to FPOP
 2804/31CF : 46 E5 31                              CALL	RESTHL             ;Recover original subroutine entry values for H & L
 2805/31D2 : 44 AA 31                              JMP	FLOAD              ;Transfer registers pointed to by H & L into the FPACC
 2806/31D5 :                            
 2807/31D5 :                                                              ;Subroutine to save the contents of CPU registers D, E, H
 2808/31D5 :                                                              ;and L in a temporary storage area in memory.
 2809/31D5 :                            
 2810/31D5 : C5                         SAVEHL:    MOV	A,H                    ;Transfer value in H to ACC
 2811/31D6 : CE                                    MOV	B,L                    ;And value in L to B
 2812/31D7 : 36 80                                 MVI	L, 200o               ;Now set L to start of tempomry storage locations
 2813/31D9 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** And set H to storage area page
 2814/31DB : F8                                    MOV	M,A                    ;Save A (entry value of H) in memory
 2815/31DC : 30                                    INR	L                    ;Advance pointer
 2816/31DD : F9                                    MOV	M,B                    ;Save B (entry value of L) in memory
 2817/31DE : 30                                    INR	L                    ;Advance pointer
 2818/31DF : FB                                    MOV	M,D                    ;Save D in memory
 2819/31E0 : 30                                    INR	L                    ;Advance pointer
 2820/31E1 : FC                                    MOV	M,E                    ;Save E in memory
 2821/31E2 : E8                                    MOV	H,A                    ;Restore entry value of H
 2822/31E3 : F1                                    MOV	L,B                    ;Restore entry value of L
 2823/31E4 : 07                                    RET                    ;Exit to calling routine
 2824/31E5 :                            
 2825/31E5 :                                                              ;Subroutine to restore the contents of CPU registers D,
 2826/31E5 :                                                              ;E, H and L from temporary storage in memory.
 2827/31E5 :                            
 2828/31E5 : 36 80                      RESTHL:    MVI	L, 200o               ;Set L to start of temporary storage locations
 2829/31E7 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to storage area page
 2830/31E9 : C7                                    MOV	A,M                    ;Fetch stored value for li iii ACC
 2831/31EA : 30                                    INR	L                    ;Advance pointer
 2832/31EB : CF                                    MOV	B,M                    ;Fetch stored value for L into B
 2833/31EC : 30                                    INR	L                    ;Advance pointer
 2834/31ED : DF                                    MOV	D,M                    ;Fetch stored value for T.)
 2835/31EE : 30                                    INR	L                    ;Advance pointer
 2836/31EF : E7                                    MOV	E,M                    ;Fetch stored value for
 2837/31F0 : E8                                    MOV	H,A                    ;Restore  saved value for H
 2838/31F1 : F1                                    MOV	L,B                    ;Restore saved value for L
 2839/31F2 : C7                                    MOV	A,M                    ;Leave stored value for E in ACC
 2840/31F3 : 07                                    RET                    ;Exit to calling routine
 2841/31F4 :                            
 2842/31F4 :                                                              ;Subroutine to exchange the contents of H & L with
 2843/31F4 :                                                              ;D & E.
 2844/31F4 :                            
 2845/31F4 : D5                         SWITCH:    MOV	C,H                    ;Transfer register H to C temporarily
 2846/31F5 : EB                                    MOV	H,D                    ;Place value of D into H
 2847/31F6 : DA                                    MOV	D,C                    ;Now put former H from C into D
 2848/31F7 : D6                                    MOV	C,L                    ;Transfer register L to C temporarily
 2849/31F8 : F4                                    MOV	L,E                    ;Place value of E into L
 2850/31F9 : E2                                    MOV	E,C                    ;Now put former L from C into E
 2851/31FA : 07                                    RET                    ;Exit to calling routine
 2852/31FB : 2E 02                      GETINP:    MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of GETINP character counter
 2853/31FD : 36 90                                 MVI	L, 220o               ;Set L to address of GETINP character counter
 2854/31FF : D7                                    MOV	C,M                    ;Load counter value into CPU register C
 2855/3200 : 10                                    INR	C                    ;Exercise the counter in order
 2856/3201 : 11                                    DCR	C                    ;To set CPU flags. If counter is non-zero, then indexing
 2857/3202 : 48 0E 32                              JNZ	NOT0               ;Register (GETINP counter) is all set so jump ahead.
 2858/3205 : F4                                    MOV	L,E                    ;But, if counter zero, then starting to process a new
 2859/3206 : EB                                    MOV	H,D                    ;Character string. Transfer char string buffer pointer into
 2860/3207 : D7                                    MOV	C,M                    ;H & L and fetch the string's character count value (cc)
 2861/3208 : 10                                    INR	C                    ;Increment the (cc) by one to take account of (cc) byte
 2862/3209 : 46 24 32                              CALL	INDEXC             ;Add contents of regis C to H & L to point to end of the
 2863/320C : 3E 00                                 MVI	M, 000                ;Character string in buffer and place a zero byte marker
 2864/320E : 36 90                      NOT0:      MVI	L, 220o               ;Set L back to address of GETINP counter which is used
 2865/3210 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** As an indexing value. Set H to correct page.
 2866/3212 : D7                                    MOV	C,M                    ;Fetch the value of GETINP counter into register C
 2867/3213 : 10                                    INR	C                    ;Increment the value in C
 2868/3214 : FA                                    MOV	M,C                    ;Restore the updated value for future use
 2869/3215 : F4                                    MOV	L,E                    ;Bring the base address of the character string buffer into
 2870/3216 : EB                                    MOV	H,D                    ;CPU registers H & L
 2871/3217 : 46 24 32                              CALL	INDEXC             ;Add contents of register C to form indexed address of
 2872/321A : C7                                    MOV	A,M                    ;Next character to be fetched as input. Fetch the next
 2873/321B : A0                                    ANA	A                    ;Character. Exercise the CPU flags.
 2874/321C : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Restore page pointer to floating point working area
 2875/321E : 0B                                    RNZ                    ;If character is non-zero, not end of string, exit to calle
 2876/321F : 36 90                                 MVI	L, 220o               ;If zero character, must reset GETINP counter for next
 2877/3221 : 3E 00                                 MVI	M, 000                ;String. Reset pointer and clear GETINP counter to zero
 2878/3223 : 07                                    RET                    ;Then exit to calling routine
 2879/3224 :                            
 2880/3224 :                                                              ;Following subroutine causes register C to be used as an
 2881/3224 :                                                              ;indexing register. Value in C is added to address in H
 2882/3224 :                                                              ;and L to form new address.
 2883/3224 :                            
 2884/3224 : C6                         INDEXC:    MOV	A,L                    ;Place value from register L into accumulator
 2885/3225 : 82                                    ADD	C                    ;Add quantity in register C
 2886/3226 : F0                                    MOV	L,A                    ;Restore updated value back to L
 2887/3227 : 03                                    RNC                    ;Exit to caller if no carry from addition
 2888/3228 : 28                                    INR	H                    ;But, if have carry then must increment register H
 2889/3229 : 07                                    RET                    ;Before returning to calling routine
 2890/322A :                            
 2891/322A :                                                              ;Main Decimal INPUT subroutine to convert strings of
 2892/322A :                                                              ;ASCII characters representing decimal fixed or floating
 2893/322A :                                                              ;point numbers to binary floating point numbers.
 2894/322A :                            
 2895/322A : E6                         DINPUT:    MOV	E,L                    ;Save entry value of register L in E. (Pointer to buffer
 2896/322B : DD                                    MOV	D,H                    ;Containing ASCII character string.) Do same for H to D.
 2897/322C : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of floating point working registers
 2898/322E : 36 68                                 MVI	L, 150o               ;Set L to start of decirnal-to-binary working area
 2899/3230 : A8                                    XRA	A                    ;Clear the accumulator
 2900/3231 : 0E 08                                 MVI	B, 010o               ;Set up a loop counter
 2901/3233 : F8                         CLRNX2:    MOV	M,A                    ;Deposit zero in working area to initialize
 2902/3234 : 30                                    INR	L                    ;Advance the memory pointer
 2903/3235 : 09                                    DCR	B                    ;Decrement the loop counter
 2904/3236 : 48 33 32                              JNZ	CLRNX2             ;Clear working area until loop counter is zero
 2905/3239 : 36 43                                 MVI	L, 103o               ;Set pointer to floating point temporary registers and
 2906/323B : 0E 04                                 MVI	B, 004                ;Indicators working area. Set up a loop counter.
 2907/323D : F8                         CLRNX3:    MOV	M,A                    ;Deposit zero in working area to initialize
 2908/323E : 30                                    INR	L                    ;Advance the memory pointer
 2909/323F : 09                                    DCR	B                    ;Decrement the loop counter
 2910/3240 : 48 3D 32                              JNZ	CLRNX3             ;Clear working area until loop counter is zero
 2911/3243 : 46 FB 31                              CALL	GETINP             ;Fetch a character from the ASCII chax string buffer
 2912/3246 : 3C AB                                 CPI	253o               ;(Typically the SYMBOL/TOKEN buffer). See if it is
 2913/3248 : 68 53 32                              JZ	NINPUT             ;Code for + sign. Jump ahead if code for + sign.
 2914/324B : 3C AD                                 CPI	255o               ;See if code for minus (-) sign.
 2915/324D : 48 56 32                              JNZ	NOTPLM             ;Jump ahead if not code for minus sign. If code for
 2916/3250 : 36 43                                 MVI	L, 103o               ;Minus sign, set pointer to MINUS flag storage location.
 2917/3252 : F8                                    MOV	M,A                    ;Set the MINUS flag to indicate a minus number
 2918/3253 : 46 FB 31                   NINPUT:    CALL	GETINP             ;Fetch another character from the ASCII char string
 2919/3256 : 3C AE                      NOTPLM:    CPI	256o               ;See if character represents a period (decimal point) in
 2920/3258 : 68 87 32                              JZ	PERIOD             ;Input string. Jump ahead if yes.
 2921/325B : 3C C5                                 CPI	305o               ;If not period, see if code for E as in Exponent
 2922/325D : 68 97 32                              JZ	FNDEXP             ;Jump ahead if yes.
 2923/3260 : 3C A0                                 CPI	240o               ;Else see if code for space.
 2924/3262 : 68 53 32                              JZ	NINPUT             ;Ignore space character, go fetch another character.
 2925/3265 : A0                                    ANA	A                    ;If none of the above see if zero byte
 2926/3266 : 68 CF 32                              JZ	ENDINP             ;Indicating end of input char string. If yes, jumn ahead.
 2927/3269 : 3C B0                                 CPI	260o               ;If not end of string, check to see
 2928/326B : 70 07 2A                              JM	NUMERR             ;If character represents
 2929/326E : 3C BA                                 CPI	272o               ;A valid decimal number (0 to 9)
 2930/3270 : 50 07 2A                              JP	NUMERR             ;Display error message if not a valid digit at this point!
 2931/3273 : 36 6E                                 MVI	L, 156o               ;For valid digit, set pointer to MSW of temporary
 2932/3275 : D0                                    MOV	C,A                    ;Decimal to binary holding registers. Save character in C.
 2933/3276 : 06 F8                                 MVI	A, 370o               ;Form mask for sizing in accumulator. Now see if
 2934/3278 : A7                                    ANA	M                    ;Holding register has enough room for the conversion of
 2935/3279 : 48 53 32                              JNZ	NINPUT             ;Another digit. Ignore the input if no more room.
 2936/327C : 36 45                                 MVI	L, IN_DIGIT_CC_L      ;If have room in register then set pointer to input digit
 2937/327E : CF                                    MOV	B,M                    ;Counter location. Fetch the present value.
 2938/327F : 08                                    INR	B                    ;Increment it to account for incoming digit.
 2939/3280 : F9                                    MOV	M,B                    ;Restore updated count to storage location.
 2940/3281 : 46 34 33                              CALL	DECBIN             ;Call the DECimal to BINary conversion routine to add
 2941/3284 : 44 53 32                              JMP	NINPUT             ;In the new digit in holding registers. Continue inputting.
 2942/3287 : C8                         PERIOD:    MOV	B,A                    ;Save character code in register B
 2943/3288 : 36 46                                 MVI	L, 106o               ;Set pointer to PERIOD indicator storage location
 2944/328A : C7                                    MOV	A,M                    ;Fetch value in PERIOD indicator
 2945/328B : A0                                    ANA	A                    ;Exercise CPU flags
 2946/328C : 48 07 2A                              JNZ	NUMERR             ;If already have a period then display error message
 2947/328F : 36 45                                 MVI	L, IN_DIGIT_CC_L      ;If not, change pointer to digit counter storage location
 2948/3291 : F8                                    MOV	M,A                    ;Clear the digit counter back to zero
 2949/3292 : 30                                    INR	L                    ;Advance pointer to PERIOD indicator
 2950/3293 : F9                                    MOV	M,B                    ;Set the PERIOD indicator
 2951/3294 : 44 53 32                              JMP	NINPUT             ;Continue processing the input character string
 2952/3297 : 46 FB 31                   FNDEXP:    CALL	GETINP             ;Get next character in Exponent
 2953/329A : 3C AB                                 CPI	253o               ;See if it is code for + sign
 2954/329C : 68 A7 32                              JZ	EXPINP             ;Jump ahead if yes.
 2955/329F : 3C AD                                 CPI	255o               ;If not + sign, see if minus sign
 2956/32A1 : 48 AA 32                              JNZ	NOEXPS             ;If not minus sign then jump ahead
 2957/32A4 : 36 44                                 MVI	L, 104o               ;For minus sign, set pointer to EXP SIGN indicator
 2958/32A6 : F8                                    MOV	M,A                    ;Set the EXP SIGN indicator for a minus exponent
 2959/32A7 : 46 FB 31                   EXPINP:    CALL	GETINP             ;Fetch the next character in the decimal exponent
 2960/32AA : A0                         NOEXPS:    ANA	A                    ;Exercise the CPU flags
 2961/32AB : 68 CF 32                              JZ	ENDINP             ;If character inputted was zero, then end of input string
 2962/32AE : 3C B0                                 CPI	260o               ;If not end of string, check to see
 2963/32B0 : 70 07 2A                              JM	NUMERR             ;If character represents
 2964/32B3 : 3C BA                                 CPI	272o               ;A valid decimal number (0 to 9)
 2965/32B5 : 50 07 2A                              JP	NUMERR             ;Display error message if not a valid digit at this point!
 2966/32B8 : 24 0F                                 ANI	017o               ;Else trim the ASCII code to BCD
 2967/32BA : C8                                    MOV	B,A                    ;And save in register B
 2968/32BB : 36 6F                                 MVI	L, 157o               ;Set pointer to input exponent storage location
 2969/32BD : 06 03                                 MVI	A, 003                ;Set accumulator equal to three
 2970/32BF : BF                                    CMP	M                    ;See if any previous digit in exponent greater than three
 2971/32C0 : 70 07 2A                              JM	NUMERR             ;Display error message if yes
 2972/32C3 : D7                                    MOV	C,M                    ;Else save any previous value in register C
 2973/32C4 : C7                                    MOV	A,M                    ;And also place any previous value in accumulator
 2974/32C5 : A0                                    ANA	A                    ;Clear the carry bit with this instruction
 2975/32C6 : 12                                    RAL                    ;Single precision multiply by ten algorithm
 2976/32C7 : 12                                    RAL                    ;Two rotate lefts equals times four
 2977/32C8 : 82                                    ADD	C                    ;Adding in the digit makes total times five
 2978/32C9 : 12                                    RAL                    ;Rotating left again equals times ten
 2979/32CA : 81                                    ADD	B                    ;now add in digit just inputted
 2980/32CB : F8                                    MOV	M,A                    ;Restore the value to exponent storage location
 2981/32CC : 44 A7 32                              JMP	EXPINP             ;Go get any additional exponent int)ut
 2982/32CF : 36 43                      ENDINP:    MVI	L, 103o               ;Set pointer to mantissa SIGN indicator
 2983/32D1 : C7                                    MOV	A,M                    ;Fetch the SIGN indicator to the acclimulator
 2984/32D2 : A0                                    ANA	A                    ;Exercise the CPU flags
 2985/32D3 : 68 DD 32                              JZ	FININP             ;If SIGN indicator is zero, go finish up as nr is positive
 2986/32D6 : 36 6C                                 MVI	L, 154o               ;But, if indicator is non-zero, number is negative
 2987/32D8 : 0E 03                                 MVI	B, 003                ;Set pntr to LSW of storage registers, set precision entr
 2988/32DA : 46 6E 31                              CALL	COMPLM             ;Negate the triple-precision number in holding registers
 2989/32DD : 36 6B                      FININP:    MVI	L, 153o               ;Set pointer to input storage LS~V minus one
 2990/32DF : A8                                    XRA	A                    ;Clear the accumulator
 2991/32E0 : F8                                    MOV	M,A                    ;Clear the LSW minus one location
 2992/32E1 : DD                                    MOV	D,H                    ;Set register D to floating point working page
 2993/32E2 : 26 53                                 MVI	E, 123o               ;Set E to address of FPACC LSW minus one
 2994/32E4 : 0E 04                                 MVI	B, 004                ;Set precision counter
 2995/32E6 : 46 11 30                              CALL	MOVEIT             ;Move number from input register to FPACC
 2996/32E9 : 46 36 2F                              CALL	FPFLT              ;Now convert the binary fixed point to floating point
 2997/32EC : 36 44                                 MVI	L, 104o               ;Set pointer to Exponent SIGN indicator location
 2998/32EE : C7                                    MOV	A,M                    ;Fetch the value of the EXP SIGN indicator
 2999/32EF : A0                                    ANA	A                    ;Exercise the CPU flags
 3000/32F0 : 36 6F                                 MVI	L, 157o               ;Reset pointer to input exponent storage location
 3001/32F2 : 68 FB 32                              JZ	POSEXP             ;If EXP SIGN indicator zero, exponent is positive
 3002/32F5 : C7                                    MOV	A,M                    ;Else, exponent is negative so must negate
 3003/32F6 : 2C FF                                 XRI	377o               ;The value in the input exponent storage location
 3004/32F8 : 04 01                                 ADI	001                ;By performing this two's complement
 3005/32FA : F8                                    MOV	M,A                    ;Restore the negated value to exponent storage location
 3006/32FB : 36 46                      POSEXP:    MVI	L, 106o               ;Set pointer to PERIOD indicator storage location
 3007/32FD : C7                                    MOV	A,M                    ;Fetch the contents of the PERIOD indicator
 3008/32FE : A0                                    ANA	A                    ;Exercise the CPU flags
 3009/32FF : 68 06 33                              JZ	EXPOK              ;If PERIOD indicator clear, no decimal point involved
 3010/3302 : 36 45                                 MVI	L, IN_DIGIT_CC_L      ;If have a decimal point, set pointer to digit counter
 3011/3304 : A8                                    XRA	A                    ;Storage location. Clear the accumulator.
 3012/3305 : 97                                    SUB	M                    ;And get a negated value of the digit counter in ACC
 3013/3306 : 36 6F                      EXPOK:     MVI	L, 157o               ;Change pointer to input exponent storage location
 3014/3308 : 87                                    ADD	M                    ;Add this value to negated digit counter value
 3015/3309 : F8                                    MOV	M,A                    ;Restore new value to storage location
 3016/330A : 70 21 33                              JM	MINEXP             ;If new value is minus, skip over next subroutine
 3017/330D : 2B                                    RZ                    ;If new value is zero, no further processing required
 3018/330E :                            
 3019/330E :                                                              ;Following subroutine will multiply the floating point
 3020/330E :                                                              ;binary number stored in FPACC by ten tirnes the
 3021/330E :                                                              ;value stored in the deciinal exponent storage location.
 3022/330E :                            
 3023/330E : 36 88                      FPX10:     MVI	L, 210o               ;Set pointer to registers containing floating point
 3024/3310 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Binary representation of 10 (decimal).
 3025/3312 : 46 C5 31                              CALL	FACXOP             ;Transfer FPACC to FPOP and 10 (dec) to FPACC
 3026/3315 : 46 2C 30                              CALL	FPMULT             ;Multiply FPOP (formerly FPACC) by 10 (decimal)
 3027/3318 : 36 6F                                 MVI	L, 157o               ;Set pointer to decimal exponent storage location
 3028/331A : D7                                    MOV	C,M                    ;Fetch the exponent value
 3029/331B : 11                                    DCR	C                    ;Decrement
 3030/331C : FA                                    MOV	M,C                    ;Restore to storage
 3031/331D : 48 0E 33                              JNZ	FPX10              ;If exponent value is not zero, continue multiplication
 3032/3320 : 07                                    RET                    ;When exponent is zero can exit. Conversion completed.
 3033/3321 :                            
 3034/3321 :                                                              ;Following subroutine will multiply the floating point
 3035/3321 :                                                              ;binary number stored in PPACC by 0.1 times the value
 3036/3321 :                                                              ;(negative) stored in the decimal exponent storage location
 3037/3321 :                            
 3038/3321 :                            MINEXP:
 3039/3321 : 36 8C                      FPD10:     MVI	L, 214o               ;Set pointer to registers containing floating point
 3040/3323 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Binary representation of 0.1 (decimal).
 3041/3325 : 46 C5 31                              CALL	FACXOP             ;Transfer FPACC to FPOP and 0.1 (dec) to FPACC
 3042/3328 : 46 2C 30                              CALL	FPMULT             ;Multitply FPOP (formerly FPACC) by 0.1 (decimal)
 3043/332B : 36 6F                                 MVI	L, 157o               ;Set pointer to decimal exponent storage location
 3044/332D : CF                                    MOV	B,M                    ;Fetch the exponent value
 3045/332E : 08                                    INR	B                    ;Increment
 3046/332F : F9                                    MOV	M,B                    ;Restore to storage
 3047/3330 : 48 21 33                              JNZ	FPD10              ;If exponent value is not zero, continue multiplication
 3048/3333 : 07                                    RET                    ;When exponent is zero can exit. Conversion completed.
 3049/3334 :                            
 3050/3334 :                                                              ;Following subroutine is used
 3051/3334 :                                                              ;to convert decimal charac-
 3052/3334 :                                                              ;ters to binary fixed point forinat
 3053/3334 :                                                              ;in a triple-precision format.
 3054/3334 :                            
 3055/3334 : 46 D5 31                   DECBIN:    CALL	SAVEHL             ;Save entry value of D, E, H and L in memory
 3056/3337 : 36 6B                                 MVI	L, 153o               ;Set pointer to temporary storage location
 3057/3339 : C2                                    MOV	A,C                    ;Restore character inputted to accumulator
 3058/333A : 24 0F                                 ANI	017o               ;Trim ASCII code to BCD
 3059/333C : F8                                    MOV	M,A                    ;Store temporarily
 3060/333D : 26 68                                 MVI	E, 150o               ;Set pointer to working area LSW of multi-byte register
 3061/333F : 36 6C                                 MVI	L, 154o               ;Set another pointer to LSW of conversion register
 3062/3341 : DD                                    MOV	D,H                    ;Make sure D set to page of working area
 3063/3342 : 0E 03                                 MVI	B, 003                ;Set precision counter
 3064/3344 : 46 11 30                              CALL	MOVEIT             ;Move original value of conversion register to working
 3065/3347 : 36 6C                                 MVI	L, 154o               ;Register. Reset pointer to LSW of conversion register.
 3066/3349 : 0E 03                                 MVI	B, 003                ;Set precision counter
 3067/334B : 46 85 31                              CALL	ROTATL             ;Rotate register left, (Multiplies value by two.)
 3068/334E : 36 6C                                 MVI	L, 154o               ;Reset pointer to LSW.
 3069/3350 : 0E 03                                 MVI	B, 003                ;Set precision counter
 3070/3352 : 46 85 31                              CALL	ROTATL             ;Multiply by two again (total now times four).
 3071/3355 : 26 6C                                 MVI	E, 154o               ;Set pointer to LSW of conversion register.
 3072/3357 : 36 68                                 MVI	L, 150o               ;Set pointer to LSW of working register (original value).
 3073/3359 : 0E 03                                 MVI	B, 003                ;Set precision counter.
 3074/335B : 46 5D 31                              CALL	ADDER              ;Add original value to rotated value (now times five).
 3075/335E : 36 6C                                 MVI	L, 154o               ;Reset pointer to LSW
 3076/3360 : 0E 03                                 MVI	B, 003                ;Set precision counter
 3077/3362 : 46 85 31                              CALL	ROTATL             ;Multiply by two once more (total now times ten).
 3078/3365 : 36 6A                                 MVI	L, 152o               ;Set pointer to clear working register locatiotis
 3079/3367 : A8                                    XRA	A                    ;Clear the accumulator
 3080/3368 : F8                                    MOV	M,A                    ;Clear MSW of working register
 3081/3369 : 31                                    DCR	L                    ;Decrement pointer
 3082/336A : F8                                    MOV	M,A                    ;Clear next byte
 3083/336B : 36 6B                                 MVI	L, 153o               ;Set pointer to current digit storage location
 3084/336D : C7                                    MOV	A,M                    ;Fetch the current digit
 3085/336E : 36 68                                 MVI	L, 150o               ;Change pointer to LSW of working register
 3086/3370 : F8                                    MOV	M,A                    ;Deposit the current digit in LSW of working register
 3087/3371 : 26 6C                                 MVI	E, 154o               ;Set pointer to conversion register LSW
 3088/3373 : 0E 03                                 MVI	B, 003                ;Set precision counter
 3089/3375 : 46 5D 31                              CALL	ADDER              ;Add current digit to conversion register to complete
 3090/3378 : 44 E5 31                              JMP	RESTHL             ;Conversion. Exit to caller by restoring CPU registers.
 3091/337B : 2E 02                      FPOUT:     MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to working area for floating point routines
 3092/337D : 36 6F                                 MVI	L, 157o               ;Set pointer to decimal exponent storage location
 3093/337F : 3E 00                                 MVI	M, 000                ;Initialize storage location to zero
 3094/3381 : 36 56                                 MVI	L, 126o               ;Change pointer to FPACC (number to be outputted)
 3095/3383 : C7                                    MOV	A,M                    ;And fetch MSW of FPACC
 3096/3384 : A0                                    ANA	A                    ;Test the contents of MSW of FPACC
 3097/3385 : 70 8D 33                              JM	OUTNEG             ;If most significant bit of MSW is a one, have a minus nr.
 3098/3388 : 06 A0                                 MVI	A, 240o               ;Else number is positive, set ASCII code for space for a
 3099/338A : 44 96 33                              JMP	AHEAD1             ;Positive number and go display a space
 3100/338D : 36 54                      OUTNEG:    MVI	L, 124o               ;If number in FPACC is negative must negate in order
 3101/338F : 0E 03                                 MVI	B, 003                ;To display. Set pntr to LSW of FPACC & set prec. cntr.
 3102/3391 : 46 6E 31                              CALL	COMPLM             ;Negate the number in the FPACC to make it positive
 3103/3394 : 06 AD                                 MVI	A, 255o               ;But load ACC with ASCII code for minus sign
 3104/3396 : 46 9D 22                   AHEAD1:    CALL	ECHO               ;Call user display driver to output space or minus sign
 3105/3399 : 36 48                                 MVI	L, 110o               ;Set pointer to FIXED/FLOAT indicator
 3106/339B : C7                                    MOV	A,M                    ;Fetch value of FIXED/FLOAT indicator
 3107/339C : A0                                    ANA	A                    ;Test contents of indicator. If contents are zero, calling
 3108/339D : 68 B1 33                              JZ	OUTFLT             ;Routine has directed floating point output format.
 3109/33A0 : 36 57                                 MVI	L, 127o               ;If indicator non-zero, fixed point fonnat requested if
 3110/33A2 : 06 17                                 MVI	A, 027o               ;Possible. Point to FPACC Exponent. Put 23 decimal in
 3111/33A4 : CF                                    MOV	B,M                    ;Accumulator. Fetch FPACC Exponent into register B
 3112/33A5 : 08                                    INR	B                    ;And exercise the register to test its
 3113/33A6 : 09                                    DCR	B                    ;Original contents. If FPACC Exponent is negative in
 3114/33A7 : 70 B1 33                              JM	OUTFLT             ;Value then go to floating point output forrnat. If value
 3115/33AA : 91                                    SUB	B                    ;Is positive, subtract value from 23 (decimal). If result
 3116/33AB : 70 B1 33                              JM	OUTFLT             ;Negative, number is too big to use fixed format.
 3117/33AE : 44 BF 33                              JMP	OUTFIX             ;Else, can use fixed format so skip next routine
 3118/33B1 : 36 48                      OUTFLT:    MVI	L, 110o               ;Set pointer to FIXED/FLOAT indicator.
 3119/33B3 : 3E 00                                 MVI	M, 000                ;Clear indicator to indicate floating point output format
 3120/33B5 : 06 B0                                 MVI	A, 260o               ;Load ASCII code for '0' into accumulator
 3121/33B7 : 46 9D 22                              CALL	ECHO               ;Call user display driver to output '0' as first character
 3122/33BA : 06 AE                                 MVI	A, 256o               ;Number string. Now load ASCII code for decimal point.
 3123/33BC : 46 9D 22                              CALL	ECHO               ;Call user display driver to output '.'as second character.
 3124/33BF : 36 57                      OUTFIX:    MVI	L, 127o               ;Set pointer to FPACC Exponent
 3125/33C1 : 06 FF                                 MVI	A, 377o               ;Load accumulator with minus one
 3126/33C3 : 87                                    ADD	M                    ;Add value in FPACC Exponent
 3127/33C4 : F8                                    MOV	M,A                    ;Restore compensated exponent value
 3128/33C5 :                            
 3129/33C5 :                                                              ;Next portion of routine establishes the value for the
 3130/33C5 :                                                              ;decimal exponent that will be outputted by processing
 3131/33C5 :                                                              ;the binary exponent value in the FPACC.
 3132/33C5 :                            
 3133/33C5 : 50 E4 33                   DECEXT:    JP	DECEXD             ;If compensated exponent value is zero or positive
 3134/33C8 : 06 04                                 MVI	A, 004                ;Then go multiply FPACC by 0.1 (decimal). Else,
 3135/33CA : 87                                    ADD	M                    ;Add four to the exponent value.
 3136/33CB : 50 F6 33                              JP	DECOUT             ;If exponent now zero or positive, ready to output
 3137/33CE : 36 88                                 MVI	L, 210o               ;If exponent negative, multiply FPACC by 10 (decimal)
 3138/33D0 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set pointer to registers holding 10 (dec) in binary
 3139/33D2 : 46 C5 31                              CALL	FACXOP             ;Floating point format. Set up for multiplication.
 3140/33D5 : 46 2C 30                              CALL	FPMULT             ;Perform the multiplication. Answer in FPACC.
 3141/33D8 : 36 6F                                 MVI	L, 157o               ;Set pointer to decimal exponent storage location.
 3142/33DA : D7                                    MOV	C,M                    ;Each time the FPACC is multiplied by ten, need to
 3143/33DB : 11                                    DCR	C                    ;Decrement the value in the decinial exponent storage
 3144/33DC : FA                                    MOV	M,C                    ;Location. (This establishes decimal exponent value!)
 3145/33DD : 36 57                      DECREP:    MVI	L, 127o               ;Reset pointer to FPACC Exponent
 3146/33DF : C7                                    MOV	A,M                    ;Fetch value in exponent
 3147/33E0 : A0                                    ANA	A                    ;Test value
 3148/33E1 : 44 C5 33                              JMP	DECEXT             ;Repeat process as required
 3149/33E4 : 36 8C                      DECEXD:    MVI	L, 214o               ;If exponent is positive, multiply FPACC by 0.1
 3150/33E6 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set pointer to registers holding 0.1 dec in binary
 3151/33E8 : 46 C5 31                              CALL	FACXOP             ;Floating point format. Set up for multipli(-ation.
 3152/33EB : 46 2C 30                              CALL	FPMULT             ;Perform the multiplication. Answer in FPACC.
 3153/33EE : 36 6F                                 MVI	L, 157o               ;Set pointer to decimal exponent storage location.
 3154/33F0 : CF                                    MOV	B,M                    ;Each time the FPACC is multiplied by one tenth, need
 3155/33F1 : 08                                    INR	B                    ;To increment the value in the decimal exponent storage
 3156/33F2 : F9                                    MOV	M,B                    ;Location. (This establishes decimal exponent value!)
 3157/33F3 : 44 DD 33                              JMP	DECREP             ;Repeat process as required
 3158/33F6 :                            
 3159/33F6 :                                                              ;The next section outputs the mantissa
 3160/33F6 :                                                              ;(or fixed point number) by converting the value remaining
 3161/33F6 :                                                              ;in the FPACC (after the decimal exponent equivalent has
 3162/33F6 :                                                              ;been extracted from the original value if required by the
 3163/33F6 :                                                              ;previous routines) to a string of decirnal digits.
 3164/33F6 : 26 74                      DECOUT:    MVI	E, 164o               ;Set pointer to LSW of output working register
 3165/33F8 : DD                                    MOV	D,H                    ;Set D to same page value as H
 3166/33F9 : 36 54                                 MVI	L, 124o               ;Set pointer to LSW of FPACC
 3167/33FB : 0E 03                                 MVI	B, 003                ;Set precision counter
 3168/33FD : 46 11 30                              CALL	MOVEIT             ;Move value in FPACC to output working register
 3169/3400 : 36 77                                 MVI	L, 167o               ;Set pointer to MSW plus one of output working register
 3170/3402 : 3E 00                                 MVI	M, 000                ;Clear that location to 0
 3171/3404 : 36 74                                 MVI	L, 164o               ;Set pointer to LSW of output working register
 3172/3406 : 0E 03                                 MVI	B, 003                ;Set precision counter
 3173/3408 : 46 85 31                              CALL	ROTATL             ;Rotate register left once to compensate for sign bit
 3174/340B : 46 99 34                              CALL	OUTX10             ;Multiply output register by 10, overflow into N4SW+ 1
 3175/340E : 36 57                      COMPEN:    MVI	L, 127o               ;Set pointer back to FPACC Exponent
 3176/3410 : CF                                    MOV	B,M                    ;Compensate for any remainder in the binary exponent
 3177/3411 : 08                                    INR	B                    ;By performing a rotate right on the output working
 3178/3412 : F9                                    MOV	M,B                    ;Register until the binary exponent becomes zero
 3179/3413 : 68 20 34                              JZ	OUTDIG             ;Go output decimal digits when this loop is finished
 3180/3416 : 36 77                                 MVI	L, 167o               ;Binary exponent compensating loop. Setpointe'r to
 3181/3418 : 0E 04                                 MVI	B, 004                ;Working register MSW+L. Set precision counter.
 3182/341A : 46 8F 31                              CALL	ROTATR             ;Rotate working register to the right.
 3183/341D : 44 0E 34                              JMP	COMPEN             ;Repeat loop as required.
 3184/3420 : 36 47                      OUTDIG:    MVI	L, 107o               ;Set pointer to output digit counter storage location
 3185/3422 : 3E 07                                 MVI	M, 007                ;Initialize to value of seven
 3186/3424 : 36 77                                 MVI	L, 167o               ;Change pointer to output working register MSW+L
 3187/3426 : C7                                    MOV	A,M                    ;Fetch MSW+L byte containing BCD of digit to be
 3188/3427 : A0                                    ANA	A                    ;Displayed. Test the contents of this byte.
 3189/3428 : 68 7B 34                              JZ	ZERODG             ;If zero jump to ZERODG routine.
 3190/342B : 36 77                      OUTDGS:    MVI	L, 167o               ;Reset pointer to working register MSW+L
 3191/342D : C7                                    MOV	A,M                    ;Fetch BCD of digit to be outputted
 3192/342E : A0                                    ANA	A                    ;Exercise CPU flags
 3193/342F : 48 4B 34                              JNZ	OUTDGX             ;If not zero, go display the digit
 3194/3432 : 36 48                                 MVI	L, 110o               ;If zero, change pointer to FIXED/FLOAT indicator
 3195/3434 : C7                                    MOV	A,M                    ;Fetch the indicator into the accumulator
 3196/3435 : A0                                    ANA	A                    ;Test value of indicator
 3197/3436 : 68 4A 34                              JZ	OUTZER             ;If in floating point mode, go display the digit
 3198/3439 : 36 6F                                 MVI	L, 157o               ;Else change pointer to decimal exponent storage
 3199/343B : D7                                    MOV	C,M                    ;Location, which, for fixed point, will have a positive
 3200/343C : 11                                    DCR	C                    ;Value for all digits before the decimal point. Decrement
 3201/343D : 10                                    INR	C                    ;And increment to exercise flags. See if count is positive.
 3202/343E : 50 4A 34                              JP	OUTZER             ;If positive, must display any zero digit.
 3203/3441 : 36 76                                 MVI	L, 166o               ;If not, change pointer to MSW of working register
 3204/3443 : C7                                    MOV	A,M                    ;And test to see if any significant digits coming up
 3205/3444 : 24 E0                                 ANI	340o               ;By forming a mask and testing for presence of bits
 3206/3446 : 48 4A 34                              JNZ	OUTZER             ;If more significant digits coming up soon, display the
 3207/3449 : 07                                    RET                    ;Zero digit. Else, exit to calling routine. Finished.
 3208/344A : A8                         OUTZER:    XRA	A                    ;Clear the accumulator to restore zero digit value
 3209/344B : 04 B0                      OUTDGX:    ADI	260o               ;Add 260 (octal) to BCD code in ACC to form ASCII
 3210/344D : 46 9D 22                              CALL	ECHO               ;Code and call the user's display driver subroutine
 3211/3450 : 36 48                      DECRDG:    MVI	L, 110o               ;Set pointer to FIXED/FLOAT indicator storage
 3212/3452 : C7                                    MOV	A,M                    ;Fetch the indicator to the accumulator
 3213/3453 : A0                                    ANA	A                    ;Exercise the CPU flags
 3214/3454 : 48 65 34                              JNZ	CKDECP             ;If indicator non-zero, doing fixed point output
 3215/3457 : 36 47                                 MVI	L, 107o               ;Else, get output digit counter
 3216/3459 : D7                                    MOV	C,M
 3217/345A : 11                                    DCR	C                    ;Decrement the digit counter & restore to storage
 3218/345B : FA                                    MOV	M,C
 3219/345C : 68 C6 34                              JZ	EXPOUT             ;When digit counter is zero, go take care of exponent
 3220/345F : 46 99 34                   PUSHIT:    CALL	OUTX10             ;Else push next BCD digit out of working register
 3221/3462 : 44 2B 34                              JMP	OUTDGS             ;And continue the outputting process
 3222/3465 : 36 6F                      CKDECP:    MVI	L, 157o               ;For fixed point output, decimal exponent serves as
 3223/3467 : D7                                    MOV	C,M                    ;Counter for number of digits before decimal point
 3224/3468 : 11                                    DCR	C                    ;Fetch the counter and decrement it to account for
 3225/3469 : FA                                    MOV	M,C                    ;Current digit being processed. Restore to storage.
 3226/346A : 48 72 34                              JNZ	NODECP             ;If count does not go to zero, jump ahead.
 3227/346D : 06 AE                                 MVI	A, 256o               ;When count reaches zero, load ASCII code for period
 3228/346F : 46 9D 22                              CALL	ECHO               ;And call user's display driver to display decimal point
 3229/3472 : 36 47                      NODECP:    MVI	L, 107o               ;Set pointer to output digit counter storage location
 3230/3474 : D7                                    MOV	C,M                    ;Fetch the digit counter
 3231/3475 : 11                                    DCR	C                    ;Decrement the value
 3232/3476 : FA                                    MOV	M,C                    ;Restore to storage
 3233/3477 : 2B                                    RZ                    ;If counter reaches zero, exit to caller. Finished.
 3234/3478 : 44 5F 34                              JMP	PUSHIT             ;Else continue to output the number.
 3235/347B : 36 6F                      ZERODG:    MVI	L, 157o               ;If first digit of floating point number is a zero, set
 3236/347D : D7                                    MOV	C,M                    ;Pointer to decimal exponent storage location.
 3237/347E : 11                                    DCR	C                    ;Decrement the value to compensate for skipping
 3238/347F : FA                                    MOV	M,C                    ;Display of first digit. Restore to storage.
 3239/3480 : 36 76                                 MVI	L, 166o               ;Change pointer to MSW of output working register
 3240/3482 : C7                                    MOV	A,M                    ;Fetch MSW of output working register
 3241/3483 : A0                                    ANA	A                    ;Test the contents
 3242/3484 : 48 50 34                              JNZ	DECRDG             ;If non-zero, continue outputting
 3243/3487 : 31                                    DCR	L                    ;Else decrement pointer to next byte in working register
 3244/3488 : C7                                    MOV	A,M                    ;Fetch its contents
 3245/3489 : A0                                    ANA	A                    ;Test
 3246/348A : 48 50 34                              JNZ	DECRDG             ;If non-zero, continue outputting
 3247/348D : 31                                    DCR	L                    ;Else decrement pointer to LSW of working register
 3248/348E : C7                                    MOV	A,M                    ;Fetch its contents
 3249/348F : A0                                    ANA	A                    ;Test
 3250/3490 : 48 50 34                              JNZ	DECRDG             ;If non-zero, continue outputting
 3251/3493 : 36 6F                                 MVI	L, 157o               ;If decimal mantissa is zero, set pointer to decirnal
 3252/3495 : F8                                    MOV	M,A                    ;Exponent storage and clear it
 3253/3496 : 44 50 34                              JMP	DECRDG             ;Finish outputting
 3254/3499 :                            
 3255/3499 :                                                              ;Following routine multiplies the binary number in the
 3256/3499 :                                                              ;output working register by ten to push the most signifi-
 3257/3499 :                                                              ;cant digit out to the MSW+L byte.
 3258/3499 :                            
 3259/3499 : 36 77                      OUTX10:    MVI	L, 167o               ;Set pointer to work ing register M SW+ 1
 3260/349B : 3E 00                                 MVI	M, 000                ;Clear it in preparation for receiving next digit pushed
 3261/349D : 36 74                                 MVI	L, 164o               ;Into it. Change pointer to working register LSW.
 3262/349F : DD                                    MOV	D,H                    ;Set up register D to same page as H.
 3263/34A0 : 26 70                                 MVI	E, 160o               ;Set second pointer to LSW of second working register
 3264/34A2 : 0E 04                                 MVI	B, 004                ;Set precision counter
 3265/34A4 : 46 11 30                              CALL	MOVEIT             ;Move first working register into second
 3266/34A7 : 36 74                                 MVI	L, 164o               ;Reset pointer to LSW of first working register
 3267/34A9 : 0E 04                                 MVI	B, 004                ;Set precision counter
 3268/34AB : 46 85 31                              CALL	ROTATL             ;Rotate contents of first working register left (X 2)
 3269/34AE : 36 74                                 MVI	L, 164o               ;Reset pointer to LSW
 3270/34B0 : 0E 04                                 MVI	B, 004                ;Reset precision counter
 3271/34B2 : 46 85 31                              CALL	ROTATL             ;Rotate contents left again (X 4)
 3272/34B5 : 36 70                                 MVI	L, 160o               ;Set pointer to LSW of original value in 2'nd register
 3273/34B7 : 26 74                                 MVI	E, 164o               ;Set pointer to LSW of rotated value
 3274/34B9 : 0E 04                                 MVI	B, 004                ;Set precision counter
 3275/34BB : 46 5D 31                              CALL	ADDER              ;Add rotated value to original value (X 5)
 3276/34BE : 36 74                                 MVI	L, 164o               ;Reset pointer to LSW of first working register
 3277/34C0 : 0E 04                                 MVI	B, 004                ;Set precision counter
 3278/34C2 : 46 85 31                              CALL	ROTATL             ;Rotate contents left again (X 10)
 3279/34C5 : 07                                    RET                    ;Exit to calling routine
 3280/34C6 :                            
 3281/34C6 :                                                              ;The final group of routines in the floating point output
 3282/34C6 :                                                              ;section take care of outputting the decimal exponent
 3283/34C6 :                                                              ;portion of floating point numbers.
 3284/34C6 :                            
 3285/34C6 : 36 6F                      EXPOUT:    MVI	L, 157o               ;Set pointer to decimal exponent storage location
 3286/34C8 : C7                                    MOV	A,M                    ;Fetch value to the accumulator
 3287/34C9 : A0                                    ANA	A                    ;Test the value
 3288/34CA : 2B                                    RZ                    ;If zero, then no exponent portion. Exit to CALLler.
 3289/34CB : 06 C5                                 MVI	A, 305o               ;Else, load ACC with ASCII code for letter E.
 3290/34CD : 46 9D 22                              CALL	ECHO               ;Display E for Exponent via user's display driver rtn
 3291/34D0 : C7                                    MOV	A,M                    ;Get decimal exponent value back into ACC
 3292/34D1 : A0                                    ANA	A                    ;Test again
 3293/34D2 : 70 DA 34                              JM	EXOUTN             ;If value is negative, skip ahead
 3294/34D5 : 06 AB                                 MVI	A, 253o               ;If positive, load ASCII code for + sign
 3295/34D7 : 44 E1 34                              JMP	AHEAD2             ;Jump to display the + sign
 3296/34DA : 2C FF                      EXOUTN:    XRI	377o               ;When decimal exponent is negative, must negate
 3297/34DC : 04 01                                 ADI	001                ;Value for display purposes. Perform two's complement
 3298/34DE : F8                                    MOV	M,A                    ;And restore the negated value to storage location
 3299/34DF : 06 AD                                 MVI	A, 255o               ;Load ASCII code for minus sign
 3300/34E1 : 46 9D 22                   AHEAD2:    CALL	ECHO               ;Display the ASCII character in ACC
 3301/34E4 : 0E 00                                 MVI	B, 000                ;Clear register B
 3302/34E6 : C7                                    MOV	A,M                    ;Fetch the decimal exponent value back into ACC
 3303/34E7 : 14 0A                      SUB12:     SUI	012o               ;Subtract 10 (decimal) from value in ACC
 3304/34E9 : 70 F1 34                              JM	TOMUCH             ;Break out of loop when accumulator goes negative
 3305/34EC : F8                                    MOV	M,A                    ;Else restore value to storage location
 3306/34ED : 08                                    INR	B                    ;Increment register B as a counter
 3307/34EE : 44 E7 34                              JMP	SUB12              ;Repeat loop to form tens value of decimal exponent
 3308/34F1 : 06 B0                      TOMUCH:    MVI	A, 260o               ;Load base ASCII value for digit into the accumulator
 3309/34F3 : 81                                    ADD	B                    ;Add to the count in B to forin tens digit of decimal
 3310/34F4 : 46 9D 22                              CALL	ECHO               ;Exponent. Display via user's driver subroutine
 3311/34F7 : C7                                    MOV	A,M                    ;Fetch remainder of decimal exponent value
 3312/34F8 : 04 B0                                 ADI	260o               ;Add in ASCII base value to form final digit
 3313/34FA : 46 9D 22                              CALL	ECHO               ;Display second digit of decirnal exponent
 3314/34FD : 07                                    RET                    ;Finished outputting. Return to caller.
 3315/34FE :                            ;;; The above RETURN SHOULD BE AT 25 367 15f7h
 3316/34FE :                            
 3317/34FE :                            ;;; NOW OPEN AREA UP TO 26 000 CAN BE USED FOR PATCHING...
 3318/34FE :                            
 3319/34FE :                            	;; THERE ARE NOW ADDRESSES AT START OF PAGE 30, NOT ASSIGNED;
 3320/34FE :                            
 3321/34FE :                            ;          ORG 	180bh	;030#013
 3322/34FE : 36 64                      NEXT:      MVI	L, 144o               ;Load L with start of AUX SYMBOL BUFFER
 3323/3500 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of AUX SYMBOL BUFFER
 3324/3502 : 3E 00                                 MVI	M, 000                ;Initialize AUX SYMBOL BUFFER by clearing first byte
 3325/3504 : 36 82                                 MVI	L, 202o               ;Change L to address of SCAN pointer
 3326/3506 : CF                                    MOV	B,M                    ;Fetch pointer value to CPU register B
 3327/3507 : 08                                    INR	B                    ;Add one to the current pointer value
 3328/3508 : 36 81                                 MVI	L, 201o               ;Load L with address of NEXT pointer storage location
 3329/350A : F9                                    MOV	M,B                    ;Place the updated SCAN pointer as the NEXT pointer
 3330/350B : 36 81                      NEXT1:     MVI	L, 201o               ;Reset L to address of NEXT pointer storage location
 3331/350D : 46 BB 21                              CALL	GETCHR             ;Fetch the character pointed to by the NEXT pointer
 3332/3510 : 68 18 35                              JZ	NEXT2              ;If the character is a space, ignore it
 3333/3513 : 36 64                                 MVI	L, 144o               ;Else, load L with start of AUX SYMBOL BUFFER
 3334/3515 : 46 E7 21                              CALL	CONCT1             ;Concatenate the character onto the AUX SYMBOL BF
 3335/3518 : 36 81                      NEXT2:     MVI	L, 201o               ;Reset L to address of NEXT pointer storage location
 3336/351A : 46 1E 22                              CALL	LOOP               ;Advance the NEXT pointer and see if end of line
 3337/351D : 48 0B 35                              JNZ	NEXT1              ;Fetch next character in line if not end of line
 3338/3520 : 36 64                                 MVI	L, 144o               ;When reach end of line, should have variable name
 3339/3522 : C7                                    MOV	A,M                    ;In the AUX SYMBOL BUFFER. Fetch the (cc) for
 3340/3523 : 3C 01                                 CPI	001                ;The buffer and see if variable name is just one letter
 3341/3525 : 48 2C 35                              JNZ	NEXT3              ;If more than one proceed directly to look for name
 3342/3528 : 36 66                                 MVI	L, 146o               ;In FOR/NEXT STACK. If have just a one letter name
 3343/352A : 3E 00                                 MVI	M, 000                ;Then set second character in buffer to zero
 3344/352C : 36 85                      NEXT3:     MVI	L, 205o               ;Load L with address of FOR/NEXT STACK pointer
 3345/352E : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to page of FOR/NEXT STACK pointer
 3346/3530 : C7                                    MOV	A,M                    ;Fetch the FOR/NEXT STACK pointer value to ACC
 3347/3531 : 02                                    RLC                    ;Rotate value left to multiply by two. Then rotate it
 3348/3532 : 02                                    RLC                    ;Left again to multiply by four. Add base address plus
 3349/3533 : 04 5E                                 ADI	136o               ;Two to form pointer to variable name in top of stack
 3350/3535 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to page of FOR/NEXT STACK
 3351/3537 : F0                                    MOV	L,A                    ;Move pointer value from ACC to CPU register L
 3352/3538 : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Set register D to page of AUX SYMBOL BUFFER
 3353/353A : 26 65                                 MVI	E, 145o               ;Set register E to first character in the buffer
 3354/353C : 0E 02                                 MVI	B, 002                ;Set B to serve as a character counter
 3355/353E : 46 13 22                              CALL	STRCPC             ;See if variable name in the NEXT statement same as
 3356/3541 : 68 4B 35                              JZ	NEXT4              ;That stored in the top of the FOR/NEXT STACK
 3357/3544 : 06 C6                      FORNXT:    MVI	A, 306o               ;Load ACC with ASCII code for letter F
 3358/3546 : 16 CE                                 MVI	C, 316o               ;Load register C with ASCII code for letter N
 3359/3548 : 44 B1 21                              JMP	ERROR              ;Display For/Next (FN) error message if required
 3360/354B : 36 F0                      NEXT4:     MVI	L, 360o               ;Load L with address of user program line pointer
 3361/354D : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of user pgm line pntr storage loc.
 3362/354F : DF                                    MOV	D,M                    ;Fetch the page portion of the line pointer into D
 3363/3550 : 30                                    INR	L                    ;Advance the memory pointer
 3364/3551 : E7                                    MOV	E,M                    ;Fetch the low portion of the line pointer into E
 3365/3552 : 30                                    INR	L                    ;Advance pntr to AUXILIARY LINE POINTER storage
 3366/3553 : FB                                    MOV	M,D                    ;Location and store value of line pointer there too (page)
 3367/3554 : 30                                    INR	L                    ;Advance pointer to second byte of AUXILIARY line
 3368/3555 : FC                                    MOV	M,E                    ;Pointer and store value of line pointer (low portion)
 3369/3556 : 36 85                                 MVI	L, 205o               ;Load L with address of FOR/NEXT STACK pointer
 3370/3558 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to page of FOR/NEXT STACK pointer
 3371/355A : C7                                    MOV	A,M                    ;Fetch the FOR/NEXT STACK pointer value to ACC
 3372/355B : 02                                    RLC                    ;Rotate value left to multiply by two. Then rotate it
 3373/355C : 02                                    RLC                    ;Left again to multiply by four. Add base address to
 3374/355D : 04 5C                                 ADI	134o               ;Form pointer to top of FOR/NEXT STACK and place
 3375/355F : F0                                    MOV	L,A                    ;The pointer value into CPU register L. Fetch the page
 3376/3560 : DF                                    MOV	D,M                    ;Address of the associated FOR statement line pointer
 3377/3561 : 30                                    INR	L                    ;Into register D. Advance the pointer and fetch the low
 3378/3562 : E7                                    MOV	E,M                    ;Address value into register E. Prepare to change user
 3379/3563 : 36 F0                                 MVI	L, 360o               ;Program line pointer to the FOR statement line by
 3380/3565 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Setting H & L to the user pgrn line pntr storage loc.
 3381/3567 : FB                                    MOV	M,D                    ;Place the page value in the pointer storage location
 3382/3568 : 30                                    INR	L                    ;Advance the memory pointer
 3383/3569 : FC                                    MOV	M,E                    ;Place the low value in the pointer storage location
 3384/356A : EB                                    MOV	H,D                    ;Now set up H and L to point to the start of the
 3385/356B : F4                                    MOV	L,E                    ;Associated FOR statement line in the user pgm buffer
 3386/356C : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Change D to point to the line input buffer
 3387/356E : 26 00                                 MVI	E, 000                ;And set L to the gtart of the line input buffer
 3388/3570 : 46 2A 29                              CALL	MOVEC              ;Move the associated FOR statement line into the input
 3389/3573 : 36 D5                                 MVI	L, 325o               ;Line buffer. Set L to point to start of TO string which is
 3390/3575 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Stored in a text strings storage area on this page
 3391/3577 : 46 14 2A                              CALL	INSTR              ;Search the statement line for the occurrence of TO
 3392/357A : C4                                    MOV	A,E                    ;Register E will be zero if TO not found. Move E to ACC
 3393/357B : A0                                    ANA	A                    ;To make a test. If TO found then proceed to set up for
 3394/357C : 68 44 35                              JZ	FORNXT             ;Evaluation. If TO not found, then have error condition.
 3395/357F : 04 02                                 ADI	002                ;Advance the pointer over the characters in TO string
 3396/3581 : 36 BE                                 MVI	L, 276o               ;Change L to point to EVAL pointer storage location
 3397/3583 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of EVAL pointer. Set up the starting
 3398/3585 : F8                                    MOV	M,A                    ;Position for the EVAL subroutine (after TO string)
 3399/3586 : 36 D8                                 MVI	L, 330o               ;Set L to point to start of STEP string which is stored
 3400/3588 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** In text stxings storage area on this page. Search the
 3401/358A : 46 14 2A                              CALL	INSTR              ;Statement line for the occurrence of STEP
 3402/358D : C4                                    MOV	A,E                    ;Register E will be zero if STEP not found. Move E to
 3403/358E : A0                                    ANA	A                    ;The accumulator to make a test. If STEP found must
 3404/358F : 48 B3 35                              JNZ	NEXT5              ;Evaluate expression after STEP to get STEP SIZE.
 3405/3592 : 36 04                                 MVI	L, 004                ;Else, have an IMPLIED STEP SIZE of 1.0. Set pointer
 3406/3594 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** To start of storage area for 1.0 in floating point
 3407/3596 : 46 AA 31                              CALL	FLOAD              ;Format and call subroutine to load FPACC with 1.0
 3408/3599 : 36 C4                                 MVI	L, 304o               ;Set L to start of FOR/NEXT STEP SIZE storage loc.
 3409/359B : 46 B3 31                              CALL	FSTORE             ;Store the value 1.0 in the F/N STEP SIZE registers
 3410/359E : 36 00                                 MVI	L, 000                ;Change L to the start of the input line buffer
 3411/35A0 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to the page of the input line buffer
 3412/35A2 : CF                                    MOV	B,M                    ;Fetch the (cc) into CPU register B (length of FOR line)
 3413/35A3 : 36 BF                                 MVI	L, 277o               ;Change L to EVAL FINISH pointer stomge location
 3414/35A5 : F9                                    MOV	M,B                    ;Set the EVAL FINISH pointer to the end of the line
 3415/35A6 : 46 AF 22                              CALL	EVAL               ;Evaluate the LIMIT expression to obtain FOR LIMIT
 3416/35A9 : 36 C8                                 MVI	L, 310o               ;Load L with address of start of F/N LIMIT registers
 3417/35AB : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with page of FOR/NEXT LIMIT registers
 3418/35AD : 46 B3 31                              CALL	FSTORE  ;MGA 3/31/12 no lab here Store the FOR/NEXT LIMIT value
 3419/35B0 : 44 DC 35                              JMP	NEXT6              ;Since have IMPLIED STEP jump ahead
 3420/35B3 : 21                         NEXT5:     DCR	E  ;MGA 3/21/12 lab here When have STEP directive, subtract one from pointer
 3421/35B4 : 36 BF                                 MVI	L, 277o               ;To get to character before S in STEP. Save this value in
 3422/35B6 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** The EVAL FINISH pointer stomge location to serve
 3423/35B8 : FC                                    MOV	M,E                    ;As evaluation end location when obtaining TO Iiinit
 3424/35B9 : 46 AF 22                              CALL	EVAL               ;Evaluate the LIMIT expression to obtain FOR LIMIT
 3425/35BC : 36 C8                                 MVI	L, 310o               ;Load L with address of start of FIN LIMIT registers
 3426/35BE : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with page of FORINEXT LIMIT registers
 3427/35C0 : 46 B3 31                              CALL	FSTORE             ;Store the FOR/NEXT LIMIT value
 3428/35C3 : 36 BF                                 MVI	L, 277o               ;Reset L to EVAL FINISH pointer storage location
 3429/35C5 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of EVAL FINISH pointer storage loc.
 3430/35C7 : C7                                    MOV	A,M                    ;Fetch the pointer value (character before S in STEP)
 3431/35C8 : 04 05                                 ADI	005                ;Add five to change pointer to character after P in STEP
 3432/35CA : 31                                    DCR	L                    ;Decrement L to point to EVAL (start) pointer
 3433/35CB : F8                                    MOV	M,A                    ;Set up the starting position for the EVAL subroutine
 3434/35CC : 36 00                                 MVI	L, 000                ; Load L with starting address of the line input buffer
 3435/35CE : CF                                    MOV	B,M                    ;Fetch the (cc) for the line input buffer (line length)
 3436/35CF : 36 BF                                 MVI	L, 277o               ;Change L to the EVAL FINISH storage location
 3437/35D1 : F9                                    MOV	M,B                    ;Set the EVAL FINISH pointer
 3438/35D2 : 46 AF 22                              CALL	EVAL               ;Evaluate the STEP SIZE expression
 3439/35D5 : 36 C4                                 MVI	L, 304o               ;Load L with address of start of F/N STEP registers
 3440/35D7 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of FIN STEP registers
 3441/35D9 : 46 B3 31                              CALL	FSTORE             ;Store the FOR/NEXT STEP SIZE value
 3442/35DC : 36 64                      NEXT6:     MVI	L, 144o               ;Load L with address of AUX SYMBOL BUFFER
 3443/35DE : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of the AUX SYMBOL BUFFER
 3444/35E0 : 3E 00                                 MVI	M, 000                ;Initialize AUX SUMBOL BUFFER with a zero byte
 3445/35E2 : 36 1C                                 MVI	L, 034o               ;Set L to start of FOR string which is stored in the
 3446/35E4 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** KEYWORD look-up table on this page
 3447/35E6 : 46 14 2A                              CALL	INSTR              ;Search the statement line for the FOR directive
 3448/35E9 : C4                                    MOV	A,E                    ;Register E will be zero if FOR not found. Move E to
 3449/35EA : A0                                    ANA	A                    ;ACC and -make test to see if FOR directive located
 3450/35EB : 36 82                                 MVI	L, 202o               ;Load L with address of SCAN pointer
 3451/35ED : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of SCAN pointer
 3452/35EF : F8                                    MOV	M,A                    ;Set up pointer to occurrence of FOR directive in line
 3453/35F0 : 68 44 35                              JZ	FORNXT             ;If FOR not found, have an error condition
 3454/35F3 : 04 03                                 ADI	003                ;If have FOR, add three to advance pointer over FOR
 3455/35F5 : 36 83                                 MVI	L, 203o               ;Set L to point to F/N pointer storage location
 3456/35F7 : F8                                    MOV	M,A                    ;Set F/N pointer to character after FOR directive
 3457/35F8 : 36 83                      NEXT7:     MVI	L, 203o               ;Set L to point to FIN pointer storage location
 3458/35FA : 46 BB 21                              CALL	GETCHR             ;Fetch a character from position pointed to by FIN pntr
 3459/35FD : 68 0A 36                              JZ	NEXT8              ;If character is a space, ignore it
 3460/3600 : 3C BD                                 CPI	275o               ;Else, test to see if character is "=" sign
 3461/3602 : 68 15 36                              JZ	NEXT9              ;If yes, have picked up variable name, jump ahead
 3462/3605 : 36 64                                 MVI	L, 144o               ;If not, set L to the start of the AUX SYMBOL BUFFER
 3463/3607 : 46 E7 21                              CALL	CONCT1             ;And store the character in the AUX SYMBOL BUFFER
 3464/360A : 36 83                      NEXT8:     MVI	L, 203o               ;Load L with address of the F/N pointer
 3465/360C : 46 1E 22                              CALL	LOOP               ;Increment the pointer and see if end of the line
 3466/360F : 48 F8 35                              JNZ	NEXT7              ;If not, continue fetching characters
 3467/3612 : 44 44 35                              JMP	FORNXT             ;If end of line before "=" sign then have error condx
 3468/3615 : 36 82                      NEXT9:     MVI	L, 202o               ;Load L with address of SCAN pointer
 3469/3617 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of SCAN pointer
 3470/3619 : C7                                    MOV	A,M                    ;Fetch pointer value to ACC (points to start of FOR
 3471/361A : 04 03                                 ADI	003                ;Directive) and add three to move pointer over FOR
 3472/361C : 36 BE                                 MVI	L, 276o               ;Directive. Change L to EVAL pointer storage location
 3473/361E : F8                                    MOV	M,A                    ;Set EVAL pointer to character after FOR in line
 3474/361F : 36 83                                 MVI	L, 203o               ;Load L with address of FIN pointer storage location
 3475/3621 : CF                                    MOV	B,M                    ;Fetch pointer to register B (points to "=" sign) and
 3476/3622 : 09                                    DCR	B                    ;Decrement the pointer (to character before "=" sign)
 3477/3623 : 36 BF                                 MVI	L, 277o               ;Load L with address of EVAL FINISH pointer
 3478/3625 : F9                                    MOV	M,B                    ;Set EVAL FINISH pointer
 3479/3626 : 46 AF 22                              CALL	EVAL               ;Call subroutine to obtain current value of the variable
 3480/3629 : 36 C4                                 MVI	L, 304o               ;Load L with address of start of F/N STEP registers
 3481/362B : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of F/N STEP registers
 3482/362D : 46 C5 31                              CALL	FACXOP             ;Call subroutine to set up FP registers for addition
 3483/3630 : 46 8B 2F                              CALL	FPADD              ;Add FIN STEP size to current VARIABLE value
 3484/3633 : 36 CC                                 MVI	L, 314o               ;Load L with address of FIN TEMP storage registers
 3485/3635 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;**Set H to page of FIN TEMP storage registers
 3486/3637 : 46 B3 31                              CALL	FSTORE             ;Save the result of the addition in F/N TEMP registers
 3487/363A : 36 C8                                 MVI	L, 310o               ;Load L with starting address of F/N LIMIT registers
 3488/363C : 46 C5 31                              CALL	FACXOP             ;Call subroutine to set up FP registers for subtraction
 3489/363F : 46 20 30                              CALL	FPSUB              ;Subtract F/N LIMIT value from VARIABLE value
 3490/3642 : 36 C6                                 MVI	L, 306o               ;Set pointer to MSW of F/N STEP registers
 3491/3644 : C7                                    MOV	A,M                    ;Fetch this value into the ACC
 3492/3645 : A0                                    ANA	A                    ;Test to see if STEP value might be zero
 3493/3646 : 36 56                                 MVI	L, 126o               ;Load L with address of MSW of FPACC
 3494/3648 : C7                                    MOV	A,M                    ;Fetch this value into the ACC
 3495/3649 : 68 44 35                              JZ	FORNXT             ;If STEP size was zero, then endless loop, an error condx
 3496/364C : 70 6B 36                              JM	NEXT11             ;If STEP size less than zero make alternate test on limit
 3497/364F : A0                                    ANA	A                    ;Test the contents of the MSW of the FPACC
 3498/3650 : 70 72 36                              JM	NEXT12             ;Continue FORINEXT loop if current variable value is
 3499/3653 : 68 72 36                              JZ	NEXT12             ;Less than or equal to the F/N LIMIT value
 3500/3656 : 36 F3                      NEXT10:    MVI	L, 363o               ;If out of LIMIT range, load L with address of the AUX
 3501/3658 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** PGM LINE pointer. (Contains pointer to the NEXT
 3502/365A : E7                                    MOV	E,M                    ;Statement line that initiated this routine.) Fetch the
 3503/365B : 31                                    DCR	L                    ;Low part of the address into E, decrement the memory
 3504/365C : DF                                    MOV	D,M                    ;And get the page part of the address into CPU register
 3505/365D : 31                                    DCR	L                    ;Decrement memory pointer to the low portion of the
 3506/365E : FC                                    MOV	M,E                    ;User pgm buffer line pointer (regular pointer) and set it
 3507/365F : 31                                    DCR	L                    ;With the value from the AUX line pntr, decrement the
 3508/3660 : FB                                    MOV	M,D                    ;Pointer and do the same for the page portion
 3509/3661 : 36 85                                 MVI	L, 205o               ;Set L to address of FOR/NEXT STACK pointer
 3510/3663 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to page of FOR/NEXT STACK pointer
 3511/3665 : CF                                    MOV	B,M                    ;Fetch and decrement the
 3512/3666 : 09                                    DCR	B                    ;FOR/NEXT STACK pointer value
 3513/3667 : F9                                    MOV	M,B                    ;To perform effective popping operation
 3514/3668 : 44 58 2A                              JMP	NXTLIN             ;Statement line after NEXT statement is done next
 3515/366B : A0                         NEXT11:    ANA	A                    ;When F/N STEP is negative, reverse test so that if the
 3516/366C : 50 72 36                              JP	NEXT12             ;Variable value is greater than or equal to the F/N LIMIT
 3517/366F : 44 56 36                              JMP	NEXT10             ;The FOR/NEXT loop continues. Else it is finished.
 3518/3672 : 36 CC                      NEXT12:    MVI	L, 314o               ;Load L with address of FIN TEMP storage registers
 3519/3674 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to FIN TEMP storage registers page
 3520/3676 : 46 AA 31                              CALL	FLOAD              ;Transfer the updated variable value to the FPACC
 3521/3679 : 46 C5 27                              CALL	RESTSY             ;Restore the variable name and value
 3522/367C : 46 48 27                              CALL	STOSYM             ;In the VARIABLES table. Exit routine so that
 3523/367F : 44 58 2A                              JMP	NXTLIN             ;Statement line after FOR statement is done next
 3524/3682 :                            
 3525/3682 :                            ;;; The label BACKSP SHOULD BE AT 31 217 198fh
 3526/3682 :                            
 3527/3682 : 06 8D                      BACKSP:    MVI	A, 215o               ;Load ASCII code for carriage-return into the ACC
 3528/3684 : 46 9D 22                              CALL	ECHO               ;Display the carriage-return
 3529/3687 : 46 9D 22                              CALL	ECHO               ;Repeat to provide extra time if TTY
 3530/368A : 36 23                                 MVI	L, 043o               ;Load L with address of COLUMN COUNTER
 3531/368C : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of COLUMN COUNTER
 3532/368E : 3E 01                                 MVI	M, 001                ;Set COLUMN COUNTER to first column
 3533/3690 : 36 54                                 MVI	L, 124o               ;Set L to address containing desired TAB position
 3534/3692 : C7                                    MOV	A,M                    ;Fetch the desired TAB position value
 3535/3693 : A0                                    ANA	A                    ;Test to see if it is
 3536/3694 : 33                                    RM                    ;Negative or zero
 3537/3695 : 2B                                    RZ                    ;In which case return to caller
 3538/3696 : 44 2D 27                              JMP	TAB1               ;Else, proceed to perform the TAB operation.
 3539/3699 :                            
 3540/3699 :                            	
 3541/3699 :                            ;;; The label FOR5 SHOULD START AT 31 246 19a6h
 3542/3699 :                            	
 3543/3699 : 36 85                      FOR5:      MVI	L, 205o               ;Load L with address of the FOR/NEXT STACK pointer
 3544/369B : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Load H with page of the FOR/NEXT STACK pntr
 3545/369D : C7                                    MOV	A,M                    ;Fetch the stack pointer to the ACC.
 3546/369E : 02                                    RLC                    ;Rotate it left to multiply by two, then rotate it again to
 3547/369F : 02                                    RLC                    ;Multiply by four. Add this value to the base address
 3548/36A0 : 04 5E                                 ADI	136o               ;Plus two of the base address to point to the next part of
 3549/36A2 : E0                                    MOV	E,A                    ;The FOR/NEXT STACK. Place this value in register E.
 3550/36A3 : DD                                    MOV	D,H                    ;Set D to the FORINEXT STACK area page.
 3551/36A4 : 36 65                                 MVI	L, 145o               ;Load L with the address of the first character in the
 3552/36A6 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** AUX SYMBOL BUFFER and set up H to this page.
 3553/36A8 : 0E 02                                 MVI	B, 002                ;Set up register B as a number of bytes to move counter.
 3554/36AA : 46 11 30                              CALL	MOVEIT             ;Move the variable name into the FOR/NEXT STACK.
 3555/36AD : 46 48 27                              CALL	STOSYM             ;Store initial variable value in the VARIABLES TABLE.
 3556/36B0 : 44 58 2A                              JMP	NXTLIN             ;Continue with next line in user program buffer.
 3557/36B3 :                            
 3558/36B3 :                            
 3559/36B3 :                            ;;; The label PARSEP SHOULD START AT 31 300 19c0h
 3560/36B3 : 36 7E                      PARSEP:    MVI	L, 176o               ;Load L with PARSER TOKEN storage location. Set
 3561/36B5 : 3E 00                                 MVI	M, 000                ;The value indicating end of expression. Call the
 3562/36B7 : 46 EF 23                              CALL	PARSER             ;PARSER subroutine for final time for the expression.
 3563/36BA : 36 97                                 MVI	L, 227o               ;Change L to point to the ARITH STACK pointer.
 3564/36BC : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to the page of the ARITH STACK pointer.
 3565/36BE : C7                                    MOV	A,M                    ;Fetch the ARITH STACK pointer value.
 3566/36BF : 3C 98                                 CPI	230o               ;Should indicate only one value (answer) in stack.
 3567/36C1 : 2B                                    RZ                    ;Exit with answer in FPACC if ARITH STACK is O.K.
 3568/36C2 : 44 85 28                              JMP	SYNERR             ;Else have a syntax error!
 3569/36C5 :                            
 3570/36C5 :                            ;;; THERE IS SOME BLANK ADDRESSES HERE 317-NEXT PAGE
 3571/36C5 :                            
 3572/36C5 :                            ;          ORG	1a00h	; 032#000
 3573/36C5 : 36 0C                      SQRX:      MVI	L, 014o               ;Load L with address of FP TEMP registers
 3574/36C7 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of FP TEMP. Move contents of FPACC
 3575/36C9 : 46 B3 31                              CALL	FSTORE             ;[Argument of SQR(X)] into FP TEMP for storage.
 3576/36CC : 36 56                                 MVI	L, 126o               ;Load L with MSW of FPACC
 3577/36CE : C7                                    MOV	A,M                    ;Fetch the MSW into the accumulator
 3578/36CF : A0                                    ANA	A                    ;Check the sign of the number in the FPACC
 3579/36D0 : 70 5A 37                              JM	SQRERR             ;If number negative, cannot take square root
 3580/36D3 : 68 C2 25                              JZ	CFALSE             ;If number is zero, return with zero value in FPACC
 3581/36D6 : 36 0F                                 MVI	L, 017o               ;Load L with address of FP TEMP Exponent register
 3582/36D8 : C7                                    MOV	A,M                    ;Fetch the Exponent value into the ACC
 3583/36D9 : A0                                    ANA	A                    ;Check sign of the Fxponent
 3584/36DA : 70 E6 36                              JM	NEGEXP             ;If Exponent less than zero, process negative Exponent
 3585/36DD : 1A                                    RAR                    ;If Exponent positive, rotate right to divide by two
 3586/36DE : C8                                    MOV	B,A                    ;And save the result in CPU register B
 3587/36DF : 06 00                                 MVI	A, 000                ;Clear the accumulator without disturbing Carry bit
 3588/36E1 : 12                                    RAL                    ;Rotate Carry bit into the ACC to save remainder
 3589/36E2 : F8                                    MOV	M,A                    ;Store the remainder back in FP TEMP Exponent reg.
 3590/36E3 : 44 F7 36                              JMP	SQREXP             ;Jump to continue processing
 3591/36E6 : C8                         NEGEXP:    MOV	B,A                    ;For negative Exponent, form two Is complement by
 3592/36E7 : A8                                    XRA	A                    ;Placing the positive value in CPU register B, clearing
 3593/36E8 : 91                                    SUB	B                    ;The accumulator, and then subtracting B from the ACC
 3594/36E9 : A0                                    ANA	A                    ;Clear the Carry bit after the complementing operation
 3595/36EA : 1A                                    RAR                    ;Rotate the value right to divide by two
 3596/36EB : C8                                    MOV	B,A                    ;Save the result in CPU register B
 3597/36EC : 06 00                                 MVI	A, 000                ;Clear the accumulator without disturbing Carry bit
 3598/36EE : 88                                    ADC	A                    ;Add Carry bit to the accumulator as remainder
 3599/36EF : F8                                    MOV	M,A                    ;Store the remainder back in FP TEMP Exponent reg
 3600/36F0 : 68 F4 36                              JZ	NOREMD             ;If remainder was zero skip ahead. If not, increment the
 3601/36F3 : 08                                    INR	B                    ;Result of the divide by two ops to compen for negative
 3602/36F4 : A8                         NOREMD:    XRA	A                    ;Clear the accumulator
 3603/36F5 : 91                                    SUB	B                    ;Subtract the quotient of the divide by two op to
 3604/36F6 : C8                                    MOV	B,A                    ;Form two's complement and save the result in register B
 3605/36F7 : 36 0B                      SQREXP:    MVI	L, 013o               ;Load L with address of TEMP register
 3606/36F9 : F9                                    MOV	M,B                    ;Store Fxponent quotient from above ops in TEMP
 3607/36FA : 36 04                                 MVI	L, 004                ;Load L with address of FP registers containing +1.0
 3608/36FC : 26 1C                                 MVI	E, 034o               ;Load E with address of SQR APPROX working registers
 3609/36FE : DD                                    MOV	D,H                    ;Set D to same page as H
 3610/36FF : 0E 04                                 MVI	B, 004                ;Set up register B as a number of bytes to move counter
 3611/3701 : 46 11 30                              CALL	MOVEIT             ;Transfer value +1.0 into SQR APPROX registers
 3612/3704 : 46 C2 25                              CALL	CFALSE             ;Now clear the FPACC registers
 3613/3707 : 36 24                                 MVI	L, 044o               ;Load L with address of LAST SQR APPROX temp regs.
 3614/3709 : 46 B3 31                              CALL	FSTORE             ;Initialize the LAST SQR APPROX regs to value of zero
 3615/370C : 36 1C                      SQRLOP:    MVI	L, 034o               ;Load L with address of SQR APPROX working registers
 3616/370E : 46 AA 31                              CALL	FLOAD              ;Transfer SQR APPROX into the FPACC
 3617/3711 : 36 0C                                 MVI	L, 014o               ;Load L with address of SQR ARG storage registers
 3618/3713 : 46 BC 31                              CALL	OPLOAD             ;Transfer SQR ARG into the FPOP
 3619/3716 : 46 D8 30                              CALL	FPDIV              ;Divde SQR ARG by SQR APPROX (Fon-n X/A)
 3620/3719 : 36 1C                                 MVI	L, 034o               ;Load L with address of SQR APPROX registers
 3621/371B : 46 BC 31                              CALL	OPLOAD             ;Transfer SQR APPROX into the FPOP
 3622/371E : 46 8B 2F                              CALL	FPADD              ;Add to form value (X/A + A)
 3623/3721 : 36 57                                 MVI	L, 127o               ;Load L with address of FPACC Exponent register
 3624/3723 : CF                                    MOV	B,M                    ;Fetch Exponent value into CPU register B
 3625/3724 : 09                                    DCR	B                    ;Subtract one to effectively divide FPACC by two
 3626/3725 : F9                                    MOV	M,B                    ;Restore to memory. (Now have ((X/A + A) /2)
 3627/3726 : 36 1C                                 MVI	L, 034o               ;Load L with address of SQR APPROX registers
 3628/3728 : 46 B3 31                              CALL	FSTORE             ;Store contents of FPACC as new SQR APPROX
 3629/372B : 36 24                                 MVI	L, 044o               ;Load L with address of LAST SQR APPROX registers
 3630/372D : 46 BC 31                              CALL	OPLOAD             ;Transfer LAST SQR APPROX into the FPOP
 3631/3730 : 46 20 30                              CALL	FPSUB              ;Subtract (LAST SQR APPROX - SQR APPROX)
 3632/3733 : 36 57                                 MVI	L, 127o               ;Load L with address of FPACC Exponent
 3633/3735 : C7                                    MOV	A,M                    ;Fetch the Exponent into the accumulator
 3634/3736 : 3C F7                                 CPI	367o                ;See if difference less than 2 to the minus ninth
 3635/3738 :                            ;;; The below is changed for PATCH 2
 3636/3738 :                            ;;; following is the original code
 3637/3738 :                            ;;;           JTS SQRCNV             ;If so, approximation has converged
 3638/3738 :                            ;;; Now is the new line
 3639/3738 :                            ;	   JMP	PATCH2
 3640/3738 :                            ;;; following is PATCH 2
 3641/3738 :                            
 3642/3738 :                            ;	ORG	1af4h	; 032#364
 3643/3738 : 70 4E 37                   PATCH2	JM	SQRCNV
 3644/373B : 31                         	DCR	L
 3645/373C : C7                         	MOV	A,M
 3646/373D : A0                         	ANA	A
 3647/373E : 68 4E 37                   	JZ	SQRCNV
 3648/3741 :                            ;	JMP	SQR1
 3649/3741 :                            ;;; The above jump should start at 32 375 1afdh
 3650/3741 :                            ;;;;           DCR L
 3651/3741 :                            ;;;;           MOV A,M
 3652/3741 :                            ;;;;           ANA A
 3653/3741 :                            ;;;;           JZ SQRCNV             ;THIS IS PATCH #2
 3654/3741 : 36 1C                      SQR1:	   MVI	L, 034o               ;Else, load L with address of SQR APPROX
 3655/3743 : DD                                    MOV	D,H                    ;Set D to same page as H
 3656/3744 : 26 24                                 MVI	E, 044o               ;And E with address of LAST SQR APPROX
 3657/3746 : 0E 04                                 MVI	B, 004o               ;Set up register B as a number of bytes to move counter
 3658/3748 : 46 11 30                              CALL	MOVEIT             ;Transfer SQR APPROX into LAST SQR APPROX
 3659/374B : 44 0C 37                              JMP	SQRLOP             ;Continue ops until approximation converges
 3660/374E : 36 0B                      SQRCNV:    MVI	L, 013o               ;Load L with address of TEMP register. Fetch the
 3661/3750 : C7                                    MOV	A,M                    ;Exponenent quotient store there into accumulator.
 3662/3751 : 36 1F                                 MVI	L, 037o               ;Change L to point to SQR APPROX exponent.
 3663/3753 : 87                                    ADD	M                    ;Add SQR APPROX exponent to quotient value.
 3664/3754 : F8                                    MOV	M,A                    ;Store sum back in SQR APPROX Exponent register.
 3665/3755 : 36 1C                                 MVI	L, 034o               ;Load L with address of SQR APPROX. Transfer the
 3666/3757 : 44 AA 31                              JMP	FLOAD              ;SQR APPROX into FPACC as answer and exit.
 3667/375A : 06 D3                      SQRERR:    MVI	A, 323o               ;Load ASCII code for letter S into the accumulator.
 3668/375C : 16 D1                                 MVI	C, 321o               ;Load ASCII code for letter Q into CPU register C.
 3669/375E : 44 B1 21                              JMP	ERROR              ;Display the SQuare root (SQ) error message.
 3670/3761 :                            ;;; above instruction starts at 223
 3671/3761 :                            ;;; some blank addresses available here.
 3672/3761 :                            
 3673/3761 :                            ;          ORG	1aa0h              ; 032#240
 3674/3761 : 36 34                      RNDX:      MVI	L, 064o               ;Load L with address of SEED storage registers
 3675/3763 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page for floating point working registers
 3676/3765 : 46 AA 31                              CALL	FLOAD              ;Transfer SEED into the FPACC
 3677/3768 : 36 28                                 MVI	L, 050o               ;Load L with address of random constant A
 3678/376A : 46 BC 31                              CALL	OPLOAD             ;Transfer random constant A into the FPOP
 3679/376D : 46 2C 30                              CALL	FPMULT             ;Multiply to form (SEED * A)
 3680/3770 : 36 30                                 MVI	L, 060o               ;Load L with address of random constant C
 3681/3772 : 46 BC 31                              CALL	OPLOAD             ;Transfer random constant C into the FPOP
 3682/3775 : 46 8B 2F                              CALL	FPADD              ;Add to fom (SEED * A) + C
 3683/3778 : 36 34                                 MVI	L, 064o               ;Load L with address of SEED storage registers
 3684/377A : 46 B3 31                              CALL	FSTORE             ;Store I (SEED * A) + C] in former SEED registers
 3685/377D : 36 57                                 MVI	L, 127o               ;Load L with address of FPACC Exponent register
 3686/377F : C7                                    MOV	A,M                    ;Fetch Exponent value into the accumulator
 3687/3780 : 14 10                                 SUI	020o               ;Subtract 16 (decimal) to effectively divide by 65,536
 3688/3782 : F8                                    MOV	M,A                    ;Now FPACC = [((SEED * A) + C)/65,536]
 3689/3783 : 46 02 2F                              CALL	FPFIX              ;Convert floating to fixed point to obtain integer part
 3690/3786 : 36 53                                 MVI	L, 123o               ;Load L with address of FPACC Extension register
 3691/3788 : 3E 00                                 MVI	M, 000                ;Clear the FPACC Extension register
 3692/378A : 36 57                                 MVI	L, 127o               ;Load L with address of FPACC Exponent
 3693/378C : 3E 00                                 MVI	M, 000                ;Clear the FPACC Exponent register
 3694/378E : 46 36 2F                              CALL	FPFLT              ;Fetch INT(((SEED * A) + C)/65,536) into the FPACC
 3695/3791 : 36 57                                 MVI	L, 127o               ;Load L with address of FPACC Exponent
 3696/3793 : C7                                    MOV	A,M                    ;Fetch FPACC Exponent into the accumulator
 3697/3794 : 04 10                                 ADI	020o               ;Add 16 (decimal) to effectively multiply by 65,536
 3698/3796 : F8                                    MOV	M,A                    ;(65,536 * INT[ ((SEED * A) + C)/65,5361) in FPACC
 3699/3797 : 36 34                                 MVI	L, 064o               ;Load L with address of [(SEED * A) + C]
 3700/3799 : 46 BC 31                              CALL	OPLOAD             ;Transfer it into FPOP. Subtract FPACC to form
 3701/379C : 46 20 30                              CALL	FPSUB              ;[(SEED * A) + C] MOD 65,536
 3702/379F : 36 34                                 MVI	L, 064o               ;Load L with address of former SEED registers
 3703/37A1 : 46 B3 31                              CALL	FSTORE             ;Store SEED MOD 65,536 in place of [(SEED * A) + Cl
 3704/37A4 : 36 57                                 MVI	L, 127o               ;Load L with address of FPACC Exponent
 3705/37A6 : C7                                    MOV	A,M                    ;Fetch FPACC Exponent into the ACC and subtract
 3706/37A7 : 14 10                                 SUI	020o               ;16 (decimal) to form (SEED MOD 65,536)/65,536
 3707/37A9 : F8                                    MOV	M,A                    ;So that random number in FPACC is between
 3708/37AA : 07                                    RET                    ;0.0 and +1.0 and exit to calling routine
 3709/37AB :                            ;;; THE ABOVE RETURN SHOULD BE 32 351 1ae9h
 3710/37AB :                            
 3711/37AB :                            ;;; NOTE OPEN ADDRESSES TO END OF PAGE 32
 3712/37AB :                            
 3713/37AB :                            
 3714/37AB :                            	;; PAGES 33 TO REMAINDER OF MEMORY
 3715/37AB :                            	;; OR START OF OPTIONAL ARRAY HANDLING
 3716/37AB :                            	;; ROUTINES USED AS USER PROGRAM BUFFER
 3717/37AB :                            
 3718/37AB :                            	;; OPTIONAL ARRAY ROUTINES ASSEMBLED FOR OPERATION
 3719/37AB :                            	;; IN THE UPPER 3 PAGES OF A 12K SYSTEM ARE LISTED HERE.
 3720/37AB :                            
 3721/37AB :                            ;          ORG	2d00h              ; 055#000
 3722/37AB :                            
 3723/37AB : 36 56                      PRIGH1:    MVI	L, 126o               ;Load L with address of the MSW in the FPACC
 3724/37AD : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of FPACC
 3725/37AF : C7                                    MOV	A,M                    ;Fetch MSW of FPACC into the ACC.
 3726/37B0 : A0                                    ANA	A                    ;Test to see if value in FPACC is positive.
 3727/37B1 : 70 09 38                              JM	OUTRNG             ;If not, go display error message.
 3728/37B4 : 46 02 2F                              CALL	FPFIX              ;If O.K. then convert floating point to fixed point
 3729/37B7 : 36 54                                 MVI	L, 124o               ;Load L with address of LSAL of converted value
 3730/37B9 : C7                                    MOV	A,M                    ;Fetch the LSW of the value into the ACC
 3731/37BA : 14 01                                 SUI	001                ;Subtract one from the value to establish proper
 3732/37BC : 02                                    RLC                    ;Origin for future ops. Now rotate the value twice
 3733/37BD : 02                                    RLC                    ;To effectively multiply by four. Save the
 3734/37BE : D0                                    MOV	C,A                    ;Calculated result in CPU register C
 3735/37BF : 36 83                                 MVI	L, 203o               ;Load L with address of F/A STACK TEMP
 3736/37C1 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Load H with page of F/A STACK TEMP
 3737/37C3 : C7                                    MOV	A,M                    ;Fetch the value into the accumulator
 3738/37C4 : 2C FF                                 XRI	377o               ;Complement the value
 3739/37C6 : 02                                    RLC                    ;Rotate the value twice to multiply by four (the number
 3740/37C7 : 02                                    RLC                    ;Of bytes per entry in the ARRAY VARIABLES table).
 3741/37C8 : 04 50                                 ADI	120o               ;Add the starting address of the ARRAY VARIABLES
 3742/37CA : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** TABLE to forin pointer. Set page address in H.
 3743/37CC : F0                                    MOV	L,A                    ;Point to the name in the ARRAY VARIABLES
 3744/37CD : 30                                    INR	L                    ;Increment the pointer value twice to move over the
 3745/37CE : 30                                    INR	L                    ;Name in the table and point to starting address for the
 3746/37CF : C7                                    MOV	A,M                    ;Array values in the ARRAY VALUES table. Fetch this
 3747/37D0 : 82                                    ADD	C                    ;Address to the ACC. Now add in the figure calculated
 3748/37D1 : F0                                    MOV	L,A                    ;To reach desired subscripted data storage location. Set
 3749/37D2 : 2E 05                                 MVI	H,PG57 ;\HB\OLDPG57   ;tt The pointer to that location. Load the floating point
 3750/37D4 : 44 AA 31                              JMP	FLOAD              ;Value stored there into the FPACC and exit to caller.
 3751/37D7 :                            
 3752/37D7 :                            
 3753/37D7 :                            ;;; The label FUNAR2 SHOULD START AT 55-054 2d2ch
 3754/37D7 : 36 82                      FUNAR2:    MVI	L, 202o               ;Load L with address of TEMP COUNTER
 3755/37D9 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Load H with page of counter
 3756/37DB : CF                                    MOV	B,M                    ;Fetch the counter value
 3757/37DC : 08                                    INR	B                    ;Increment the value
 3758/37DD : F9                                    MOV	M,B                    ;Restore the value to memory
 3759/37DE : 16 02                                 MVI	C, 002                ;Initialize register C to a value of two for future ops
 3760/37E0 : 36 4C                                 MVI	L, 114o               ;Load L with address of start of ARRAY VARIABLES
 3761/37E2 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** TABLE (less four). Set H to page of the table.
 3762/37E4 : 46 B3 26                              CALL	TABADR             ;Calculate address of start of next narne in table.
 3763/37E7 : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Load D with page of the SYMBOL BUFFER
 3764/37E9 : 26 50                                 MVI	E, 120o               ;Set E to starting address of the SYMBOL BUFFER
 3765/37EB : 46 F5 21                              CALL	STRCP              ;Compare name in ARRAY VARIABLES table to the
 3766/37EE : 68 FF 37                              JZ	FUNAR3             ;Contents of the SYMBOL BUFFER. If match, go set up
 3767/37F1 : 36 82                                 MVI	L, 202o               ;Array token value. Else, reset L to address of TEMP
 3768/37F3 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** COUNTER. Set H to page of TEMP COUNTER.
 3769/37F5 : C7                                    MOV	A,M                    ;Fetch the counter value into the accumulator.
 3770/37F6 : 36 3D                                 MVI	L, 075o               ;Change L to number of arrays storage location.
 3771/37F8 : BF                                    CMP	M                    ;Compare number of entries checked against number
 3772/37F9 : 48 D7 37                              JNZ	FUNAR2             ;Possible. Keep searching table if not finished.
 3773/37FC : 44 95 26                              JMP	FAERR              ;If finished and no match than have F/A error condx.
 3774/37FF : 36 82                      FUNAR3:    MVI	L, 202o               ;Load L with address of TEMP COUNTER
 3775/3801 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Load H with page of counter.
 3776/3803 : A8                                    XRA	A                    ;Clear the accumulator. Subtract the value in the TEMP
 3777/3804 : 9F                                    SBB	M                    ;COUNTER from zero to obtain two's complement.
 3778/3805 : F8                                    MOV	M,A                    ;Place this back in counter location as ARRAY TOKEN
 3779/3806 : 44 A2 26                              JMP	FUNAR4             ;VALUE (negative). Go place the value on F/A STACK.
 3780/3809 :                            
 3781/3809 :                            
 3782/3809 :                            ;;; The label OUTRNG STARTS AT 55 136 2d5eh
 3783/3809 : 06 CF                      OUTRNG:    MVI	A, 317o               ;Load the ASCII code for letter 0 into the accumulator
 3784/380B : 16 D2                                 MVI	C, 322o               ;Load the ASCII code for letter R into register C
 3785/380D : 44 B1 21                              JMP	ERROR              ;Go display Out of Range (OR) error message.
 3786/3810 :                            
 3787/3810 :                            
 3788/3810 :                            
 3789/3810 :                            
 3790/3810 : 46 C5 27                   ARRAY:     CALL	RESTSY             ;Transfer contents of AUX SYMBOL BUFFER into the
 3791/3813 : 44 1B 38                              JMP	ARRAY2             ;SYMBOL BUFFER. (Entry when have actual LET)
 3792/3816 : 36 82                      ARRAY1:    MVI	L, 202o               ;Load L with address of SCAN pointer
 3793/3818 : 44 1D 38                              JMP	ARRAY3             ;Proceed to process. (Entry point for IMPLIED LET)
 3794/381B : 36 83                      ARRAY2:    MVI	L, 203o               ;Load L with address of LET pointer
 3795/381D : 2E 03                      ARRAY3:    MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to pointer page
 3796/381F : CF                                    MOV	B,M                    ;Fetch pointer to location where "(" found in statement
 3797/3820 : 08                                    INR	B                    ;Line. Increment it to point to next character in the line.
 3798/3821 : 36 BE                                 MVI	L, 276o               ;Load L with address of EVAL pointer and load it with
 3799/3823 : F9                                    MOV	M,B                    ;The starting address for the EVAL routine
 3800/3824 : 36 86                                 MVI	L, 206o               ;Change L to address of ARRAY SETUP pointer
 3801/3826 : F9                                    MOV	M,B                    ;And also store address in that location
 3802/3827 : 36 86                      ARRAY4:    MVI	L, 206o               ;Load L with address of ARRAY SETUP pointer
 3803/3829 : 46 BB 21                              CALL	GETCHR             ;Fetch character pointed to by ARRAY SETUP pntr
 3804/382C : 3C A9                                 CPI	251o               ;See if character is ")" ? If so, then have located
 3805/382E : 68 40 38                              JZ	ARRAY5             ;End of the subscript. If not, reset
 3806/3831 : 36 86                                 MVI	L, 206o               ;to the ARRAY SETUP pointer. Increment the
 3807/3833 : 46 1E 22                              CALL	LOOP               ;Pointer and test for the end of the statement line.
 3808/3836 : 48 27 38                              JNZ	ARRAY4             ;If not end of line, continue looking for right paren.
 3809/3839 : 06 C1                                 MVI	A, 301o               ;If reach end of line before right parenthesis than load
 3810/383B : 16 C6                                 MVI	C, 306o               ;ASCII code for letters A and F and display message
 3811/383D : 44 B1 21                              JMP	ERROR              ;Indicating Array Forrnat (AF) error condition
 3812/3840 : 36 86                      ARRAY5:    MVI	L, 206o               ;Load L with address of ARRAY SETUP pointer
 3813/3842 : CF                                    MOV	B,M                    ;Fetch pointer (pointing to ")"sign) into register B
 3814/3843 : 09                                    DCR	B                    ;Decrement it to move back to end of subscript number
 3815/3844 : 36 BF                                 MVI	L, 277o               ;Load L with address of EVAL FINISH pointer location
 3816/3846 : F9                                    MOV	M,B                    ;Place the pointer value in the EVAL FINISH pointer
 3817/3847 : 36 87                                 MVI	L, 207o               ;Load L with address of LOOP COUNTER
 3818/3849 : 3E 00                                 MVI	M, 000                ;Initialize LOOP COUNTER to value of zero
 3819/384B : 36 87                      ARRAY6:    MVI	L, 207o               ;Load L with address of LOOP COUNTER
 3820/384D : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of LOOP COUNTER
 3821/384F : CF                                    MOV	B,M                    ;Fetch the counter value
 3822/3850 : 08                                    INR	B                    ;Increment it
 3823/3851 : F9                                    MOV	M,B                    ;Restore the counter value to memory
 3824/3852 : 16 02                                 MVI	C, 002                ;Set up counter in register C for future ops
 3825/3854 : 36 4C                                 MVI	L, 114o               ;Load L with address of start of ARRAY VARIABLES
 3826/3856 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Table less four). Set H to page of the table.
 3827/3858 : 46 B3 26                              CALL	TABADR             ;Calculate the address of next entry in the table
 3828/385B : 26 50                                 MVI	E, 120o               ;Load register E with starting address of SYMBOL BUFF
 3829/385D : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Set D to page of SYMBOL BUFFER
 3830/385F : 46 F5 21                              CALL	STRCP              ;Compare entry in table against contents of SYMBOL BF
 3831/3862 : 68 75 38                              JZ	ARRAY7             ;If match, have found array naine in the table.
 3832/3865 : 36 87                                 MVI	L, 207o               ;Else, set L to address of the LOOP COUNTER
 3833/3867 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of the LOOP COUNTER
 3834/3869 : C7                                    MOV	A,M                    ;Fetch the counter value to the ACC
 3835/386A : 36 3D                                 MVI	L, 075o               ;Change L to the counter containing number of arrays
 3836/386C : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to the proper page
 3837/386E : BF                                    CMP	M                    ;Compare number of arrays to count in LOOP CNTR
 3838/386F : 48 4B 38                              JNZ	ARRAY6             ;If more entries in the table, continue looking for match
 3839/3872 : 44 95 26                              JMP	FAERR              ;If no matching name in table then have an error condx.
 3840/3875 : 46 AF 22                   ARRAY7:    CALL	EVAL               ;Call subroutine to evaluate subscript expression
 3841/3878 : 46 02 2F                              CALL	FPFIX              ;Convert the subscript value obtained to fixed forrnat
 3842/387B : 36 87                                 MVI	L, 207o               ;Load L with address of LOOP COUNTER
 3843/387D : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of the LOOP COUNTER
 3844/387F : CF                                    MOV	B,M                    ;Fetch the value in the LOOP COUNTER into the ACC
 3845/3880 : 16 02                                 MVI	C, 002                ;Set up counter in register C future ops
 3846/3882 : 36 4C                                 MVI	L, 114o               ;Load L with address of ARRAY VARIABLES
 3847/3884 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Table less four). Set H to page of the table.
 3848/3886 : 46 B3 26                              CALL	TABADR             ;Calculate the address of entry in the table
 3849/3889 : 30                                    INR	L                    ;Advance the ARRAY VARIABLES table pointer twice
 3850/388A : 30                                    INR	L                    ;To advance pointer over array name.
 3851/388B : D7                                    MOV	C,M                    ;Fetch array base address in ARRAY VALUES table
 3852/388C : 36 54                                 MVI	L, 124o               ;Load L with address of subscript value
 3853/388E : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of subscript value
 3854/3890 : C7                                    MOV	A,M                    ;Fetch the subscript value into the accumulator
 3855/3891 : 14 01                                 SUI	001                ;Subtract one from subscript value to allow for zero
 3856/3893 : 02                                    RLC                    ;Origin. Now multiply by four
 3857/3894 : 02                                    RLC                    ;Using rotates (number of bytes required for each entry
 3858/3895 : 82                                    ADD	C                    ;In the ARRAY VALUES table). Add in base address to
 3859/3896 : 36 84                                 MVI	L, 204o               ;The calculated value to form final address in the
 3860/3898 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** ARRAY VALUES table. Now set H & L to TEMP
 3861/389A : F8                                    MOV	M,A                    ;ARRAY ELEMENT storage location & store the addr.
 3862/389B : 36 81                                 MVI	L, 201o               ;Change L to point to ARRAY FLAG
 3863/389D : 3E FF                                 MVI	M, 377o               ;Set the ARRAY FLAG for future use
 3864/389F : 07                                    RET                    ;Exit to calling routine
 3865/38A0 :                            
 3866/38A0 :                            
 3867/38A0 :                            ;;; The label DIM SHOULD START AT 55 365 2df5h
 3868/38A0 : 46 C8 21                   DIM:       CALL	CLESYM             ;Initialize the SYMBOL BUFFER to cleared condition
 3869/38A3 : 36 82                                 MVI	L, 202o               ;Load L with address of SCAN pointer
 3870/38A5 : CF                                    MOV	B,M                    ;Fetch SCAN pointer value into register B
 3871/38A6 : 08                                    INR	B                    ;Add one to the SCAN pointer value
 3872/38A7 : 36 83                                 MVI	L, 203o               ;Change L to DIM pointer (formerly TOKEN) storage
 3873/38A9 : F9                                    MOV	M,B                    ;Store the updated SCAN pointer as the DIM pointer
 3874/38AA : 36 83                      DIM1:      MVI	L, 203o               ;Load L with the address of DIM pointer storage location
 3875/38AC : 46 BB 21                              CALL	GETCHR             ;Fetch a character from the line input buffer
 3876/38AF : 68 BA 38                              JZ	DIM2               ;If character fetched is a space, ignore it
 3877/38B2 : 3C A8                                 CPI	250o               ;Else see if character is "(" left parenthesis
 3878/38B4 : 68 C5 38                              JZ	DIM3               ;If so, should have ARRAY VARIABLE naine in buffer
 3879/38B7 : 46 E3 21                              CALL	CONCTS             ;If not, append the character to the SYMBOL BUFFER
 3880/38BA : 36 83                      DIM2:      MVI	L, 203o               ;Load L with the address of DIM pointer stomge location
 3881/38BC : 46 1E 22                              CALL	LOOP               ;Increment the pointer and see if end of line
 3882/38BF : 48 AA 38                              JNZ	DIM1               ;If not end of line, fetch next character
 3883/38C2 : 44 8A 39                              JMP	DIMERR             ;Else have a DIMension error condition
 3884/38C5 : 36 86                      DIM3:      MVI	L, 206o               ;Load L with address of ARRAY pointer storage loc
 3885/38C7 : 3E 00                                 MVI	M, 000                ;Initialize ARRAY pointer to starting value of zero
 3886/38C9 : 36 86                      DIM4:      MVI	L, 206o               ;Load L with address of ARRAY pointer storage loc
 3887/38CB : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of ARRAY pointer storage location
 3888/38CD : C7                                    MOV	A,M                    ;Fetch value in ARRAY pointer to ACC (effectively
 3889/38CE : 02                                    RLC                    ;Represents number of arrays defined in pgm). Rotate
 3890/38CF : 02                                    RLC                    ;Left twice to multiply by four (niunber of bytes per
 3891/38D0 : 04 4C                                 ADI	114o               ;entry in ARRAY VARIABLES table). Add to base
 3892/38D2 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Address to form pointer to ARRAY VARIA.BLES
 3893/38D4 : F0                                    MOV	L,A                    ;Table and set up H & L as the memory pointer.
 3894/38D5 : 26 50                                 MVI	E, 120o               ;Load E with starting address of the SYMBOL BUFFER
 3895/38D7 : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Load D with the page address of the SYMBOL BUFF
 3896/38D9 : 46 F5 21                              CALL	STRCP              ;Compare contents of SYMBOL BF to entry in ARRAY
 3897/38DC : 68 6C 39                              JZ	DIM9               ;VARIABLES table. If same, have duplicate array name.
 3898/38DF : 36 86                                 MVI	L, 206o               ;Else, load L with address of ARRAY pointer storage
 3899/38E1 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of ARRAY pointer storage
 3900/38E3 : CF                                    MOV	B,M                    ;Fetch the ARRAY pointer value to register B
 3901/38E4 : 08                                    INR	B                    ;Increment the value
 3902/38E5 : F9                                    MOV	M,B                    ;Restore it to ARRAY pointer storage location
 3903/38E6 : 36 3D                                 MVI	L, 075o               ;Change L to number of arrays storage location
 3904/38E8 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to page of the number of arrays stomge loc
 3905/38EA : C7                                    MOV	A,M                    ;Fetch the number of arrays value to the ACC
 3906/38EB : 09                                    DCR	B                    ;Restore B to previous count
 3907/38EC : B9                                    CMP	B                    ;Compare number of arrays tested against nr defined
 3908/38ED : 48 C9 38                              JNZ	DIM4               ;If not equal, continue searching ARRAY VARIABLES
 3909/38F0 : 36 3D                                 MVI	L, 075o               ;Table. When table searched with no match, then must
 3910/38F2 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Append naine to table. First set pointer to number
 3911/38F4 : CF                                    MOV	B,M                    ;Of arrays storage location. Fetch that value and
 3912/38F5 : 08                                    INR	B                    ;Add one to account for new name being added.
 3913/38F6 : F9                                    MOV	M,B                    ;Restore the updated value back to memory.
 3914/38F7 : 36 3E                                 MVI	L, 076o               ;Change pointer to ARRAY TEMP pointer storage
 3915/38F9 : F9                                    MOV	M,B                    ;Store pointer to current array in ARRAY TEMP too.
 3916/38FA : 36 86                                 MVI	L, 206o               ;Load L with address of ARRAY pointer stomge loc.
 3917/38FC : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of ARRAY pointer storage location
 3918/38FE : F9                                    MOV	M,B                    ;And update it also for new array being added.
 3919/38FF : C7                                    MOV	A,M                    ;Fetch the current ARRAY pointer value to the ACC
 3920/3900 : 02                                    RLC                    ;Multiply it times four by performing two rotate left
 3921/3901 : 02                                    RLC                    ;Operations and add it to base value to form address in
 3922/3902 : 04 4C                                 ADI	114o               ;The ARRAY VARIABLES table. Place the low part
 3923/3904 : E0                                    MOV	E,A                    ;Of this calculated address value into register E.
 3924/3905 : 1E 04                                 MVI	D,PG27 ;\HB\OLDPG27   ;** Set register D to the page of the table.
 3925/3907 : 36 50                                 MVI	L, 120o               ;Load L with the start of the SYMBOL BUFFER
 3926/3909 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with the page of the SYMBOL BUFFER
 3927/390B : 46 2A 29                              CALL	MOVEC              ;Move the array name from the SYMBOL BUFFER to
 3928/390E : 46 C8 21                              CALL	CLESYM             ;The ARRAY VARIABLES table. Then clear the
 3929/3911 : 36 83                                 MVI	L, 203o               ;SYMBOL BUFFER. Reset L to the DIM pointer storage
 3930/3913 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Location. Set H to the DIM pointer page.
 3931/3915 : CF                                    MOV	B,M                    ;Fetch the pointer value (points to "(" part of DIM
 3932/3916 : 08                                    INR	B                    ;Statement). Increment the pointer to next character in
 3933/3917 : 36 84                                 MVI	L, 204o               ;The line input buffer. Cbange L to DIMEN pointer.
 3934/3919 : F9                                    MOV	M,B                    ;Store the updated DIM pointer in DIMEN storage loc.
 3935/391A : 36 84                      DIM5:      MVI	L, 204o               ;Set L to DIMEN pointer storage location
 3936/391C : 46 BB 21                              CALL	GETCHR             ;Fetch character in line input buffer
 3937/391F : 68 34 39                              JZ	DIM6               ;Ignore character for space
 3938/3922 : 3C A9                                 CPI	251o               ;If not space, see if character is right parenthesis
 3939/3924 : 68 3F 39                              JZ	DIM7               ;If yes, process DIMension size (array length)
 3940/3927 : 3C B0                                 CPI	260o               ;If not, see if character is a valid decimal number
 3941/3929 : 70 8A 39                              JM	DIMERR             ;If not valid number, have DIMension error condition
 3942/392C : 3C BA                                 CPI	272o               ;Continue testing for valid decitnal number
 3943/392E : 50 8A 39                              JP	DIMERR             ;If not valid number, then DIMension error condition
 3944/3931 : 46 E3 21                              CALL	CONCTS             ;If valid decirnal number, append digit to SYMBOL BF
 3945/3934 : 36 84                      DIM6:      MVI	L, 204o               ;Set L to DIMEN pointer storage location
 3946/3936 : 46 1E 22                              CALL	LOOP               ;Advance the pointer value and check for end of the line
 3947/3939 : 48 1A 39                              JNZ	DIM5               ;If not end of line, continue fetching DIMension size
 3948/393C : 44 8A 39                              JMP	DIMERR             ;If end of line before right parenthesis, have error condx.
 3949/393F : 36 50                      DIM7:      MVI	L, 120o               ;Load L with address of start of SYMBOL BUFFER
 3950/3941 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of SYMBOL BUFFER. (Now
 3951/3943 : 46 2A 32                              CALL	DINPUT             ;Contains DIMension size.) Convert buffer to floating
 3952/3946 : 46 02 2F                              CALL	FPFIX              ;Point number and then reformat to fixed point.
 3953/3949 : 36 54                                 MVI	L, 124o               ;Load L with address of LSW of fixed point number
 3954/394B : C7                                    MOV	A,M                    ; And fetch the low order byte of the nr into the ACC
 3955/394C : 02                                    RLC                    ;Rotate it left two tirnes to multiply it by four (the
 3956/394D : 02                                    RLC                    ;Number of bytes required to store a floating point nr).
 3957/394E : D0                                    MOV	C,A                    ;Store this value in CPU register C temporarily
 3958/394F : 36 3E                                 MVI	L, 076o               ;Set L to ARRAY TEMP storage location.
 3959/3951 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to ARRAY TEMP pointer page.
 3960/3953 : C7                                    MOV	A,M                    ;Fetch the value in ARRAY TEMP (points to ARRAY
 3961/3954 : 14 01                                 SUI	001                ;VARIABLES table). Subtract one from the pointer
 3962/3956 : 02                                    RLC                    ;Value and multiply the result by four using rotate left
 3963/3957 : 02                                    RLC                    ;Instructions. Add this value to a base address
 3964/3958 : 04 52                                 ADI	122o               ;(Augmented by two) to point to ARRAY VALUES
 3965/395A : F0                                    MOV	L,A                    ;Pointer storage location in the ARRAY VARIABLES
 3966/395B : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;Table and set the pointer up in registers H & L.
 3967/395D : CF                                    MOV	B,M                    ;Fetch the starting address in the ARRAY VALUES
 3968/395E : 04 04                                 ADI	004                ;Table for the previous array into register B. Now add
 3969/3960 : F0                                    MOV	L,A                    ;Four to the ARRAY VARIABLES table pointer to
 3970/3961 : C1                                    MOV	A,B                    ;Point to curront ARRAY VALUES starting address.
 3971/3962 : 82                                    ADD	C                    ;Add the previous array starting address plus number of
 3972/3963 : F8                                    MOV	M,A                    ;Bytes required and store as starting loc for next array
 3973/3964 : 36 84                      DIM8:      MVI	L, 204o               ;Set L to address of DIMEN pointer storage location
 3974/3966 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of DIMEN pointer
 3975/3968 : CF                                    MOV	B,M                    ;Fetch pointer value (points to ") " in line)
 3976/3969 : 36 83                                 MVI	L, 203o               ;Change L to DIM pointer storage location
 3977/396B : F9                                    MOV	M,B                    ;Store former DIMEN value back in DIM pointer
 3978/396C : 36 83                      DIM9:      MVI	L, 203o               ;Load L with address of DIM pointer storage location
 3979/396E : 46 BB 21                              CALL	GETCHR             ;Fetch a character from the line input buffer
 3980/3971 : 3C AC                                 CPI	254o               ;See if character is a comma (,) sign
 3981/3973 : 68 81 39                              JZ	DIM10              ;If yes, have another array being defined on the line
 3982/3976 : 36 83                                 MVI	L, 203o               ;If not, reset L to the DIM pointer
 3983/3978 : 46 1E 22                              CALL	LOOP               ;Increment the pointer and see if end of the line
 3984/397B : 48 6C 39                              JNZ	DIM9               ;If not end of the line, keep looking for a comma
 3985/397E : 44 58 2A                              JMP	NXTLIN             ;Else exit the DIM statement routine to continue pgm
 3986/3981 : 36 83                      DIM10:     MVI	L, 203o               ;Set L to DIM pointer storage location
 3987/3983 : CF                                    MOV	B,M                    ;Fetch pointer value (points to comma sign just found)
 3988/3984 : 36 82                                 MVI	L, 202o               ;Load L with address of SCAN pointer storage location
 3989/3986 : F9                                    MOV	M,B                    ;Place DIM pointer into the-SCAN pointer
 3990/3987 : 44 A0 38                              JMP	DIM                ;Continue processing DIM statement line for next array
 3991/398A : 06 C4                      DIMERR:    MVI	A, 304o               ;On error condition, load ASCII code for letter D in ACC
 3992/398C : 16 C5                                 MVI	C, 305o               ;And ASCII code for letter E in CPU register C
 3993/398E : 44 B1 21                              JMP	ERROR              ;Go display the Dirnension Error (DE) message.
 3994/3991 :                            
 3995/3991 :                            ;------------------------------------------------------------------------
 3996/3991 :                            ;;; Page one has many constants and variables.
 3997/3991 :                            
 3998/3991 :                            ;		ORG	PG01 * 0100h	;001#000
 3999/3D00 :                            		ORG	ORG_PG01
 4000/3D00 :                            
 4001/3D00 : 00 00 00 00                		db	0,0,0,0		;DATA *4
 4002/3D04 : 00 00 40 01                		db	0,0,100o,1	;DATA 000,000,100,001	; STORES FLOATING POINT CONSTANT +1.0
 4003/3D08 : 00 00 00                   		db	0,0,0		;DATA *3
 4004/3D0B : 00                         		db	0		;DATA 000		; EXPONENT COUNTER
 4005/3D0C : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; STORES FLOATING POINT NUMBER TEMPORARILLY
 4006/3D10 : 00 00 00 00                		db	0,0,0,0		;DATA *4
 4007/3D14 : 00 00 C0 01                		db	0,0,300o,1	;DATA 000,000,300,001	; STORES FLOATING POINT CONSTANT -1.0
 4008/3D18 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; SCRATCH PAD AREA (16 BYTES)
 4009/3D1C : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
 4010/3D20 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
 4011/3D24 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
 4012/3D28 : 01 50 72 02                		db	1,120o,162o,2o	;DATA 001,120,162,002	; STORES RANDOM NUMBER GENERATOR CONSTANT VALUE
 4013/3D2C : 00 00 00 00                		db	0,0,0,0		;DATA *4
 4014/3D30 : 03 68 6F 0C                		db	3,150o,157o,14o	;DATA 003,150,157,014	; STORES RANDOM NUMBER GENERATOR CONSTANT VALUE
 4015/3D34 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; SCRATCH PAD AREA (12 BYTES) (01 064-077)
 4016/3D38 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
 4017/3D3C : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
 4018/3D40 : 00 00                      		db	0,0		;DATA 000,000		; SIGN INDICATOR
 4019/3D42 : 00                         		db	0		;DATA 000		; BITS COUNTER
 4020/3D43 : 00 00                      		db	0,0		;DATA 000,000		; SIGN INDICATOR
 4021/3D45 : 00                         IN_DIGIT_CC_L0	db	0		;DATA 000		; INPUT DIGIT COUNTER
 4022/3D46 : =45H                       IN_DIGIT_CC_L	equ	105o
 4023/3D46 : 00                         		db	0		;DATA 000		; TEMP STORATE
 4024/3D47 : 00                         		db	0		;DATA 000		; OUTPUT DIGIT COUNTER
 4025/3D48 : 00                         		db	0		;DATA 000 		; FP MODE INDICATOR
 4026/3D49 : 00 00 00 00 00 00 00       		db	0,0,0,0,0,0,0	;DATA *7		; NOT ASSIGNED (SHOULD BE 01 111-117)
 4027/3D50 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; FPACC EXTENSION
 4028/3D54 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; FPACC LSW, NSW, MSW, EXPONENT
 4029/3D58 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; FPOP  Extension
 4030/3D5C : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; FPOP  LSW, NSW, MSW, EXPONENT
 4031/3D60 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; FLOATING POINT WORKING AREA
 4032/3D64 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; (SHOULD BE AT 01 140-01-167)
 4033/3D68 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
 4034/3D6C : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
 4035/3D70 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
 4036/3D74 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
 4037/3D78 : 00 00 00 00 00 00 00 00    		db	0,0,0,0,0,0,0,0	;DATA *8		; NOT ASSIGNED (SHOULD BE 01 170-01 177)
 4038/3D80 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; TEMPORARY REGISTER STORAGE AREA (D,E,H&L)
 4039/3D84 : 00 00 00 00                		db	0,0,0,0		;DATA *4		; NOT ASSIGNED (01 204-01 207)
 4040/3D88 : 00 00 50 04                		db	0,0,120o,4	;DATA 000,000,120,004	; STORES FLOATING POINT CONSTANT +10.0
 4041/3D8C : 67 66 66 FD                		db	147o,146o,146o,375o	;DATA 147,146,146,375	; STORES FLOATING POINT CONSTANT +0.1
 4042/3D90 : 00                         		db	0		;DATA 000		; GETINP COUNTER
 4043/3D91 : 00 00 00 00 00 00          		db	0,0,0,0,0,0	;DATA *6		; NOT ASSIGNED (01 221-01 226)
 4044/3D97 : 00                         		db	0		;DATA 000		; ARITHMETIC STACK POINTER (01 227)
 4045/3D98 : 00                         		db	0		;DATA 000		; ARITHMETIC STACK (NOT CLEAR HOW LONG)
 4046/3D99 :                            
 4047/3D99 :                            ;		ORG	PG01 * 0100h + 0bah	;001#272
 4048/3DBA :                            		ORG	ORG_PG01 + 0bah	;001#272
 4049/3DBA : 04                         		db	4		;DATA 004		; CC FOR SAVE
 4050/3DBB :                            ;		db	"SAVE"		;DATA "SAVE"
 4051/3DBB : C5                         		db	"E"+80h
 4052/3DBC : D8                         		db	"X"+80h
 4053/3DBD : C9                         		db	"I"+80h
 4054/3DBE : D4                         		db	"T"+80h
 4055/3DBF : 03                         		db	3		;DATA 004		; CC FOR LOAD
 4056/3DC0 :                            ;		db	"LOAD"		;DATA "LOAD"
 4057/3DC0 : CD                         		db	"M"+80h
 4058/3DC1 : CF                         		db	"O"+80h
 4059/3DC2 : CE                         		db	"N"+80h
 4060/3DC3 : A0                         		db	" "+80h
 4061/3DC4 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; UNCLEAR WHAT THIS IS (01 304-01 317) ZEROS
 4062/3DC8 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; (PROBABLY STEP, FOR/NEXT, AND ARRAY PTR TEMP)
 4063/3DCC : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
 4064/3DD0 :                            					;; AT THIS POINT WE SHOULD BE AT LOCATION 01 320 01d0h
 4065/3DD0 : 04                         		db	4		;DATA 4
 4066/3DD1 :                            ;		db	"THEN"		;DATA "THEN"
 4067/3DD1 : D4                         		db	"T"+80h
 4068/3DD2 : C8                         		db	"H"+80h
 4069/3DD3 : C5                         		db	"E"+80h
 4070/3DD4 : CE                         		db	"N"+80h
 4071/3DD5 : 02                         		db	2		;DATA 2
 4072/3DD6 :                            ;		db	"TO"		;DATA "TO"
 4073/3DD6 : D4                         		db	"T"+80h
 4074/3DD7 : CF                         		db	"O"+80h
 4075/3DD8 : 04                         		db	4		;DATA 4
 4076/3DD9 :                            ;		db	"STEP"		;DATA "STEP"
 4077/3DD9 : D3                         		db	"S"+80h
 4078/3DDA : D4                         		db	"T"+80h
 4079/3DDB : C5                         		db	"E"+80h
 4080/3DDC : D0                         		db	"P"+80h
 4081/3DDD : 04                         		db	4		;DATA 4
 4082/3DDE :                            ;		db	"LIST"		;DATA "LIST"
 4083/3DDE : CC                         		db	"L"+80h
 4084/3DDF : C9                         		db	"I"+80h
 4085/3DE0 : D3                         		db	"S"+80h
 4086/3DE1 : D4                         		db	"T"+80h
 4087/3DE2 : 03                         		db	3		;DATA 3
 4088/3DE3 :                            ;		db	"RUN"		;DATA "RUN"
 4089/3DE3 : D2                         		db	"R"+80h
 4090/3DE4 : D5                         		db	"U"+80h
 4091/3DE5 : CE                         		db	"N"+80h
 4092/3DE6 : 03                         		db	3		;DATA 3
 4093/3DE7 :                            ;		db	"SCR"		;DATA "SCR
 4094/3DE7 : D3                         		db	"S"+80h
 4095/3DE8 : C3                         		db	"C"+80h
 4096/3DE9 : D2                         		db	"R"+80h
 4097/3DEA : 0B                         		db	013o		;DATA 013		; CC FOR "READY" MESSAGE
 4098/3DEB : 94 8D 8A                   		db	224o,215o,212o	;DATA 224,215,212	; CTRL-T, CARRIAGE RETURN, LINE FEED
 4099/3DEE :                            ;		db	"READY"		;DATA "READY"
 4100/3DEE : D2                         		db	"R"+80h
 4101/3DEF : C5                         		db	"E"+80h
 4102/3DF0 : C1                         		db	"A"+80h
 4103/3DF1 : C4                         		db	"D"+80h
 4104/3DF2 : D9                         		db	"Y"+80h
 4105/3DF3 : 8D 8A 8A                   		db	215o,212o,212o	;DATA 215,212,212	; CARRIAGE RETURN, LINE FEED, LINE FEED;
 4106/3DF6 : 09                         		db	011o		;DATA 011
 4107/3DF7 :                            ;		db	" AT LINE "	;DATA " AT LINE "
 4108/3DF7 : A0                         		db	" "+80h
 4109/3DF8 : C1                         		db	"A"+80h
 4110/3DF9 : D4                         		db	"T"+80h
 4111/3DFA : A0                         		db	" "+80h
 4112/3DFB : CC                         		db	"L"+80h
 4113/3DFC : C9                         		db	"I"+80h
 4114/3DFD : CE                         		db	"N"+80h
 4115/3DFE : C5                         		db	"E"+80h
 4116/3DFF : A0                         		db	" "+80h
 4117/3E00 :                            
 4118/3E00 :                            	;; THIS SHOULD BE THE END OF PAGE 01
 4119/3E00 :                            
 4120/3E00 :                            ;	ORG	PG26 * 100h	;026#000
 4121/3E00 :                            	ORG	ORG_PG26	;026#000
 4122/3E00 :                            
 4123/3E00 : 00                         	db	0		;DATA 000		; CC FOR INPUT LINE BUFFER
 4124/3E01 : 00 00 00 00 00 00 00 00 00 	db	79 dup (0)	;DATA *79 		; THE INPUT LINE BUFFER
      3E0A : 00 00 00 00 00 00 00 00 00
      3E13 : 00 00 00 00 00 00 00 00 00
      3E1C : 00 00 00 00 00 00 00 00 00
      3E25 : 00 00 00 00 00 00 00 00 00
      3E2E : 00 00 00 00 00 00 00 00 00
      3E37 : 00 00 00 00 00 00 00 00 00
      3E40 : 00 00 00 00 00 00 00 00 00
      3E49 : 00 00 00 00 00 00 00      
 4125/3E50 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; THESE ARE SYMBOL BUFFER STORAGE
 4126/3E54 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4127/3E58 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; SHOULD BE 26-120 TO 26 143
 4128/3E5C : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4129/3E60 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4130/3E64 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; THESE LOCATIONS ARE AUXILIARY SYMBOL BUFFER
 4131/3E68 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4132/3E6C : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; SHOULD BE 26 144 TO 26 175
 4133/3E70 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4134/3E74 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4135/3E78 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4136/3E7C : 00 00                      	db	0,0		;DATA 000,000
 4137/3E7E : 00                         	db	0		;DATA 000		; TEMP SCAN STORAGE REGISTER
 4138/3E7F : 00                         	db	0		;DATA 000		; TAB FLAG
 4139/3E80 : 00                         	db	0		;DATA 000		; EVAL CURRENT TEMP REG.
 4140/3E81 : 00                         	db	0		;DATA 000		; SYNTAX LINE NUMBER
 4141/3E82 : 00                         	db	0		;DATA 000		; SCAN TEMPORARY REGISTER
 4142/3E83 : 00                         	db	0		;DATA 000		; STATEMENT TOKEN
 4143/3E84 : 00 00                      	db	0,0		;DATA 000,000		; TEMPORARY WORKING REGISTERS
 4144/3E86 : 00 00                      	db	0,0		;DATA 000,000		; ARRAY POINTERS
 4145/3E88 :                            ;;; NOW WE SHOULD BE UP TO 26 210 1688h
 4146/3E88 : 00                         	db	0		;DATA 000		; OPERATOR STACK POINTER
 4147/3E89 : 00 00 00 00 00 00 00 00 00 	db	15 dup (0)	;DATA *15		; OPERATOR STACK
      3E92 : 00 00 00 00 00 00         
 4148/3E98 : 00                         	db	0		;DATA 000		; FUN/ARRAY STACK POINTER
 4149/3E99 : 00 00 00 00 00 00 00       	db	7 dup (0)	;DATA *7			; FUNCTION/ARRAY STACK
 4150/3EA0 :                            ;;; THE LAST BYTE SHOULD HAVE BEEN 26 237 169fh
 4151/3EA0 :                            
 4152/3EA0 :                            
 4153/3EA0 :                            	;; HEIRARCHY TABLE (FOR OUT OF STACK OPS)
 4154/3EA0 :                            	;; USED BY PARSER ROUTINE.
 4155/3EA0 :                            ;;; This SHOULD START AT 26 240
 4156/3EA0 : 00                         	db	0		;DATA 000		; EOS
 4157/3EA1 : 03                         	db	3		;DATA 003		; PLUS SIGN
 4158/3EA2 : 03                         	db	3		;DATA 003		; MINUS SIGN
 4159/3EA3 : 04                         	db	4		;DATA 004		; MULTIPLICATION SIGN
 4160/3EA4 : 04                         	db	4		;DATA 004		; DIVISION SIGN
 4161/3EA5 : 05                         	db	5		;DATA 005		; EXPONENT SIGN
 4162/3EA6 : 06                         	db	6		;DATA 006		; LEFT PARENTHESIS
 4163/3EA7 : 01                         	db	1		;DATA 001		; RIGHT PARENTHESIS
 4164/3EA8 : 02                         	db	2		;DATA 002		; NOT ASSIGNED
 4165/3EA9 : 02                         	db	2		;DATA 002		; LESS THAN SIGN
 4166/3EAA : 02                         	db	2		;DATA 002		; Equal sign
 4167/3EAB : 02                         	db	2		;DATA 002		; GREATER THAN SIGN
 4168/3EAC : 02                         	db	2		;DATA 002		; LESS THAN OR EQUAL COMBO
 4169/3EAD : 02                         	db	2		;DATA 002		; EQUAL OR GREATER THAN
 4170/3EAE : 02                         	db	2		;DATA 002		; LESS THAN OR GREATER THAN
 4171/3EAF :                            
 4172/3EAF :                            	;; HEIRARCHY TABLE (FOR INTO STACK OPS)
 4173/3EAF :                            	;; USED BY PARSER ROUTINE.
 4174/3EAF :                            ;;; This SHOULD START AT 26 257 16afh
 4175/3EAF : 00                         	db	0		;DATA 000		; EOS
 4176/3EB0 : 03                         	db	3		;DATA 003		; PLUS SIGN
 4177/3EB1 : 03                         	db	3		;DATA 003		; MINUS SIGN
 4178/3EB2 : 04                         	db	4		;DATA 004		; MULTIPLICATION SIGN
 4179/3EB3 : 04                         	db	4		;DATA 004		; DIVISION SIGN
 4180/3EB4 : 05                         	db	5		;DATA 005		; EXPONENTIATION SIGN
 4181/3EB5 : 01                         	db	1		;DATA 001		; LEFT PARENTHESIS
 4182/3EB6 : 01                         	db	1		;DATA 001		; RIGHT PARENTHESIS
 4183/3EB7 : 02                         	db	2		;DATA 002		; NOT ASSIGNED
 4184/3EB8 : 02                         	db	2		;DATA 002		; LESS THAN SIGN
 4185/3EB9 : 02                         	db	2		;DATA 002		; EQUAL SIGN
 4186/3EBA : 02                         	db	2		;DATA 002		; GREATER THAN SIGN
 4187/3EBB : 02                         	db	2		;DATA 002		; LESS THAN OR EQUAL SIGN
 4188/3EBC : 02                         	db	2		;DATA 002		; EQUAL TO OR GREATER THAN
 4189/3EBD : 02                         	db	2		;DATA 002		; LESS THAN OR GREATER THAN
 4190/3EBE :                            
 4191/3EBE : 00                         	db	0		;DATA 000		; EVAL START POINTER
 4192/3EBF : 00                         	db	0		;DATA 000		; EVAL FINISH POINTER
 4193/3EC0 :                            
 4194/3EC0 :                            	;; FUNCTION NAMES TABLE
 4195/3EC0 :                            ;;; This SHOULD START AT 26 300 16c0h
 4196/3EC0 :                            
 4197/3EC0 : 03                         	db	3		;DATA 3
 4198/3EC1 :                            ;	db	"INT"		;DATA "INT"
 4199/3EC1 : C9                         	db	"I"+80h
 4200/3EC2 : CE                         	db	"N"+80h
 4201/3EC3 : D4                         	db	"T"+80h
 4202/3EC4 : 03                         	db	3		;DATA 3
 4203/3EC5 :                            ;	db	"SGN"		;DATA "SGN"
 4204/3EC5 : D3                         	db	"S"+80h
 4205/3EC6 : C7                         	db	"G"+80h
 4206/3EC7 : CE                         	db	"N"+80h
 4207/3EC8 : 03                         	db	3		;DATA 3
 4208/3EC9 :                            ;	db	"ABS"		;DATA "ABS"
 4209/3EC9 : C1                         	db	"A"+80h
 4210/3ECA : C2                         	db	"B"+80h
 4211/3ECB : D3                         	db	"S"+80h
 4212/3ECC : 03                         	db	3		;DATA 3
 4213/3ECD :                            ;	db	"SQR"		;DATA "SQR"
 4214/3ECD : D3                         	db	"S"+80h
 4215/3ECE : D1                         	db	"Q"+80h
 4216/3ECF : D2                         	db	"R"+80h
 4217/3ED0 : 03                         	db	3		;DATA 3
 4218/3ED1 :                            ;	db	"TAB"		;DATA "TAB"
 4219/3ED1 : D4                         	db	"T"+80h
 4220/3ED2 : C1                         	db	"A"+80h
 4221/3ED3 : C2                         	db	"B"+80h
 4222/3ED4 : 03                         	db	3		;DATA 3
 4223/3ED5 :                            ;	db	"RND"		;DATA "RND"
 4224/3ED5 : D2                         	db	"R"+80h
 4225/3ED6 : CE                         	db	"N"+80h
 4226/3ED7 : C4                         	db	"D"+80h
 4227/3ED8 : 03                         	db	3		;DATA 3
 4228/3ED9 :                            ;	db	"CHR"		;DATA "CHR"
 4229/3ED9 : C3                         	db	"C"+80h
 4230/3EDA : C8                         	db	"H"+80h
 4231/3EDB : D2                         	db	"R"+80h
 4232/3EDC : 03                         	db	3		;DATA 3
 4233/3EDD :                            ;	db	"UDF"		;DATA "UDF"
 4234/3EDD : D5                         	db	"U"+80h
 4235/3EDE : C4                         	db	"D"+80h
 4236/3EDF : C6                         	db	"F"+80h
 4237/3EE0 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; LINE NUMBER BUFFER STORAGE
 4238/3EE4 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; (SHOULD BE 340-347)
 4239/3EE8 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; AUX LINE NUMBER BUFFER
 4240/3EEC : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; (SHOULD BE 350-357)
 4241/3EF0 :                            ;;; The following data is a change in page 3 of Scelbal update issue 4
 4242/3EF0 :                            ;;; which apparently makes the "INSERT" command work correctly, the
 4243/3EF0 :                            ;;; first time (later SCR commands load 33 into this spot) 
 4244/3EF0 : 1B                         	db	033o		;DATA 033 		; USER PGM LINE PTR (PG)
 4245/3EF1 : 00                         	db	0		;DATA 000 		; USER PGM LINE PTR (LOW)
 4246/3EF2 : 00                         	db	0		;DATA 000 		; AUX PGM LINE PTR (PG)
 4247/3EF3 : 00                         	db	0		;DATA 000 		; AUX PGM LINE PTR (LOW)
 4248/3EF4 : 00                         	db	0		;DATA 000 		; END OF USER PGM BUFFER PTR (PG)
 4249/3EF5 : 00                         	db	0		;DATA 000 		; END OF USER PGM BUFFER PTR (LOW)
 4250/3EF6 : 00                         	db	0		;DATA 000		; PARENTHESIS COUNTER (366)
 4251/3EF7 : 00                         	db	0		;DATA 000		; QUOTE INDICATOR
 4252/3EF8 : 00                         	db	0		;DATA 000		; TABLE COUNTER (370)
 4253/3EF9 :                            ;;; locations 371-377 NOT ASSIGNED
 4254/3EF9 :                            
 4255/ 400 :                            	org	PG27 * 100h		;ORG 027#000
 4256/3F00 :                            	org	ORG_PG27		;ORG 027#000
 4257/3F00 : 03                         	db	3		;DATA 3
 4258/3F01 :                            ;	db	"REM"		;DATA "REM"
 4259/3F01 : D2                         	db	"R"+80h
 4260/3F02 : C5                         	db	"E"+80h
 4261/3F03 : CD                         	db	"M"+80h
 4262/3F04 : 02                         	db	2		;DATA 2
 4263/3F05 :                            ;	db	"IF"		;DATA "IF"
 4264/3F05 : C9                         	db	"I"+80h
 4265/3F06 : C6                         	db	"F"+80h
 4266/3F07 : 03                         	db	3		;DATA 3
 4267/3F08 :                            ;	db	"LET"		;DATA "LET"
 4268/3F08 : CC                         	db	"L"+80h
 4269/3F09 : C5                         	db	"E"+80h
 4270/3F0A : D4                         	db	"T"+80h
 4271/3F0B : 04                         	db	4		;DATA 4
 4272/3F0C :                            ;	db	"GOTO"		;DATA "GOTO"
 4273/3F0C : C7                         	db	"G"+80h
 4274/3F0D : CF                         	db	"O"+80h
 4275/3F0E : D4                         	db	"T"+80h
 4276/3F0F : CF                         	db	"O"+80h
 4277/3F10 : 05                         	db	5		;DATA 5
 4278/3F11 :                            ;	db	"PRINT"		;DATA "PRINT"
 4279/3F11 : D0                         	db	"P"+80h
 4280/3F12 : D2                         	db	"R"+80h
 4281/3F13 : C9                         	db	"I"+80h
 4282/3F14 : CE                         	db	"N"+80h
 4283/3F15 : D4                         	db	"T"+80h
 4284/3F16 : 05                         	db	5		;DATA 5
 4285/3F17 :                            ;	db	"INPUT"		;DATA "INPUT"
 4286/3F17 : C9                         	db	"I"+80h
 4287/3F18 : CE                         	db	"N"+80h
 4288/3F19 : D0                         	db	"P"+80h
 4289/3F1A : D5                         	db	"U"+80h
 4290/3F1B : D4                         	db	"T"+80h
 4291/3F1C : 03                         	db	3		;DATA 3
 4292/3F1D :                            ;	db	"FOR"		;DATA "FOR"
 4293/3F1D : C6                         	db	"F"+80h
 4294/3F1E : CF                         	db	"O"+80h
 4295/3F1F : D2                         	db	"R"+80h
 4296/3F20 : 04                         	db	4		;DATA 4
 4297/3F21 :                            ;	db	"NEXT"		;DATA "NEXT"
 4298/3F21 : CE                         	db	"N"+80h
 4299/3F22 : C5                         	db	"E"+80h
 4300/3F23 : D8                         	db	"X"+80h
 4301/3F24 : D4                         	db	"T"+80h
 4302/3F25 : 05                         	db	5		;DATA 5
 4303/3F26 :                            ;	db	"GOSUB"		;DATA "GOSUB"
 4304/3F26 : C7                         	db	"G"+80h
 4305/3F27 : CF                         	db	"O"+80h
 4306/3F28 : D3                         	db	"S"+80h
 4307/3F29 : D5                         	db	"U"+80h
 4308/3F2A : C2                         	db	"B"+80h
 4309/3F2B : 06                         	db	6		;DATA 6
 4310/3F2C :                            ;	db	"RETURN"	;DATA "RETURN"
 4311/3F2C : D2                         	db	"R"+80h
 4312/3F2D : C5                         	db	"E"+80h
 4313/3F2E : D4                         	db	"T"+80h
 4314/3F2F : D5                         	db	"U"+80h
 4315/3F30 : D2                         	db	"R"+80h
 4316/3F31 : CE                         	db	"N"+80h
 4317/3F32 : 03                         	db	3		;DATA 3
 4318/3F33 :                            ;	db	"DIM"		;DATA "DIM"
 4319/3F33 : C4                         	db	"D"+80h
 4320/3F34 : C9                         	db	"I"+80h
 4321/3F35 : CD                         	db	"M"+80h
 4322/3F36 : 03                         	db	3		;DATA 3
 4323/3F37 :                            ;	db	"END"		;DATA "END"
 4324/3F37 : C5                         	db	"E"+80h
 4325/3F38 : CE                         	db	"N"+80h
 4326/3F39 : C4                         	db	"D"+80h
 4327/3F3A : 00                         	db	0		;DATA 0
 4328/3F3B :                            
 4329/3F3B :                            	; END OF TABLE, SHOULD BE 072 3ah
 4330/3F3B :                            
 4331/3F3B : 00                         	db	0		;DATA 000		; GOSUB STACK POINTER
 4332/3F3C : 00                         	db	0		;DATA *1			; NOT ASSIGNED;
 4333/3F3D : 00                         	db	0		;DATA 000		; NUMBER OF ARRAYS COUNTER
 4334/3F3E : 00                         	db	0		;DATA 000		; ARRAY POINTER
 4335/3F3F : 00                         	db	0		;DATA 000		; VARIABLES COUNTER SHOULD BE 077
 4336/3F40 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; USED AS THE GOSUB STACK 100-117
 4337/3F44 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4338/3F48 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4339/3F4C : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4340/3F50 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; USED AS ARRAY VARIABLES TABLE
 4341/3F54 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; SHOULD BE 120-137
 4342/3F58 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4343/3F5C : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4344/3F60 :                            
 4345/3F60 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; USED FOR FOR/NEXT STACK STORAGE
 4346/3F64 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; SHOULD BE 140 TO 177
 4347/3F68 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4348/3F6C : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4349/3F70 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4350/3F74 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4351/3F78 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4352/3F7C : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4353/3F80 : 00                         	db	0		;DATA 000		; FOR/NEXT STACK POINTER
 4354/3F81 : 00                         	db	0		;DATA 000		; ARRAY/VARIABLE FLAG
 4355/3F82 : 00                         	db	0		;DATA 000  		; STOSYM COUNTER
 4356/3F83 : 00                         	db	0		;DATA 000		; FUN/ARRAY STACK POINTER (203
 4357/3F84 : 00                         	db	0		;DATA 000		; ARRAY VALUES POINTER
 4358/3F85 : 00 00 00                   	db	0,0,0		;DATA *3			; NOT USED (SHOULD BE 205-207)
 4359/3F88 : 00                         	db	0		;DATA 000		; USED AS VARIABLES SYMBOL TABLE
 4360/3F89 : 00 00 00 00 00 00 00 00 00 	db	119 dup (0)	;DATA *119		; (SHOULD BE 211-377 RESERVED)
      3F92 : 00 00 00 00 00 00 00 00 00
      3F9B : 00 00 00 00 00 00 00 00 00
      3FA4 : 00 00 00 00 00 00 00 00 00
      3FAD : 00 00 00 00 00 00 00 00 00
      3FB6 : 00 00 00 00 00 00 00 00 00
      3FBF : 00 00 00 00 00 00 00 00 00
      3FC8 : 00 00 00 00 00 00 00 00 00
      3FD1 : 00 00 00 00 00 00 00 00 00
      3FDA : 00 00 00 00 00 00 00 00 00
      3FE3 : 00 00 00 00 00 00 00 00 00
      3FEC : 00 00 00 00 00 00 00 00 00
      3FF5 : 00 00 00 00 00 00 00 00 00
      3FFE : 00 00                     
 4361/4000 :                            
 4362/4000 :                            
 AS V1.42 Beta [Bld 290] - Source File sc1.asm - Page 3 - 8/12/2025 11:1:30


  Symbol Table (* = unused):
  --------------------------

 ABSX :                        2701 C |  ACCSET :                      2F78 C |
 ACNONZ :                      2F65 C |  ACZERT :                      2F52 C |
 AD4DE :                       25C9 C |  ADBDE :                       29C9 C |
 ADDER :                       315D C | *ADDEXP :                      302F C |
 ADDMOR :                      315E C |  ADOPPP :                      30BE C |
 ADV :                         221A C |  ADVDE :                       2A3E C |
 AHEAD1 :                      3396 C |  AHEAD2 :                      34E1 C |
*ARCHITECTURE :                                        "i386-unknown-win32" - |
 ARRAY :                       3810 C |  ARRAY1 :                      3816 C |
 ARRAY2 :                      381B C |  ARRAY3 :                      381D C |
 ARRAY4 :                      3827 C |  ARRAY5 :                      3840 C |
 ARRAY6 :                      384B C |  ARRAY7 :                      3875 C |
 BACKSP :                      3682 C |  BGNPGRAM :                       6 - |
 BIGERR :                      21AD C | *BRING1 :                      300D C |
*CASESENSITIVE :                  0 - |  CFALSE :                      25C2 C |
 CHRX :                        271A C |  CINP :                        20CC C |
 CINPUT :                      22AC C |  CINP_BS :                     20DC C |
 CKDECP :                      3465 C | *CKEQEX :                      2FA4 C |
 CKSIGN :                      307C C |  CLESYM :                      21C8 C |
 CLRNEX :                      3083 C |  CLRNX1 :                      308D C |
 CLRNX2 :                      3233 C |  CLRNX3 :                      323D C |
*CLROPL :                      3089 C |  CODE_START :                  2000 - |
 COMPEN :                      340E C |  COMPLM :                      316E C |
 CONCT1 :                      21E7 C | *CONCTA :                      21CF C |
 CONCTE :                      21F2 C |  CONCTN :                      21D9 C |
 CONCTS :                      21E3 C | *CONSTPI :        3.141592653589793 - |
 CONTIN :                      293F C |  CPHLDE :                      29C3 C |
 CPRINT :                      20DF C |  CPRINT_1 :                    20F6 C |
 CP_BS :                       20FF C |  CP_BS2 :                      2108 C |
 CP_BS3 :                      2111 C |  CP_NO :                       20FE C |
 CP_OK :                       20F5 C |  CRLF :                        227C C |
 CROUND :                      30CD C |  CTRLC :                       29CF C |
 CTRUE :                       25BD C |  DATE :                 "8/12/2025" - |
 DEC :                         228F C |  DECBIN :                      3334 C |
 DECEXD :                      33E4 C |  DECEXT :                      33C5 C |
 DECNO :                       2295 C |  DECOUT :                      33F6 C |
 DECRDG :                      3450 C |  DECREP :                      33DD C |
 DIM :                         38A0 C |  DIM1 :                        38AA C |
 DIM10 :                       3981 C |  DIM2 :                        38BA C |
 DIM3 :                        38C5 C |  DIM4 :                        38C9 C |
 DIM5 :                        391A C |  DIM6 :                        3934 C |
 DIM7 :                        393F C | *DIM8 :                        3964 C |
 DIM9 :                        396C C |  DIMERR :                      398A C |
 DINPUT :                      322A C |  DIRECT :                      2A93 C |
 DIVIDE :                      30EF C |  DVERR :                       29F9 C |
 DVEXIT :                      313E C |  DVLOOP :                      260D C |
 ECHO :                        229D C |  ENDINP :                      32CF C |
 ENDPGRAM :                      1E - |  ENTRY_SCR :                   2825 C |
 EQ :                          2579 C |  ERROR :                       21B1 C |
 EVAL :                        22AF C |  EXEC :                        27D1 C |
 EXEC1 :                       27D8 C |  EXIT :                        20B4 C |
 EXMLDV :                      306C C |  EXOUTN :                      34DA C |
 EXPINP :                      32A7 C |  EXPOK :                       3306 C |
 EXPOUT :                      34C6 C |  FACXOP :                      31C5 C |
 FAERR :                       2695 C | *FALSE :                          0 - |
 FINER1 :                      29ED C |  FINERR :                      29D6 C |
 FININP :                      32DD C |  FIXERR :                      2A00 C |
 FLOAD :                       31AA C | *FLOATMAX :      1.797693134866E308 - |
 FNDEXP :                      3297 C |  FOR :                         2E7E C |
 FOR1 :                        2EB4 C |  FOR2 :                        2EC0 C |
 FOR3 :                        2ED2 C |  FOR4 :                        2EDD C |
 FOR5 :                        3699 C |  FORERR :                      2EAD C |
 FORNXT :                      3544 C |  FP0 :                         2E79 C |
 FPADD :                       2F8B C |  FPCOMP :                      2F84 C |
 FPD10 :                       3321 C |  FPDIV :                       30D8 C |
 FPFIX :                       2F02 C |  FPFIXL :                      2F1D C |
 FPFLT :                       2F36 C |  FPMULT :                      302C C |
 FPNORM :                      2F38 C |  FPONE :                       25BD C |
 FPOPER :                      250F C |  FPOUT :                       337B C |
 FPSUB :                       3020 C |  FPX10 :                       330E C |
 FPZERO :                      2F2B C |  FRAC :                        2BF2 C |
*FSHIFT :                      3008 C |  FSTORE :                      31B3 C |
 FUNAR1 :                      2668 C |  FUNAR2 :                      37D7 C |
 FUNAR3 :                      37FF C |  FUNAR4 :                      26A2 C |
 FUNARR :                      265B C |  GE :                          25A6 C |
 GETAU0 :                      28A4 C |  GETAU1 :                      28BD C |
 GETAU2 :                      28D2 C |  GETAUX :                      289A C |
 GETCHP :                      2957 C |  GETCHR :                      21BB C |
 GETINP :                      31FB C |  GOSERR :                      2DF1 C |
 GOSUB :                       2DA8 C |  GOSUB1 :                      2DB7 C |
 GOTO :                        2C86 C |  GOTO1 :                       2C93 C |
 GOTO2 :                       2CAA C |  GOTO3 :                       2CB2 C |
 GOTO4 :                       2CBB C |  GOTO5 :                       2CC2 C |
 GOTO6 :                       2CD7 C |  GOTO7 :                       2CEA C |
*GOTOER :                      2D1A C |  GT :                          2586 C |
 HAJIME :                      2080 C | *HAS64 :                          1 - |
 IF :                          2D21 C |  IF1 :                         2D4C C |
 IF2 :                         2D6D C |  IF3 :                         2D80 C |
 IF4 :                         2D8A C |  IFERR :                       2D45 C |
*INCLIN :                      29B1 C |  INDEXB :                      2297 C |
 INDEXC :                      3224 C |  INPUT :                       2DFF C |
 INPUT1 :                      2E09 C |  INPUT2 :                      2E29 C |
 INPUT3 :                      2E2C C |  INPUT4 :                      2E3D C |
 INPUTN :                      2E6A C |  INPUTX :                      2E4E C |
 INSER1 :                      299D C |  INSER3 :                      29B1 C |
 INSERT :                      2989 C |  INSTR :                       2A14 C |
 INSTR1 :                      2A18 C |  INSTR2 :                      2A3B C |
 INT1 :                        26F2 C |  INT2 :                        26FC C |
 INTEXP :                      25CE C |  INTX :                        26BE C |
*INT_PTR :                       41 - |  IN_DATA :                        1 - |
 IN_DIGIT_CC_L :                 45 - | *IN_DIGIT_CC_L0 :              3D45 C |
 IN_STATUS :                      0 - |  JMP_ADDR :                    1EFC - |
 LE :                          2596 C |  LET :                         2C23 C |
 LET0 :                        2C15 C |  LET1 :                        2C2C C |
 LET2 :                        2C35 C |  LET3 :                        2C55 C |
 LET4 :                        2C5C C |  LET5 :                        2C6B C |
*LETERR :                      2C64 C |  LINEUP :                      2FC5 C |
 LIST :                        27F6 C | *LISTON :                         1 - |
 LOOK0 :                       2F56 C |  LOOKU1 :                      244C C |
 LOOKU2 :                      2464 C |  LOOKU4 :                      249C C |
 LOOKUP :                      2436 C |  LOOP :                        221E C |
 LOOP_PG01 :                   208D C |  LOOP_PG26 :                   209B C |
 LOOP_PG27 :                   20A9 C |  LT :                          256C C |
*MACEXP :                         7 - |  MINEXP :                      3321 C |
*MOMCPU :                     8008E - | *MOMCPUNAME :             "8008NEW" - |
 MON :                         20B8 C |  MORACC :                      2FCD C |
 MORCOM :                      3173 C |  MOROP :                       2FDA C |
 MOVEC :                       292A C |  MOVECP :                      27CC C |
 MOVEIT :                      3011 C |  MOVEPG :                      292C C |
 MOVOP :                       2F94 C |  MROUND :                      30C8 C |
 MULOOP :                      25FC C |  MULTIP :                      303C C |
 NE :                          25B3 C |  NEGEXP :                      36E6 C |
 NEGFPA :                      30AF C | *NESTMAX :                      100 - |
 NEXT :                        34FE C |  NEXT1 :                       350B C |
 NEXT10 :                      3656 C |  NEXT11 :                      366B C |
 NEXT12 :                      3672 C |  NEXT2 :                       3518 C |
 NEXT3 :                       352C C |  NEXT4 :                       354B C |
 NEXT5 :                       35B3 C |  NEXT6 :                       35DC C |
 NEXT7 :                       35F8 C |  NEXT8 :                       360A C |
 NEXT9 :                       3615 C |  NINPUT :                      3253 C |
 NODECP :                      3472 C |  NOEXC0 :                      2F42 C |
 NOEXPO :                      2420 C |  NOEXPS :                      32AA C |
 NOGO :                        3104 C |  NOLIST :                      2807 C |
 NONZAC :                      2F9F C |  NOREMD :                      36F4 C |
 NOSAME :                      2909 C |  NOSCR :                       2854 C |
 NOT0 :                        320E C |  NOTDEL :                      2240 C |
 NOTEND :                      28E2 C |  NOTPLM :                      3256 C |
 NUMERR :                      2A07 C |  NXTLIN :                      2A58 C |
 OPLOAD :                      31BC C |  OPN :                         2003 C |
 OPN_MSG :                     2004 C |  OPN_MSG1 :                    207F C |
 OPSGNT :                      309E C |  ORG_PG01 :                    3D00 - |
 ORG_PG26 :                    3E00 - |  ORG_PG27 :                    3F00 - |
 OUTDGS :                      342B C |  OUTDGX :                      344B C |
 OUTDIG :                      3420 C |  OUTFIX :                      33BF C |
 OUTFLT :                      33B1 C |  OUTNEG :                      338D C |
 OUTRNG :                      3809 C |  OUTX10 :                      3499 C |
 OUTZER :                      344A C |  OUT_DATA :                      10 - |
 PARNER :                      255F C |  PARNUM :                      2409 C |
 PARSE :                       24B4 C |  PARSE1 :                      24E2 C |
 PARSE2 :                      24F5 C |  PARSEP :                      36B3 C |
 PARSER :                      23EF C | *PATCH1 :                      2FE3 C |
*PATCH2 :                      3738 C | *PATCH3 :                      29F0 C |
 PCOM1 :                       2C0D C |  PCOMMA :                      2BF9 C |
 PERIOD :                      3287 C |  PFPOUT :                      2BD6 C |
 PG01 :                           2 - |  PG26 :                           3 - |
 PG27 :                           4 - |  PG57 :                           5 - |
 POSEXP :                      32FB C |  PRIGH1 :                      37AB C |
 PRIGHT :                      261E C |  PRINT :                       2AEF C |
 PRINT1 :                      2B00 C |  PRINT2 :                      2B0C C |
 PRINT3 :                      2B2D C |  PRINT4 :                      2B47 C |
*PRINT5 :                      2B56 C |  PRINT6 :                      2B5F C |
 PUSHIT :                      345F C |  QUOROT :                      3105 C |
 QUOTE :                       2B8D C |  QUOTE1 :                      2B9A C |
 QUOTE2 :                      2BBD C | *QUOTER :                      2BB0 C |
*RELAXED :                        0 - |  REMOV1 :                      297B C |
 REMOVE :                      2968 C |  RESIGN :                      2F7F C |
 RESTHL :                      31E5 C |  RESTSY :                      27C5 C |
 RETERR :                      2DF8 C |  RETURN :                      2DCE C |
 RNDX :                        3761 C |  ROTATL :                      3185 C |
 ROTATR :                      318F C |  ROTL :                        3186 C |
 ROTR :                        3190 C |  RUN :                         2A42 C |
 SAMLIN :                      2A78 C |  SAVEHL :                      31D5 C |
 SAVESY :                      27BB C |  SCAN1 :                       22C7 C |
 SCAN10 :                      23DC C |  SCAN11 :                      237E C |
 SCAN12 :                      23A1 C |  SCAN13 :                      23C4 C |
 SCAN14 :                      23CB C |  SCAN15 :                      23D2 C |
 SCAN16 :                      23D9 C |  SCAN2 :                       22DB C |
 SCAN3 :                       2300 C |  SCAN4 :                       230A C |
 SCAN5 :                       2316 C |  SCAN6 :                       2322 C |
 SCAN7 :                       2336 C |  SCAN8 :                       234F C |
 SCAN9 :                       235B C |  SCANFN :                      2304 C |
 SCRLOP :                      284B C | *SETDCT :                      30EB C |
 SETIT :                       31C0 C | *SETMCT :                      3038 C |
 SETSUB :                      3147 C |  SGNX :                        270B C |
 SHACOP :                      2FE3 C |  SHIFT0 :                      2FD9 C |
 SHLOOP :                      3002 C |  SKPNEG :                      2FB6 C |
*SQR1 :                        3741 C |  SQRCNV :                      374E C |
 SQRERR :                      375A C |  SQREXP :                      36F7 C |
 SQRLOP :                      370C C |  SQRX :                        36C5 C |
 STOSY1 :                      275B C |  STOSY2 :                      2771 C |
 STOSY3 :                      2789 C |  STOSY5 :                      27B2 C |
 STOSYM :                      2748 C |  STRCP :                       21F5 C |
 STRCPC :                      2213 C |  STRCPE :                      2209 C |
 STRCPL :                      21FF C |  STRIN :                       2227 C |
 STRIN1 :                      2229 C |  STRINF :                      225D C |
 SUB12 :                       34E7 C |  SUBBER :                      3199 C |
*SUBEXP :                      30E2 C |  SUBHL :                       2266 C |
 SUBTRA :                      319A C |  SWITCH :                      31F4 C |
 SYNERR :                      2885 C |  SYNTAX :                      211B C |
 SYNTOK :                      288C C |  SYNTX1 :                      2128 C |
 SYNTX2 :                      213F C |  SYNTX3 :                      214C C |
 SYNTX4 :                      2152 C |  SYNTX5 :                      2177 C |
 SYNTX6 :                      216F C |  SYNTX7 :                      21A3 C |
 SYNTX8 :                      21A8 C |  SYNTXL :                      2182 C |
 TAB1 :                        272D C |  TABAD1 :                      26B4 C |
 TABADR :                      26B3 C | *TABC :                        273D C |
 TABLOP :                      2740 C |  TABX :                        272A C |
 TEXTC :                       226C C |  TEXTCL :                      2270 C |
 TIME :                   "11:1:30" - |  TOMUCH :                      34F1 C |
*TRUE :                           1 - |  UDEFX :                       20B5 C |
*VERSION :                     142F - | *Z80SYNTAX :                      0 - |
 ZERO :                        2BE8 C |  ZERODG :                      347B C |

    423 symbols
     37 unused symbols

 AS V1.42 Beta [Bld 290] - Source File sc1.asm - Page 4 - 8/12/2025 11:1:30


  Defined Functions:
  ------------------

LO                                    | HI                                   

 AS V1.42 Beta [Bld 290] - Source File sc1.asm - Page 5 - 8/12/2025 11:1:30


  Code Pages:
  ----------

STANDARD (0 changed characters)

1 code page

0.20 seconds assembly time

   4362 lines source file
      2 passes
      0 errors
      0 warnings
