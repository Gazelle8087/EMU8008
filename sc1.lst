 AS V1.42 Beta [Bld 290] - Source File sc1.asm - Page 1 - 8/11/2025 18:46:17


    1/   0 :                            ;	SCELBAL BASIC for EMU8008
    2/   0 :                            ;
    3/   0 :                            ;Gazelle states the copyright about;
    4/   0 :                            ;Converted old 8008 mnemonics to new 8008 mnemonics.
    5/   0 :                            ;Relocate code for ROM start at 2000h and RAM at lower address.
    6/   0 :                            ;Added IO routines to match the specifications of the DOS loader.
    7/   0 :                            ;
    8/   0 :                            ;	Copyright (C) 2025 by Gazelle
    9/   0 :                            ;
   10/   0 :                            ;Permission is hereby granted, free of charge, to any person
   11/   0 :                            ;obtaining a copy of this software and associated documentation
   12/   0 :                            ;files (the "Software"), to deal in the Software without
   13/   0 :                            ;restriction, including without limitation the rights to use,
   14/   0 :                            ;copy, modify, merge, publish, distribute, sublicense, and/or sell
   15/   0 :                            ;copies of the Software, and to permit persons to whom the
   16/   0 :                            ;Software is furnished to do so, subject to the following
   17/   0 :                            ;conditions:
   18/   0 :                            ;
   19/   0 :                            ;The above copyright notice and this permission notice shall be
   20/   0 :                            ;included in all copies or substantial portions of the Software.
   21/   0 :                            ;
   22/   0 :                            ;THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   23/   0 :                            ;EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
   24/   0 :                            ;OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   25/   0 :                            ;NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
   26/   0 :                            ;HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
   27/   0 :                            ;WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   28/   0 :                            ;FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   29/   0 :                            ;OTHER DEALINGS IN THE SOFTWARE.
   30/   0 :                            ;
   31/   0 :                            ;Repository https://github.com/Gazelle8087/EMU8008
   32/   0 :                            ;
   33/   0 :                            ;original source for SELBAL is available here under
   34/   0 :                            ;https://www.willegal.net/scelbi/the8008andScelbi.html
   35/   0 :                            ;
   36/   0 :                            ;2025/07/26 Rev. 1.00 Initial release
   37/   0 :                            ;2025/08/11 Rev. 1.10 remove SAVE LOAD command
   38/   0 :                            ;                     EXIT command implement (Return to DOS if run on emulator)
   39/   0 :                            ;                     MON  command implement (switch to Serial monitor)
   40/   0 :                            ;
   41/   0 :                            ;;; This is the Scelbi Basic Program from 1974 known as
   42/   0 :                            ;;; SCELBAL by Mark G. Arnold (MGA) and Nat Wadsworth  
   43/   0 :                            ;;;
   44/   0 :                            ;;;  Copyright 1975 Scelbi Computer Consulting, Inc.
   45/   0 :                            ;;;  All rights reserved
   46/   0 :                            ;;;
   47/   0 :                            ;;; MGA gives permission to use SCELBAL for 
   48/   0 :                            ;;; educational, historical, non-commercial purposes.
   49/   0 :                            ;;; Versions of this have been circulating on the web since
   50/   0 :                            ;;; about 2000; this version is authorized by MGA (Mar 2012)
   51/   0 :                            ;;; with the understanding no warranty is expressed or implied.
   52/   0 :                            ;;; As stated in the original, "no responsibility is assumed for
   53/   0 :                            ;;; for inaccuracies or for the success or failure of
   54/   0 :                            ;;; various applications to which the information herein
   55/   0 :                            ;;; may be applied."
   56/   0 :                            ;;; 
   57/   0 :                            ;;; SCELBAL is the only open-source, floating-point 
   58/   0 :                            ;;; high-level language ever implemented on Intel's first
   59/   0 :                            ;;; general-purpose microprocessor, the 8008.  It was
   60/   0 :                            ;;; published in book form:
 AS V1.42 Beta [Bld 290] - Source File sc1.asm - Page 2 - 8/11/2025 18:46:17


   61/   0 :                            ;;;
   62/   0 :                            ;;;  SCELBAL: A Higher-Level Language for 8008/8080 Systems
   63/   0 :                            ;;;
   64/   0 :                            ;;; (Tiny BASIC only used 16-bit integers; the MCM\70
   65/   0 :                            ;;; was a closed system; calculators implemented with 8008
   66/   0 :                            ;;; were floating-point, but not high-level.)
   67/   0 :                            ;;;
   68/   0 :                            ;;; This version is modified to assemble with the
   69/   0 :                            ;;; as8 assembler (using the -octal option) 
   70/   0 :                            ;;; for the Intel 8008 by Thomas E. Jones.
   71/   0 :                            ;;; This current form is made up non-relocatable so that
   72/   0 :                            ;;; locations of all code and data is identical to the
   73/   0 :                            ;;; original SCELBAL documents and patches.  It should be
   74/   0 :                            ;;; reasonable after debugging code to convert this to a
   75/   0 :                            ;;; relocatable and ROMable code with variables in RAM.
   76/   0 :                            ;;; This code originates from a version made by 
   77/   0 :                            ;;;
   78/   0 :                            ;;;    Steve Loboyko in 2001.
   79/   0 :                            ;;;
   80/   0 :                            ;;; This version has all 3 patches for SCELBAL (the two
   81/   0 :                            ;;; pasted in the original manual, and a third which was
   82/   0 :                            ;;; written in SCELBAL UPDATE publication, as well as
   83/   0 :                            ;;; a couple changes to constants which didn't actually
   84/   0 :                            ;;; require a patch, just changes to bytes of data or
   85/   0 :                            ;;; arguments to an instruction--one of these (Tucker) was 
   86/   0 :                            ;;; incorrect and restored to original by MGA March 2012).
   87/   0 :                            ;;; 
   88/   0 :                            ;;; This comment must be incorporated with any version of SCELBAL
   89/   0 :                            ;;; downloaded, distributed, posted or disemenated.
   90/   0 :                            
   91/   0 :                            		CPU	8008new
   92/   0 :                            		page	0
   93/   0 :                            
   94/   0 :                            hi		FUNCTION hex4, hex4/256		;midified by Gazelle
   95/   0 :                            lo		FUNCTION hex4, hex4&0ffh	;modified by Gazelle
   96/   0 :                            
   97/   0 :                            
   98/   0 : =1EH                       ENDPGRAM	EQU	1eh	;055o	;MGA 4/10/12 as in orig; for his ROMable Loboyko said 077       [077]
   99/   0 : =6H                        BGNPGRAM	EQU	6h	;033o	;MGA 4/10/12 as in orig; for his ROMable Loboyko said 044       [044]
  100/   0 : =2000H                     code_start	EQU	2000h
  101/   0 : =41H                       INT_PTR		EQU	41h	; DO NOT change, Should match to PIC firmware
  102/   0 : =0H                        IN_STATUS	EQU 	00h	; DO NOT change, Should match to PIC firmware
  103/   0 : =1H                        IN_DATA		EQU	01h	; DO NOT change, Should match to PIC firmware
  104/   0 : =10H                       OUT_DATA	EQU 	10h	; DO NOT change, Should match to PIC firmware
  105/   0 :                            
  106/   0 :                            ;;; Here are labels originally attempting to make the code
  107/   0 :                            ;;; relocatable.  These 4 pages contain variable data
  108/   0 :                            ;;; which needs to be relocated from ROM to RAM.
  109/   0 :                            ;;; I can't vouch for ALL references to these pages in
  110/   0 :                            ;;; the code being switched to these labels, but they
  111/   0 :                            ;;; seem to be.
  112/   0 :                            
  113/   0 : =2H                        PG01		EQU	2	;OLDPG1:	EQU	001#000
  114/   0 : =3D00H                     ORG_PG01	EQU	3D00H
  115/   0 : =3H                        PG26		EQU	3	;OLDPG26:	EQU	026#000
  116/   0 : =3E00H                     ORG_PG26	EQU	3E00H
  117/   0 : =4H                        PG27		EQU	4	;OLDPG27:	EQU	027#000
  118/   0 : =3F00H                     ORG_PG27	EQU	3F00H
  119/   0 : =5H                        PG57		EQU	5	;OLDPG57:	EQU	057#000
  120/   0 :                            
  121/   0 :                            ;;; Page zero will contain the I/O Routines.  These are actually
  122/   0 :                            ;;; just as suggested by Scelbal Manual for Serial I/O.
  123/   0 :                            
  124/2000 :                            		org	code_start
  125/2000 :                            
  126/2000 : 44 81 20                   		JMP	HAJIME
  127/2003 : 7C                         OPN:		db	OPN_MSG1 - OPN_MSG
  128/2004 : 46 61 73 74 65 72 20 53 43 OPN_MSG:	db	"Faster SCELBAL (2012)",0dh,0ah
      200D : 45 4C 42 41 4C 20 28 32 30
      2016 : 31 32 29 0D 0A            
  129/201B : 43 6F 64 65 20 52 65 6C 6F 		db	"Code Relocation, IO and start up code by Gazelle 2025",0dh,0ah
      2024 : 63 61 74 69 6F 6E 2C 20 49
      202D : 4F 20 61 6E 64 20 73 74 61
      2036 : 72 74 20 75 70 20 63 6F 64
      203F : 65 20 62 79 20 47 61 7A 65
      2048 : 6C 6C 65 20 32 30 32 35 0D
      2051 : 0A                        
  130/2052 : 52 65 76 2E 20 31 2E 31 30 		db	"Rev. 1.10 Assembled on ",DATE," at ",TIME,0dh,0ah
      205B : 20 41 73 73 65 6D 62 6C 65
      2064 : 64 20 6F 6E 20 38 2F 31 31
      206D : 2F 32 30 32 35 20 61 74 20
      2076 : 31 38 3A 34 36 3A 31 37 0D
      207F : 0A                        
  131/2080 : 00                         OPN_MSG1:	db	0
  132/2081 :                            
  133/2081 : 2E 20                      HAJIME:		MVI	H,OPN / 256
  134/2083 : 36 03                      		MVI	L,OPN - OPN/256*256
  135/2085 : 46 6D 22                   		CALL	TEXTC
  136/2088 :                            
  137/2088 : 1E 3D                      		MVI	D,ORG_PG01/256
  138/208A : 26 02                      		MVI	E,PG01
  139/208C : 36 00                      		MVI	L,0
  140/208E : EB                         LOOP_PG01:	MOV	H,D
  141/208F : C7                         		MOV	A,M
  142/2090 : EC                         		MOV	H,E
  143/2091 : F8                         		MOV	M,A
  144/2092 : 30                         		INR	L
  145/2093 : 48 8E 20                   		JNZ	LOOP_PG01
  146/2096 :                            
  147/2096 : 1E 3E                      		MVI	D,ORG_PG26/256
  148/2098 : 26 03                      		MVI	E,PG26
  149/209A : 36 00                      		MVI	L,0
  150/209C : EB                         LOOP_PG26:	MOV	H,D
  151/209D : C7                         		MOV	A,M
  152/209E : EC                         		MOV	H,E
  153/209F : F8                         		MOV	M,A
  154/20A0 : 30                         		INR	L
  155/20A1 : 48 9C 20                   		JNZ	LOOP_PG26
  156/20A4 :                            
  157/20A4 : 1E 3F                      		MVI	D,ORG_PG27/256
  158/20A6 : 26 04                      		MVI	E,PG27
  159/20A8 : 36 00                      		MVI	L,0
  160/20AA : EB                         LOOP_PG27:	MOV	H,D
  161/20AB : C7                         		MOV	A,M
  162/20AC : EC                         		MOV	H,E
  163/20AD : F8                         		MOV	M,A
  164/20AE : 30                         		INR	L
  165/20AF : 48 AA 20                   		JNZ	LOOP_PG27
  166/20B2 :                            
  167/20B2 : 44 26 28                   		JMP	ENTRY_SCR
  168/20B5 :                            ;---------------------------------------------------------------------
  169/20B5 :                            ;		HARDWARE DEPENDENT ROUTINE
  170/20B5 :                            EXIT:
  171/20B5 : 7F                         		OUT	1FH	; Exit from emulator.
  172/20B6 :                            
  173/20B6 :                            ;;; no user defined functions yet, stop here if we see one.
  174/20B6 : 44 D2 27                   UDEFX		JMP	exec
  175/20B9 :                            
  176/20B9 : =1EFCH                     JMP_ADDR	equ 1EFCH
  177/20B9 :                            
  178/20B9 : 2E 1E                      MON:		MVI H,hi(JMP_ADDR)
  179/20BB : 36 FC                      		MVI L,lo(JMP_ADDR)
  180/20BD : 3E 55                      		MVI M,55H	; store "OUT 10" instruction at 'jmp_addr'  
  181/20BF : 30                         		INR L
  182/20C0 : 3E 44                      		MVI M,44H	; store "JMP" instruction at 'jmp_addr'+1
  183/20C2 : 30                         		INR L
  184/20C3 : 3E 00                      		MVI M,00H	; store "00H" (the lo byte of address 2000H) at 'jmp_addr'+2
  185/20C5 : 30                         		INR L
  186/20C6 : 3E 20                      		MVI M,20H	; store "20H" (the hi byte of address 2000H) at 'jmp_addr'+3
  187/20C8 : 06 00                      		MVI A,00H	; ROM access offset(=00) for first 8K of ROM area
  188/20CA : 44 FC 1E                   		JMP JMP_ADDR 	; jump to the beginning monitor the first bank 8K of ROM
  189/20CD :                            
  190/20CD : 41                         CINP:		IN	IN_STATUS
  191/20CE : 24 01                      		ANI	1
  192/20D0 : 68 CD 20                   		JZ	CINP
  193/20D3 :                            
  194/20D3 : 43                         		IN	IN_DATA
  195/20D4 : 3C 08                      		CPI	08H
  196/20D6 : 68 DD 20                   		JZ	CINP_BS
  197/20D9 : 61                         		OUT	OUT_DATA
  198/20DA : 34 80                      		ORI	80H
  199/20DC : 07                         		RET
  200/20DD :                            
  201/20DD : 06 FF                      CINP_BS:	MVI	A,0FFH
  202/20DF : 07                         		RET
  203/20E0 :                            
  204/20E0 : 3C DC                      CPRINT:		CPI	0DCH
  205/20E2 : 68 00 21                   		JZ	CP_BS
  206/20E5 : 24 7F                      		ANI	7Fh
  207/20E7 : 3C 0D                      		CPI	0DH
  208/20E9 : 68 F6 20                   		JZ	CP_OK
  209/20EC : 3C 0A                      		CPI	0AH
  210/20EE : 68 F6 20                   		JZ	CP_OK
  211/20F1 : 3C 20                      		CPI	20H
  212/20F3 : 60 FF 20                   		JC	CP_NO
  213/20F6 :                            
  214/20F6 : E8                         CP_OK:		MOV	H,A
  215/20F7 : 41                         CPRINT_1:	IN	IN_STATUS
  216/20F8 : 24 02                      		ANI	2
  217/20FA : 68 F7 20                   		JZ	CPRINT_1
  218/20FD : C5                         		MOV	A,H
  219/20FE : 61                         		OUT	OUT_DATA
  220/20FF : 07                         CP_NO:		RET
  221/2100 :                            
  222/2100 : 41                         CP_BS:		IN	IN_STATUS
  223/2101 : 24 02                      		ANI	2
  224/2103 : 68 00 21                   		JZ	CP_BS
  225/2106 : 06 08                      		MVI	A,08H
  226/2108 : 61                         		OUT	OUT_DATA
  227/2109 :                            
  228/2109 : 41                         CP_BS2:		IN	IN_STATUS
  229/210A : 24 02                      		ANI	2
  230/210C : 68 09 21                   		JZ	CP_BS2
  231/210F : 06 20                      		MVI	A,20H
  232/2111 : 61                         		OUT	OUT_DATA
  233/2112 :                            
  234/2112 : 41                         CP_BS3:		IN	IN_STATUS
  235/2113 : 24 02                      		ANI	2
  236/2115 : 68 12 21                   		JZ	CP_BS3
  237/2118 : 06 08                      		MVI	A,08H
  238/211A : 61                         		OUT	OUT_DATA
  239/211B : 07                         		RET
  240/211C :                            
  241/211C :                            ;           ORG	code_start	;002#000		; START PAGE 02, THE CODE
  242/211C :                            
  243/211C : 46 C9 21                   SYNTAX:    CALL	CLESYM		;Clear the SYMBOL BUFFER area
  244/211F : 36 E0                                 MVI	L,0e0h	;340o	;Set L to start of LINE NUMBER BUFFER
  245/2121 : 2E 03                                 MVI	H,PG26	;	;** Set H to page of LINE NUMBER BUFFER
  246/2123 : 3E 00                                 MVI	M,0	;000o	;Initialize line number buff by placing zero as (cc)
  247/2125 : 36 81                                 MVI	L, 201o		;Change pointer to syntax counter/pointer storage loc.
  248/2127 : 3E 01                                 MVI	M, 001o		;Set pointer to first character (after cc) in line buffer
  249/2129 : 36 81                      SYNTX1:    MVI	L, 201o		;Set pointer to syntax cntr/pntr storage location
  250/212B : 46 BC 21                              CALL	GETCHR		;Fetch the character pointed to by contents of syntax
  251/212E : 68 40 21                              JZ	SYNTX2		;Cntr/pntr from the line input buffer. If character was
  252/2131 : 3C B0                                 CPI	260o		;A space, ignore. Else, test to see if character was ASCII
  253/2133 : 70 4D 21                              JM	SYNTX3		;Code for a decimal digit. If not a decimal digit, consider
  254/2136 : 3C BA                                 CPI	272o		;Line number to have been processed by jumping
  255/2138 : 50 4D 21                              JP	SYNTX3		;Over the remainder of this SYNTX1 section.
  256/213B : 36 E0                                 MVI	L, 340o		;If have decimal digit, set pointer to start of LINE
  257/213D : 46 E8 21                              CALL	CONCT1		;NUMBER BUFFER and append incoming digit there.
  258/2140 : 36 81                      SYNTX2:    MVI	L, 201o		;Reset L to syntax cntr/pntr storage location. Call sub-
  259/2142 : 46 1F 22                              CALL	LOOP		;Routine to advance pntr and test for end of inr)ut buffer
  260/2145 : 48 29 21                              JNZ	SYNTX1		;If not end of input buffer, go back for next digit
  261/2148 : 36 83                                 MVI	L, 203o		;If end of buffer, only had a line number in the line.
  262/214A : 3E 00                                 MVI	M, 000o		;Set pntr to TOKEN storage location. Set TOKEN = 000.
  263/214C : 07                                    RET			;Return to caller.
  264/214D : 36 81                      SYNTX3:    MVI	L, 201o		;Reset pointer to syntax cntr/pntr and fetch
  265/214F : CF                                    MOV	B,M		;Position of next character after the line number
  266/2150 : 36 82                                 MVI	L, 202o		;Change pntr to SCAN pntr storage location
  267/2152 : F9                                    MOV	M,B		;Store address when SCAN takes up after line number
  268/2153 : 36 82                      SYNTX4:    MVI	L, 202o		;Set pntr to SCAN pntr stomge location
  269/2155 : 46 BC 21                              CALL	GETCHR		;Fetch the character pointed to by contents of the SCAN
  270/2158 : 68 70 21                              JZ	SYNTX6		;Pointer storage location. If character was ASCII code
  271/215B : 3C BD                                 CPI	275o		;For space, ignore. Else, compare character with "=" sign
  272/215D : 68 A4 21                              JZ	SYNTX7		;If is an equal sign, go set TOKEN for IMPLIED LET.
  273/2160 : 3C A8                                 CPI	250o		;Else, compare character with left parenthesis " ( "
  274/2162 : 68 A9 21                              JZ	SYNTX8		;If left parenthesis, go set TOKEN for implied array LET
  275/2165 : 46 E4 21                              CALL	CONCTS		;Otherwise, concatenate the character onto the string
  276/2168 :                            				; MGA 4/2012 begin "fast SYNTX5" patch: 
  277/2168 :                            				; the following patch doubles the overall speed of execution.  
  278/2168 :                            				; It is similar to the approach taken on 8080 SCELBAL II in 1978 
  279/2168 :                            				; it adhears to the rules for patches in issue 1 of SCELBAL update 
  280/2168 :                            				;SYNTX6:   these four lines moved up w/o label
  281/2168 : 36 82                                 MVI	L, 202o		;Set L to SCAN pointer storage location
  282/216A :                            				;LHI \HB\OLDPG26       ;** Set H to page of SCAN pointer stomge location
  283/216A :                            				;MGA 4/2012 except LHI needed at original place, not here 
  284/216A : 46 1F 22                              CALL	LOOP		;Call routine to advance pntr & test for end of In buffer
  285/216D : 48 53 21                              JNZ	SYNTX4		;Go back and add another character to SYMBOL BUFF
  286/2170 :                            SYNTX6:   			; MGA 4/2012 label here 
  287/2170 : 36 83                                 MVI	L, 203o		;Being constructed in the SYMBOL BUFFER. Now set
  288/2172 : 3E 01                                 MVI	M, 001o		;Up TOKEN storage location to an initial value of 001.
  289/2174 : 2E 04                                 MVI	H,PG27		;\HB\OLDPG27   ;** Set H to point to start of KEYWORD TABLE.
  290/2176 : 36 00                                 MVI	L, 000o		;Set L to point to start of KEYWORD TABLE.
  291/2178 : 1E 03                      SYNTX5:    MVI	D,PG26		;\HB\OLDPG26   ;** Set D to page of SYMBOL BUFFER
  292/217A : 26 50                                 MVI	E, 120o		;Set E to start of SYMBOL BUFFER
  293/217C : 46 F6 21                              CALL	STRCP		;Compare char string presently in SYMBOL BUFFER
  294/217F : 2B                                    RZ			;With entry in KEYWORD TABLE. Exit if match.
  295/2180 : 46 F5 31                              CALL	SWITCH		;TOKEN will be set to keyword found. Else, switch
  296/2183 : 30                         SYNTXL:    INR	L		;Pointers to get table address back and advance pntr to
  297/2184 : C7                                    MOV	A,M		;KEYWORD TABLE. Now look for start of next entry
  298/2185 : 24 C0                                 ANI	300o		;In KEYWORD TABLE by looking for (cc) byte which
  299/2187 : 48 83 21                              JNZ	SYNTXL             ;Will NOT have a one in the two most sig. bits. Advance
  300/218A : 46 F5 31                              CALL	SWITCH             ;Pntr til next entry found. Then switch pointers apin so
  301/218D : 36 83                                 MVI	L, 203o               ;Table pointer is in D&E. Put addr of TOKEN in L.
  302/218F : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** And page of TOKEN in H. Fetch the value currently
  303/2191 : CF                                    MOV	B,M                    ;In TOKEN and advance it to account for going on to
  304/2192 : 08                                    INR	B                    ;The next entry in the KEYWORD TABLE.
  305/2193 : F9                                    MOV	M,B                    ;Restore the updated TOKEN value back to storage.
  306/2194 : 46 F5 31                              CALL	SWITCH             ;Restore the keyword table pointer back to H&L.
  307/2197 : C1                                    MOV	A,B                    ;Put TOKEN count in ACC.
  308/2198 : 3C 0D                                 CPI	015o               ;See if have tested all entries in the keyword table.
  309/219A : 48 78 21                              JNZ	SYNTX5             ;If not, continue checking the keyword table.
  310/219D :                            				;MGA 4/2012 3 of 4 lines removed below (keep LHI)
  311/219D : 2E 16                                 MVI	H, 26o	;\HB\OLDPG26        ;** Set H to page of SCAN pointer stomge location
  312/219F :                            				; MGA 4/2012 end of "fast SYNTX5" patch: 
  313/219F : 36 83                                 MVI	L, 203o               ;And search table for KEYWORD again. Unless reach
  314/21A1 : 3E FF                                 MVI	M, 377o               ;End of line input buffer. In which case set TOKEN=377
  315/21A3 : 07                                    RET                    ;As an error indicator and exit to caMVI L,ng routine.
  316/21A4 : 36 83                      SYNTX7:    MVI	L, 203o               ;Set pointer to TOKEN storage register. Set TOKEN
  317/21A6 : 3E 0D                                 MVI	M, 015o               ;Equal to 015 when "=" sign found for IMPLIED LET.
  318/21A8 : 07                                    RET                    ;Exit to caMVI L,ng routine.
  319/21A9 : 36 83                      SYNTX8:    MVI	L, 203o               ;Set pointer to TOKEN storage register. Set TOKEN
  320/21AB : 3E 0E                                 MVI	M, 016o               ;Equal to 016 when "(" found for IMPLIED array LET.
  321/21AD : 07                                    RET                    ;Exit to calling routine.
  322/21AE :                            
  323/21AE :                                                              ;The following are subroutines used by SYNTAX and
  324/21AE :                                                              ;other routines in SCELBAL.
  325/21AE :                            
  326/21AE : 06 C2                      BIGERR:    MVI	A, 302o               ;Load ASCII code for letters B and G to indicate BIG
  327/21B0 : 16 C7                                 MVI	C, 307o               ;ERROR (for when buffer, stack,etc., overflows).
  328/21B2 : 46 9E 22                   ERROR:     CALL	ECHO               ;Call user provided display routine to print ASCII code
  329/21B5 : C2                                    MOV	A,C                    ;In accumulator. Transfer ASCII code from C to ACC
  330/21B6 : 46 9E 22                              CALL	ECHO               ;And repeat to display error codes.
  331/21B9 : 44 D7 29                              JMP	FINERR             ;Go cpmplete error message (AT LINE) as required.
  332/21BC : C7                         GETCHR:    MOV	A,M                    ;Get pointer from memory location pointed to by H&L
  333/21BD : 3C 50                                 CPI	120o               ;See if within range of line input buffer.
  334/21BF : 50 AE 21                              JP	BIGERR             ;If not then have an overflow condition = error.
  335/21C2 : F0                                    MOV	L,A                    ;Else can use it as addr of character to fetch from the
  336/21C3 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** LINE INPUT BUFFER by setting up H too.
  337/21C5 : C7                                    MOV	A,M                    ;Fetch the character from the line input buffer.
  338/21C6 : 3C A0                                 CPI	240o               ;See if it is ASCII code for space.
  339/21C8 : 07                                    RET                    ;Return to caller with flags set according to comparison.
  340/21C9 : 36 50                      CLESYM:    MVI	L, 120o               ;Set L to start of SYMBOL BUFFER.
  341/21CB : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of SYMBOL BUFFER.
  342/21CD : 3E 00                                 MVI	M, 000o               ;Place a zero byte at start of SYMBOL BUFFER.
  343/21CF : 07                                    RET                    ;To effectively clear the buffer. Then exit to caller.
  344/21D0 :                            
  345/21D0 :                            
  346/21D0 :                                                              ;Subroutine to concatenate (append) a character to the
  347/21D0 :                                                              ;SYMBOL BUFFER. Character must be alphanumeric.
  348/21D0 :                            
  349/21D0 : 3C C1                      CONCTA:    CPI	301o               ;See if character code less than that for letter A.
  350/21D2 : 70 DA 21                              JM	CONCTN             ;If so, go see if it is numeric.
  351/21D5 : 3C DB                                 CPI	333o               ;See if character code greater than that for letter Z.
  352/21D7 : 70 E4 21                              JM	CONCTS             ;If not, have valid alphabetical character.
  353/21DA : 3C B0                      CONCTN:    CPI	260o               ;Else, see if character in valid numeric range.
  354/21DC : 70 F3 21                              JM	CONCTE             ;If not, have an error condition.
  355/21DF : 3C BA                                 CPI	272o               ;Continue to check for valid number.
  356/21E1 : 50 F3 21                              JP	CONCTE             ;If not, have an error condition.
  357/21E4 : 36 50                      CONCTS:    MVI	L, 120o               ;If character alphanumeric, can concatenate. Set pointer
  358/21E6 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** To starting address of SYMBOL BUFFER.
  359/21E8 : D7                         CONCT1:    MOV	C,M                    ;Fetch old character count in SYMBOL BUFFER.
  360/21E9 : 10                                    INR	C                    ;Increment the value to account for adding new
  361/21EA : FA                                    MOV	M,C                    ;Character to the buffer. Restore updated (cc).
  362/21EB : C8                                    MOV	B,A                    ;Save character to be appended in register B.
  363/21EC : 46 25 32                              CALL	INDEXC             ;Add (cc) to address in H & L to get new end of buffer
  364/21EF : F9                                    MOV	M,B                    ;Address and append the new character to buffer
  365/21F0 : 06 00                                 MVI	A, 000o               ;Clear the accumulator
  366/21F2 : 07                                    RET                    ;Exit to caller
  367/21F3 : 44 86 28                   CONCTE:    JMP	SYNERR             ;If character to be appended not alphanumeric, ERROR!
  368/21F6 :                            
  369/21F6 :                                                              ;Subroutine to compare
  370/21F6 :                                                              ;character strings pointed to by
  371/21F6 :                                                              ;register pairs D & E and H & L.
  372/21F6 :                            
  373/21F6 : C7                         STRCP:     MOV	A,M                    ;Fetch (cc) of first string.
  374/21F7 : 46 F5 31                              CALL	SWITCH             ;Switch pointers and fetch length of second string (cc)
  375/21FA : CF                                    MOV	B,M                    ;Into register B. Compare the lengths of the two strings.
  376/21FB : B9                                    CMP	B                    ;If they are not the same
  377/21FC : 0B                                    RNZ                    ;Return to caller with flags set to non-zero condition
  378/21FD : 46 F5 31                              CALL	SWITCH             ;Else, exchange the pointers back to first string.
  379/2200 : 46 1B 22                   STRCPL:    CALL	ADV                ;Advance the pointer to string number 1 and fetch a
  380/2203 : C7                                    MOV	A,M                    ;Character from that string into the accumulator.
  381/2204 : 46 F5 31                              CALL	SWITCH             ;Now switch the pointers to string number 2.
  382/2207 : 46 1B 22                              CALL	ADV                ;Advance the pointer in line number 2.
  383/220A : BF                         STRCPE:    CMP	M                    ;Compare char in stxing 1 (ACC) to string 2 (memory)
  384/220B : 0B                                    RNZ                    ;If not equal, return to cauer with flags set to non-zero
  385/220C : 46 F5 31                              CALL	SWITCH             ;Else, exchange pointers to restore pntr to string 1
  386/220F : 09                                    DCR	B                    ;Decrement the string length counter in register B
  387/2210 : 48 00 22                              JNZ	STRCPL             ;If not finiahed, continue testing entire string
  388/2213 : 07                                    RET                    ;If complete match, return with flag in zero condition
  389/2214 : C7                         STRCPC:    MOV	A,M                    ;Fetch character pointed to by pointer to string 1
  390/2215 : 46 F5 31                              CALL	SWITCH             ;Exchange pointer to examine string 2
  391/2218 : 44 0A 22                              JMP	STRCPE             ;Continue the string comparison loop
  392/221B :                            
  393/221B :                                                              ;Subroutine to advance the two byte
  394/221B :                                                              ;value in CPU registers H and L.
  395/221B :                            
  396/221B : 30                         ADV:       INR	L                    ;Advance value in register L.
  397/221C : 0B                                    RNZ                    ;If new value not zero, return to caller.
  398/221D : 28                                    INR	H                    ;Else must increment value in H
  399/221E : 07                                    RET                    ;Before retuming to caller
  400/221F :                            
  401/221F :                                                              ;Subroutine to advance a buffer pointer
  402/221F :                                                              ;and test to see if the end of the buffer
  403/221F :                                                              ;has been reached.
  404/221F :                            
  405/221F : CF                         LOOP:      MOV	B,M                    ;Fetch memory location pointed to by H & L into B.
  406/2220 : 08                                    INR	B                    ;Increment the value.
  407/2221 : F9                                    MOV	M,B                    ;Restore it back to memory.
  408/2222 : 36 00                                 MVI	L, 000                ;Change pointer to start of INPUT LINE BUFFER
  409/2224 : C7                                    MOV	A,M                    ;Fetch buffer length (cc) value into the accumulator
  410/2225 : 09                                    DCR	B                    ;Make value in B original value
  411/2226 : B9                                    CMP	B                    ;See if buffer length same as that in B
  412/2227 : 07                                    RET                    ;Return with flags yielding results of the comparison
  413/2228 :                            
  414/2228 :                                                              ;The following subroutine is used to
  415/2228 :                                                              ;input characters from the system's
  416/2228 :                                                              ;input device (such as a keyboard)
  417/2228 :                                                              ;into the LINE INPUT BUFFER. Routine has limited
  418/2228 :                                                              ;editing capability included.
  419/2228 :                                                              ;(Rubout = delete previous character(s) entered.)
  420/2228 :                            ;;; This label, STRIN:	should be location 03 014 030ch
  421/2228 : 16 00                      STRIN:     MVI	C, 000                ;Initialize register C to zero.
  422/222A : 46 AD 22                   STRIN1:    CALL	CINPUT             ;Call user provided device input subroutine to fetch one
  423/222D : 3C FF                                 CPI	0FFH	;modifiedby gazelle 2025/6/1 ;377o  ;Character from the input device. Is it ASCII code for
  424/222F : 48 41 22                              JNZ	NOTDEL             ;Rubout? Skip to next section if not rubout.
  425/2232 :                            ;          MVI	A, 0DCH	;modified by Gazelle 2025/6/1 ;334o ;Else, load ASCII code for backslash into ACC.
  426/2232 :                            ;          CALL	ECHO	;modified by gazelle 2025/6/1 ;Call user display driver to present backslash as a delete
  427/2232 : 11                                    DCR	C                    ;Indicator. Now decrement the input character counter.
  428/2233 : 70 28 22                              JM	STRIN              ;If at beginning of line do NOT decrement H and L.
  429/2236 : 46 90 22                              CALL	DEC                ;Else, decrement H & L line pointer to erase previous
  430/2239 : 06 DC                                 MVI	A, 0DCH	;modified by gazelle 2025/6/1
  431/223B : 46 9E 22                              CALL	ECHO	;modified by gazelle 2025/6/1
  432/223E :                            
  433/223E : 44 2A 22                              JMP	STRIN1             ;Entry, then go back for a new input.
  434/2241 : 3C 83                      NOTDEL:    CPI	203o               ;See if character inputted was'CONTROL C'
  435/2243 : 68 D0 29                              JZ	CTRLC              ;If so, stop inputting and go back to the EXECutive
  436/2246 : 3C 8D                                 CPI	215o               ;If not, see if character was carriage-return
  437/2248 : 68 5E 22                              JZ	STRINF             ;If so, have end of line of input
  438/224B : 3C 8A                                 CPI	212o               ;If not, see if character was line-feed
  439/224D : 68 2A 22                              JZ	STRIN1             ;If so, ignore the input, get another character
  440/2250 : 46 1B 22                              CALL	ADV                ;If none of the above, advance contents of H & L
  441/2253 : 10                                    INR	C                    ;Increment the character counter
  442/2254 : F8                                    MOV	M,A                    ;Store the new character in the line input buffer
  443/2255 : C2                                    MOV	A,C                    ;Put new character count in the accumulator
  444/2256 : 3C 50                                 CPI	120o               ;Make sure maximum buffer size not exceeded
  445/2258 : 50 AE 21                              JP	BIGERR             ;If buffer size exceeded, go display BG error message
  446/225B : 44 2A 22                              JMP	STRIN1             ;Else can go back to look for next input
  447/225E : CA                         STRINF:    MOV	B,C                    ;Transfer character count from C to B
  448/225F : 46 67 22                              CALL	SUBHL              ;Subtract B from H & L to get starting address of
  449/2262 : FA                                    MOV	M,C                    ;The string and place the character count (cc) there
  450/2263 : 46 7D 22                              CALL	CRLF               ;Provide a line ending CR & LF combination on the
  451/2266 : 07                                    RET                    ;Display device. Then exit to caller.
  452/2267 :                            
  453/2267 :                                                              ;Subroutine to subtract contents of CPU register B from
  454/2267 :                                                              ;the two byte value in CPU registers H & L.
  455/2267 :                            
  456/2267 : C6                         SUBHL:     MOV	A,L                    ;Load contents of register L into the accumulator
  457/2268 : 91                                    SUB	B                    ;Subtract the contents of register B
  458/2269 : F0                                    MOV	L,A                    ;Restore the new value back to L
  459/226A : 03                                    RNC                    ;If no carry, then no underflow. Exit to caller.
  460/226B : 29                                    DCR	H                    ;Else must also decrement contents of H.
  461/226C : 07                                    RET                    ;Before retuming to caller.
  462/226D :                            
  463/226D :                                                              ;Subroutine to display a character string on the system's
  464/226D :                                                              ;display device.
  465/226D :                            
  466/226D : D7                         TEXTC:     MOV	C,M                    ;Fetch (cc) from the first location in the buffer (H & L
  467/226E : C7                                    MOV	A,M                    ;Pointing there upon entry) into register B and ACC.
  468/226F : A0                                    ANA	A                    ;Test the character count value.
  469/2270 : 2B                                    RZ                    ;No display if (cc) is zero.
  470/2271 : 46 1B 22                   TEXTCL:    CALL	ADV                ;Advance pointer to next location in buffer
  471/2274 : C7                                    MOV	A,M                    ;Fetch a character from the buffer into ACC
  472/2275 : 46 9E 22                              CALL	ECHO               ;Call the user's display driver subroutine
  473/2278 : 11                                    DCR	C                    ;Decrement the (cc)
  474/2279 : 48 71 22                              JNZ	TEXTCL             ;If character counter not zero, continue display
  475/227C : 07                                    RET                    ;Exit to caller when (cc) is zero.
  476/227D :                            
  477/227D :                                                              ;Subroutine to provide carriage-return and line-feed
  478/227D :                                                              ;combination to system's display device. Routine also
  479/227D :                                                              ;initializes a column counter to zero. Column counter
  480/227D :                                                              ;is used by selected output routines to count the num-
  481/227D :                                                              ;ber of characters that have been displayed on a line.
  482/227D :                            
  483/227D : 06 8D                      CRLF:      MVI	A, 215o               ;Load ASCII code for carriage-return into ACC
  484/227F : 46 9E 22                              CALL	ECHO               ;Call user provided display driver subroutine
  485/2282 : 06 8A                                 MVI	A, 212o               ;Load ASCII code for line-feed into ACC
  486/2284 : 46 9E 22                              CALL	ECHO               ;Call user provided display driver subroutine
  487/2287 : 36 23                                 MVI	L, 043o               ;Set L to point to COLUMN COUNTER storage location
  488/2289 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of COLUMN COUNTER
  489/228B : 3E 01                                 MVI	M, 001o               ;Initialize COLUMN COUNTER to a value of one
  490/228D : EB                                    MOV	H,D                    ;Restore H from D (saved by ECHO subroutine)
  491/228E : F4                                    MOV	L,E                    ;Restore L from E (saved by ECHO subroutine)
  492/228F : 07                                    RET                    ;Then exit to calling routine
  493/2290 :                            
  494/2290 :                                                              ;Subroutine to decrement double-byte value in CPU
  495/2290 :                                                              ;registers H and L.
  496/2290 :                            
  497/2290 : 31                         DEC:       DCR	L                    ;Decrement contents of L
  498/2291 : 30                                    INR	L                    ;Now increment to exercise CPU flags
  499/2292 : 48 96 22                              JNZ	DECNO              ;If L not presently zero, skip decrementing H
  500/2295 : 29                                    DCR	H                    ;Else decrement H
  501/2296 : 31                         DECNO:     DCR	L                    ;Do the actual decrement of L
  502/2297 : 07                                    RET                    ;Return to caller
  503/2298 :                            
  504/2298 :                            
  505/2298 :                                                              ;Subroutine to index the value in CPU registers H and L
  506/2298 :                                                              ;by the contents of CPU register B.
  507/2298 :                            
  508/2298 : C6                         INDEXB:    MOV	A,L                    ;Load L into the accumulator
  509/2299 : 81                                    ADD	B                    ;Add B to that value
  510/229A : F0                                    MOV	L,A                    ;Restore the new value to L
  511/229B : 03                                    RNC                    ;If no carry,  return to caller
  512/229C : 28                                    INR	H                    ;Else, increment value in H
  513/229D : 07                                    RET                    ;Before returning to caller
  514/229E :                            
  515/229E :                                                              ;The following subroutine is used to
  516/229E :                                                              ;display the ASCII encoded character in the ACC on the
  517/229E :                                                              ;system's display device. This routine calls a routine
  518/229E :                                                              ;labeled CINPUT which must be provided by the user to
  519/229E :                                                              ;actually drive the system's output device. The subroutine
  520/229E :                                                              ;below also increments an output column counter each time
  521/229E :                                                              ;it is used.
  522/229E :                            
  523/229E : DD                         ECHO:      MOV	D,H                    ;Save entry value of H in register D
  524/229F : E6                                    MOV	E,L                    ;And save entry value of L in register E
  525/22A0 : 36 23                                 MVI	L, 043o               ;Set L to point to COLUMN COUNTER storage location
  526/22A2 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of COLUMN COUNTER
  527/22A4 : CF                                    MOV	B,M                    ;Fetch the value in the COLUMN COUNTER
  528/22A5 : 08                                    INR	B                    ;And increment it for each character displayed
  529/22A6 : F9                                    MOV	M,B                    ;Restore the updated count in memory
  530/22A7 : 46 E0 20                              CALL	CPRINT             ;tt Call the user's device driver subroutine
  531/22AA : EB                                    MOV	H,D                    ;Restore entry value of H from D
  532/22AB : F4                                    MOV	L,E                    ;Restore entry value of L from E
  533/22AC : 07                                    RET                    ;Return to calling routine
  534/22AD : 44 CD 20                   CINPUT:	   JMP	CINP               ;Reference to user defined input subroutine
  535/22B0 :                            
  536/22B0 :                            ;;; The label EVAL: SHOULD BE AT 03 224 0394h
  537/22B0 : 36 97                      EVAL:      MVI	L, 227o               ;Load L with address of ARITHMETIC STACK pointer
  538/22B2 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of ARITHMETIC STACK pointer
  539/22B4 : 3E 94                                 MVI	M, 224o               ;Initialize ARITH STACK pointer value to addr minus 4
  540/22B6 : 30                                    INR	L                    ;Advance memory pointer to FUN/ARRAY STACK pntr
  541/22B7 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of FUN/ARRAY STACK pointer
  542/22B9 : 3E 00                                 MVI	M, 000o               ;Initialize FUNIARRAY STACK pointer to start of stack
  543/22BB : 46 C9 21                              CALL	CLESYM             ;Initialize the SYMBOL BUFFER to empty condition
  544/22BE : 36 88                                 MVI	L, 210o               ;Load L with address of OPERATOR STACK pointer
  545/22C0 : 3E 00                                 MVI	M, 000                ;Initialize OPERATOR STACK pointer value
  546/22C2 : 36 BE                                 MVI	L, 276o               ;Set L to address of EVAL pointer (start of expression)
  547/22C4 : CF                                    MOV	B,M                    ;Fetch the EVAL pointer value into register B
  548/22C5 : 36 80                                 MVI	L, 200o               ;Set up a working pointer register in this location
  549/22C7 : F9                                    MOV	M,B                    ;And initialize EVAL CURRENT pointer
  550/22C8 : 36 80                      SCAN1:     MVI	L, 200o               ;Load L with address of EVAL CURRENT pointer
  551/22CA : 46 BC 21                              CALL	GETCHR             ;Fetch a character in the expression being evaluated
  552/22CD : 68 DD 23                              JZ	SCAN10             ;If character is a space, jump out of this section
  553/22D0 : 3C AB                                 CPI	253o               ;See if character is a "+" sign
  554/22D2 : 48 DC 22                              JNZ	SCAN2              ;If not, continue checking for an operator
  555/22D5 : 36 7E                                 MVI	L, 176o               ;If yes, set pointer to PARSER TOKEN storage location
  556/22D7 : 3E 01                                 MVI	M, 001                ;Place TOKEN value for "+" sign in PARSER TOKEN
  557/22D9 : 44 05 23                              JMP	SCANFN             ;Go to PARSER subroutine entry point
  558/22DC : 3C AD                      SCAN2:     CPI	255o               ;See if character is a minus ("-") sign
  559/22DE : 48 0B 23                              JNZ	SCAN4              ;If not, continue checking for an operator
  560/22E1 : 36 50                                 MVI	L, 120o               ;If yes, check the length of the symbol stored in the
  561/22E3 : C7                                    MOV	A,M                    ;SYMBOL BUFFER by fetching the (cc) byte
  562/22E4 : A0                                    ANA	A                    ;And testing to see if (cc) is zero
  563/22E5 : 48 01 23                              JNZ	SCAN3              ;If length not zero, then not a unary minus indicator
  564/22E8 : 36 7E                                 MVI	L, 176o               ;Else, check to see if last operator was a right parenthesi
  565/22EA : C7                                    MOV	A,M                    ;By fetching the value in the PARSER TOKEN storage
  566/22EB : 3C 07                                 CPI	007                ;Location and seeing if it is token value for ")"
  567/22ED : 68 01 23                              JZ	SCAN3              ;If last operator was I')" then do not have a unary minus
  568/22F0 : 3C 03                                 CPI	003                ;Check to see if last operator was C4*~2
  569/22F2 : 68 86 28                              JZ	SYNERR             ;If yes, then have a syntax error
  570/22F5 : 3C 05                                 CPI	005                ;Check to see if last operator was exponentiation
  571/22F7 : 68 86 28                              JZ	SYNERR             ;If yes, then have a syntax error
  572/22FA : 36 50                                 MVI	L, 120o               ;If none of the above, then minus sign is unary, put
  573/22FC : 3E 01                                 MVI	M, 001                ;Character string representing the
  574/22FE : 30                                    INR	L                    ;Value zero in the SYMBOL BUFFER in string format
  575/22FF : 3E B0                                 MVI	M, 260o               ;(Character count (cc) followed by ASCII code for zero)
  576/2301 : 36 7E                      SCAN3:     MVI	L, 176o               ;Set L to address of PARSER TOKEN storage location
  577/2303 : 3E 02                                 MVI	M, 002                ;Set PARSER TOKEN value for minus operator
  578/2305 : 46 F0 23                   SCANFN:    CALL	PARSER             ;Call the PARSER subroutine to process current symbol
  579/2308 : 44 DD 23                              JMP	SCAN10             ;And operator. Then jump to continue processing.
  580/230B : 3C AA                      SCAN4:     CPI	252o               ;See if character fetched from expression is
  581/230D : 48 17 23                              JNZ	SCAN5              ;If not, continue checking for an operator
  582/2310 : 36 7E                                 MVI	L, 176o               ;If yes, set pointer to PARSER TOKEN storage location
  583/2312 : 3E 03                                 MVI	M, 003                ;Place TOKEN value for "*" (multiplication) operator in
  584/2314 : 44 05 23                              JMP	SCANFN             ;PARSER TOKEN and go to PARSER subroutine entry
  585/2317 : 3C AF                      SCAN5:     CPI	257o               ;See if character fetched from expression is
  586/2319 : 48 23 23                              JNZ	SCAN6              ;If not, continue checking for an operator
  587/231C : 36 7E                                 MVI	L, 176o               ;If yes, set pointer to PARSER TOKEN storage location
  588/231E : 3E 04                                 MVI	M, 004                ;Place TOKEN value for "/" (division) operator in
  589/2320 : 44 05 23                              JMP	SCANFN             ;PARSER TOKEN and go to PARSER subroutine entry
  590/2323 : 3C A8                      SCAN6:     CPI	250o               ;See if character fetched from expression is
  591/2325 : 48 37 23                              JNZ	SCAN7              ;If not, continue checking for an operator
  592/2328 : 36 98                                 MVI	L, 230o               ;If yes, load L with address of FUN/ARRAY STACK
  593/232A : CF                                    MOV	B,M                    ;Pointer. Fetch the value in the stack pointer. Increment
  594/232B : 08                                    INR	B                    ;It to indicate number of "(" operators encountered.
  595/232C : F9                                    MOV	M,B                    ;Restore the updated stack pointer back to memory
  596/232D : 46 5C 26                              CALL	FUNARR             ;Call subroutine to process possible FUNCTION or
  597/2330 : 36 7E                                 MVI	L, 176o               ;ARRAY variable subscript. Ihen set pointer to
  598/2332 : 3E 06                                 MVI	M, 006                ;PARSER TOKEN storage and set value for operator
  599/2334 : 44 05 23                              JMP	SCANFN             ;Go to PARSER subroutine entry point.
  600/2337 : 3C A9                      SCAN7:     CPI	251o               ;See if character fetched from expression is
  601/2339 : 48 50 23                              JNZ	SCAN8              ;If not, continue checking for an operator
  602/233C : 36 7E                                 MVI	L, 176o               ;If yes, load L with address of PARSER TOKEN
  603/233E : 3E 07                                 MVI	M, 007                ;Set PARSER TOKEN value to reflect ")"
  604/2340 : 46 F0 23                              CALL	PARSER             ;Call the  PARSER subroutine to process current symbol
  605/2343 :                            
  606/2343 : 46 1F 26                              CALL	PRIGHT             ;Call subroutine to handle FUNCTION or ARRAY
  607/2346 : 36 98                                 MVI	L, 230o               ;Load L with address of FUN/ARRAY STACK pointer
  608/2348 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of FUN/ARRAY STACK pointer
  609/234A : CF                                    MOV	B,M                    ;Fetch the value in the stack pointer. Decrement it
  610/234B : 09                                    DCR	B                    ;To account for left parenthesis just processed.
  611/234C : F9                                    MOV	M,B                    ;Restore the updated value back to memory.
  612/234D : 44 DD 23                              JMP	SCAN10             ;Jump to continue processing expression.
  613/2350 : 3C DE                      SCAN8:     CPI	336o               ;See if character fetched from expression is " t
  614/2352 : 48 5C 23                              JNZ	SCAN9              ;If not, continue checking for an operator
  615/2355 : 36 7E                                 MVI	L, 176o               ;If yes, load L with address of PARSER TOKEN
  616/2357 : 3E 05                                 MVI	M, 005                ;Put in value for exponentiation
  617/2359 : 44 05 23                              JMP	SCANFN             ;Go to PARSER subroutine entry point.
  618/235C : 3C BC                      SCAN9:     CPI	274o               ;See if character fetched is the "less than" sign
  619/235E : 48 7F 23                              JNZ	SCAN11             ;If not, continue checking for an operator
  620/2361 : 36 80                                 MVI	L, 200o               ;If yes, set L to the EVAL CURRENT pointer
  621/2363 : CF                                    MOV	B,M                    ;Fetch the pointer
  622/2364 : 08                                    INR	B                    ;Increment it to point to the next character
  623/2365 : F9                                    MOV	M,B                    ;Restore the updated pointer value
  624/2366 : 46 BC 21                              CALL	GETCHR             ;Fetch the next character in the expression
  625/2369 : 3C BD                                 CPI	275o               ;Is the character the "= 9 $ sign?
  626/236B : 68 C5 23                              JZ	SCAN13             ;If so, have 'less than or equal" combination
  627/236E : 3C BE                                 CPI	276o               ;Is the character the "greater than" sign?
  628/2370 : 68 D3 23                              JZ	SCAN15             ;If so, have "less than or greater than" combination
  629/2373 : 36 80                                 MVI	L, 200o               ;Else character is not part of the operator. Set L back
  630/2375 : CF                                    MOV	B,M                    ;To the EVAL CURRENT pointer. Fetch the pointer
  631/2376 : 09                                    DCR	B                    ;Value and decriment it back one character in the
  632/2377 : F9                                    MOV	M,B                    ;Expression. Restore the original pointer value.
  633/2378 : 36 7E                                 MVI	L, 176o               ;Have just the 'less than" operator. Set L to the
  634/237A : 3E 09                                 MVI	M, 011o               ;PARSER TOKEN storage location and set the value for
  635/237C : 44 05 23                              JMP	SCANFN             ;The 'less than" sign then go to PARSER entry point.
  636/237F : 3C BD                      SCAN11:    CPI	275o               ;See if character fetched is the "= " sign
  637/2381 : 48 A2 23                              JNZ	SCAN12             ;If not, continue checking for an operator
  638/2384 : 36 80                                 MVI	L, 200o               ;If yes, set L to the EVAL CURRENT pointer
  639/2386 : CF                                    MOV	B,M                    ;Fetch the pointer
  640/2387 : 08                                    INR	B                    ;Increment it to point to the next character
  641/2388 : F9                                    MOV	M,B                    ;Restore the updated pointer value
  642/2389 : 46 BC 21                              CALL	GETCHR             ;Fetch the next character in the expression
  643/238C : 3C BC                                 CPI	274o               ;Is the character the "less than" sign?
  644/238E : 68 C5 23                              JZ	SCAN13             ;If so, have "less than or equal" combination
  645/2391 : 3C BE                                 CPI	276o               ;Is the character the "greater than" sign?
  646/2393 : 68 CC 23                              JZ	SCAN14             ;If so, have "equal or greater than" combination
  647/2396 : 36 80                                 MVI	L, 200o               ;Else character is not part of the operator. Set L back
  648/2398 : CF                                    MOV	B,M                    ;To the EVAL CURRENT pointer. Fetch the pointer
  649/2399 : 09                                    DCR	B                    ;Value and decrement it back one character in the
  650/239A : F9                                    MOV	M,B                    ;Expression. Restore the original pointer value.
  651/239B : 36 7E                                 MVI	L, 176o               ;Just have '~-- " operator. Set L to the PARSER TOKEN
  652/239D : 3E 0A                                 MVI	M, 012o               ;Storage location and set the value for the sign.
  653/239F : 44 05 23                              JMP	SCANFN             ;Go to the PARSER entry point.
  654/23A2 : 3C BE                      SCAN12:    CPI	276o               ;See if character fetched is the "greater than" sign
  655/23A4 : 48 DA 23                              JNZ	SCAN16             ;If not, go append the character to the SYMBOL BUFF
  656/23A7 : 36 80                                 MVI	L, 200o               ;If so, set L to the EVAL CURRENT pointer
  657/23A9 : CF                                    MOV	B,M                    ;Fetch the pointer
  658/23AA : 08                                    INR	B                    ;Increment it to point to the next character
  659/23AB : F9                                    MOV	M,B                    ;Restore the updated pointer value
  660/23AC : 46 BC 21                              CALL	GETCHR             ;Fetch the next character in the expression
  661/23AF : 3C BC                                 CPI	274o               ;Is the character the "less than" sign?
  662/23B1 : 68 D3 23                              JZ	SCAN15             ;If so, have "less than or greater than" combination
  663/23B4 : 3C BD                                 CPI	275o               ;Is the character the "= " sign?
  664/23B6 : 68 CC 23                              JZ	SCAN14             ;If so, have the "equal to or greater than " combination
  665/23B9 : 36 80                                 MVI	L, 200o               ;Else character is not part of the operator. Set L back
  666/23BB : CF                                    MOV	B,M                    ;To the EVAL CURRENT pointer. Fetch the pointer
  667/23BC : 09                                    DCR	B                    ;Value and decrement it back one character in the
  668/23BD : F9                                    MOV	M,B                    ;Expression. Restore the original pointer value.
  669/23BE : 36 7E                                 MVI	L, 176o               ;Have just the "greater than" operator. Set L to the
  670/23C0 : 3E 0B                                 MVI	M, 013o               ;PARSER TOKEN storage location and set the value for
  671/23C2 : 44 05 23                              JMP	SCANFN             ;The "greater than" sign then go to PARSER entry
  672/23C5 : 36 7E                      SCAN13:    MVI	L, 176o               ;When have 'less than or equal" combination set L to
  673/23C7 : 3E 0C                                 MVI	M, 014o               ;PARSER TOKEN storage location and set the value.
  674/23C9 : 44 05 23                              JMP	SCANFN             ;Then go to the PARSER entry point.
  675/23CC : 36 7E                      SCAN14:    MVI	L, 176o               ;When have "equal to or greater than" combination set L
  676/23CE : 3E 0D                                 MVI	M, 015o               ;To PARSER TOKEN storage location and set the value.
  677/23D0 : 44 05 23                              JMP	SCANFN             ;Then go to the PARSER entry point.
  678/23D3 : 36 7E                      SCAN15:    MVI	L, 176o               ;When have 'less than or greater than" combination set
  679/23D5 : 3E 0E                                 MVI	M, 016o               ;L to PARSER TOKEN storage location and set value.
  680/23D7 : 44 05 23                              JMP	SCANFN             ;Then go to the PARSER entry point.
  681/23DA : 46 E4 21                   SCAN16:    CALL	CONCTS             ;Concatenate the character to the SYMBOL BUFFER
  682/23DD : 36 80                      SCAN10:    MVI	L, 200o               ;Set L to the EVAL CURRENT pointer storage location
  683/23DF : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of EVAL CURRENT pointer
  684/23E1 : CF                                    MOV	B,M                    ;Fetch the EVAL CURRENT pointer value into B
  685/23E2 : 08                                    INR	B                    ;Increment the pointer value to point to next character
  686/23E3 : F9                                    MOV	M,B                    ;In the expression and restore the updated value.
  687/23E4 : 36 BF                                 MVI	L, 277o               ;Set L to EVAL FINISH storage location.
  688/23E6 : C7                                    MOV	A,M                    ;Fetch the EVAL FINISH value into the accumulator.
  689/23E7 : 09                                    DCR	B                    ;Set B to last character processed in the expression.
  690/23E8 : B9                                    CMP	B                    ;See if last character was at EVAL FINISH location.
  691/23E9 : 48 C8 22                              JNZ	SCAN1              ;If not, continue processing the expression. Else, jump
  692/23EC : 44 B4 36                              JMP	PARSEP             ;To final evaluation procedure and test.  (Directs routine
  693/23EF : 00                                    HLT             ;To a dislocated section.) Safety Halt in unused byte.
  694/23F0 : 36 50                      PARSER:    MVI	L, 120o               ;Load L with starting address of SYMBOL BUFFER
  695/23F2 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of SYMBOL BUFFER
  696/23F4 : C7                                    MOV	A,M                    ;Fetch the (cc) for  contents of SYMBOL BUFFER
  697/23F5 : A0                                    ANA	A                    ;Into the ACC and see if buffer is  empty
  698/23F6 : 68 B5 24                              JZ	PARSE              ;If empty then no need to convert contents
  699/23F9 : 30                                    INR	L                    ;If not empty, advance buffer pointer
  700/23FA : C7                                    MOV	A,M                    ;Fetch the first character in the buffer
  701/23FB : 3C AE                                 CPI	256o               ;See if it is ASCII code for decimal sign
  702/23FD : 68 0A 24                              JZ	PARNUM             ;If yes, consider contents of buffer to be a number
  703/2400 : 3C B0                                 CPI	260o               ;If not decimal sign, see if first character represents
  704/2402 : 70 37 24                              JM	LOOKUP             ;A deciinal digit, if not, should have a variable
  705/2405 : 3C BA                                 CPI	272o               ;Continue to test for a decimal digit
  706/2407 : 50 37 24                              JP	LOOKUP             ;If not, go look up the variable nwne
  707/240A : 31                         PARNUM:    DCR	L                    ;If SYMBOL BUFFER contains number, decrement
  708/240B : C7                                    MOV	A,M                    ;Buffer pointer back to (cc) and fetch it to ACC
  709/240C : 3C 01                                 CPI	001o               ;See if length of string in buffer is just one
  710/240E : 68 21 24                              JZ	NOEXPO             ;If so, cannot have number with scientific notation
  711/2411 : 86                                    ADD	L                    ;If not, add length to buffer pointer to
  712/2412 : F0                                    MOV	L,A                    ;Point to last character in the buffer
  713/2413 : C7                                    MOV	A,M                    ;Fetch the last character in buffer and see if it
  714/2414 : 3C C5                                 CPI	305o               ;Represents letter E for Exponent
  715/2416 : 48 21 24                              JNZ	NOEXPO             ;If not, cannot have number with scientific notation
  716/2419 : 36 80                                 MVI	L, 200o               ;If yes, have part of a scientific number, set pointer to
  717/241B : 46 BC 21                              CALL	GETCHR             ;Get the operator that follows the E and append it to
  718/241E : 44 E4 21                              JMP	CONCTS             ;The SYMBOL BUFFER and return to EVAL routine
  719/2421 : 36 97                      NOEXPO:    MVI	L, 227o               ;Load L with address of ARITHMETIC STACK pointer
  720/2423 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with page of ARITHMETIC STACK pointer
  721/2425 : C7                                    MOV	A,M                    ;Fetch AS pointer value to ACC and add four to account
  722/2426 : 04 04                                 ADI	004o               ;For the number of bytes required to store a number in
  723/2428 : F8                                    MOV	M,A                    ;Floating point format. Restore pointer to mernory.
  724/2429 : F0                                    MOV	L,A                    ;Then, change L to point to entry position in the AS
  725/242A : 46 B4 31                              CALL	FSTORE             ;Place contents of the FPACC onto top of the AS
  726/242D : 36 50                                 MVI	L, 120o               ;Change L to point to start of the SYMBOL BUFFER
  727/242F : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of the SYMBOL BUFFER
  728/2431 : 46 2B 32                              CALL	DINPUT             ;Convert number in the buffer to floating point format
  729/2434 : 44 B5 24                              JMP	PARSE              ;In the FPACC then jump to check operator sign.
  730/2437 : 36 F8                      LOOKUP:    MVI	L, 370o               ;Load L with address of LOOK-UP COUNTER
  731/2439 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of the counter
  732/243B : 3E 00                                 MVI	M, 000                ;Initialize the counter to zero
  733/243D : 36 50                                 MVI	L, 120o               ;Load L with starting address of the SYMBOL BUFFER
  734/243F : 1E 04                                 MVI	D,PG27 ;\HB\OLDPG27   ;** Load D with page of the VARIABLES TABLE
  735/2441 : 26 88                                 MVI	E, 210o               ;Load E with start of the VARL433LES TABLE
  736/2443 : C7                                    MOV	A,M                    ;Fetch the (cc) for the string in the SYMBOL BUFFER
  737/2444 : 3C 01                                 CPI	001                ;See if the name length is just one character. If not,
  738/2446 : 48 4D 24                              JNZ	LOOKU1             ;Should be two so proceed to look-up routine. Else,
  739/2449 : 36 52                                 MVI	L, 122o               ;Change L to second character byte in the buffer and set
  740/244B : 3E 00                                 MVI	M, 000                ;It to zero to provide compatibility with entries in table
  741/244D : 36 51                      LOOKU1:    MVI	L, 121o               ;Load L with addr of first character in the SYMBOL
  742/244F : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** BUFFER. Set H to page of the SYMBOL BUFFER.
  743/2451 : 46 F5 31                              CALL	SWITCH             ;Exchange contents of D&E with H&L so that can
  744/2454 : C7                                    MOV	A,M                    ;Fetch the first character of a name in the VARIABLES
  745/2455 : 30                                    INR	L                    ;TABLE. Advance the table pointer and save the
  746/2456 : CF                                    MOV	B,M                    ;Second byte of name in B. Then advance the pointer
  747/2457 : 30                                    INR	L                    ;Again to reach first bvte of floating point forrnatted
  748/2458 : 46 F5 31                              CALL	SWITCH             ;Number in table. Now exchange D&E with H&L and
  749/245B : BF                                    CMP	M                    ;Compare first byte in table against first char in buffer
  750/245C : 48 65 24                              JNZ	LOOKU2             ;If not the same, go try next entry in table. If same,
  751/245F : 30                                    INR	L                    ;Advance pointer to next char in buffer. Transfer the
  752/2460 : C1                                    MOV	A,B                    ;Character in B (second byte in table entry) to the ACC
  753/2461 : BF                                    CMP	M                    ;Compare it against second character in the buffer.
  754/2462 : 68 9D 24                              JZ	LOOKU4             ;If match, have found the name in the VARIABLES tbl.
  755/2465 : 46 CA 25                   LOOKU2:    CALL	AD4DE              ;Call subroutine to add four to the pointer in D&E to
  756/2468 : 36 F8                                 MVI	L, 370o               ;Advance the table pointer over value bytes. Then set
  757/246A : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Up H and L to point to LOOK-UP COUNTER.
  758/246C : CF                                    MOV	B,M                    ;Fetch counter value (counts number of entries tested
  759/246D : 08                                    INR	B                    ;In the VARIABLES TABLE), increment it
  760/246E : F9                                    MOV	M,B                    ;And restore it back to meynory
  761/246F : 36 3F                                 MVI	L, 077o               ;Load L with address of SYMBOL VARIABLES counter
  762/2471 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Do same for H. (Counts number of names in table.)
  763/2473 : C1                                    MOV	A,B                    ;Place LOOK-UP COUNTER value in the accumulator.
  764/2474 : BF                                    CMP	M                    ;Compare it with number of entries in the table.
  765/2475 : 48 4D 24                              JNZ	LOOKU1             ;If have not reached end of table, keep looking for name.
  766/2478 : 36 3F                                 MVI	L, 077o               ;If reach end of table without match, need to add name
  767/247A : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** To table. First set H & L to the SYMBOL
  768/247C : CF                                    MOV	B,M                    ;VARIABLES counter. Fetch the counter value and
  769/247D : 08                                    INR	B                    ;Increment to account for new name being added to the
  770/247E : F9                                    MOV	M,B                    ;Table. Restore the updated count to meinory. Also,
  771/247F : C1                                    MOV	A,B                    ;Move the new counter value to the accumulator and
  772/2480 : 3C 15                                 CPI	025o               ;Check to see that table size is not exceeded. If try to
  773/2482 : 50 AE 21                              JP	BIGERR             ;Go over 20 (decirnal) entries then have BIG error.
  774/2485 : 36 51                                 MVI	L, 121o               ;Else, set L to point to first character in the SYMBOL
  775/2487 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** BUFFER and set H to proper page. Set the number
  776/2489 : 0E 02                                 MVI	B, 002                ;Of bytes to be transferred into register B as a counter.
  777/248B : 46 12 30                              CALL	MOVEIT             ;Move the symbol name from the buffer to the
  778/248E : F4                                    MOV	L,E                    ;VARIABLES TABLE. Now set up H & L with value
  779/248F : EB                                    MOV	H,D                    ;Contained in D & E after moving ops (points to first
  780/2490 : A8                                    XRA	A                    ;Byte of the value to be associated with the symbol
  781/2491 : F8                                    MOV	M,A                    ;Name.) Clear the accumulator and place zero in all four
  782/2492 : 30                                    INR	L                    ;Bytes associated with the variable name entered
  783/2493 : F8                                    MOV	M,A                    ;In the VARIABLES TABLE
  784/2494 : 30                                    INR	L                    ;In order to
  785/2495 : F8                                    MOV	M,A                    ;Assign an
  786/2496 : 30                                    INR	L                    ;Initial value
  787/2497 : F8                                    MOV	M,A                    ;To the variable narne
  788/2498 : C6                                    MOV	A,L                    ;Then transfer the address in L to the acc'umulator
  789/2499 : 14 04                                 SUI	004                ;Subtract four to reset the pointer to start of zeroing ops
  790/249B : E0                                    MOV	E,A                    ;Restore the address in D & E to be in same state as if
  791/249C : DD                                    MOV	D,H                    ;Name was found in the table in the LOOKUP routine
  792/249D : 46 D6 31                   LOOKU4:    CALL	SAVEHL             ;Save current address to VARIABLES TABLE
  793/24A0 : 36 97                                 MVI	L, 227o               ;Load L with address of ARITHMETIC STACK pointer
  794/24A2 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with page of the pointer
  795/24A4 : C7                                    MOV	A,M                    ;Fetch the AS pointer value to the accumulator
  796/24A5 : 04 04                                 ADI	004                ;Add four to account for next floating point forrnatted
  797/24A7 : F8                                    MOV	M,A                    ;Number to be stored in the stack. Restore the stack
  798/24A8 : F0                                    MOV	L,A                    ;Pointer to memory and set it up in register L too.
  799/24A9 : 46 B4 31                              CALL	FSTORE             ;Place the value in the FPACC on the top of the
  800/24AC : 46 E6 31                              CALL	RESTHL             ;ARITHMETIC STACK. Restore the VARIABLES
  801/24AF : 46 F5 31                              CALL	SWITCH             ;TABLE pointer to H&L and move it to D&E. Now load
  802/24B2 : 46 AB 31                              CALL	FLOAD              ;The VARIABLE value from the table to the FPACC.
  803/24B5 : 46 C9 21                   PARSE:     CALL	CLESYM             ;Clear the SYMBOL BUFFER
  804/24B8 : 36 7E                                 MVI	L, 176o               ;Load L with address of PARSER TOKEN VALUE
  805/24BA : C7                                    MOV	A,M                    ;And fetch the token value into the accumulator
  806/24BB : 3C 07                                 CPI	007                ;Is it token value for right parenthesis ")" ? If so, have
  807/24BD : 68 F6 24                              JZ	PARSE2             ;Special case where must perforin ops til find a "(" !
  808/24C0 : 04 A0                                 ADI	240o               ;Else, fon-n address to HEIRARCHY IN table and
  809/24C2 : F0                                    MOV	L,A                    ;Set L to point to HEIRARCHY IN VALUE in the table
  810/24C3 : CF                                    MOV	B,M                    ;Fetch the heirarchy value from the table to register B
  811/24C4 : 36 88                                 MVI	L, 210o               ;Set L to OPERATOR STACK pointer storage location
  812/24C6 : D7                                    MOV	C,M                    ;Fetch the OS pointer into CPU register C
  813/24C7 : 46 25 32                              CALL	INDEXC             ;Add OS pointer to address of OS pointer storage loc
  814/24CA : C7                                    MOV	A,M                    ;Fetch the token value for the operator at top of the OS
  815/24CB : 04 AF                                 ADI	257o               ;And form address to HEIRARCHY OUT table
  816/24CD : F0                                    MOV	L,A                    ;Set L to point to HEIRARCHY OUT VALUE in the
  817/24CE : C1                                    MOV	A,B                    ;Table. Move the HEIRARCHY IN value to the ACC.
  818/24CF : BF                                    CMP	M                    ;Compare the HEIRARCHY IN with the HEIRARCHY
  819/24D0 : 68 E3 24                              JZ	PARSE1             ;OUT value. If heirarchy of current operator equal to or
  820/24D3 : 70 E3 24                              JM	PARSE1             ;Less than operator on top of OS stack, perfo
  821/24D6 : 36 7E                                 MVI	L, 176o               ;Operation indicated in top of OS stack. Else, fetch the
  822/24D8 : CF                                    MOV	B,M                    ;Current operator token value into register B.
  823/24D9 : 36 88                                 MVI	L, 210o               ;Load L with address of the OPERATOR STACK pntr
  824/24DB : D7                                    MOV	C,M                    ;Fetch the stack pointer value
  825/24DC : 10                                    INR	C                    ;Increment it to account for new entry on the stack
  826/24DD : FA                                    MOV	M,C                    ;Restore the stack pointer value to memory
  827/24DE : 46 25 32                              CALL	INDEXC             ;For in pointer to next entry in OPERATOR STACK
  828/24E1 : F9                                    MOV	M,B                    ;Place the current operator token value on top of the OS
  829/24E2 : 07                                    RET                    ;Exit back to the EVAL routine.
  830/24E3 : 36 88                      PARSE1:    MVI	L, 210o               ;Load L with address of the OPERATOR STACK pntr
  831/24E5 : C7                                    MOV	A,M                    ;Fetch the stack pointer value to the accumulator
  832/24E6 : 86                                    ADD	L                    ;Add in the value of the stack pointer address to form
  833/24E7 : F0                                    MOV	L,A                    ;Address that points to top entry in the OS
  834/24E8 : C7                                    MOV	A,M                    ;Fetch the token value at the top of the OS to the ACC
  835/24E9 : A0                                    ANA	A                    ;Check to see if the token value is zero for end of stack
  836/24EA : 2B                                    RZ                    ;Exit back to the EVAL routine if stack empty
  837/24EB : 36 88                                 MVI	L, 210o               ;Else, reset L to the OS pointer storage location
  838/24ED : D7                                    MOV	C,M                    ;Fetch the pointer value
  839/24EE : 11                                    DCR	C                    ;Decrement it to account for operator rernoved from
  840/24EF : FA                                    MOV	M,C                    ;The OPERATOR STACK and restore the pointer value
  841/24F0 : 46 10 25                              CALL	FPOPER             ;Perform the operation obtained from the top of the OS
  842/24F3 : 44 B5 24                              JMP	PARSE              ;Continue to compare current operator against top of OS
  843/24F6 : 36 88                      PARSE2:    MVI	L, 210o               ;Load L with address of the OPERATOR STACK pntr
  844/24F8 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of the pointer
  845/24FA : C7                                    MOV	A,M                    ;Fetch the stack pointer value to the accumulator
  846/24FB : 86                                    ADD	L                    ;Add in the value of the stack pointer address to form
  847/24FC : F0                                    MOV	L,A                    ;Address that points to top entry in the OS
  848/24FD : C7                                    MOV	A,M                    ;Fetch the token value at the top of the 0 S to the ACC
  849/24FE : A0                                    ANA	A                    ;Check to see if the token value is zero for end of stack
  850/24FF : 68 60 25                              JZ	PARNER             ;If end of stack, then have a parenthesis error condx
  851/2502 : 36 88                                 MVI	L, 210o               ;Else, reset L to the OS pointer storage location
  852/2504 : D7                                    MOV	C,M                    ;Fetch the pointer value
  853/2505 : 11                                    DCR	C                    ;Decrement it to account for operator removed from
  854/2506 : FA                                    MOV	M,C                    ;The OPERATOR STACK and restore the pointer value
  855/2507 : 3C 06                                 CPI	006                ;Check to see if token value is "(" to close parenthesis
  856/2509 : 2B                                    RZ                    ;If so, exit back to EVAL routine.
  857/250A : 46 10 25                              CALL	FPOPER             ;Else, perforin the op obtained from the top of the OS
  858/250D : 44 F6 24                              JMP	PARSE2             ;Continue to process data in parenthesis
  859/2510 : 36 F9                      FPOPER:    MVI	L, 371o               ;Load L with address of TEMP OP storage location
  860/2512 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of TEMP OP storage location
  861/2514 : F8                                    MOV	M,A                    ;Store OP (from top of OPERATOR STACK)
  862/2515 : 36 97                                 MVI	L, 227o               ;Change L to address of ARff HMETIC STACK pointer
  863/2517 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with page of AS pointer
  864/2519 : C7                                    MOV	A,M                    ;Fetch AS pointer value into ACC
  865/251A : F0                                    MOV	L,A                    ;Set L to top of ARITHMETIC STACK
  866/251B : 46 BD 31                              CALL	OPLOAD             ;Transfer number from ARffHMETIC STACK to FPOP
  867/251E : 36 97                                 MVI	L, 227o               ;Restore pointer to AS pointer
  868/2520 : C7                                    MOV	A,M                    ;Fetch the pointer value to the ACC and subtract four
  869/2521 : 14 04                                 SUI	004                ;To remove top value from the ARITHMETIC STACK
  870/2523 : F8                                    MOV	M,A                    ;Restore the updated AS pointer to memory
  871/2524 : 36 F9                                 MVI	L, 371o               ;Set L to address of TEMP OP storage location
  872/2526 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of TEMP OP storage location
  873/2528 : C7                                    MOV	A,M                    ;Fetch the operator token value to the ACC
  874/2529 : 3C 01                                 CPI	001                ;Find out which kind of operation indicated
  875/252B : 68 8C 2F                              JZ	FPADD              ;Perforn addition if have plus operator
  876/252E : 3C 02                                 CPI	002                ;If not plus, see if minus
  877/2530 : 68 21 30                              JZ	FPSUB              ;Perform subtraction if have minus operator
  878/2533 : 3C 03                                 CPI	003                ;If not minus, see if multiplication
  879/2535 : 68 2D 30                              JZ	FPMULT             ;Perform multiplication if have multiplication operator
  880/2538 : 3C 04                                 CPI	004                ;If not multiplication, see if division
  881/253A : 68 D9 30                              JZ	FPDIV              ;Perform division if have division operator
  882/253D : 3C 05                                 CPI	005                ;If not division, see if exponentiation
  883/253F : 68 CF 25                              JZ	INTEXP             ;Perform exponentiation if have exponentiation operator
  884/2542 : 3C 09                                 CPI	011o               ;If not exponentiation, see if "less than" operator
  885/2544 : 68 6D 25                              JZ	LT                 ;Perform compaison for "less than" op if indicated
  886/2547 : 3C 0A                                 CPI	012o               ;If not 'less than" see if have "equal" operator
  887/2549 : 68 7A 25                              JZ	EQ                 ;Perforin comparison for "equal" op if indicated
  888/254C : 3C 0B                                 CPI	013o               ;If not "equal" see if have "greater than" operator
  889/254E : 68 87 25                              JZ	GT                 ;Perform comparison for "greater than" op if indicated
  890/2551 : 3C 0C                                 CPI	014o               ;If not "'greater than" see if have 'less than or equal" op
  891/2553 : 68 97 25                              JZ	LE                 ;Perform comparison for the combination op if indicated
  892/2556 : 3C 0D                                 CPI	015o               ;See if have "equal to or greater than" operator
  893/2558 : 68 A7 25                              JZ	GE                 ;Perform comparison for the combination op if indicated
  894/255B : 3C 0E                                 CPI	016o               ;See if have "less than or greater than" operator
  895/255D : 68 B4 25                              JZ	NE                 ;Perform comparison for the combination op if indicated
  896/2560 : 36 98                      PARNER:    MVI	L, 230o               ;If cannot find operator, expression is not balanced
  897/2562 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H and L to address of F/A STACK pointer
  898/2564 : 3E 00                                 MVI	M, 000                ;Clear the F/A STACK pointer to re-initialize
  899/2566 : 06 C9                                 MVI	A, 311o               ;Load ASCII code for letter I into the accumulator
  900/2568 : 16 A8                                 MVI	C, 250o               ;And code for "(" character into register C
  901/256A : 44 B2 21                              JMP	ERROR              ;Go display 1( for "Imbalanced Parenthesis") error msg
  902/256D : 46 21 30                   LT:        CALL	FPSUB              ;Subtract contents of FPACC from FPOP to compare
  903/2570 : 36 56                                 MVI	L, 126o               ;Set L to point to the MSW of the FPACC (Contains
  904/2572 : C7                                    MOV	A,M                    ;Result of the subtraction.) Fetch the MSW of the
  905/2573 : A0                                    ANA	A                    ;FPACC to the accumulator and test to see if result is
  906/2574 : 70 BE 25                              JM	CTRUE              ;Positive or negative. Set up the FPACC as a function
  907/2577 : 44 C3 25                              JMP	CFALSE             ;Of the result obtained.
  908/257A : 46 21 30                   EQ:        CALL	FPSUB              ;Subtract contents of FPACC from FPOP to compare
  909/257D : 36 56                                 MVI	L, 126o               ;Set L to point to the MSW of the FPACC (Contains
  910/257F : C7                                    MOV	A,M                    ;Result of the subtraction.) Fetch the MSW of the
  911/2580 : A0                                    ANA	A                    ;FPACC to the accumulator and test to see if result is
  912/2581 : 68 BE 25                              JZ	CTRUE              ;Equal. Set up the FPACC as a function
  913/2584 : 44 C3 25                              JMP	CFALSE             ;Of the result obtained.
  914/2587 : 46 21 30                   GT:        CALL	FPSUB              ;Subtract contents of FPACC from FPOP to compare
  915/258A : 36 56                                 MVI	L, 126o               ;Set L to point to the MSW of the FPACC (Contains
  916/258C : C7                                    MOV	A,M                    ;Result of the subtraction.) Fetch the MSW of the
  917/258D : A0                                    ANA	A                    ;FPACC to the accumulator and test to see if result is
  918/258E : 68 C3 25                              JZ	CFALSE             ;Positive, Negative, or Equal. Set up the FPACC
  919/2591 : 50 BE 25                              JP	CTRUE              ;As a function
  920/2594 : 44 C3 25                              JMP	CFALSE             ;Of the result obtained.
  921/2597 : 46 21 30                   LE:        CALL	FPSUB              ;Subtract contents of FPACC from FPOP to compare
  922/259A : 36 56                                 MVI	L, 126o               ;Set L to point to the MSW of the FPACC (Contains
  923/259C : C7                                    MOV	A,M                    ;Result of the subtraction.) Fetch the MSW of the
  924/259D : A0                                    ANA	A                    ;FPACC to the accumulator and test to see if result is
  925/259E : 68 BE 25                              JZ	CTRUE              ;Positive, Negative, or Equal. Set up the FPACC
  926/25A1 : 70 BE 25                              JM	CTRUE              ;As a function
  927/25A4 : 44 C3 25                              JMP	CFALSE             ;Of the result obtained
  928/25A7 : 46 21 30                   GE:        CALL	FPSUB              ;Submit contents of FPACC from FPOP to compare
  929/25AA : 36 56                                 MVI	L, 126o               ;Set L to point to the MSW of the FPACC (Contains
  930/25AC : C7                                    MOV	A,M                    ;Result of the subtraction.) Fetch the MSW of the
  931/25AD : A0                                    ANA	A                    ;FPACC to the accumulator and test to see if result is
  932/25AE : 50 BE 25                              JP	CTRUE              ;Positive or Negative. Set up the FPACC
  933/25B1 : 44 C3 25                              JMP	CFALSE             ;As a function of the result obtained
  934/25B4 : 46 21 30                   NE:        CALL	FPSUB              ;Subtract contents of FPACC from FPOP to compare
  935/25B7 : 36 56                                 MVI	L, 126o               ;Set L to point to the MSW of the FPACC (Contains
  936/25B9 : C7                                    MOV	A,M                    ;Result of the subtraction.) Fetch the MSW of the
  937/25BA : A0                                    ANA	A                    ;FPACC to the accumulator and test to see if result is
  938/25BB : 68 C3 25                              JZ	CFALSE             ;Equal. Set up the FPACC as a function of the result.
  939/25BE :                            CTRUE:
  940/25BE : 36 04                      FPONE:     MVI	L, 004                ;Load L with address of floating point value +1.0
  941/25C0 : 44 AB 31                              JMP	FLOAD              ;Load FPACC with value +1.0 and exit to caller
  942/25C3 : 36 57                      CFALSE:    MVI	L, 127o               ;Load L with address of FPACC Exponent register
  943/25C5 : 3E 00                                 MVI	M, 000                ;Set the FPACC Exponent to zero and then set the
  944/25C7 : 44 2C 2F                              JMP	FPZERO             ;Mantissa portion of the FPACC to zero. Exit to caller.
  945/25CA : C4                         AD4DE:     MOV	A,E                    ;Subroutine to add four to the value in register E.
  946/25CB : 04 04                                 ADI	004                ;Move contents of E to the ACC and add four.
  947/25CD : E0                                    MOV	E,A                    ;Restore the updated value back to register E.
  948/25CE : 07                                    RET                    ;Return to the caMVI L,ng routine.
  949/25CF : 36 56                      INTEXP:    MVI	L, 126o               ;Load L with address of WSW of FPACC (Floating Point
  950/25D1 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** ACCumulator). Load H with page of FPACC.
  951/25D3 : C7                                    MOV	A,M                    ;Fetch MSW of the FPACC into the accumulator.
  952/25D4 : 36 03                                 MVI	L, 003                ;Load L with address of EXP TEMP storage location
  953/25D6 : F8                                    MOV	M,A                    ;Store the FPACC MSW value in EXP TEMP location
  954/25D7 : A0                                    ANA	A                    ;Test contents of the MSW of the FPACC. ff zero, then
  955/25D8 : 68 BE 25                              JZ	FPONE              ;Set FPACC equal to +1.0 (any nr to zero power = 1.0!)
  956/25DB : 72 85 2F                              CM	 FPCOMP             ;If MSW indicates negative number, complement
  957/25DE : 46 03 2F                              CALL	FPFIX              ;The FPACC. Then convert floating point number to
  958/25E1 : 36 54                                 MVI	L, 124o               ;Fixed point. Load L with address of LSW of fixed nr
  959/25E3 : CF                                    MOV	B,M                    ;Fetch the LSW into CPU register B.
  960/25E4 : 36 0B                                 MVI	L, 013o               ;Set L to address of EXPONENT COUNTER
  961/25E6 : F9                                    MOV	M,B                    ;Place the fixed value in the EXP CNTR to indicate
  962/25E7 : 36 5C                                 MVI	L, 134o               ;Number of multiplications needed (power). Now set L
  963/25E9 : 26 0C                                 MVI	E, 014o               ;To LSW of FPOP and E to address of FP TEMP (LSW)
  964/25EB : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to floating point working area page.
  965/25ED : DD                                    MOV	D,H                    ;Set D to same page address.
  966/25EE : 0E 04                                 MVI	B, 004o               ;Set transfer (precision) counter. Call subroutine to move
  967/25F0 : 46 12 30                              CALL	MOVEIT             ;Contents of FPOP into FP TEMP registers to save
  968/25F3 : 46 BE 25                              CALL	FPONE              ;Original value of FPOP. Now set FPACC to +1.0.
  969/25F6 : 36 03                                 MVI	L, 003                ;Load L with pointer to original value of FPACC
  970/25F8 : C7                                    MOV	A,M                    ;(Stored in FP TEMP) MSW and fetch contents to ACC.
  971/25F9 : A0                                    ANA	A                    ;Test to see if raising to a negative power. If so, divide
  972/25FA : 70 0E 26                              JM	DVLOOP             ;Instead of multiply!
  973/25FD : 36 0C                      MULOOP:    MVI	L, 014o               ;Load L with address of LSW of FP TEMP (original
  974/25FF : 46 C6 31                              CALL	FACXOP             ;Value in FPOP). Move FP TEMP into FPOP.
  975/2602 : 46 2D 30                              CALL	FPMULT             ;Multiply FPACC by FPOP. Result left in FPACC.
  976/2605 : 36 0B                                 MVI	L, 013o               ;Load L with address of EXPONENT COUNTER.
  977/2607 : CF                                    MOV	B,M                    ;Fetch the counter value
  978/2608 : 09                                    DCR	B                    ;Decrement it
  979/2609 : F9                                    MOV	M,B                    ;Restore it to memory
  980/260A : 48 FD 25                              JNZ	MULOOP             ;If counter not zero, continue exponentiation process
  981/260D : 07                                    RET                    ;When have raised to proper power, return to caller.
  982/260E : 36 0C                      DVLOOP:    MVI	L, 014o               ;Load L with address of LSW of FP TEMP (original
  983/2610 : 46 C6 31                              CALL	FACXOP             ;Value in FPOP). Move FP TEMP into FPOP.
  984/2613 : 46 D9 30                              CALL	FPDIV              ;Divide FPACC by FPOP. Result left in FPACC.
  985/2616 : 36 0B                                 MVI	L, 013o               ;Load L with address of EXPONENT COUNTER
  986/2618 : CF                                    MOV	B,M                    ;Fetch the counter value
  987/2619 : 09                                    DCR	B                    ;Decrement it
  988/261A : F9                                    MOV	M,B                    ;Restore to memory
  989/261B : 48 0E 26                              JNZ	DVLOOP             ;If counter not zero, continue exponentiation process
  990/261E : 07                                    RET                    ;When have raised to proper power, return to caller.
  991/261F :                            
  992/261F :                            ;;; The label PRIGHT: SHOULD BE UP TO 07 003 0703h
  993/261F : 36 98                      PRIGHT:    MVI	L, 230o               ;Load L with address of F/A STACK pointer
  994/2621 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of F/A STACK pointer
  995/2623 : C7                                    MOV	A,M                    ;Fetch the pointer value into the ACC
  996/2624 : 86                                    ADD	L                    ;Form pointer to top of the F/A STACK
  997/2625 : F0                                    MOV	L,A                    ;Set L to point to top of the F/A STACK
  998/2626 : C7                                    MOV	A,M                    ;Fetch the contents of the top of the F/A STACK into
  999/2627 : 3E 00                                 MVI	M, 000                ;The ACC then clear the top of the F/A STACK
 1000/2629 : 36 83                                 MVI	L, 203o               ;Load L with address of F /A STACK TEMP storage
 1001/262B : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Location. Set H to page of F/A STACK TEMP
 1002/262D : F8                                    MOV	M,A                    ;Store value from top of F/A STACK into temp loc.
 1003/262E : A0                                    ANA	A                    ;Test to see if token value in top of stack was zero
 1004/262F : 2B                                    RZ                    ;If so, just had simple grouping parenthesis!
 1005/2630 : 70 AC 37                              JM	PRIGH1             ;@@ If token value minus, indicates array subscript
 1006/2633 : 3C 01                                 CPI	001                ;For positive token value, look for appropriate function
 1007/2635 : 68 BF 26                              JZ	INTX               ;If token value for INTeger function, go do it.
 1008/2638 : 3C 02                                 CPI	002                ;Else, see if token value for SIGN function.
 1009/263A : 68 0C 27                              JZ	SGNX               ;If so, go do it.
 1010/263D : 3C 03                                 CPI	003                ;Else, see if token value for ABSolute function
 1011/263F : 68 02 27                              JZ	ABSX               ;If so, go do it.
 1012/2642 : 3C 04                                 CPI	004                ;If not, see if token value for SQuare Root function
 1013/2644 : 68 C6 36                              JZ	SQRX               ;If so, go do it.
 1014/2647 : 3C 05                                 CPI	005                ;If not, see if token value for TAB function
 1015/2649 : 68 2B 27                              JZ	TABX               ;If so, go do it.
 1016/264C : 3C 06                                 CPI	006                ;If not, see if token value for RaNDom function
 1017/264E : 68 62 37                              JZ	RNDX               ;If so, go find a random number.
 1018/2651 : 3C 07                                 CPI	007                ;If not, see if token value for CHaRacter function
 1019/2653 : 68 1B 27                              JZ	CHRX               ;If so, go perform the function.
 1020/2656 : 3C 08                                 CPI	010o               ;Else, see if token for user defined machine language
 1021/2658 : 68 B6 20                              JZ	UDEFX              ;# Function. If so, perform the User DEfined Function
 1022/265B : 00                                    HLT             ;Safety halt. Program should not reach this location!
 1023/265C :                            
 1024/265C :                            ;;; The label FUNARR SHOULD BE AT 07 100 0740h
 1025/265C : 36 50                      FUNARR:    MVI	L, 120o               ;Load L with starting address of SYMBOL BUFFER
 1026/265E : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of SYMBOL BUFFER
 1027/2660 : C7                                    MOV	A,M                    ;Fetch the (cc) for contents of buffer to the ACC
 1028/2661 : A0                                    ANA	A                    ;See if (cc) is zero, if so buffer is empty, return to
 1029/2662 : 2B                                    RZ                    ;Caller as have simple grouping parenthesis sign
 1030/2663 : 36 82                                 MVI	L, 202o               ;Else set L to TEMP COUNTER location
 1031/2665 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to TEMP COUNTER page
 1032/2667 : 3E 00                                 MVI	M, 000                ;Initialize TEMP COUNTER to zero
 1033/2669 : 36 82                      FUNAR1:    MVI	L, 202o               ;Load L with address of TEMP COUNTER
 1034/266B : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Load H with page of TEMP COUNTER
 1035/266D : CF                                    MOV	B,M                    ;Fetch the counter value to register B
 1036/266E : 08                                    INR	B                    ;Increment the counter
 1037/266F : F9                                    MOV	M,B                    ;Restore the updated value to memory
 1038/2670 : 16 02                                 MVI	C, 002                ;Initialize C to a value of two for future ops
 1039/2672 : 36 BC                                 MVI	L, 274o               ;Load L with starting address (less four) of FUNCTION
 1040/2674 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** LOOK-UP TABLE. Set H to table page.
 1041/2676 : 46 B4 26                              CALL	TABADR             ;Find address of next entry in the table
 1042/2679 : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Load D with page of SYMBOL BUFFER
 1043/267B : 26 50                                 MVI	E, 120o               ;Load E with starting address of SYMBOL BUFFER
 1044/267D : 46 F6 21                              CALL	STRCP              ;Compare entry in FUNCTION LOOK-UP TABLE with
 1045/2680 : 68 A3 26                              JZ	FUNAR4             ;Contents of SYMBOL BUFFER. If find match, go set
 1046/2683 : 36 82                                 MVI	L, 202o               ;Up the function token value. Else, set L to the TEMP
 1047/2685 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** COUNTER and set H to the proper page. Fetch the
 1048/2687 : C7                                    MOV	A,M                    ;Current counter value and see if have tried all eight
 1049/2688 : 3C 08                                 CPI	010o               ;Possible functions in the table.
 1050/268A : 48 69 26                              JNZ	FUNAR1             ;If not, go back and check the next entry.
 1051/268D : 36 82                                 MVI	L, 202o               ;If have tried all of the entries in the table, set L
 1052/268F : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** As well as H to the address of the TEMP COUI,.7ER
 1053/2691 : 3E 00                                 MVI	M, 000                ;And reset it to zero. Now go see if have subscripted
 1054/2693 : 44 D8 37                              JMP	FUNAR2             ;@@ Array (unless array capability not in program).
 1055/2696 : 36 98                      FAERR:     MVI	L, 230o               ;Load L with address of F/A STACK pointer
 1056/2698 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of F/A STACK pointer
 1057/269A : 3E 00                                 MVI	M, 000                ;Clear the F/A STACK pointer to reset on an error
 1058/269C : 06 C6                                 MVI	A, 306o               ;Load the ASCII code for letter F into the ACC
 1059/269E : 16 C1                                 MVI	C, 301o               ;Load the ASCII code for letter A into register C
 1060/26A0 : 44 B2 21                              JMP	ERROR              ;Go display the FA error message
 1061/26A3 : 36 82                      FUNAR4:    MVI	L, 202o               ;Load L with address of TEMP COUNTER
 1062/26A5 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to page of TEMP COUNTER
 1063/26A7 : CF                                    MOV	B,M                    ;Load value in counter to register B. This is FUNCTION
 1064/26A8 : 36 98                                 MVI	L, 230o               ;TOKEN VALUE. Cbange- L to F/A STACK pointer.
 1065/26AA : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of F/A STACK pointer.
 1066/26AC : D7                                    MOV	C,M                    ;Fetch the F/A STACK pointer value into register C.
 1067/26AD : 46 25 32                              CALL	INDEXC             ;Form the address to the top of the F/A STACK.
 1068/26B0 : F9                                    MOV	M,B                    ;Store the FUNCTION TOKEN VALUE in the F/A
 1069/26B1 : 44 C9 21                              JMP	CLESYM             ;STACK. Then exit by clearing the SYMBOL BUFFER.
 1070/26B4 : C1                         TABADR:    MOV	A,B                    ;Move the TEMP COUNTER value from B to ACC
 1071/26B5 : 02                         TABAD1:    RLC                    ;Multiply by four using this loop to form value equal
 1072/26B6 : 11                                    DCR	C                    ;To number of bytes per entry (4) times current entry
 1073/26B7 : 48 B5 26                              JNZ	TABAD1             ;In the FUNCTION LOOK-UP TABLE.
 1074/26BA : 86                                    ADD	L                    ;Add this value to the starting address of the table.
 1075/26BB : F0                                    MOV	L,A                    ;Form pointer to next entry in table
 1076/26BC : 03                                    RNC                    ;If no carry return to caller
 1077/26BD : 28                                    INR	H                    ;Else, increment H before
 1078/26BE : 07                                    RET                    ;Returning to caller
 1079/26BF :                            
 1080/26BF :                            ;;; The label INTX SHOULD BE AT 07 243 07a3h
 1081/26BF : 36 56                      INTX:      MVI	L, 126o               ;Load L with address of MSW of the FPACC
 1082/26C1 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with the page of the PPACC
 1083/26C3 : C7                                    MOV	A,M                    ;Fetch the MSW of the FPACC into the accumulator
 1084/26C4 : A0                                    ANA	A                    ;Test the sign of the number in the FPACC. If
 1085/26C5 : 50 F3 26                              JP	INT1               ;Positive jump ahead to integerize
 1086/26C8 : 36 0C                                 MVI	L, 014o               ;If negative, load L with address of FP TEMP registers
 1087/26CA : 46 B4 31                              CALL	FSTORE             ;Store the value in the FPACC in FP TEMP
 1088/26CD : 46 03 2F                              CALL	FPFIX              ;Convert the value in FPACC from floating point to
 1089/26D0 : 36 53                                 MVI	L, 123o               ;Fixed point. Load L with address of FPACC
 1090/26D2 : 3E 00                                 MVI	M, 000                ;Extension register and clear it.
 1091/26D4 : 46 37 2F                              CALL	FPFLT              ;Convert fixed binary back to FP to integerize
 1092/26D7 : 36 0C                                 MVI	L, 014o               ;Load L with address of FP TEMP registers
 1093/26D9 : 46 BD 31                              CALL	OPLOAD             ;Load the value in FP TEMP into FPOP
 1094/26DC : 46 21 30                              CALL	FPSUB              ;Subtract integerized value from original
 1095/26DF : 36 56                                 MVI	L, 126o               ;Set L to address of MSW of FPACC
 1096/26E1 : C7                                    MOV	A,M                    ;Fetch the MSW of the FPACC into the accumulator
 1097/26E2 : A0                                    ANA	A                    ;See if original value and integerized value the same
 1098/26E3 : 68 FD 26                              JZ	INT2               ;If so, have integer value in FP TEMP
 1099/26E6 : 36 0C                                 MVI	L, 014o               ;Else, load L with address of FP TEMP registers
 1100/26E8 : 46 AB 31                              CALL	FLOAD              ;Restore FPACC to original (non-integerized) value
 1101/26EB : 36 14                                 MVI	L, 024o               ;Set L to register containing small value
 1102/26ED : 46 C6 31                              CALL	FACXOP             ;Set up to add small value to original value in FPACC
 1103/26F0 : 46 8C 2F                              CALL	FPADD              ;Perform the addition
 1104/26F3 : 46 03 2F                   INT1:      CALL	FPFIX              ;Convert the number in FPACC from floating point
 1105/26F6 : 36 53                                 MVI	L, 123o               ;To fixed point. Load L with address of FPACC
 1106/26F8 : 3E 00                                 MVI	M, 000                ;Extension register and clear it. Now convert the number
 1107/26FA : 44 37 2F                              JMP	FPFLT              ;Back to floating point to integerize it and exit to caller
 1108/26FD : 36 0C                      INT2:      MVI	L, 014o               ;Load L with address of FP TEMP registers. Transfer
 1109/26FF : 44 AB 31                              JMP	FLOAD              ;Number from FP TEMP (orig) to FPACC and return.
 1110/2702 : 36 56                      ABSX:      MVI	L, 126o               ;Load L with address of MSW of the FPACC
 1111/2704 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of the FPACC
 1112/2706 : C7                                    MOV	A,M                    ;Fetch the MSW of the FPACC into the accumulator
 1113/2707 : A0                                    ANA	A                    ;Test the sign of the number to see if it is positive.
 1114/2708 : 70 85 2F                              JM	FPCOMP             ;If negative, complement the number before returning.
 1115/270B : 07                                    RET                    ;Else, just return with absolute value in the FPACC.
 1116/270C : 36 56                      SGNX:      MVI	L, 126o               ;Load L with address of MSW of the FPACC
 1117/270E : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with the page of the FPACC
 1118/2710 : C7                                    MOV	A,M                    ;Fetch the MSW of the FPACC into the accumulator
 1119/2711 : A0                                    ANA	A                    ;Test to see if the FPACC is zero
 1120/2712 : 2B                                    RZ                    ;Return to caller if FPACC is zero
 1121/2713 : 50 BE 25                              JP	FPONE              ;If FPACC is positive, load +1.0 into FPACC and exit
 1122/2716 : 36 14                                 MVI	L, 024o               ;If FPACC is negative, set up to load -1.0 into the
 1123/2718 : 44 AB 31                              JMP	FLOAD              ;FPACC and exit to caller
 1124/271B : 46 03 2F                   CHRX:      CALL	FPFIX              ;Convert contents of FPACC from floating point to
 1125/271E : 36 54                                 MVI	L, 124o               ;Fixed point. Load L with address of LSW of fixed
 1126/2720 : C7                                    MOV	A,M                    ;Value. Fetch this byte into the accumulator.
 1127/2721 : 46 9E 22                              CALL	ECHO               ;Display the value.
 1128/2724 : 36 7F                                 MVI	L, 177o               ;Set L to address of the TAB FLAG
 1129/2726 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of the TAB FLAG
 1130/2728 : 3E FF                                 MVI	M, 377o               ;Set TAB FLAG (to inhibit display of FP value)
 1131/272A : 07                                    RET                    ;Exit to caller.
 1132/272B : 46 03 2F                   TABX:      CALL	FPFIX              ;Convert contents of FPACC from floating point to
 1133/272E : 36 54                      TAB1:      MVI	L, 124o               ;Fixed point. Load L with address of 1,SW of fixed
 1134/2730 : C7                                    MOV	A,M                    ;Value. Fetch this byte into the accumulator.
 1135/2731 : 36 23                                 MVI	L, 043o               ;Load L with address of COLUMN COUNTER
 1136/2733 : 97                                    SUB	M                    ;Subtract value in C-OLUMN COUNTER from desired
 1137/2734 : 36 7F                                 MVI	L, 177o               ;TAB position. Load L with address of the TAB FLAG.
 1138/2736 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of the TAB FLAG.
 1139/2738 : 3E FF                                 MVI	M, 377o               ;Set TAB FLAG (to inhibit display of FP value)
 1140/273A : 70 83 36                              JM	BACKSP             ;If beyond TAB point desired, simulate back spacing
 1141/273D : 2B                                    RZ                    ;Return to caller if at desired TAB location
 1142/273E : D0                         TABC:      MOV	C,A                    ;Else, put difference count in register C
 1143/273F : 06 A0                                 MVI	A, 240o               ;Place ASCII code for space in ACC
 1144/2741 : 46 9E 22                   TABLOP:    CALL	ECHO               ;Display space on output device
 1145/2744 : 11                                    DCR	C                    ;Decrement displacement counter
 1146/2745 : 48 41 27                              JNZ	TABLOP             ;If have not reached TAB position, continue to space
 1147/2748 : 07                                    RET                    ;Else, return to calling routine.
 1148/2749 :                            
 1149/2749 :                            ;;; The label STOSYM should be AT 10 055 082dh
 1150/2749 : 36 81                      STOSYM:    MVI	L, 201o               ;Load L with address of ARRAY FLAG
 1151/274B : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Load H with page of ARRAY FLAG
 1152/274D : C7                                    MOV	A,M                    ;Fetch the value of the ARRAY FLAG into the ACC
 1153/274E : A0                                    ANA	A                    ;Check to see if the flag is set indicating processing an
 1154/274F : 68 5C 27                              JZ	STOSY1             ;Array variable value. Jump ahead if flag not set.
 1155/2752 : 3E 00                                 MVI	M, 000                ;If ARRAY FLAG was set, clear it for next time.
 1156/2754 : 36 84                                 MVI	L, 204o               ;Then load L with address of array address storage loc
 1157/2756 : F7                                    MOV	L,M                    ;Fetch the array storage address as new pointer
 1158/2757 : 2E 05                                 MVI	H,PG57 ;\HB\OLDPG57   ;tt Set H to ARRAY VALUES page   ****************
 1159/2759 : 44 B4 31                              JMP	FSTORE             ;Store the array variable value and exit to caller.
 1160/275C : 36 F8                      STOSY1:    MVI	L, 370o               ;Load L with address of TEMP CNTR
 1161/275E : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of TEMP CNTR
 1162/2760 : 3E 00                                 MVI	M, 000                ;Initialize the TEMP CNTR by clearing it
 1163/2762 : 36 50                                 MVI	L, 120o               ;Load L with starting address of SYMBOL BUFFER
 1164/2764 : 1E 04                                 MVI	D,PG27 ;\HB\OLDPG27   ;** Load D with page of VARIABLES LOOK-UP table
 1165/2766 : 26 88                                 MVI	E, 210o               ;Load E with starting addr of VARIABLES LOOK-UP
 1166/2768 : C7                                    MOV	A,M                    ;Table. Fetch the (cc) for the SYMBOL BUFFER into
 1167/2769 : 3C 01                                 CPI	001                ;The ACC and see if length of variable name is just one
 1168/276B : 48 72 27                              JNZ	STOSY2             ;Character. If not, skip next couple of instructions.
 1169/276E : 36 52                                 MVI	L, 122o               ;Else, set pointer to second character location in the
 1170/2770 : 3E 00                                 MVI	M, 000                ;SYMBOL BUFFER and set it to zero
 1171/2772 : 36 51                      STOSY2:    MVI	L, 121o               ;load L with address of first character in the SYMBOL
 1172/2774 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** BUFFER. Load H with page of the buffer.
 1173/2776 : 46 F5 31                              CALL	SWITCH             ;Exchange pointer to buffer for pointer to VARIABLES
 1174/2779 : C7                                    MOV	A,M                    ;LOOK-UP table. Fetch first char in a name from the
 1175/277A : 30                                    INR	L                    ;Table. Advance the pointer to second char in a name.
 1176/277B : CF                                    MOV	B,M                    ;Fetch the second character into register B.
 1177/277C : 30                                    INR	L                    ;Advance the pointer to first byte of a value in the table.
 1178/277D : 46 F5 31                              CALL	SWITCH             ;Exchange table pointer for pointer to SYMBOL BUFF
 1179/2780 : BF                                    CMP	M                    ;Compare first character in buffer against first character
 1180/2781 : 48 8A 27                              JNZ	STOSY3             ;In table entry. If no match, try next entry in the table.
 1181/2784 : 30                                    INR	L                    ;If match, advance pointer to second character in buffer.
 1182/2785 : C1                                    MOV	A,B                    ;Move second character obtained from table into ACC.
 1183/2786 : BF                                    CMP	M                    ;Compare second characters in table and buffer.
 1184/2787 : 68 B3 27                              JZ	STOSY5             ;If same, have found the variable name in the table.
 1185/278A : 46 CA 25                   STOSY3:    CALL	AD4DE              ;Add four to pointer in registers D&E to skip over value
 1186/278D : 36 F8                                 MVI	L, 370o               ;Portion of entry in table. Load L with address of TEMP
 1187/278F : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** CNTR. Load H with page of TEMP CNTR.
 1188/2791 : CF                                    MOV	B,M                    ;Fetch the counter
 1189/2792 : 08                                    INR	B                    ;Increment the counter
 1190/2793 : F9                                    MOV	M,B                    ;Restore it to storage
 1191/2794 : 36 3F                                 MVI	L, 077o               ;Set L to address of VARIABLES CNTR (indicates
 1192/2796 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Number of variables currently in table.) Set H too
 1193/2798 : C1                                    MOV	A,B                    ;Move the TEMP CNTR value into the ACC. (Number of
 1194/2799 : BF                                    CMP	M                    ;Entries checked.) Compare with number of entries in
 1195/279A : 48 72 27                              JNZ	STOSY2             ;The table. If have not checked all entries, try next one.
 1196/279D : 36 3F                                 MVI	L, 077o               ;If have checked all entries, load L with address of the
 1197/279F : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** VARIABLES CNTR. Set H too. Fetch the counter
 1198/27A1 : CF                                    MOV	B,M                    ;Value and incrernent it to account for
 1199/27A2 : 08                                    INR	B                    ;New variable nwne that will now be
 1200/27A3 : F9                                    MOV	M,B                    ;Added to the table. Save the new value.
 1201/27A4 : C1                                    MOV	A,B                    ;Place the new counter value into the accumulator
 1202/27A5 : 3C 15                                 CPI	025o               ;And check to see that adding new variable name to the
 1203/27A7 : 50 AE 21                              JP	BIGERR             ;Table will not cause table overflow. Big Error if it does!
 1204/27AA : 36 51                                 MVI	L, 121o               ;If room available in table, set L to address of first
 1205/27AC : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Caracter in the SYMBOL BUFFER. Set H too.
 1206/27AE : 0E 02                                 MVI	B, 002                ;Set a counter for number of characters to transfer.
 1207/27B0 : 46 12 30                              CALL	MOVEIT             ;Move the variable name from buffer to table.
 1208/27B3 : 46 F5 31                   STOSY5:    CALL	SWITCH             ;Exchange buffer pointer for table pointer.
 1209/27B6 : 46 B4 31                              CALL	FSTORE             ;Transfer new mathematical value into the table.
 1210/27B9 : 44 C9 21                              JMP	CLESYM             ;Clear the SYMBOL BUFFER and exit to calling routine.
 1211/27BC :                            
 1212/27BC :                                                              ;The subroutines below are used by some of the routines
 1213/27BC :                                                              ;in this chapter as well as other parts of the program.
 1214/27BC :                            
 1215/27BC : 36 50                      SAVESY:    MVI	L, 120o               ;Load L with the address of the start of the SYMBOL
 1216/27BE : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** BUFFER. Load H with the page of the buffer.
 1217/27C0 : DD                                    MOV	D,H                    ;Load register D with the page of the AUX SYMBOL
 1218/27C1 : 26 64                                 MVI	E, 144o               ;BUFFER and set register E to start of that buffer.
 1219/27C3 : 44 CD 27                              JMP	MOVECP             ;Transfer SYMBOL BF contents to AUX SYMBOL BF
 1220/27C6 :                            
 1221/27C6 : 36 64                      RESTSY:    MVI	L, 144o               ;Load L with address of start of AUX SYMBOL BUFF
 1222/27C8 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of AUX SYMBOL BUFFER
 1223/27CA : DD                                    MOV	D,H                    ;Set D to page of SYMBOL BUFFER (same as H)
 1224/27CB : 26 50                                 MVI	E, 120o               ;Load E with start of SYMBOL BUFFER
 1225/27CD : CF                         MOVECP:    MOV	B,M                    ;Load (cc) for source string (first byte in source buffer)
 1226/27CE : 08                                    INR	B                    ;Add one to (cc) to include (cc) byte itself
 1227/27CF : 44 12 30                              JMP	MOVEIT             ;Move the source string to destination buffer
 1228/27D2 :                            
 1229/27D2 :                            ;;; The label Exec SHOULD BE AT 10 266 (This is the start of the code) 08b6h
 1230/27D2 : 36 EA                      EXEC:      MVI	L, 352o               ;Load L with address of READY message
 1231/27D4 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with page of READY message
 1232/27D6 : 46 6D 22                              CALL	TEXTC              ;Call subroutine to display the READY message
 1233/27D9 :                            
 1234/27D9 : 36 00                      EXEC1:     MVI	L, 000                ;Load L with starting address of INPUT LINE BUFFER
 1235/27DB : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of INPUT LINE BUFFER
 1236/27DD : 46 28 22                              CALL	STRIN              ;Call subroutine to input a line into the buffer
 1237/27E0 : C7                                    MOV	A,M                    ;The STRIN subroutine will exit with pointer set to the
 1238/27E1 : A0                                    ANA	A                    ;CHARACTER COUNT for the line inputted. Fetch the
 1239/27E2 : 68 D9 27                              JZ	EXEC1              ;Value of the counter, if it is zero then line was blank.
 1240/27E5 : 36 DD                                 MVI	L, 335o               ;Load L with address of LIST in look up table
 1241/27E7 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;Load H with address of LIST in look up table
 1242/27E9 : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;Load D with page of line input buffer
 1243/27EB : 26 00                                 MVI	E, 000                ;Load E with start of line input buffer
 1244/27ED : 46 F6 21                              CALL	STRCP              ;Call string compare subroutine to see if first word in
 1245/27F0 : 48 08 28                              JNZ	NOLIST             ;Input buffer is LIST. Jump 3 ahead if not LIST.
 1246/27F3 : 36 00                                 MVI	L, 000                ;If LIST, set up pointers to start of USER PROGRAM
 1247/27F5 : 2E 06                                 MVI	H, BGNPGRAM           ;BUFFER. (Note user could alter this starting addr)   *****
 1248/27F7 :                            
 1249/27F7 :                                                              ;Next portion of program will LIST the contents of the
 1250/27F7 :                                                              ;USER PROGRAM BUFFER until an end of buffer
 1251/27F7 :                                                              ;(zero byte) indicator is detected.
 1252/27F7 :                            
 1253/27F7 : C7                         LIST:      MOV	A,M                    ;Fetch the first byte of a line in the USER PROGRAM
 1254/27F8 : A0                                    ANA	A                    ;BUFFER and see if it is zero. If so, have finished LIST
 1255/27F9 : 68 D2 27                              JZ	EXEC               ;So go back to start of Executive and display READY.
 1256/27FC : 46 6D 22                              CALL	TEXTC              ;Else call subroutine to display a line of information
 1257/27FF : 46 1B 22                              CALL	ADV                ;Now call subroutine to advance buffer pointer to
 1258/2802 : 46 7D 22                              CALL	CRLF               ;Character count in next line. Also display a CR & LF.
 1259/2805 : 44 F7 27                              JMP	LIST               ;Continue LISTing process
 1260/2808 :                            
 1261/2808 :                                                              ;If line inputted by operator did not contain a LIST comman
 1262/2808 :                                                              ;continue program to see if RUN or SCRatch command.
 1263/2808 :                            
 1264/2808 : 36 E2                      NOLIST:    MVI	L, 342o               ;Load L with address of RUN in look up table
 1265/280A : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with address of RUN in look up table
 1266/280C : 26 00                                 MVI	E, 000                ;Load E with start of line input buffer
 1267/280E : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Load D with page of line input buffer
 1268/2810 : 26 00                                 MVI	E, 000                ;(Reserve 2 locs in case of patching by duplicating above)
 1269/2812 : 46 F6 21                              CALL	STRCP              ;Call string compare subroutine to see if first word in
 1270/2815 : 68 43 2A                              JZ	RUN                ;Input buffer is RUN. Go to RUN routine if match.
 1271/2818 : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;** If not RUN command, reset address pointers back
 1272/281A : 26 00                                 MVI	E, 000                ;To the start of the line input buffer
 1273/281C : 36 E6                                 MVI	L, 346o               ;Load L with address of SCR in look up table
 1274/281E : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with page of SCR in look up table
 1275/2820 : 46 F6 21                              CALL	STRCP              ;Call string compare subroutine to see if first word in
 1276/2823 : 48 55 28                              JNZ	NOSCR              ;Input buffer is SCR. If not then jump ahead.
 1277/2826 : 2E 03                      ENTRY_SCR: MVI	H,PG26 ;\HB\OLDPG26   ;** If found SCR command then load memory pointer
 1278/2828 : 36 F4                                 MVI	L, 364o               ;With address of a pointer storage location. Set that
 1279/282A : 3E 06                                 MVI	M, BGNPGRAM           ;tt Storage location to page of start of USER PRO-  *******
 1280/282C : 30                                    INR	L                    ;GRAM BUFFER. (Buffer start loc may be altered).
 1281/282D : 3E 00                                 MVI	M, 000                ;Then adv pntr and do same for low addr portion of pntr
 1282/282F : 36 3F                                 MVI	L, 077o               ;Now set pointer to address of VARIABLES counter
 1283/2831 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Storage location. Initialize this counter by placing
 1284/2833 : 3E 01                                 MVI	M, 001                ;The count of one into it. Now change the memory pntr
 1285/2835 :                            ;MGA 3/31/12 put it back to 001; solves nested FOR/NEXT, but limits vars to 19
 1286/2835 :                            ;   as the letter from James Tucker (1/77) mentioned
 1287/2835 :                            ;   apparently, James didn't test FOR/NEXT; original Loboyko didn't have this
 1288/2835 :                            ;;;           LMI 001                ;The count of one into it. Now change the memory pntr
 1289/2835 :                            ;;; Apparently, in Page 3 of Issue 4 of Scelbal update (1/77) they say the above should change.
 1290/2835 :                            ;;; This makes the SCR command clear the whole variable space, otherwise one space is lost.  
 1291/2835 : 36 3D                                 MVI	L, 075o               ;To storage location for number of dimensioned arrays
 1292/2837 : 3E 00                                 MVI	M, 000                ;@@ And initialize to zero. (@@ = Substitute NOPs if
 1293/2839 : 36 50                                 MVI	L, 120o               ;@@ DIMension capability not used in package.) Also
 1294/283B : 3E 00                                 MVI	M, 000                ;@@ Initialize l'st byte of array name table to zero.
 1295/283D : 36 88                                 MVI	L, 210o               ;Set pointer to storage location for the first byte of the
 1296/283F : 3E 00                                 MVI	M, 000                ;VARIABLES symbol table. Initialize it to zero too.
 1297/2841 : 30                                    INR	L                    ;Advance the pointer and zero the second location
 1298/2842 : 3E 00                                 MVI	M, 000                ;In the Variables table also.
 1299/2844 : 2E 06                                 MVI	H, BGNPGRAM           ;tt Load H with page of start of USER PROGRAM    **********
 1300/2846 : 36 00                                 MVI	L, 000                ;BUFFER. (Buffer start location could be altered.)
 1301/2848 : 3E 00                                 MVI	M, 000                ;Clear first location to indicate end of user program.
 1302/284A : 2E 05                                 MVI	H,PG57 ;\HB\OLDPG57   ;@@ Load H with page of ARRAYS storage
 1303/284C : 3E 00                      SCRLOP:    MVI	M, 000                ;@@ And form a loop to clear out all the locations
 1304/284E : 30                                    INR	L                    ;@@ On the ARRAYS storage page. (@@ These become
 1305/284F : 48 4C 28                              JNZ SCRLOP             ;@@ NOPs if DIMension capability deleted fm package.)
 1306/2852 : 44 D2 27                              JMP EXEC               ;SCRatch operations completed, go back to EXEC.
 1307/2855 :                            
 1308/2855 :                                                              ;If line inputted did not contain RUN or SCRatch com-
 1309/2855 :                                                              ;mand, program continues by testing for SAVE or LOAD
 1310/2855 :                                                              ;commands. If it does not find either of these com-
 1311/2855 :                                                              ;mands, then operator did not input an executive com-
 1312/2855 :                                                              ;mand. Program then sets up to see if the first entry in
 1313/2855 :                                                              ;the line inputted is a LINE NUMBER.
 1314/2855 :                            
 1315/2855 : 26 BA                      NOSCR:     MVI	E, 272o               ;Load E with address of SAVE in look up table
 1316/2857 : 1E 02                                 MVI	D,PG01 ;\HB\OLDPG1    ;Load D with page of look up table
 1317/2859 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;Load H with page of input line buffer
 1318/285B : 36 00                                 MVI	L, 000                ;Set L to start of input line buffer
 1319/285D : 46 F6 21                              CALL	STRCP              ;Call string compare subroutine to see if first word in
 1320/2860 : 68 B5 20                              JZ	EXIT               ;tt Input buffer is SAVE. If so, go to user's SAVE rtn
 1321/2863 : 36 BF                                 MVI	L, 277o               ;If not SAVE then load L with address of LOAD in look
 1322/2865 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;Up table and load H with page of look up table
 1323/2867 : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;Load D with page of input line buffer
 1324/2869 : 26 00                                 MVI	E, 000                ;And L to start of input line buffer
 1325/286B : 46 F6 21                              CALL	STRCP              ;Call string compare subroutine to see if first word in
 1326/286E : 68 B9 20                              JZ	MON                ;tt Input buffer is LOAD. If so, go to user's LOAD rtn
 1327/2871 : 36 F0                                 MVI	L, 360o               ;If not LOAD then set pointer to address of storage loc
 1328/2873 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** For USER PROGRAM BUFFER pointer. Initialize this
 1329/2875 : 3E 06                                 MVI	M, BGNPGRAM           ;tt Pointer to the starting address of the program buffer.
 1330/2877 : 30                                    INR	L                    ;Advance memory pntr. Since pointer storage requires
 1331/2878 : 3E 00                                 MVI	M, 000                ;Two locations, initialize the low addr portion also.
 1332/287A : 46 1C 21                              CALL	SYNTAX             ;Call the SYNTAX subroutine to obtain a TOKEN indi-
 1333/287D : 36 83                                 MVI	L, 203o               ;Cator which will be stored in this location. Upon return
 1334/287F : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** From SYNTAX subroutine set memory pointer to
 1335/2881 : C7                                    MOV	A,M                    ;The TOKEN indicator storage location and fetch the
 1336/2882 : A0                                    ANA	A                    ;Value of the TOKEN. If the value of the syntax TOKEN
 1337/2883 : 50 8D 28                              JP	SYNTOK             ;Is positive then have a valid entry.
 1338/2886 : 06 D3                      SYNERR:    MVI	A, 323o               ;However, if SYNTAX returns a negative value TOKEN
 1339/2888 : 16 D9                                 MVI	C, 331o               ;Then have an error condition. Set up the letters SY in
 1340/288A : 44 B2 21                              JMP	ERROR              ;ASCII code and go to display error message to operator.
 1341/288D : 36 E0                      SYNTOK:    MVI	L, 340o               ;Set pointer to start of LINE NUMBER storage area
 1342/288F : C7                                    MOV	A,M                    ;First byte there will contain the length of the line
 1343/2890 : A0                                    ANA	A                    ;Number character string. Fetch that value (cc).
 1344/2891 : 68 94 2A                              JZ	DIRECT             ;DIRECT If line number blank, have a DIRECT statement!
 1345/2894 : 36 F0                                 MVI	L, 360o               ;If have a line number must get line in input buffer into
 1346/2896 : 3E 06                                 MVI	M, BGNPGRAM           ;tt User program buffer. Initialize pointer to user buffer.
 1347/2898 : 30                                    INR	L                    ;This is a two byte pointer so after initializing page addr
 1348/2899 : 3E 00                                 MVI	M, 000                ;Advance pointer and initialize location on page address
 1349/289B :                            
 1350/289B :                                                              ;If the line in the LINE INPUT BUFFER has a line num-
 1351/289B :                                                              ;ber then the line is to be placed in the USER PRO-
 1352/289B :                                                              ;GRAM BUFFER. It is now necessary to determine
 1353/289B :                                                              ;where the new line is to be placed in the USER PRO-
 1354/289B :                                                              ;GRAM BUFFER. This is dictated by the value of the
 1355/289B :                                                              ;new line number in relation to the line numbers cur-
 1356/289B :                                                              ;rently in the program buffer. The next portion of the
 1357/289B :                                                              ;program goes through the contents of the USER PRO-
 1358/289B :                                                              ;GRAM BUFFER comparing the values of the line num-
 1359/289B :                                                              ;bers already stored against the value of the line number
 1360/289B :                                                              ;currently being held in the LINE INPUT BUFFER.
 1361/289B :                                                              ;Appropriate action is then taken to Insert or Append,
 1362/289B :                                                              ;Change, or Delete a line in the program buffer.
 1363/289B :                            
 1364/289B : 36 81                      GETAUX:    MVI	L, 201o               ;Set memory pointer to line character pointer storage
 1365/289D : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Location and then initialize that storage location
 1366/289F : 3E 01                                 MVI	M, 001                ;To point to the 1'st character in a line
 1367/28A1 : 36 E8                                 MVI	L, 350o               ;Set memory pointer to addr of start of auxiliary line
 1368/28A3 : 3E 00                                 MVI	M, 000                ;Number storage area and initialize first byte to zero
 1369/28A5 : 36 81                      GETAU0:    MVI	L, 201o               ;Set memory pointer to line character pointer storage loc
 1370/28A7 : 46 58 29                              CALL	GETCHP             ;Fetch a char in line pointed to by line pointer
 1371/28AA : 68 BE 28                              JZ	GETAU1             ;If character is a space, skip it by going to advance pntrs
 1372/28AD : 3C B0                                 CPI	260o               ;If not a space check to see if character represents a
 1373/28AF : 70 D3 28                              JM	GETAU2             ;Valid decimal digit in the range 0 to 9 by testing the
 1374/28B2 : 3C BA                                 CPI	272o               ;ASCII code value obtained. If not a deciznal digit then
 1375/28B4 : 50 D3 28                              JP	GETAU2             ;Assume have obtained the line number. Go process.
 1376/28B7 : 36 E8                                 MVI	L, 350o               ;If valid decimal digit want to append the digit to the
 1377/28B9 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Current string being built up in the auxiliary line
 1378/28BB : 46 E8 21                              CALL	CONCT1             ;Number storage area so call sub to concat a character.
 1379/28BE : 36 81                      GETAU1:    MVI	L, 201o               ;Reset memory pointer to line character pntr storage loc
 1380/28C0 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;On the appropriate page.
 1381/28C2 : CF                                    MOV	B,M
 1382/28C3 : 08                                    INR	B                    ;Fetch the pointer, increment it, and restore new value
 1383/28C4 : F9                                    MOV	M,B
 1384/28C5 : 36 F0                                 MVI	L, 360o               ;Set memory pointer to pgm buff line pntr storage loc
 1385/28C7 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   
 1386/28C9 : D7                                    MOV	C,M                    ;Bring the high order byte of this double byte pointer
 1387/28CA : 30                                    INR	L                    ;Into CPU register C. Then advance the memory pntr
 1388/28CB : F7                                    MOV	L,M                    ;And bring the low order byte into register L. Now trans-
 1389/28CC : EA                                    MOV	H,C                    ;Fer the higher order portion into memory pointer H.
 1390/28CD : C7                                    MOV	A,M                    ;Obtain the char cntr (cc) which indicates the length of
 1391/28CE : 09                                    DCR	B                    ;The line being pointed to by the user program line pntr
 1392/28CF : B9                                    CMP	B                    ;Compare this with the value of the chars processed so
 1393/28D0 : 48 A5 28                              JNZ	GETAU0             ;Far in current line. If not equal, continue getting line n
 1394/28D3 : 36 F0                      GETAU2:    MVI	L, 360o               ;Reset mem pntr to pgm buffer line pntr storage
 1395/28D5 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** On this page and place the high order byte
 1396/28D7 : DF                                    MOV	D,M                    ;Of this pointer into CPU register D
 1397/28D8 : 30                                    INR	L                    ;Advance the memory pointer, fetch the second
 1398/28D9 : F7                                    MOV	L,M                    ;Byte of the pgm buffer line pointer into register L
 1399/28DA : EB                                    MOV	H,D                    ;Now make the memory pointer equal to this value
 1400/28DB : C7                                    MOV	A,M                    ;Fetch the first byte of a line in the program buffer
 1401/28DC : A0                                    ANA	A                    ;Test to see if end of contents of pgm buff (zero byte)
 1402/28DD : 48 E3 28                              JNZ	NOTEND             ;If not zero continue processing. If zero have reached
 1403/28E0 : 44 0A 29                              JMP	NOSAME             ;End of buffer contents so go APPEND line to buffer.
 1404/28E3 :                            ;;; there are some open addresses here.  Above JUMP starts at 11-304;
 1405/28E3 :                            
 1406/28E3 :                            ;          ORG	09deh              ;011#336
 1407/28E3 : 36 E8                      NOTEND:    MVI	L, 350o               ;Load L with addr of auxiliary line number storage loc
 1408/28E5 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;Load H with addr of aux line number storage loc
 1409/28E7 : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;Load D with addr of line number buffer location
 1410/28E9 : 26 E0                                 MVI	E, 340o               ;Load E with address of line number buffer location
 1411/28EB : 46 F6 21                              CALL	STRCP              ;Compare line nr in input buffer with line number in
 1412/28EE : 70 40 29                              JM	CONTIN             ;User program buffer. If lesser in value keep looking.
 1413/28F1 : 48 0A 29                              JNZ	NOSAME             ;If greater in value then go to Insert line in pgm buffer
 1414/28F4 : 36 F0                                 MVI	L, 360o               ;If same values then must remove the line with the same
 1415/28F6 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Line number from the user program buffer. Set up
 1416/28F8 : D7                                    MOV	C,M                    ;The CPU memory pointer to point to the current
 1417/28F9 : 30                                    INR	L                    ;Position in the user program buffer by retrieving that
 1418/28FA : F7                                    MOV	L,M                    ;Pointer from its storage location. Then obtain the first
 1419/28FB : EA                                    MOV	H,C                    ;Byte of data pointed to which will be the character
 1420/28FC : CF                                    MOV	B,M                    ;Count for that line (cc). Add one to the cc value to take
 1421/28FD : 08                                    INR	B                    ;Account of the (cc) byte itself and then remove that
 1422/28FE : 46 69 29                              CALL	REMOVE             ;Many bytes to effectively delete the line fm the user
 1423/2901 : 36 83                                 MVI	L, 203o               ;Program buffer. Now see if line in input buffer consists
 1424/2903 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Only of a line number by checking SYNTAX
 1425/2905 : C7                                    MOV	A,M                    ;TOKEN value. Fetch the TOKEN value from its
 1426/2906 : A0                                    ANA	A                    ;Storage location. If it is zero then input buffer only
 1427/2907 : 68 D2 27                              JZ	EXEC               ;Contains a line number. Action is a pure Delete.
 1428/290A : 36 F0                      NOSAME:    MVI	L, 360o               ;Reset memory pointer to program buffer
 1429/290C : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;Line pointer storage location
 1430/290E : DF                                    MOV	D,M                    ;Load high order byte into CPU register D
 1431/290F : 30                                    INR	L                    ;Advance memory pointer
 1432/2910 : E7                                    MOV	E,M                    ;Load low order byte into CPU register E
 1433/2911 : 36 00                                 MVI	L, 000                ;Load L with address of start of line input buffer
 1434/2913 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Do same for CPU register H
 1435/2915 : CF                                    MOV	B,M                    ;Get length of line input buffer
 1436/2916 : 08                                    INR	B                    ;Advance length by one to include (cc) byte
 1437/2917 : 46 8A 29                              CALL	INSERT             ;Go make room to insert line into user program buffer
 1438/291A : 36 F0                                 MVI	L, 360o               ;Reset memory pointer to program buffer
 1439/291C : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Line pointer storage location
 1440/291E : DF                                    MOV	D,M                    ;Load higher byte into CPU register D
 1441/291F : 30                                    INR	L                    ;Advance memory pointer
 1442/2920 : E7                                    MOV	E,M                    ;Load low order byte into CPU register E
 1443/2921 : 36 00                                 MVI	L, 000                ;Load L with address of start of line input buffer
 1444/2923 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Do same for CPU register H
 1445/2925 : 46 2B 29                              CALL	MOVEC              ;Call subroutine to Insert line in input buffer into the
 1446/2928 : 44 D9 27                              JMP	EXEC1              ;User program buffer then go back to start of EXEC.
 1447/292B : CF                         MOVEC:     MOV	B,M                    ;Fetch length of string in line input buffer
 1448/292C : 08                                    INR	B                    ;Increment that value to provide for (cc)
 1449/292D : C7                         MOVEPG:    MOV	A,M                    ;Fetch character from line input buffer
 1450/292E : 46 1B 22                              CALL	ADV                ;Advance pointer for line input buffer
 1451/2931 : 46 F5 31                              CALL	SWITCH             ;Switch memory pointer to point to user pgm buffer
 1452/2934 : F8                                    MOV	M,A                    ;Deposit character fm input buff into user pgm buff
 1453/2935 : 46 1B 22                              CALL	ADV                ;Advance pointer for user program buffer
 1454/2938 : 46 F5 31                              CALL	SWITCH             ;Switch memory pntr back to point to input buffer
 1455/293B : 09                                    DCR	B                    ;Decrement character counter stored in CPU register B
 1456/293C : 48 2D 29                              JNZ	MOVEPG             ;If counter does not go to zero continue transfer ops
 1457/293F : 07                                    RET                    ;When counter equals zero return to caMVI L,ng routine
 1458/2940 : 36 F0                      CONTIN:    MVI	L, 360o               ;Reset memory pointer to program buffer
 1459/2942 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Line pointer storage location
 1460/2944 : DF                                    MOV	D,M                    ;Load high order byte into CPU register D
 1461/2945 : 30                                    INR	L                    ;Advance memory pointer
 1462/2946 : E7                                    MOV	E,M                    ;Load low order byte into CPU register E
 1463/2947 : EB                                    MOV	H,D                    ;Now set CPU register H to high part of address
 1464/2948 : F4                                    MOV	L,E                    ;And set CPU register L to low part of address
 1465/2949 : CF                                    MOV	B,M                    ;Fetch the character counter (cc) byte fm line in
 1466/294A : 08                                    INR	B                    ;Program buffer and add one to compensate for (cc)
 1467/294B : 46 CA 29                              CALL	ADBDE              ;Add length of line value to old value to get new pointer
 1468/294E : 36 F0                                 MVI	L, 360o               ;Reset memory pointer to program buffer
 1469/2950 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Line pointer storage location
 1470/2952 : FB                                    MOV	M,D                    ;Restore new high portion
 1471/2953 : 30                                    INR	L                    ;Advance memory pointer
 1472/2954 : FC                                    MOV	M,E                    ;And restore new low portion
 1473/2955 : 44 9B 28                              JMP	GETAUX             ;Continue til find point at which to enter new line
 1474/2958 : 2E 03                      GETCHP:    MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with pointer page (low portion set upon
 1475/295A : CF                                    MOV	B,M                    ;Entry). Now fetch pointer into CPU register B.
 1476/295B : 36 F0                                 MVI	L, 360o               ;Reset pntr to pgm buffer line pointer storage location
 1477/295D : DF                                    MOV	D,M                    ;Load high order byte into CPU register D
 1478/295E : 30                                    INR	L                    ;Advance memory pointer
 1479/295F : E7                                    MOV	E,M                    ;Load low order byte into CPU register E
 1480/2960 : 46 CA 29                              CALL	ADBDE              ;Add pointer to pgm buffer pointer to obtain address of
 1481/2963 : EB                                    MOV	H,D                    ;Desired character. Place high part of new addr in H.
 1482/2964 : F4                                    MOV	L,E                    ;And low part of new address in E.
 1483/2965 : C7                                    MOV	A,M                    ;Fetch character from position in line in user pgm buffer
 1484/2966 : 3C A0                                 CPI	240o               ;See if it is the ASCII code for space
 1485/2968 : 07                                    RET                    ;Return to caller with flags set to indicate result
 1486/2969 : 46 98 22                   REMOVE:    CALL	INDEXB             ;Add (cc) plus one to addr of start of line
 1487/296C : D7                                    MOV	C,M                    ;Obtain byte from indexed location and
 1488/296D : 46 67 22                              CALL	SUBHL              ;Subtract character count to obtain old location
 1489/2970 : FA                                    MOV	M,C                    ;Put new byte in old location
 1490/2971 : C2                                    MOV	A,C                    ;As well as in the Accumulator
 1491/2972 : A0                                    ANA	A                    ;Test to see if zero byte to indicate end of user pgm buff
 1492/2973 : 68 7C 29                              JZ	REMOV1             ;If it is end of user pgm buffer, go complete process
 1493/2976 : 46 1B 22                              CALL	ADV                ;Otherwise add one to the present pointer value
 1494/2979 : 44 69 29                              JMP	REMOVE             ;And continue removing chamcters from the user pgm bf
 1495/297C : 36 F4                      REMOV1:    MVI	L, 364o               ;Load L with end of user pgm buffer pointer storage loc
 1496/297E : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of that pointer storage location
 1497/2980 : DF                                    MOV	D,M                    ;Get page portion of end of pgm buffer address
 1498/2981 : 30                                    INR	L                    ;Advance memory pointer
 1499/2982 : C7                                    MOV	A,M                    ;And get low portion of end of pgm buffer address into
 1500/2983 : 91                                    SUB	B                    ;Accumulator then subtract displacement value in B
 1501/2984 : F8                                    MOV	M,A                    ;Restore new low portion of end of pgm buffer address
 1502/2985 : 03                                    RNC                    ;If subtract did not cause carry can return now
 1503/2986 : 31                                    DCR	L                    ;Otherwise decrement memory pointer back to page
 1504/2987 : 19                                    DCR	D                    ;Storage location, decrement page value to give new page
 1505/2988 : FB                                    MOV	M,D                    ;And store new page value back in buffer pntr storage loc
 1506/2989 : 07                                    RET                    ;Then return to calling routine
 1507/298A : 36 F4                      INSERT:    MVI	L, 364o               ;Load L with end of user pgm buffer pointer storage loc
 1508/298C : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of that pointer storage location
 1509/298E : C7                                    MOV	A,M                    ; Get page portion of end of program buffer address
 1510/298F : 30                                    INR	L                    ;Advance memory pointer
 1511/2990 : F7                                    MOV	L,M                    ;Load low portion of end of program buffer address
 1512/2991 : E8                                    MOV	H,A                    ;Into L and finish setting up memory pointer
 1513/2992 : 46 98 22                              CALL	INDEXB             ;Add (cc) of line in input buffer to form new end of
 1514/2995 : C5                                    MOV	A,H                    ;Program buffer address. Fetch new end of buffer page
 1515/2996 : 3C 1E                                 CPI	ENDPGRAM           ;tt Address and see if this value would exceed user's
 1516/2998 : 50 AE 21                              JP	BIGERR             ;System capabilit'y. Go display error message if so!
 1517/299B : 46 67 22                              CALL	SUBHL              ;Else restore original value of end of buffer address
 1518/299E : D7                         INSER1:    MOV	C,M                    ;Bring byte pointed to by H & L into CPU register C
 1519/299F : 46 98 22                              CALL	INDEXB             ;Add displacement value to current memory pointer
 1520/29A2 : FA                                    MOV	M,C                    ;Store the byte in the new location
 1521/29A3 : 46 67 22                              CALL	SUBHL              ;Now subtract displacement value from H & L
 1522/29A6 : 46 C4 29                              CALL	CPHLDE             ;Compare this with the address stored in D & E
 1523/29A9 : 68 B2 29                              JZ	INSER3             ;If same then go finish up Insert operation
 1524/29AC : 46 90 22                              CALL	DEC                ;Else set pointer to the byte before the byte just
 1525/29AF : 44 9E 29                              JMP	INSER1             ;Processed and continue the Insert operation
 1526/29B2 :                            INSER3:
 1527/29B2 : 36 00                      INCLIN:    MVI	L, 000                ;Load L with start of line input buffer
 1528/29B4 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of start of line input buffer
 1529/29B6 : CF                                    MOV	B,M                    ;Fetch length of the line in line input buffer
 1530/29B7 : 08                                    INR	B                    ;Increment value by one to include (cc) byte
 1531/29B8 : 36 F4                                 MVI	L, 364o               ;Set memory pointer to end of user pgrn buffer pointer
 1532/29BA : DF                                    MOV	D,M                    ;Storage location on same page and fetch page address
 1533/29BB : 30                                    INR	L                    ;Of this pointer into D. Then advance memory pointer
 1534/29BC : E7                                    MOV	E,M                    ;And get low part of this pointer into CPU register E.
 1535/29BD : 46 CA 29                              CALL	ADBDE              ;Now add displacement (cc) of line in input buffer to
 1536/29C0 : FC                                    MOV	M,E                    ;The end of program buffer pointer. Replace the updated
 1537/29C1 : 31                                    DCR	L                    ;Low portion of the new pointer value back in stomge
 1538/29C2 : FB                                    MOV	M,D                    ;And restore the new page value back into storage
 1539/29C3 : 07                                    RET                    ;Then return to calling routine
 1540/29C4 : C5                         CPHLDE:    MOV	A,H                    ;Subroutine to compare if the contents of CPU registers
 1541/29C5 : BB                                    CMP	D                    ;H & L are equal to registers D & E. First compare
 1542/29C6 : 0B                                    RNZ                    ;Register H to D. Return with flags set if not equal. If
 1543/29C7 : C6                                    MOV	A,L                    ;Equal continue by comparing register L to E.
 1544/29C8 : BC                                    CMP	E                    ;IF L equals E then H & L equal to D & E so return to
 1545/29C9 : 07                                    RET                    ;Calling routines with flags set to equality status
 1546/29CA : C4                         ADBDE:     MOV	A,E                    ;Subroutine to add the contents of CPU register B (single
 1547/29CB : 81                                    ADD	B                    ;Byte value) to the double byte value in registers D & E.
 1548/29CC : E0                                    MOV	E,A                    ;First add B to E to form new least significant byte
 1549/29CD : 03                                    RNC                    ;Restore new value to E and exit if no carry resulted
 1550/29CE : 18                                    INR	D                    ;If had a carry then must increment most significant byte
 1551/29CF : 07                                    RET                    ;In register D before returning to calling routine
 1552/29D0 : 06 DE                      CTRLC:     MVI	A, 336o               ;Set up ASCII code for t (up arrow) in Accumulator.
 1553/29D2 : 16 C3                                 MVI	C, 303o               ;Set up ASCII code for letter 'C' in CPU register C.
 1554/29D4 : 44 B2 21                              JMP	ERROR              ;Go display the 'Control C' condition message.
 1555/29D7 : 36 E0                      FINERR:    MVI	L, 340o               ;Load L with starting address of line number storage area
 1556/29D9 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of line number storage area
 1557/29DB : C7                                    MOV	A,M                    ;Get (cc) for line number string. If length is zero meaning
 1558/29DC : A0                                    ANA	A                    ;There is no line number stored in the buffer then jump
 1559/29DD : 68 EE 29                              JZ	FINER1             ;Ahead to avoid displaying "AT LINE" message
 1560/29E0 : 36 F6                                 MVI	L, 366o               ;Else load L with address of start of "AT LINE" message
 1561/29E2 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Stored on this page
 1562/29E4 : 46 6D 22                              CALL	TEXTC              ;Call subroutine to display the "AT LINE" message
 1563/29E7 : 36 E0                                 MVI	L, 340o               ;Now reset L to starting address of line number storage
 1564/29E9 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Area and do same for CPU register H
 1565/29EB : 46 6D 22                              CALL	TEXTC              ;Call subroutine to display the line number
 1566/29EE : 46 7D 22                   FINER1:    CALL	CRLF               ;Call subroutine to provide a carriage-return and line-feed
 1567/29F1 :                            ;	   JMP	PATCH3 
 1568/29F1 :                            ;;; The below label patch3 should start at 11 307 09c7h
 1569/29F1 : 36 81                      PATCH3:	   MVI	L, 201o               ; ptr to A/V storage
 1570/29F3 : 2E 04                      	   MVI	H,PG27 ;\HB\OLDPG27   ; MGA 3/31/12 make relocatable; prev: LHI 027
 1571/29F5 : 3E 00                      	   MVI	M, 000o               ; clear A/V flag
 1572/29F7 : 44 D2 27                   	   JMP	EXEC
 1573/29FA :                            ;;; The following is the old code, before patch 3
 1574/29FA :                            ;;;        JMP	EXEC               ;To the display device then return to EXECUTIVE.
 1575/29FA : 06 C4                      DVERR:     MVI	A, 304o               ;Set up ASCII code for letter 'D' in Accumulator
 1576/29FC : 16 DA                                 MVI	C, 332o               ;Set up ASCII code for letter 'Z' in CPU register C
 1577/29FE : 44 B2 21                              JMP	ERROR              ;Go display the 'DZ' (divide by zero) error message
 1578/2A01 : 06 C6                      FIXERR:    MVI	A, 306o               ;Set up ASCII code for letter 'F' in Accumulator
 1579/2A03 : 16 D8                                 MVI	C, 330o               ;Set up ASCII code for letter 'X' in CPU register C
 1580/2A05 : 44 B2 21                              JMP	ERROR              ;Go display the 'FX' (FiX) error message
 1581/2A08 : 06 C9                      NUMERR:    MVI	A, 311o               ;Set up ASCII code for letter 'I' in Accumulator
 1582/2A0A : 16 CE                                 MVI	C, 316o               ;Set up ASCII code for letter 'N' in CPU register C
 1583/2A0C : 36 90                                 MVI	L, 220o               ;Load L with address of pointer used by DINPUT
 1584/2A0E : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Routine. Do same for register H.
 1585/2A10 : 3E 00                                 MVI	M, 000                ;Clear the location
 1586/2A12 : 44 B2 21                              JMP	ERROR              ;Go display the'IN'(Illegal Number) error message
 1587/2A15 :                            
 1588/2A15 :                                                              ;The following subroutine, used by various sections of
 1589/2A15 :                                                              ;SCELBAL, will search the LINE INPUT BUGGER for
 1590/2A15 :                                                              ;a character string which is contained in a buffer starting
 1591/2A15 :                                                              ;at the address pointed to by CPU registers H & L when
 1592/2A15 :                                                              ;the subroutine is entered.
 1593/2A15 :                            
 1594/2A15 : 1E 03                      INSTR:     MVI	D,PG26 ;\HB\OLDPG26   ;**Set D to starting page of LINE INPUT BUFFER
 1595/2A17 : 26 00                                 MVI	E, 000                ;Load E with starting location of LINE INPUT BUFFER
 1596/2A19 : 46 3F 2A                   INSTR1:    CALL	ADVDE              ;Advancer D & E pointer to the next location (input
 1597/2A1C : 46 D6 31                              CALL	SAVEHL             ;Buffer). Now save contents of d, E, H & L vefore the
 1598/2A1F : CF                                    MOV	B,M                    ;Compare operations. Get length of TEST buffer in B.
 1599/2A20 : 46 1B 22                              CALL	ADV                ;Advance H & L buffer to first char in TEST buffer.
 1600/2A23 : 46 14 22                              CALL	STRCPC             ;Compare contents of TEST buffer against input buffer
 1601/2A26 : 68 E6 31                              JZ	RESTHL             ;For length B. If match, restore pntrs and exit to caller.
 1602/2A29 : 46 E6 31                              CALL	RESTHL             ;If no match, restore pointers for loop test.
 1603/2A2C : 36 00                                 MVI	L, 000                ;Load L with start of input buffer (to get the char cntr).
 1604/2A2E : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;**Load H with page of input buffer.
 1605/2A30 : C7                                    MOV	A,M                    ;Get length of buffer (cc) into the accumulator.
 1606/2A31 : BC                                    CMP	E                    ;Compare with current input buffer pointer value.
 1607/2A32 : 68 3C 2A                              JZ	INSTR2             ;If at end of buffer, jump ahead.
 1608/2A35 : 46 E6 31                              CALL	RESTHL             ;Else restore test string address (H&L) and input buffer
 1609/2A38 : 44 19 2A                              JMP	INSTR1             ;Address (D&E). Look gor occurrence of test string in ln.
 1610/2A3B : 00                                    HLT             ;Safety halt. If program reaches here have system failure.
 1611/2A3C : 26 00                      INSTR2:    MVI	E, 000                ;If reach end of input buffer without finding a match
 1612/2A3E : 07                                    RET                    ;Load E with 000 as an indicator and return to caller.
 1613/2A3F : 20                         ADVDE:     INR	E                    ;Subroutine to advance the pointer in the register
 1614/2A40 : 0B                                    RNZ                    ;Pair D & E. Advance contents of E. Return if not zero.
 1615/2A41 : 18                                    INR	D                    ;If register E goes to 0 when advanced, then advance
 1616/2A42 : 07                                    RET                    ;Register D too. Exit to calling routine.
 1617/2A43 :                            
 1618/2A43 :                            ;;; The label RUN should start at 13-170 0b78h
 1619/2A43 : 36 3B                      RUN:       MVI	L, 073o               ;Load L with addr of GOSUB/RETURN stack pointer
 1620/2A45 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Load H with page of same pointer
 1621/2A47 : 3E 00                                 MVI	M, 000                ;Initialize the GOSUB/RETURN stack pointer to zero
 1622/2A49 : 36 85                                 MVI	L, 205o               ;Load L with addr of FOR/NEXT stack pointer
 1623/2A4B : 3E 00                                 MVI	M, 000                ;Initialize the FOR/NEXT stack pointer to zero
 1624/2A4D : 36 F0                                 MVI	L, 360o               ;Load L with addr of user pgm buffer line pointer
 1625/2A4F : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of user pgm buffer line pointer
 1626/2A51 : 3E 06                                 MVI	M, BGNPGRAM           ;tt Initialize pointer (may be altered by user)   *******
 1627/2A53 : 30                                    INR	L                    ;Advance memory pointer to low portion of user pgm
 1628/2A54 : 3E 00                                 MVI	M, 000                ;Buffer pointer and initialize to start of buffer
 1629/2A56 : 44 79 2A                              JMP	SAMLIN             ;Start executing user program with first line in buffer
 1630/2A59 : 36 F0                      NXTLIN:    MVI	L, 360o               ;Load L with addr of user program buffer line pointer
 1631/2A5B : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of user pgm buffer line pointer
 1632/2A5D : DF                                    MOV	D,M                    ;Place page addr of pgm buffer line pointer in D
 1633/2A5E : 30                                    INR	L                    ;Advance the memory pointer
 1634/2A5F : E7                                    MOV	E,M                    ;Place low addr of pgm buffer line pointer in E
 1635/2A60 : EB                                    MOV	H,D                    ;Also put page addr of pgm buffer line pointer in H
 1636/2A61 : F4                                    MOV	L,E                    ;And low addr of pgm buffer line pointer in L
 1637/2A62 : CF                                    MOV	B,M                    ;Now fetch the (cc) of current line into register B
 1638/2A63 : 08                                    INR	B                    ;Add one to account for (cc) byte itself
 1639/2A64 : 46 CA 29                              CALL	ADBDE              ;Add value in B to D&E to point to next line in
 1640/2A67 : 36 F0                                 MVI	L, 360o               ;User program buffer. Reset L to addr of user logrn
 1641/2A69 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Buffer pointer storage location. Store the new
 1642/2A6B : FB                                    MOV	M,D                    ;Updated user pgm line pointer in pointer storage
 1643/2A6C : 30                                    INR	L                    ;Location. Store both the high portion
 1644/2A6D : FC                                    MOV	M,E                    ;And low portion. (Now points to next line to be
 1645/2A6E : 36 E0                                 MVI	L, 340o               ;Processed from user program buffer.) Change pointer
 1646/2A70 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** To address of line number buffer. Fetch the last
 1647/2A72 : C7                                    MOV	A,M                    ;Line number (length) processed. Test to see if it was
 1648/2A73 : A0                                    ANA	A                    ;Blank. If it was blank
 1649/2A74 : 68 D2 27                              JZ	EXEC               ;Then stop processing and return to the Executive
 1650/2A77 : C0                                    MOV	A,A                    ;Insert two effective NOPs here
 1651/2A78 : C0                                    MOV	A,A                    ;In case of patching
 1652/2A79 : 36 F0                      SAMLIN:    MVI	L, 360o               ;Load L with addr of user program buffer line pointer
 1653/2A7B : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of same pointer
 1654/2A7D : D7                                    MOV	C,M                    ;Fetch the high portion of the pointer into register C
 1655/2A7E : 30                                    INR	L                    ;Advance the memory pointer
 1656/2A7F : F7                                    MOV	L,M                    ;Fetch the low portion of the pointer into register L
 1657/2A80 : EA                                    MOV	H,C                    ;Now move the high portion into register H
 1658/2A81 : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Set D to page of line input buffer
 1659/2A83 : 26 00                                 MVI	E, 000                ;Set E to address of start of line input buffer
 1660/2A85 : 46 2B 29                              CALL	MOVEC              ;Move the line ftom the user program buffer into the
 1661/2A88 : 36 00                                 MVI	L, 000                ;Line input buffer. Now reset the pointer to the start
 1662/2A8A : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Of the line input buffer.
 1663/2A8C : C7                                    MOV	A,M                    ;Fetch the first byte of the line input buffer (cc)
 1664/2A8D : A0                                    ANA	A                    ;Test (cc) value to see if fetched a blank line
 1665/2A8E : 68 D2 27                              JZ	EXEC               ;If fetched a blank line, return to the Executive
 1666/2A91 : 46 1C 21                              CALL	SYNTAX             ;Else call subrtn to strip off line nr & set statement toke
 1667/2A94 :                            
 1668/2A94 : 36 83                      DIRECT:    MVI	L, 203o               ;Load L with address of syntax TOKEN storage location
 1669/2A96 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of syntax TOKEN location
 1670/2A98 : C7                                    MOV	A,M                    ;Fetch the TOKEN value into the accumulator
 1671/2A99 : 3C 01                                 CPI	001                ;Is it token value for REM statement? If so, ignore the
 1672/2A9B : 68 59 2A                              JZ	NXTLIN             ;Current line and go on to the next line in pgm buffer.
 1673/2A9E : 3C 02                                 CPI	002                ;Is it token value for IF statement?
 1674/2AA0 : 68 22 2D                              JZ	IF                 ;If yes, then go to the IF statement routine.
 1675/2AA3 : 3C 03                                 CPI	003                ;Is it token value for LET statement? (Using keyword)
 1676/2AA5 : 68 24 2C                              JZ	LET                ;If yes, then go to the LET statement routine.
 1677/2AA8 : 3C 04                                 CPI	004                ;Is it token value for GOTO statement?
 1678/2AAA : 68 87 2C                              JZ	GOTO               ;If yes, then go to the GOTO statement routine.
 1679/2AAD : 3C 05                                 CPI	005                ;Is it token value for PRINT statement?
 1680/2AAF : 68 F0 2A                              JZ	PRINT              ;If yes, then go to the PRINT statement routine.
 1681/2AB2 : 3C 06                                 CPI	006                ;Is it token value for INPUT statement?
 1682/2AB4 : 68 00 2E                              JZ	INPUT              ;If yes, then go to the INPUT statement routine.
 1683/2AB7 : 3C 07                                 CPI	007                ;Is it token value for FOR statement?
 1684/2AB9 : 68 7F 2E                              JZ	FOR                ;If yes, then go to the FOR statement routine.
 1685/2ABC : 3C 08                                 CPI	010o               ;Is it token value for NEXT statement?
 1686/2ABE : 68 FF 34                              JZ	NEXT               ;If yes, then go to the NEXT statement routine.
 1687/2AC1 : 3C 09                                 CPI	011o               ;Is it token value for GOSUB statement?
 1688/2AC3 : 68 A9 2D                              JZ	GOSUB              ;If yes, then go to the GOSUB statement routine.
 1689/2AC6 : 3C 0A                                 CPI	012o               ;Is it token value for RETURN statement?
 1690/2AC8 : 68 CF 2D                              JZ	RETURN             ;If yes, then go to the RETURN statement routine.
 1691/2ACB : 3C 0B                                 CPI	013o               ;Is it token value for DIM statement?
 1692/2ACD : 68 A1 38                              JZ	DIM                ;If yes, then go to the DIM statement routine.
 1693/2AD0 : 3C 0C                                 CPI	014o               ;Is it token value for END statement?
 1694/2AD2 : 68 D2 27                              JZ	EXEC               ;If yes, then go back to the Executive, user pgm finished!
 1695/2AD5 : 3C 0D                                 CPI	015o               ;Is it token value for IMPLIED LET statement?
 1696/2AD7 : 68 16 2C                              JZ	LET0               ;If yes, then go to special LET entry point.
 1697/2ADA : 3C 0E                                 CPI	016o               ;@@ Is it token value for ARRAY IMPLIED LET?
 1698/2ADC : 48 86 28                              JNZ	SYNERR             ;If not, then assume a syntax error condition.
 1699/2ADF : 46 17 38                              CALL	ARRAY1             ;@@ Else, perform array storage set up subroutine.
 1700/2AE2 : 36 86                                 MVI	L, 206o               ;@@ Set L to array pointer storage location.
 1701/2AE4 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;@@ * * Set H to array pointer storage location.
 1702/2AE6 : CF                                    MOV	B,M                    ;@@ Fetch array pointer to register B.
 1703/2AE7 : 36 82                                 MVI	L, 202o               ;@@ Change memory pointer to syntax pntr storage loc.
 1704/2AE9 : F9                                    MOV	M,B                    ;@@ Save array pointer value there.
 1705/2AEA : 46 BC 27                              CALL	SAVESY             ;@@ Save array name in auxiliary symbol buffer
 1706/2AED : 44 2D 2C                              JMP	LET1
 1707/2AF0 : 36 82                      PRINT:     MVI	L, 202o               ;Load L with address of SCAN pointer storage location
 1708/2AF2 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of SCAN pointer
 1709/2AF4 : C7                                    MOV	A,M                    ;Fetch the pointer value (last character scanned by the
 1710/2AF5 : 36 00                                 MVI	L, 000                ;SYNTAX routine). Change pointer to line buffer (cc).
 1711/2AF7 : BF                                    CMP	M                    ;Compare pointer value to buffer length. If not equal
 1712/2AF8 : 70 01 2B                              JM	PRINT1             ;Then line contains more than stand alone PRINT state-
 1713/2AFB : 46 7D 22                              CALL	CRLF               ;Ment. However, if just have PRINT statement then issue
 1714/2AFE : 44 59 2A                              JMP	NXTLIN             ;A carriage-return & line-feed combination, then exit.
 1715/2B01 : 46 C9 21                   PRINT1:    CALL	CLESYM             ;Initialize the SYMBOL buffer for new entry.
 1716/2B04 : 36 82                                 MVI	L, 202o               ;Load L with address of SCAN buffer pointer
 1717/2B06 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of SCAN pointer
 1718/2B08 : CF                                    MOV	B,M                    ;Pointer points to last char scanned by SYNTAX. Need
 1719/2B09 : 08                                    INR	B                    ;To increment it to point to next char in statement line.
 1720/2B0A : 36 83                                 MVI	L, 203o               ;Load L with address of former TOKEN value. Use it as
 1721/2B0C : F9                                    MOV	M,B                    ;Storage location for a PRINT statement pointer.
 1722/2B0D : 36 83                      PRINT2:    MVI	L, 203o               ;Set memory pointer to PRINT pointer storage location
 1723/2B0F : 46 BC 21                              CALL	GETCHR             ;Fetch character in input buffer pointed to by PRINT
 1724/2B12 : 3C A7                                 CPI	247o               ;Pointer. See if it is ASCII code for single quote mark.
 1725/2B14 : 68 8E 2B                              JZ	QUOTE              ;If so, go to QUOTE section to process text string.
 1726/2B17 : 3C A2                                 CPI	242o               ;If not, see if it is ASCII code for double quote mark.
 1727/2B19 : 68 8E 2B                              JZ	QUOTE              ;If so, go to QUOTE section to process text string.
 1728/2B1C : 3C AC                                 CPI	254o               ;If not, see if it is ASCII code for comma sign.
 1729/2B1E : 68 2E 2B                              JZ	PRINT3             ;If so, go evaluate expression.
 1730/2B21 : 3C BB                                 CPI	273o               ;If not, see if it is ASCII code for semi-colon sign.
 1731/2B23 : 68 2E 2B                              JZ	PRINT3             ;If so, go evaluate expression.
 1732/2B26 : 36 83                                 MVI	L, 203o               ;Load L with address of PRINT pointer storage location.
 1733/2B28 : 46 1F 22                              CALL	LOOP               ;Increment pointer and test for end of line.
 1734/2B2B : 48 0D 2B                              JNZ	PRINT2             ;If not end of line, fetch the next character.
 1735/2B2E : 36 82                      PRINT3:    MVI	L, 202o               ;Load L with address of SCAN pointer storage location
 1736/2B30 : CF                                    MOV	B,M                    ;Fetch value of the pointer (last letter of KEYWORD)
 1737/2B31 : 08                                    INR	B                    ;Add one to point to first character of expression
 1738/2B32 : 36 BE                                 MVI	L, 276o               ;Load L with addr of EVAL pointer storage location
 1739/2B34 : F9                                    MOV	M,B                    ;Store addr at which EVAL should start scanning
 1740/2B35 : 36 83                                 MVI	L, 203o               ;Load L with address of PRINT pointer
 1741/2B37 : CF                                    MOV	B,M                    ;Which points to field terminator
 1742/2B38 : 09                                    DCR	B                    ;Decrement pointer value to last character of expression
 1743/2B39 : 36 BF                                 MVI	L, 277o               ;Load L with address of EVAL FINISH pntr storage loc.
 1744/2B3B : F9                                    MOV	M,B                    ;Place address value of last char in PRINT field there
 1745/2B3C : 36 F7                                 MVI	L, 367o               ;Load L with address of QUOTE flag
 1746/2B3E : C7                                    MOV	A,M                    ;Fetch the value of the QUOTE flag into the ACC
 1747/2B3F : A0                                    ANA	A                    ;Test the QUOTE flag status
 1748/2B40 : 68 48 2B                              JZ	PRINT4             ;If field not quoted, proceed to evaluate expression
 1749/2B43 : 3E 00                                 MVI	M, 000                ;If field quoted, then clear the QUOTE flag for next field
 1750/2B45 : 44 60 2B                              JMP	PRINT6             ;And skip the evaluation procedure
 1751/2B48 : 46 B0 22                   PRINT4:    CALL	EVAL               ;Evaluate the current PRINT field
 1752/2B4B : 36 7F                                 MVI	L, 177o               ;Then load L,with address of the TAB flag
 1753/2B4D : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with the page of the TAB flag
 1754/2B4F : C7                                    MOV	A,M                    ;Fetch the value of the TAB flag into the accumulator
 1755/2B50 : A0                                    ANA	A                    ;Test the TAB flag
 1756/2B51 : 36 48                                 MVI	L, 110o               ;Change L to the FIXED/FLOAT flag location
 1757/2B53 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Change H to the FIXED/FLOAT flag page
 1758/2B55 : 3E FF                                 MVI	M, 377o               ;Set FIXED/FLOAT flag to fixed point
 1759/2B57 : 6A D7 2B                   PRINT5:    CZ	PFPOUT             ;If TAB flag not set, display value of expression
 1760/2B5A : 36 7F                                 MVI	L, 177o               ;Load L with address of TAB flag
 1761/2B5C : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of TAB flag
 1762/2B5E : 3E 00                                 MVI	M, 000                ;Reset TAB flag for next PRINT field
 1763/2B60 : 36 83                      PRINT6:    MVI	L, 203o               ;Load L with address of PRINT pointer stomge location
 1764/2B62 : 46 BC 21                              CALL	GETCHR             ;Fetch the character pointed to by the PRINT pointer
 1765/2B65 : 3C AC                                 CPI	254o               ;See if the last character scanned was a comma sign
 1766/2B67 : 6A FA 2B                              CZ	PCOMMA             ;If so, then display spaces to next TA.B location
 1767/2B6A : 36 83                                 MVI	L, 203o               ;Reset L to address of PRINT pointer storage location
 1768/2B6C : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Reset H to page of PRINT pointer stomge location
 1769/2B6E : CF                                    MOV	B,M                    ;Fetch the value of the pointer into register B
 1770/2B6F : 36 82                                 MVI	L, 202o               ;Change L to SCAN pointer storage location
 1771/2B71 : F9                                    MOV	M,B                    ;Place end of last field processed into SCAN pointer
 1772/2B72 : 36 00                                 MVI	L, 000                ;Change pointer to start of line input buffer
 1773/2B74 : C1                                    MOV	A,B                    ;Place pntr to last char scanned into the accumulator
 1774/2B75 : BF                                    CMP	M                    ;Compare this value to the (cc) for the line buffer
 1775/2B76 : 70 01 2B                              JM	PRINT1             ;If not end of line, continue to process next field
 1776/2B79 : 36 00                                 MVI	L, 000                ;If end of line, fetch the last character in the line
 1777/2B7B : 46 BC 21                              CALL	GETCHR             ;And check to see if it
 1778/2B7E : 3C AC                                 CPI	254o               ;Was a comma. If it was, go on to the next line in the
 1779/2B80 : 68 59 2A                              JZ	NXTLIN             ;User program buffer without displaying a CR & LF.
 1780/2B83 : 3C BB                                 CPI	273o               ;If not a comma, check to see if it was a semi-colon.
 1781/2B85 : 68 59 2A                              JZ	NXTLIN             ;If so, do not provide a CR & LF combination.
 1782/2B88 : 46 7D 22                              CALL	CRLF               ;If not comma or semi-colon, provide CR & LF at end
 1783/2B8B : 44 59 2A                              JMP	NXTLIN             ;Of a PRINT statement. Go process next line of pgrm.
 1784/2B8E : 36 F7                      QUOTE:     MVI	L, 367o               ;Load L with address of QUOTE flag
 1785/2B90 : F8                                    MOV	M,A                    ;Store type of quote in flag storage location
 1786/2B91 : 46 C9 21                              CALL	CLESYM             ;Initialize the SYMBOL buffer for new entry
 1787/2B94 : 36 83                                 MVI	L, 203o               ;Load L with address of PRINT pointer
 1788/2B96 : CF                                    MOV	B,M                    ;Fetch the PRINT pointer into register B
 1789/2B97 : 08                                    INR	B                    ;Add one to advance over quote character
 1790/2B98 : 36 84                                 MVI	L, 204o               ;Load L with address of QUOTE pointer
 1791/2B9A : F9                                    MOV	M,B                    ;Store the beginning of the QUOTE field pointer
 1792/2B9B : 36 84                      QUOTE1:    MVI	L, 204o               ;Load L with address of QUOTE pointer
 1793/2B9D : 46 BC 21                              CALL	GETCHR             ;Fetch the next character in the TEXT field
 1794/2BA0 : 36 F7                                 MVI	L, 367o               ;Load L with the QUOTE flag (type of quote)
 1795/2BA2 : BF                                    CMP	M                    ;Compare to see if latest character this quote mark
 1796/2BA3 : 68 BE 2B                              JZ	QUOTE2             ;If so, finish up this quote field
 1797/2BA6 : 46 9E 22                              CALL	ECHO               ;If not, display the character as part of TEXT
 1798/2BA9 : 36 84                                 MVI	L, 204o               ;Reset L to QUOTE pointer storage location
 1799/2BAB : 46 1F 22                              CALL	LOOP               ;Increment QUOTE pointer and test for end of line
 1800/2BAE : 48 9B 2B                              JNZ	QUOTE1             ;If not end of line, continue processing TEXT field
 1801/2BB1 : 06 C9                      QUOTER:    MVI	A, 311o               ;If end of line before closing quote mark have an error
 1802/2BB3 : 16 D1                                 MVI	C, 321o               ;So load ACC with I and register C with Q
 1803/2BB5 : 36 F7                                 MVI	L, 367o               ;Load L with the address of the QUOTE flag
 1804/2BB7 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with the page of the QUOTE flag
 1805/2BB9 : 3E 00                                 MVI	M, 000                ;Clear the QUOTE flag for future use
 1806/2BBB : 44 B2 21                              JMP	ERROR              ;Go display the IQ (Illegal Quote) error message
 1807/2BBE : 36 84                      QUOTE2:    MVI	L, 204o               ;Load L with address of QUOTE pointer
 1808/2BC0 : CF                                    MOV	B,M                    ;Fetch the QUOTE pointer into register B
 1809/2BC1 : 36 82                                 MVI	L, 202o               ;Load L with address of SCAN pointer storage location
 1810/2BC3 : F9                                    MOV	M,B                    ;Store former QUOTE vointer as start of next field
 1811/2BC4 : C1                                    MOV	A,B                    ;Place QUOTE pointer into the accumulator
 1812/2BC5 : 36 00                                 MVI	L, 000                ;Change L to point to start of the input line buffer
 1813/2BC7 : BF                                    CMP	M                    ;Compare QUOTE pointer value with (cc) value
 1814/2BC8 : 48 01 2B                              JNZ	PRINT1             ;If not end of line, process next PRINT field
 1815/2BCB : 46 7D 22                              CALL	CRLF               ;Else display a CR & LF combination at the end of line
 1816/2BCE : 36 F7                                 MVI	L, 367o               ;Load L with the address of the TAB flag
 1817/2BD0 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with the page of the TAB flag
 1818/2BD2 : 3E 00                                 MVI	M, 000                ;Clear the TAB flag for future use
 1819/2BD4 : 44 59 2A                              JMP	NXTLIN             ;Go process next line of the program.
 1820/2BD7 :                            
 1821/2BD7 :                                                              ;The following subroutines are utilized by the PRINT
 1822/2BD7 :                                                              ;routine.
 1823/2BD7 :                            ;;; The label PFPOUT SHOULD BE AT 14 314 0ccch
 1824/2BD7 : 36 56                      PFPOUT:    MVI	L, 126o               ;Load L with the address of the FPACC MSW (Floating
 1825/2BD9 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Point ACC). Load H with page of the FPACC MSW.
 1826/2BDB : C7                                    MOV	A,M                    ;Fetch the FPACC MSW into the accumulator. Test to
 1827/2BDC : A0                                    ANA	A                    ;See if the FPACC MSW is zero. If so, then simply go and
 1828/2BDD : 68 E9 2B                              JZ	ZERO               ;Display the value "0"
 1829/2BE0 : 30                                    INR	L                    ;Else advance the pointer to the FPACC Exponent
 1830/2BE1 : C7                                    MOV	A,M                    ;Fetch the FPACC Exponent into the accumulator
 1831/2BE2 : A0                                    ANA	A                    ;See if any exponent value. If not, mantissa is in range
 1832/2BE3 : 68 F3 2B                              JZ	FRAC               ;0.5 to 1.0. Treat number as a fraction.
 1833/2BE6 : 44 7C 33                              JMP	FPOUT              ;Else perform regular numerical output routine.
 1834/2BE9 : 06 A0                      ZERO:      MVI	A, 240o               ;Load ASCII code for space into the ACC
 1835/2BEB : 46 9E 22                              CALL	ECHO               ;Display the space
 1836/2BEE : 06 B0                                 MVI	A, 260o               ;Load ASCII code for 0 into the ACC
 1837/2BF0 : 44 9E 22                              JMP	ECHO               ;Display 0 and exit to calling routine
 1838/2BF3 : 36 48                      FRAC:      MVI	L, 110o               ;Load L with address of FIXED/FLOAT flag
 1839/2BF5 : 3E 00                                 MVI	M, 000                ;Reset it to indicate floating point mode
 1840/2BF7 : 44 7C 33                              JMP	FPOUT              ;Display floating point number and return to caller
 1841/2BFA : 36 00                      PCOMMA:    MVI	L, 000                ;Load L with address of (cc) in line input buffer
 1842/2BFC : C7                                    MOV	A,M                    ;Fetch the (cc) for the line into the ACC
 1843/2BFD : 36 83                                 MVI	L, 203o               ;Change pointer to PRINT pointer storage location
 1844/2BFF : 97                                    SUB	M                    ;Subtract value of PRINT pointer from line (cc)
 1845/2C00 : 33                                    RM                    ;If at end of buffer, do not TAB
 1846/2C01 : 36 23                                 MVI	L, 043o               ;If not end, load L with address of COLUMN COUNTER
 1847/2C03 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of COLUMN COUNTER
 1848/2C05 : C7                                    MOV	A,M                    ;Fetch COLUMN COUNTER into the accumulator
 1849/2C06 : 24 F0                                 ANI	360o               ;Find the last TAB position (multiple of 16 decimal)
 1850/2C08 : 04 10                                 ADI	020o               ;Add 16 (decimal) to get new TAB position
 1851/2C0A : 97                                    SUB	M                    ;Subtract current position from next TAB position
 1852/2C0B : D0                                    MOV	C,A                    ;Store this value in register C as a counter
 1853/2C0C : 06 A0                                 MVI	A, 240o               ;Load the ACC with the ASCII code for space
 1854/2C0E : 46 9E 22                   PCOM1:     CALL	ECHO               ;Display the space
 1855/2C11 : 11                                    DCR	C                    ;Decrement the loop counter
 1856/2C12 : 48 0E 2C                              JNZ	PCOM1              ;Continue displaying spaces until loop counter is zero
 1857/2C15 : 07                                    RET                    ;Then return to calling routine
 1858/2C16 : 46 BC 27                   LET0:      CALL	SAVESY             ;Entry point for IMPLIED LET statement. Save the
 1859/2C19 : 36 82                                 MVI	L, 202o               ;Variable (to left of the equal sign). Set L to the SCAN
 1860/2C1B : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Pointer. Set H to the page of the SCAN pointer.
 1861/2C1D : CF                                    MOV	B,M                    ;Fetch value of SCAN pointer. (Points to = sign in In bf)
 1862/2C1E : 36 83                                 MVI	L, 203o               ;Change pointer to LET pointer (was TOKEN value)
 1863/2C20 : F9                                    MOV	M,B                    ;Place the SCAN pointer value into the LET pointer
 1864/2C21 : 44 6C 2C                              JMP	LET5               ;Continue processing the LET statement line
 1865/2C24 : 46 C9 21                   LET:       CALL	CLESYM             ;Initialize the SYMBOL BUFFER for new entry
 1866/2C27 : 36 64                                 MVI	L, 144o               ;Load L with address of start of AUX SYMBOL BUFF
 1867/2C29 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of AUX SYMBOL BUFFER
 1868/2C2B : 3E 00                                 MVI	M, 000                ;Initialize AUX SYMBOL BUFFER
 1869/2C2D : 36 82                      LET1:      MVI	L, 202o               ;Entry point for ARRAY IMPLIED LET statement.
 1870/2C2F : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set pointer to SCAN pointer storage location
 1871/2C31 : CF                                    MOV	B,M                    ;Fetch the SCAN pointer value (last letter scanned by
 1872/2C32 : 08                                    INR	B                    ;SYNTAX subroutine) and add one to next character
 1873/2C33 : 36 83                                 MVI	L, 203o               ;Change L to LET pointer storage location
 1874/2C35 : F9                                    MOV	M,B                    ;Store former SCAN value (updated) in LET pointer
 1875/2C36 : 36 83                      LET2:      MVI	L, 203o               ;Set L to gtorage location of LET pointer
 1876/2C38 : 46 BC 21                              CALL	GETCHR             ;Fetch the character pointed to by the LET pointer
 1877/2C3B : 68 5D 2C                              JZ	LET4               ;If character is a space, ignore it
 1878/2C3E : 3C BD                                 CPI	275o               ;See if character is the equal (=) sign
 1879/2C40 : 68 6C 2C                              JZ	LET5               ;If so, go process other side of the statement (after
 1880/2C43 : 3C A8                                 CPI	250o               ;@@ If not, see if character is a right parenthesis
 1881/2C45 : 48 56 2C                              JNZ	LET3               ;If not, continue looking for equal sign
 1882/2C48 : 46 11 38                              CALL	ARRAY              ;@@ If so, have subscript. Call array set up subroutine.
 1883/2C4B : 36 86                                 MVI	L, 206o               ;@@ Load L with address of ARRAY pointer
 1884/2C4D : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;@@ ** Load H with page of ARRAY pointer
 1885/2C4F : CF                                    MOV	B,M                    ;@@ Fetch value (points to ")" character of subscript)
 1886/2C50 : 36 83                                 MVI	L, 203o               ;@@ Load L with address of LET pointer
 1887/2C52 : F9                                    MOV	M,B                    ;@@ Place ARRAY pointer value as new LET pointer
 1888/2C53 : 44 5D 2C                              JMP	LET4               ;@@ Continue to look for = sign in statement line
 1889/2C56 : 36 64                      LET3:      MVI	L, 144o               ;Reset L to start of AUX SYMBOL BUFFER
 1890/2C58 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ** Load H with page of AUX SYMBOL BUFFER
 1891/2C5A : 46 E8 21                              CALL	CONCT1             ;Concatenate character to the AUX SYMBOL BUFFER
 1892/2C5D : 36 83                      LET4:      MVI	L, 203o               ;Load L with address of LET pointer storage location
 1893/2C5F : 46 1F 22                              CALL	LOOP               ;Add one to pointer and test for end of line input buffer
 1894/2C62 : 48 36 2C                              JNZ	LET2               ;If not end of line, continue looking for the equal sign
 1895/2C65 : 06 CC                      LETERR:    MVI	A, 314o               ;If do not find an equal sign in the LET statement line
 1896/2C67 : 16 C5                                 MVI	C, 305o               ;Then have a LE (Let Error). Load the code for L and E
 1897/2C69 : 44 B2 21                              JMP	ERROR              ;Into registers ACC and C and go display the error msg.
 1898/2C6C : 36 83                      LET5:      MVI	L, 203o               ;When find the equal sign, reset L to point to the LET
 1899/2C6E : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Pointer and H to the proper page. Fetch the pointer
 1900/2C70 : CF                                    MOV	B,M                    ;Value into register B and add one to advance pointer
 1901/2C71 : 08                                    INR	B                    ;Over the equal sign to first char in the expression.
 1902/2C72 : 36 BE                                 MVI	L, 276o               ;Set L to point to the address of the EVAL pointer
 1903/2C74 : F9                                    MOV	M,B                    ;Set EVAL pointer to start evaluating right after the
 1904/2C75 : 36 00                                 MVI	L, 000                ;Equal sign. Now change L to start of line input buffer.
 1905/2C77 : CF                                    MOV	B,M                    ;Fetch the (cc) value into register B. (Length of line.)
 1906/2C78 : 36 BF                                 MVI	L, 277o               ;Load L with EVAL FINISH pointer storage location.
 1907/2C7A : F9                                    MOV	M,B                    ;Set it to stop evaluating at end of the line.
 1908/2C7B : 46 B0 22                              CALL	EVAL               ;Call the subroutine to evaluate the expression.
 1909/2C7E : 46 C6 27                              CALL	RESTSY             ;Restore the name of the variable to receive new value.
 1910/2C81 : 46 49 27                              CALL	STOSYM             ;Store the new value for the variable in variables table.
 1911/2C84 : 44 59 2A                              JMP	NXTLIN             ;Go process next line of the program.
 1912/2C87 : 36 E8                      GOTO:      MVI	L, 350o               ;Load L with start of AUX LINE NR BUFFER
 1913/2C89 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of AUX LINE NR BUFFER
 1914/2C8B : 3E 00                                 MVI	M, 000                ;Initialize the AUX LINE NR BUFFER to zero
 1915/2C8D : 36 82                                 MVI	L, 202o               ;Load L with address of SCAN pointer storage location
 1916/2C8F : CF                                    MOV	B,M                    ;Fetch pointer value (last char scanned by SYNTAX)
 1917/2C90 : 08                                    INR	B                    ;Add one to skip over the last 0 in GOTO keyword
 1918/2C91 : 36 83                                 MVI	L, 203o               ;Change pointer to GOTO pointer (formerly TOKEN)
 1919/2C93 : F9                                    MOV	M,B                    ;Store the updated SCAN pointer as the GOTO pointer
 1920/2C94 : 36 83                      GOTO1:     MVI	L, 203o               ;Load L with address of GOTO pointer
 1921/2C96 : 46 BC 21                              CALL	GETCHR             ;Fetch the character pointed to by the GOTO pointer
 1922/2C99 : 68 AB 2C                              JZ	GOTO2              ;If character was a space, ignore it
 1923/2C9C : 3C B0                                 CPI	260o               ;See if character is in the range of a decimal digit
 1924/2C9E : 70 B3 2C                              JM	GOTO3              ;If not, must have end of the line number digit string
 1925/2CA1 : 3C BA                                 CPI	272o               ;Continue to test for decitnal digit
 1926/2CA3 : 50 B3 2C                              JP	GOTO3              ;If not, mugt have end of the line number digit string
 1927/2CA6 : 36 E8                                 MVI	L, 350o               ;If valid decimal digit, load L with addr of AUX LINE
 1928/2CA8 : 46 E8 21                              CALL	CONCT1             ;NR BUFFER and concatenate digit to the buffer.
 1929/2CAB : 36 83                      GOTO2:     MVI	L, 203o               ;Reset pointer to GOTO pointer storage location
 1930/2CAD : 46 1F 22                              CALL	LOOP               ;Advance the pointer value and test for end of line
 1931/2CB0 : 48 94 2C                              JNZ	GOTO1              ;If not end of line, fetch next digit in GOTO line number
 1932/2CB3 : 36 F0                      GOTO3:	   MVI	L, 360o               ;Set L to user program buffer pointer storage location
 1933/2CB5 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of program buffer pointer
 1934/2CB7 : 3E 06                                 MVI	M, BGNPGRAM           ;Initialize high part of pointer to start of pgm buffer
 1935/2CB9 : 30                                    INR	L                    ;Advance the memory point
 1936/2CBA : 3E 00                                 MVI	M, 000                ;Initialize the low part of pointer to start of pgm buffer
 1937/2CBC : 46 C9 21                   GOTO4:     CALL	CLESYM             ;Clear the SYMBOL BUFFER
 1938/2CBF : 36 84                                 MVI	L, 204o               ;Load L with address of GOTO SEARCH pointer
 1939/2CC1 : 3E 01                                 MVI	M, 001                ;Initialize to one for first char of line
 1940/2CC3 : 36 84                      GOTO5:     MVI	L, 204o               ;Load L with address of GOTO SEARCH pointer
 1941/2CC5 : 46 58 29                              CALL	GETCHP             ;Fetch character pointed to by GOTO SEARCH pointer
 1942/2CC8 : 68 D8 2C                              JZ	GOTO6              ;From line pointed to in user program buffer. Ignore
 1943/2CCB : 3C B0                                 CPI	260o               ;Spaces. Check to see if character is a decirnal digit.
 1944/2CCD : 70 EB 2C                              JM	GOTO7              ;If not, then have processed line number at the start of
 1945/2CD0 : 3C BA                                 CPI	272o               ;The current line. Continue the check for a valid decimal
 1946/2CD2 : 50 EB 2C                              JP	GOTO7              ;Digit. If have a decirnal digit then concatenate the digit
 1947/2CD5 : 46 E4 21                              CALL	CONCTS             ;Onto the current string in the SYMBOL BUFFER,
 1948/2CD8 : 36 84                      GOTO6:     MVI	L, 204o               ;Change L to the address of the GOTO SEARCH pointer
 1949/2CDA : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** And H to the proper page of the pointer
 1950/2CDC : CF                                    MOV	B,M                    ;Fetch the GOTO SEARCH pointer value
 1951/2CDD : 08                                    INR	B                    ;Increment the GOTO SEARCH pointer
 1952/2CDE : F9                                    MOV	M,B                    ;And restore it back to memory
 1953/2CDF : 36 F0                                 MVI	L, 360o               ;Change L to address of user program buffer pointer
 1954/2CE1 : D7                                    MOV	C,M                    ;Save the high part of this pointer value in register C
 1955/2CE2 : 30                                    INR	L                    ;Advance L to the low part of the pgrn buffer pointer
 1956/2CE3 : F7                                    MOV	L,M                    ;Now load it into L
 1957/2CE4 : EA                                    MOV	H,C                    ;And transfer C into H to point to start of the line
 1958/2CE5 : C7                                    MOV	A,M                    ;Fetch the (cc) of the current line being pointed to in the
 1959/2CE6 : 09                                    DCR	B                    ;User pgm buff. Decrernent B to previous value. Compare
 1960/2CE7 : B9                                    CMP	B                    ;GOTO SEARCH pointer value to length of current line.
 1961/2CE8 : 48 C3 2C                              JNZ	GOTO5              ;If not end of line then continue getting current line nr.
 1962/2CEB : 36 50                      GOTO7:     MVI	L, 120o               ;Load L with address of start of the SYMBOL BUFFER
 1963/2CED : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;Set H to the page of the SYMBOL BUFFER
 1964/2CEF : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;Set D to the page of the AUX LINE NR BUFFER
 1965/2CF1 : 26 E8                                 MVI	E, 350o               ;Set E to the start of the AUX LINE NR BUFFER
 1966/2CF3 : 46 F6 21                              CALL	STRCP              ;Compare GOTO line number against current line nr.
 1967/2CF6 : 68 79 2A                              JZ	SAMLIN             ;If they match, found GOTO line. Pick up ops there!
 1968/2CF9 : 36 F0                                 MVI	L, 360o               ;Else, set L to user program buffer pntr storage location
 1969/2CFB : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of user program buffer pointer
 1970/2CFD : DF                                    MOV	D,M                    ;Fetch the high part of this pointer into register D
 1971/2CFE : 30                                    INR	L                    ;Advance the memory pointer
 1972/2CFF : E7                                    MOV	E,M                    ;Fetch the low part into register E
 1973/2D00 : EB                                    MOV	H,D                    ;Transfer the pointer to H
 1974/2D01 : F4                                    MOV	L,E                    ;And L. Fetch the (cc) of the current line into register
 1975/2D02 : CF                                    MOV	B,M                    ;B and then add one to account for the (cc) byte to get
 1976/2D03 : 08                                    INR	B                    ;Total length of the current line in the user pgm buffer
 1977/2D04 : 46 CA 29                              CALL	ADBDE              ;Add the total length to the pointer value in D & E
 1978/2D07 : 36 F0                                 MVI	L, 360o               ;To get the starting address of the next line in the user
 1979/2D09 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** User program buffer. Place the new value for the user
 1980/2D0B : FB                                    MOV	M,D                    ;Program buffer pointer back into the user program
 1981/2D0C : 30                                    INR	L                    ;Buffer pointer storage locations so that it points to the
 1982/2D0D : FC                                    MOV	M,E                    ;Next line to be processed in the user program buffer.
 1983/2D0E : 36 F4                                 MVI	L, 364o               ;Load L with address of end of user pgm buffer storage
 1984/2D10 : C3                                    MOV	A,D                    ;Location (page address) and fetch end of buffer page.
 1985/2D11 : BF                                    CMP	M                    ;Compare this with next line pointer (updated).
 1986/2D12 : 48 BC 2C                              JNZ	GOTO4              ;If not end of buffer, keep looking for the specified line
 1987/2D15 : 30                                    INR	L                    ;If have same page addresses, check the low address
 1988/2D16 : C4                                    MOV	A,E                    ;Portions to see if
 1989/2D17 : BF                                    CMP	M                    ;Have reached end of user program buffer
 1990/2D18 : 48 BC 2C                              JNZ	GOTO4              ;If not, continue looking. If end of buffer without
 1991/2D1B : 06 D5                      GOTOER:    MVI	A, 325o               ;Finding specified line, then have an error condition.
 1992/2D1D : 16 CE                                 MVI	C, 316o               ;Load ACC and register C with code for "UN" and go
 1993/2D1F : 44 B2 21                              JMP	ERROR              ;Display "Undefined Line" error message.
 1994/2D22 : 36 82                      IF:        MVI	L, 202o               ;Set L to SCAN pointer storage location.
 1995/2D24 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H to page of SCAN pointer storage location.
 1996/2D26 : CF                                    MOV	B,M                    ;Fetch the SCAN pointer value to register B.
 1997/2D27 : 08                                    INR	B                    ;Add one to advance pointer over last char scanned.
 1998/2D28 : 36 BE                                 MVI	L, 276o               ;Change L to address of EVAL pointer. Set up EVAL
 1999/2D2A : F9                                    MOV	M,B                    ;Pointer to begin evaluation with next char in the line.
 2000/2D2B : 46 C9 21                              CALL	CLESYM             ;Clear the SYMBOL BUFFER.
 2001/2D2E : 36 D0                                 MVI	L, 320o               ;Set L to starting address of THEN in look-up table.
 2002/2D30 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of the look-up table.
 2003/2D32 : 46 15 2A                              CALL	INSTR              ;Search for occurrence of THEN in the line input buffer.
 2004/2D35 : C4                                    MOV	A,E                    ;Transfer register E to ACC. If THEN not found
 2005/2D36 : A0                                    ANA	A                    ;The value in E will be zero.
 2006/2D37 : 48 4D 2D                              JNZ	IF1                ;If THEN found, can evaluate the IF expression.
 2007/2D3A : 36 0B                                 MVI	L, 013o               ;If THEN not found, set L to Auting address of GOTO
 2008/2D3C : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** In the KEYWORD look-up table. Set H to table
 2009/2D3E : 46 15 2A                              CALL	INSTR              ;Search for occurrence of GOTO in the line input buffer.
 2010/2D41 : C4                                    MOV	A,E                    ;Transfer E to ACC. If GOTO not found
 2011/2D42 : A0                                    ANA	A                    ;The value in E will be zero.
 2012/2D43 : 48 4D 2D                              JNZ	IF1                ;If GOTO found, can evaluate the IF expression.
 2013/2D46 : 06 C9                      IFERR:     MVI	A, 311o               ;Set ASCII code for letter I in ACC
 2014/2D48 : 16 C6                                 MVI	C, 306o               ;And code for letter F in register C
 2015/2D4A : 44 B2 21                              JMP	ERROR              ;Go display the IF error message
 2016/2D4D : 36 BF                      IF1:       MVI	L, 277o               ;Load L with addr of EVAL FINISH pointer storage loc
 2017/2D4F : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of storage location
 2018/2D51 : 21                                    DCR	E                    ;Subtract one from pointer in E and set the EVAL
 2019/2D52 : FC                                    MOV	M,E                    ;FINISH pointer so that it will evaluate up to the THEN
 2020/2D53 : 46 B0 22                              CALL	EVAL               ;Or GOTO directive. Evaluate the expression.
 2021/2D56 : 36 56                                 MVI	L, 126o               ;Load L with address of FPACC Most Significant Word
 2022/2D58 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with page of FPACC MSW
 2023/2D5A : C7                                    MOV	A,M                    ;Fetch the FPACC MSW into the accumulator
 2024/2D5B : A0                                    ANA	A                    ;Test the value of the FPACC MSW
 2025/2D5C : 68 59 2A                              JZ	NXTLIN             ;If it is zero, IF condition failed, ignore rest of line.
 2026/2D5F : 36 BF                                 MVI	L, 277o               ;If not, load L with addr of EVAL FINISH pointer
 2027/2D61 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to the appmpriate page
 2028/2D63 : C7                                    MOV	A,M                    ;Fetch the value in the EVAL FINISH pointer
 2029/2D64 : 04 05                                 ADI	005                ;Add five to skip over THEN or GOTO directive
 2030/2D66 : 36 82                                 MVI	L, 202o               ;Change L to SCAN pointer stomge location
 2031/2D68 : F8                                    MOV	M,A                    ;Set up the SCAN pointer to location after THEN or
 2032/2D69 : C8                                    MOV	B,A                    ;GOTO directive. Also put this value in register B.
 2033/2D6A : 08                                    INR	B                    ;Add one to the value in B to point to next character
 2034/2D6B : 36 84                                 MVI	L, 204o               ;After THEN or GOTO. Change L to addr of THEN pntr
 2035/2D6D : F9                                    MOV	M,B                    ;Storage location and store the pointer value.
 2036/2D6E : 36 84                      IF2:       MVI	L, 204o               ;Load L with the address of the THEN pointer
 2037/2D70 : 46 BC 21                              CALL	GETCHR             ;Fetch the character pointed to by the THEN pointer
 2038/2D73 : 48 81 2D                              JNZ	IF3                ;If character is not a space, exit this loop
 2039/2D76 : 36 84                                 MVI	L, 204o               ;If fetch a space, ignore. Reset L to the THEN pointer
 2040/2D78 : 46 1F 22                              CALL	LOOP               ;Add one to the THEN pointer and test for end of line
 2041/2D7B : 48 6E 2D                              JNZ	IF2                ;If not end of line, keep looking for a character other
 2042/2D7E : 44 46 2D                              JMP	IFERR              ;Than a space. If reach end of line first, then error
 2043/2D81 : 3C B0                      IF3:       CPI	260o               ;When find a character see if it is numeric.
 2044/2D83 : 70 8B 2D                              JM	IF4                ;If not numeric, then should have a new type of
 2045/2D86 : 3C BA                                 CPI	272o               ;Statement. If numeric, then should have a line number.
 2046/2D88 : 70 87 2C                              JM	GOTO               ;So process as though have a GOTO statement!
 2047/2D8B : 36 00                      IF4:       MVI	L, 000                ;Load L with addr of start of line input buffer.
 2048/2D8D : C7                                    MOV	A,M                    ;Fetch the (cc) byte to get length of line value.
 2049/2D8E : 36 84                                 MVI	L, 204o               ;Change L to current value of THEN pointer (where first
 2050/2D90 : 97                                    SUB	M                    ;Non-space char. found after THEN or GOTO). Subtract
 2051/2D91 : C8                                    MOV	B,A                    ;This value from length of line to get remainder. Now
 2052/2D92 : 08                                    INR	B                    ;Have length of second statement portion. Add one for
 2053/2D93 : D7                                    MOV	C,M                    ;(cc) count. Save THEN pointer value in register C.
 2054/2D94 : 36 00                                 MVI	L, 000                ;Reset L to start of line input buffer. Now put length of
 2055/2D96 : F9                                    MOV	M,B                    ;Second statement into (cc) position of input buffer.
 2056/2D97 : F2                                    MOV	L,C                    ;Set L to where second statement starts.
 2057/2D98 : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Set D to page of line input buffer.
 2058/2D9A : 26 01                                 MVI	E, 001                ;Set E to first character position of line input buffer.
 2059/2D9C : 46 12 30                              CALL	MOVEIT             ;Move the second statement up in line to become first!
 2060/2D9F : 36 82                                 MVI	L, 202o               ;Load L with address of new SCAN pointer. Load
 2061/2DA1 : 3E 01                                 MVI	M, 001                ;It with starting position for SYNTAX scan.
 2062/2DA3 : 46 53 21                              CALL	SYNTX4             ;Use special entry to SYNTAX to get new TOKEN value.
 2063/2DA6 : 44 94 2A                              JMP	DIRECT             ;Process the second statement in the original line.
 2064/2DA9 : 36 E0                      GOSUB:     MVI	L, 340o               ;Load L with start of LINE NUMBER BUFFER
 2065/2DAB : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;Fetch (cc) of cuffent line number into register D
 2066/2DAD : DF                                    MOV	D,M                    ;Fetch high value (page) of pgm line pointer to D
 2067/2DAE : 18                                    INR	D                    ;Test contents of register by first incrementing
 2068/2DAF : 19                                    DCR	D                    ;And then decrementing the value in the register
 2069/2DB0 : 68 B8 2D                              JZ	GOSUB1             ;If no line number, then processing a DIRECT statement
 2070/2DB3 : 36 F0                                 MVI	L, 360o               ;Else, load L with address of user pgm buff line pointer
 2071/2DB5 : DF                                    MOV	D,M                    ;Fetch high value (page) of pgm line pointer to D
 2072/2DB6 : 30                                    INR	L                    ;Advance the memory pointer
 2073/2DB7 : E7                                    MOV	E,M                    ;Fetch the low part of pgm line pointer to E
 2074/2DB8 : 36 3B                      GOSUB1:    MVI	L, 073o               ;Set L to address of GOSUB STACK POINTER
 2075/2DBA : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to page of GOSUB STACK POINTER
 2076/2DBC : C7                                    MOV	A,M                    ;Fetch value in GOSUB stack pointer to ACC
 2077/2DBD : 04 02                                 ADI	002                ;Add two to current stack pointer for new data to be
 2078/2DBF : 3C 11                                 CPI	021o               ;Placed on the stack and see if stack overflows
 2079/2DC1 : 50 F2 2D                              JP	GOSERR             ;If stack filled, have an error condition
 2080/2DC4 : F8                                    MOV	M,A                    ;Else, store updated stack pointer
 2081/2DC5 : 36 3E                                 MVI	L, 076o               ;Load L with address of start of stack less offset (2)
 2082/2DC7 : 86                                    ADD	L                    ;Add GOSUB stack pointer to base address
 2083/2DC8 : F0                                    MOV	L,A                    ;To get pointer to top of stack (page byte)
 2084/2DC9 : FB                                    MOV	M,D                    ;Store page part of pgm buffer line pointer in stack
 2085/2DCA : 30                                    INR	L                    ;Advance pointer to next byte in stack
 2086/2DCB : FC                                    MOV	M,E                    ;Store low part of pgm buffer line pointer in stack
 2087/2DCC : 44 87 2C                              JMP	GOTO               ;Proceed from here as though processing a GOTO
 2088/2DCF : 36 3B                      RETURN:    MVI	L, 073o               ;Set L to address of GOSUB STACK POINTER
 2089/2DD1 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to page of GOSUB STACK POINTER
 2090/2DD3 : C7                                    MOV	A,M                    ;Fetch the value of GOSUB stack pointer to ACC
 2091/2DD4 : 14 02                                 SUI	002                ;Subtract two for data to be removed from stack
 2092/2DD6 : 70 F9 2D                              JM	RETERR             ;If stack underflow, then have an error condition
 2093/2DD9 : F8                                    MOV	M,A                    ;Restore new stack pointer to memory
 2094/2DDA : 04 02                                 ADI	002                ;Add two to point to previous top of stack
 2095/2DDC : 36 3E                                 MVI	L, 076o               ;Load L with address of start of GOSUB stack less two
 2096/2DDE : 86                                    ADD	L                    ;Add address of previous top of stack to base value
 2097/2DDF : F0                                    MOV	L,A                    ;Set pointer to high address value in the stack
 2098/2DE0 : DF                                    MOV	D,M                    ;Fetch the high address value from stack to register D
 2099/2DE1 : 18                                    INR	D                    ;Exercise the register contents to see if high address
 2100/2DE2 : 19                                    DCR	D                    ;Obtained is zero. If so, original GOSUB statement was
 2101/2DE3 : 68 D2 27                              JZ	EXEC               ;A DIRECT statement. Must return to Executive!
 2102/2DE6 : 30                                    INR	L                    ;Else, advance pointer to get low address value from the
 2103/2DE7 : E7                                    MOV	E,M                    ;Stack into CPU register E.
 2104/2DE8 : 36 F0                                 MVI	L, 360o               ;Load L with address of user pgm line pointer storage
 2105/2DEA : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Location. Load H with page of user pgm line pntr.
 2106/2DEC : FB                                    MOV	M,D                    ;Put high address from stack into pgm line pointer.
 2107/2DED : 30                                    INR	L                    ;Advance the memory pointer
 2108/2DEE : FC                                    MOV	M,E                    ;Put low address from stack into pgrn line pointer.
 2109/2DEF : 44 59 2A                              JMP	NXTLIN             ;Execute the next line after originating GOSUB line!
 2110/2DF2 : 06 C7                      GOSERR:    MVI	A, 307o               ;Load ASCII code for letter G into accumulator
 2111/2DF4 : 16 D3                                 MVI	C, 323o               ;Load ASCII code for letter S into register C
 2112/2DF6 : 44 B2 21                              JMP	ERROR              ;Go display GoSub (GS) error message.
 2113/2DF9 : 06 D2                      RETERR:    MVI	A, 322o               ;Load ASCII code for letter R into accumulator
 2114/2DFB : 16 D4                                 MVI	C, 324o               ;Load ASCII code for letter T into register C
 2115/2DFD : 44 B2 21                              JMP	ERROR              ;Go display ReTurn (RT) error message.
 2116/2E00 : 46 C9 21                   INPUT:     CALL	CLESYM             ;Clear the SYMBOL BUFFER
 2117/2E03 : 36 82                                 MVI	L, 202o               ;Load L with address of SCAN pointer storage location
 2118/2E05 : CF                                    MOV	B,M                    ;Fetch value of SCAN pointer to register B
 2119/2E06 : 08                                    INR	B                    ;Increment value to point to next chamcter
 2120/2E07 : 36 83                                 MVI	L, 203o               ;Change L to point to INPUT pointer (formerly TOKEN)
 2121/2E09 : F9                                    MOV	M,B                    ;Updated SCAN pointer becomes INPUT pointer
 2122/2E0A : 36 83                      INPUT1:    MVI	L, 203o               ;Load L with address of INPUT pointer
 2123/2E0C : 46 BC 21                              CALL	GETCHR             ;Fetch a character from the line input buffer
 2124/2E0F : 68 2D 2E                              JZ	INPUT3             ;If character is a space, ignore it. Else,
 2125/2E12 : 3C AC                                 CPI	254o               ;See if character is a comma. If so, process the
 2126/2E14 : 68 3E 2E                              JZ	INPUT4             ;Variable that preceeds the comma.
 2127/2E17 : 3C A8                                 CPI	250o               ;If not, see if character is a left parenthesis.
 2128/2E19 : 48 2A 2E                              JNZ	INPUT2             ;If not, continue processing to build up symbolic variable
 2129/2E1C : 46 1C 38                              CALL	ARRAY2             ;@@ If so, call array subscripting subroutine
 2130/2E1F : 36 86                                 MVI	L, 206o               ;@@ Load L with address of array set up pointer
 2131/2E21 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;@@ ** Load H with page of array set up pointer
 2132/2E23 : CF                                    MOV	B,M                    ;@@ Fetch pointer value (point to ")" of subscript)
 2133/2E24 : 36 83                                 MVI	L, 203o               ;@@ Change pointer to address of INPUT pointer
 2134/2E26 : F9                                    MOV	M,B                    ;@@ Update INPUT pointer
 2135/2E27 : 44 2D 2E                              JMP	INPUT3             ;@@ Jump over concatenate instruction below
 2136/2E2A : 46 E4 21                   INPUT2:    CALL	CONCTS             ;Concatenate character to SYMBOL BUFFER
 2137/2E2D : 36 83                      INPUT3:    MVI	L, 203o               ;Load L with address of INPUT pointer
 2138/2E2F : 46 1F 22                              CALL	LOOP               ;Increment INPUT pointer and test for end of line
 2139/2E32 : 48 0A 2E                              JNZ	INPUT1             ;If not end of line, go get next character
 2140/2E35 : 46 4F 2E                              CALL	INPUTX             ;If end of buffer, get input for variable in the SYMBOL
 2141/2E38 : 46 49 27                              CALL	STOSYM             ;BUFFER and store the value in the VARIABLES table
 2142/2E3B : 44 59 2A                              JMP	NXTLIN             ;Then continue to interpret next statement line
 2143/2E3E : 46 4F 2E                   INPUT4:    CALL	INPUTX             ;Get input from user for variable in SYMBOL BUFFER
 2144/2E41 : 46 49 27                              CALL	STOSYM             ;Store the inputted value in the VARIABLES table
 2145/2E44 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of INPUT pointer
 2146/2E46 : 36 83                                 MVI	L, 203o               ;Set L to location of INPUT pointer
 2147/2E48 : CF                                    MOV	B,M                    ;Fetch pointer value for last character examined
 2148/2E49 : 36 82                                 MVI	L, 202o               ;Change L to point to SCAN pointer storage location
 2149/2E4B : F9                                    MOV	M,B                    ;Update the SCAN pointer
 2150/2E4C : 44 00 2E                              JMP	INPUT              ;Continue processing statement line for next variable
 2151/2E4F : 36 50                      INPUTX:    MVI	L, 120o               ;Load L with start of SYMBOL BUFFER (contains cc)
 2152/2E51 : C7                                    MOV	A,M                    ;Fetch the (cc) (length of symbol in the buffer) to ACC
 2153/2E52 : 86                                    ADD	L                    ;Add (cc) to base address to set up
 2154/2E53 : F0                                    MOV	L,A                    ;Pointer to last character in the SYMBOL BUFFER
 2155/2E54 : C7                                    MOV	A,M                    ;Fetch the last character in the SYMBOL BUFFER
 2156/2E55 : 3C A4                                 CPI	244o               ;See if the last chamcter was a $ sign
 2157/2E57 : 48 6B 2E                              JNZ	INPUTN             ;If not a $ sign, get variable value as a numerical entry
 2158/2E5A : 36 50                                 MVI	L, 120o               ;If $ sign, reset L to start of the SYMBOL BUFFER
 2159/2E5C : CF                                    MOV	B,M                    ;Fetch the (cc) for the variable in the SYMBOL BUFF
 2160/2E5D : 09                                    DCR	B                    ;Subtract one from (cc) to chop off the $ sign
 2161/2E5E : F9                                    MOV	M,B                    ;Restore the new (cc) for the SYMBOL BUFFER
 2162/2E5F : 46 7A 2E                              CALL	FP0                ;Call subroutine to zero the floating point accumulator
 2163/2E62 : 46 AD 22                              CALL	CINPUT             ;Input one character from system input device
 2164/2E65 : 36 54                                 MVI	L, 124o               ;Load L with address of the LSW of the FPACC
 2165/2E67 : F8                                    MOV	M,A                    ;Place the ASCII code for the character inputted there
 2166/2E68 : 44 37 2F                              JMP	FPFLT              ;Convert value to floating point format in FPACC
 2167/2E6B : 36 64                      INPUTN:    MVI	L, 144o               ;Load L with address of start of AUX SYMBOL BUFF
 2168/2E6D : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of AUX SYMBOL BUFFER
 2169/2E6F : 06 BF                                 MVI	A, 277o               ;Load accumulator with ASCII code for ? mark
 2170/2E71 : 46 9E 22                              CALL	ECHO               ;Call output subroutine to display the ? mark
 2171/2E74 : 46 28 22                              CALL	STRIN              ;Input string of characters (number) fm input device
 2172/2E77 : 44 2B 32                              JMP	DINPUT             ;Convert decimal string into binary floating point nr.
 2173/2E7A : 2E 02                      FP0:       MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with floating point working registers page
 2174/2E7C : 44 C3 25                              JMP	CFALSE             ;Zero the floating point accumulator & exit to caller
 2175/2E7F : 36 64                      FOR:       MVI	L, 144o               ;Load L with address of AUX SYMBOL BUFFER
 2176/2E81 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of AUX SYMBOL BUFFER
 2177/2E83 : 3E 00                                 MVI	M, 000                ;Initialize buffer by clearing first byte
 2178/2E85 : 36 66                                 MVI	L, 146o               ;Load L with location of second character in buffer
 2179/2E87 : 3E 00                                 MVI	M, 000                ;Clear that location in case of single character variable
 2180/2E89 : 36 85                                 MVI	L, 205o               ;Load L with address of FOR/NEXT STACK pointer
 2181/2E8B : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Load H with page of FOR/NEXT STACK pointer
 2182/2E8D : CF                                    MOV	B,M                    ;Fetch the FOR/NEXT STACK pointer
 2183/2E8E : 08                                    INR	B                    ;Increment it in preparation for pushing operation
 2184/2E8F : F9                                    MOV	M,B                    ;Restore it back to its storage location
 2185/2E90 : 36 F0                                 MVI	L, 360o               ;Load L with address of user pgrn buffer line pointer
 2186/2E92 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of line pointer
 2187/2E94 : DF                                    MOV	D,M                    ;Fetch page address of pgm buffer line pntr into D
 2188/2E95 : 30                                    INR	L                    ;Advance the memory pointer to pick up low part
 2189/2E96 : E7                                    MOV	E,M                    ;Fetch low address of pgm buffer line pntr into E
 2190/2E97 : C1                                    MOV	A,B                    ;Restore updated FOR/NEXT STACK pointer to ACC
 2191/2E98 : 02                                    RLC                    ;Rotate it left to multiply by two, then rotate it again to
 2192/2E99 : 02                                    RLC                    ;Multiply by four. Add this value to the base address of
 2193/2E9A : 04 5C                                 ADI	134o               ;The FOR/NEXT STACK to point to the new top of
 2194/2E9C : F0                                    MOV	L,A                    ;The FOR/NEXT STACK and set up to point to stack
 2195/2E9D : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H for page of the FOR/NEXT STACK
 2196/2E9F : FB                                    MOV	M,D                    ;Store the page portion of the user pgrn buffer line pntr
 2197/2EA0 : 30                                    INR	L                    ;In the FORINEXT STACK, advance register 4 then
 2198/2EA1 : FC                                    MOV	M,E                    ;Store the low portion of the pgrn line pntr on the stack
 2199/2EA2 : 36 D5                                 MVI	L, 325o               ;Change L to point to start of TO string which is stored
 2200/2EA4 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** In a text strings storage area on this page
 2201/2EA6 : 46 15 2A                              CALL	INSTR              ;Search the statement line for the occurrence of TO
 2202/2EA9 : C4                                    MOV	A,E                    ;Register E wiU be zero if TO not found. Move E to ACC
 2203/2EAA : A0                                    ANA	A                    ;To make a test
 2204/2EAB : 48 B5 2E                              JNZ	FOR1               ;If TO found then proceed with FOR statement
 2205/2EAE : 06 C6                      FORERR:    MVI	A, 306o               ;Else have a For Error. Load ACC with ASCII code for
 2206/2EB0 : 16 C5                                 MVI	C, 305o               ;Letter F and register C with code for letter E.
 2207/2EB2 : 44 B2 21                              JMP	ERROR              ;Then go display the FE message.
 2208/2EB5 : 36 82                      FOR1:      MVI	L, 202o               ;Load L with address of SCAN pointer storage location
 2209/2EB7 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of the SCAN pointer
 2210/2EB9 : CF                                    MOV	B,M                    ;Fetch pointer value to ACC (points to letter R in the
 2211/2EBA : 08                                    INR	B                    ;For directive). Increment it to point to next character
 2212/2EBB : 36 84                                 MVI	L, 204o               ;In the line. Change register L and set this value up
 2213/2EBD : F9                                    MOV	M,B                    ;As an updated FOR pointer.
 2214/2EBE : 36 83                                 MVI	L, 203o               ;Set L to address of TO pointer (formerly TOKEN)
 2215/2EC0 : FC                                    MOV	M,E                    ;Save pointer to TO in the TO pointer!
 2216/2EC1 : 36 84                      FOR2:      MVI	L, 204o               ;Load L with address of the FOR pointer
 2217/2EC3 : 46 BC 21                              CALL	GETCHR             ;Fetch a character from the statement line
 2218/2EC6 : 68 D3 2E                              JZ	FOR3               ;If it is a space, ignore it
 2219/2EC9 : 3C BD                                 CPI	275o               ;Test to see if character is the "=" sign
 2220/2ECB : 68 DE 2E                              JZ	FOR4               ;If so, variable name is in the AUX SYMBOLBUFFER
 2221/2ECE : 36 64                                 MVI	L, 144o               ;If not, then set L to point to start of the AUX SYMBOL
 2222/2ED0 : 46 E8 21                              CALL	CONCT1             ;BUFFER and concatenate the character onto the buffer
 2223/2ED3 : 36 84                      FOR3:      MVI	L, 204o               ;Reset L to address of the FOR pointer
 2224/2ED5 : 46 1F 22                              CALL	LOOP               ;Increment the pointer and see if end of line
 2225/2ED8 : 48 C1 2E                              JNZ	FOR2               ;If not end of line, continue looking for the "=" sign
 2226/2EDB : 44 AE 2E                              JMP	FORERR             ;If reach end of line before "=" sign, then have error
 2227/2EDE : 36 84                      FOR4:      MVI	L, 204o               ;Set L with address of the FOR pointer
 2228/2EE0 : CF                                    MOV	B,M                    ;Fetch pointer value to ACC (pointing to sign)
 2229/2EE1 : 08                                    INR	B                    ;Increment it to skip over the "=" sign
 2230/2EE2 : 36 BE                                 MVI	L, 276o               ;Set L to address of the EVAL pointer
 2231/2EE4 : F9                                    MOV	M,B                    ;Restore the updated pointer to storage
 2232/2EE5 : 36 83                                 MVI	L, 203o               ;Set L to the address of the TO pointer
 2233/2EE7 : CF                                    MOV	B,M                    ;Fetch pointer value to ACC (pointing to letter T in TO)
 2234/2EE8 : 09                                    DCR	B                    ;Decrement it to point to character before the T in TO
 2235/2EE9 : 36 BF                                 MVI	L, 277o               ;Set L to EVAL FINISH pointer storage location
 2236/2EEB : F9                                    MOV	M,B                    ;Store the EVAL FINISH pointer value
 2237/2EEC : 46 B0 22                              CALL	EVAL               ;Evaluate the expression between the "=" sign and TO
 2238/2EEF : 46 C6 27                              CALL	RESTSY             ;Directive. Place the variable name in the variables table.
 2239/2EF2 : 36 64                                 MVI	L, 144o               ;Load L with starting address of the AUX SYMBOL BF
 2240/2EF4 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with the page of the AUX SYMBOL BUFF
 2241/2EF6 : C7                                    MOV	A,M                    ;Fetch the (cc) for the name in the buffer
 2242/2EF7 : 3C 01                                 CPI	001o               ;See if the symbol (name) length is just one character
 2243/2EF9 : 48 9A 36                              JNZ	FOR5               ;If not, go directly to place name in FOR/NEXT STACK
 2244/2EFC : 36 66                                 MVI	L, 146o               ;If so, set L to point to second character location in the
 2245/2EFE : 3E 00                                 MVI	M, 000                ;AUX SYMBOL BUFFER and set it equal to zero.
 2246/2F00 : 44 9A 36                              JMP	FOR5               ;This jump directs program over ontrs/cntrs/table area
 2247/2F03 :                            ;;; LAST LINE SHOULD START AT 17 365 0ff5h
 2248/2F03 :                            ;;; PATCH AREA FOLLOWS THIS
 2249/2F03 :                            
 2250/2F03 :                            ;          ORG	1000h              ;020#000
 2251/2F03 :                            
 2252/2F03 : 36 56                      FPFIX:     MVI	L, 126o               ;Set L to point to MSW of FPACC
 2253/2F05 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to point to page of FPACC
 2254/2F07 : C7                                    MOV	A,M                    ;Fetch MSW of FPACC
 2255/2F08 : 36 40                                 MVI	L, 100o               ;Change pointer to SIGN indicator on same page
 2256/2F0A : F8                                    MOV	M,A                    ;Place MSW of FPACC into SIGN indicator
 2257/2F0B : A0                                    ANA	A                    ;Now test sign bit of MSW of FPACC
 2258/2F0C : 72 85 2F                              CM	FPCOMP             ;Two's complement value in FPACC if negative
 2259/2F0F : 36 57                                 MVI	L, 127o               ;Change pointer to FPACC Exponent register
 2260/2F11 : 06 17                                 MVI	A, 027o               ;Set accumulator to 23 (decimal) for number of bits
 2261/2F13 : CF                                    MOV	B,M                    ;Load FPACC Exponent into CPU register B
 2262/2F14 : 08                                    INR	B                    ;Exercise the value in register B
 2263/2F15 : 09                                    DCR	B                    ;To set CPU flags
 2264/2F16 : 70 2C 2F                              JM	FPZERO             ;If FPACC Exponent is negative set FPACC to zero
 2265/2F19 : 91                                    SUB	B                    ;Subtract value of FPACC Exponent from 23 decimal
 2266/2F1A : 70 01 2A                              JM	FIXERR             ;If Exp larger than 23 decimal cannot convert
 2267/2F1D : D0                                    MOV	C,A                    ;Else place result in register C as counter for number
 2268/2F1E : 36 56                      FPFIXL:    MVI	L, 126o               ;Of rotate ops. Set pointer to MSW of FPACC
 2269/2F20 : 0E 03                                 MVI	B, 003                ;Set precision counter (number of bytes in mantissa)
 2270/2F22 : 46 90 31                              CALL	ROTATR             ;Rotate FPACC right the number of places indicated
 2271/2F25 : 11                                    DCR	C                    ;By count in register C to effectively rotate all the
 2272/2F26 : 48 1E 2F                              JNZ	FPFIXL             ;Significant bits to the left of the floating point decimal
 2273/2F29 : 44 80 2F                              JMP	RESIGN             ;Point. Go check original sign & negate answer if req'd.
 2274/2F2C :                            
 2275/2F2C :                                                              ;Following subroutine clears the FPACC to the zero
 2276/2F2C :                                                              ;condition.
 2277/2F2C :                            
 2278/2F2C : 36 56                      FPZERO:    MVI	L, 126o               ;Set L to point to MSW of FPACC
 2279/2F2E : A8                                    XRA	A                    ;Clear the accumulator
 2280/2F2F : F8                                    MOV	M,A                    ;Set the MSW of FPACC to zero
 2281/2F30 : 31                                    DCR	L                    ;Decrement the pointer
 2282/2F31 : F8                                    MOV	M,A                    ;Set the next significant word of FPACC to zero
 2283/2F32 : 31                                    DCR	L                    ;Decrement the pointer
 2284/2F33 : F8                                    MOV	M,A                    ;Set the LSW of FPACC to zero
 2285/2F34 : 31                                    DCR	L                    ;Decrement the pointer
 2286/2F35 : F8                                    MOV	M,A                    ;Set the auxiliary FPACC byte to zero
 2287/2F36 : 07                                    RET                    ;Exit to calling routine
 2288/2F37 :                            
 2289/2F37 :                                                              ;The next instruction is a special entry point to
 2290/2F37 :                                                              ;the FPNORM subroutine that is used when a number is
 2291/2F37 :                                                              ;converted from fixed to floating point. The FPNORM
 2292/2F37 :                                                              ;label is the entry point when a number already in float-
 2293/2F37 :                                                              ;ing point fonnat is to be normalized.
 2294/2F37 :                            
 2295/2F37 : 0E 17                      FPFLT:     MVI	B, 027o               ;For fixed to float set CPU register B to 23 decimal
 2296/2F39 : C1                         FPNORM:    MOV	A,B                    ;Get CPU register B into ACC to check for special case
 2297/2F3A : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of FPACC
 2298/2F3C : 36 57                                 MVI	L, 127o               ;Set L to FPACC Exponent byte
 2299/2F3E : A0                                    ANA	A                    ;Set CPU flags to test what was in CPU register B
 2300/2F3F : 68 43 2F                              JZ	NOEXC0             ;If B was zero then do standard normalization
 2301/2F42 : F9                                    MOV	M,B                    ;Else set Exponent of FPACC to 23 decimal
 2302/2F43 : 31                         NOEXC0:    DCR	L                    ;Change pointer to MSW of FPACC
 2303/2F44 : C7                                    MOV	A,M                    ;Fetch MSW of FPACC into accumulator
 2304/2F45 : 36 40                                 MVI	L, 100o               ;Change pointer to SIGN indicator storage location
 2305/2F47 : F8                                    MOV	M,A                    ;Place the MSW of FPACC there for future reference
 2306/2F48 : A0                                    ANA	A                    ;Set CPU flags to test MSW of FPACC
 2307/2F49 : 50 53 2F                              JP	ACZERT             ;If sign bit not set then jump ahead to do next test
 2308/2F4C : 0E 04                                 MVI	B, 004                ;If sign bit set, number in FPACC is negative. Set up
 2309/2F4E : 36 53                                 MVI	L, 123o               ;For two's complement operation
 2310/2F50 : 46 6F 31                              CALL	COMPLM             ;And negate the value in the FPACC to make it positive
 2311/2F53 : 36 56                      ACZERT:    MVI	L, 126o               ;Reset pointer to MSW of FPACC
 2312/2F55 : 0E 04                                 MVI	B, 004                ;Set precision counter to number of bytes in FPACC
 2313/2F57 : C7                         LOOK0:     MOV	A,M                    ;Plus one. Fetch a byte of the FPACC.
 2314/2F58 : A0                                    ANA	A                    ;Set CPU flags
 2315/2F59 : 48 66 2F                              JNZ	ACNONZ             ;If find anything then FPACC is not zero
 2316/2F5C : 31                                    DCR	L                    ;Else decrement pointer to NSW of FPACC
 2317/2F5D : 09                                    DCR	B                    ;Decrement precision counter
 2318/2F5E : 48 57 2F                              JNZ	LOOK0              ;Continue checking to see if FPACC contains anything
 2319/2F61 : 36 57                                 MVI	L, 127o               ;Until precision counter is zero. If reach here then
 2320/2F63 : A8                                    XRA	A                    ;Reset pointer to FPACC Exponent. Clear the ACC and
 2321/2F64 : F8                                    MOV	M,A                    ;Clear out the FPACC Exponent. Value of FPACC is zip!
 2322/2F65 : 07                                    RET                    ;Exit to calling routine
 2323/2F66 : 36 53                      ACNONZ:    MVI	L, 123o               ;If FPACC has any value set pointer to LSW minus one
 2324/2F68 : 0E 04                                 MVI	B, 004                ;Set precision counter to number of bytes in FPACC
 2325/2F6A : 46 86 31                              CALL	ROTATL             ;Plus one for special cases. Rotate the contents of the
 2326/2F6D : C7                                    MOV	A,M                    ;FPACC to the LEFT. Pointer will be set to MSW after
 2327/2F6E : A0                                    ANA	A                    ;Rotate ops. Fetch MSW and see if have anything in
 2328/2F6F : 70 79 2F                              JM	ACCSET             ;Most significant bit position. If so, have rotated enough
 2329/2F72 : 30                                    INR	L                    ;If not, advance pointer to FPACC Exponent. Fetch
 2330/2F73 : CF                                    MOV	B,M                    ;The value of the Exponent and decrement it by one
 2331/2F74 : 09                                    DCR	B                    ;To compensate for the rotate left of the mantissa
 2332/2F75 : F9                                    MOV	M,B                    ;Restore the new value of the Exponent
 2333/2F76 : 44 66 2F                              JMP	ACNONZ             ;Continue rotating ops to normalize the FPACC
 2334/2F79 : 36 56                      ACCSET:    MVI	L, 126o               ;Set pntr to FPACC MSW. Now must provide room for
 2335/2F7B : 0E 03                                 MVI	B, 003                ;Sign bit in nonnalized FPACC. Set precision counter.
 2336/2F7D : 46 90 31                              CALL	ROTATR             ;Rotate the FPACC once to the right now.
 2337/2F80 : 36 40                      RESIGN:    MVI	L, 100o               ;Set the pointer to SIGN indicator storage location
 2338/2F82 : C7                                    MOV	A,M                    ;Fetch the original sign of the FPACC
 2339/2F83 : A0                                    ANA	A                    ;Set CPU flags
 2340/2F84 : 13                                    RP                    ;If original sign of FPACC was positive, can exit now.
 2341/2F85 :                            
 2342/2F85 : 36 54                      FPCOMP:    MVI	L, 124o               ; However, if original sign was negative, must now restore
 2343/2F87 : 0E 03                                 MVI	B, 003                ;The FPACC to negative by performing two's comple-
 2344/2F89 : 44 6F 31                              JMP	COMPLM             ;Ment on FPACC. Return to caring rtn via COMPLM.
 2345/2F8C :                            
 2346/2F8C :                                                              ;Floating point ADDITION. Adds contents of FPACC to
 2347/2F8C :                                                              ;FPOP and leaves result in FPACC. Routine first checks
 2348/2F8C :                                                              ;to see if either register contains zero. If so addition
 2349/2F8C :                                                              ;result is already present!
 2350/2F8C :                            
 2351/2F8C : 36 56                      FPADD:     MVI	L, 126o               ;Set L to point to MSW of FPACC
 2352/2F8E : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Do same for register H
 2353/2F90 : C7                                    MOV	A,M                    ;Fetch MSW of FPACC to accumulator
 2354/2F91 : A0                                    ANA	A                    ;Set CPU flags after loading op
 2355/2F92 : 48 A0 2F                              JNZ	NONZAC             ;If accumulator non-zero then FPACC has some value
 2356/2F95 : 36 54                      MOVOP:     MVI	L, 124o               ;But, if accumulator was zero then normalized FPACC
 2357/2F97 : DD                                    MOV	D,H                    ;Must also be zero. Thus answer to addition is simply the
 2358/2F98 : E6                                    MOV	E,L                    ;Value in FPOP. Set up pointers to transfer contents of
 2359/2F99 : 36 5C                                 MVI	L, 134o               ;FPOP to FPACC by pointing to the LSW of both
 2360/2F9B : 0E 04                                 MVI	B, 004                ;Registers and perform the transfer. Then exit to calling
 2361/2F9D : 44 12 30                              JMP	MOVEIT             ;Routine with answer in FPACC via MOVEIT.
 2362/2FA0 : 36 5E                      NONZAC:    MVI	L, 136o               ;If FPACC was non-zero then check to see if FPOP has
 2363/2FA2 : C7                                    MOV	A,M                    ;Some value by obtaining MSW of FPOP
 2364/2FA3 : A0                                    ANA	A                    ;Set CPU flags after loading op. If MSW zero then
 2365/2FA4 : 2B                                    RZ                    ;Normalized FPOP must be zero. Answer is in FPACC!
 2366/2FA5 :                            
 2367/2FA5 :                                                              ;If neither FPACC or FPOP was zero then must perform
 2368/2FA5 :                                                              ;addition operation. Must first check to see if two num-
 2369/2FA5 :                                                              ;bers are within significant mnge. If not, largest number
 2370/2FA5 :                                                              ;is answer. If numbers within range, then must align ex-
 2371/2FA5 :                                                              ;ponents before perforrning the addition of the man-
 2372/2FA5 :                                                              ;tissa.
 2373/2FA5 :                            
 2374/2FA5 : 36 57                      CKEQEX:    MVI	L, 127o               ;Set pointer to FPACC Exponent storage location.
 2375/2FA7 : C7                                    MOV	A,M                    ;Fetch the Exponent value to the accumulator.
 2376/2FA8 : 36 5F                                 MVI	L, 137o               ;Change the pointer to the FPOP Exponent
 2377/2FAA : BF                                    CMP	M                    ;Compare the values of the exponents. If they are the
 2378/2FAB : 68 E4 2F                              JZ	SHACOP             ;Same then can immediately proceed to add operations.
 2379/2FAE : C8                                    MOV	B,A                    ;If not the same, store FPACC Exponent size in regis B
 2380/2FAF : C7                                    MOV	A,M                    ;Fetch the FPOP Exponent size into the ACC
 2381/2FB0 : 99                                    SBB	B                    ;Subtract the FPACC Exponent from the FPOP Exp.
 2382/2FB1 : 50 B7 2F                              JP	SKPNEG             ;If result is positive jump over the next few instructions
 2383/2FB4 : C8                                    MOV	B,A                    ;If result was negative, store the result in B
 2384/2FB5 : A8                                    XRA	A                    ;Clear the accumulator
 2385/2FB6 : 99                                    SBB	B                    ;Subtract register B to negate the original value
 2386/2FB7 : 3C 18                      SKPNEG:    CPI	030o               ;See if difference is less than 24 decimal.
 2387/2FB9 : 70 C6 2F                              JM	LINEUP             ;If so, can align exponents. Go do it.
 2388/2FBC : C7                                    MOV	A,M                    ;If not, find out which number is largest. Fetch FPOP
 2389/2FBD : 36 57                                 MVI	L, 127o               ;Exponent into ACC. Change pointer to FPACC Exp.
 2390/2FBF : 97                                    SUB	M                    ;Subtract FPACC from FPOP. If result is negative then
 2391/2FC0 : 33                                    RM                    ;was larger. Return with answer in FPACC.
 2392/2FC1 : 36 54                                 MVI	L, 124o               ;If result was positive, larger value in FPOP. Set pointers
 2393/2FC3 : 44 95 2F                              JMP	MOVOP              ;To transfer FPOP into FPACC and then exit to caller.
 2394/2FC6 : C7                         LINEUP:    MOV	A,M                    ;Fetch FPOP Exponent into accumulator.
 2395/2FC7 : 36 57                                 MVI	L, 127o               ;Change pointer to FPACC Exponent.
 2396/2FC9 : 97                                    SUB	M                    ;Subtract FPACC Exponent from FPOP Exponent. If
 2397/2FCA : 70 DA 2F                              JM	SHIFT0             ;Result is negative FPACC is larger. Go shift FPOP.
 2398/2FCD : D0                                    MOV	C,A                    ;If result positive FPOP larger, must shift FPACC. Store
 2399/2FCE : 36 57                      MORACC:    MVI	L, 127o               ;Difference count in C. Reset pointer to FPACC Exp
 2400/2FD0 : 46 03 30                              CALL	SHLOOP             ;Call the SHift LOOP to rotate FPACC mantissa RIGHT
 2401/2FD3 : 11                                    DCR	C                    ;And INCREMENT Exponent. Decr difference counter
 2402/2FD4 : 48 CE 2F                              JNZ	MORACC             ;Continue rotate operations until diff counter is zero
 2403/2FD7 : 44 E4 2F                              JMP	SHACOP             ;Go do final alignment and perform addition process
 2404/2FDA : D0                         SHIFT0:    MOV	C,A                    ;Routine to shift FPOP. Set difference count into reg. C
 2405/2FDB : 36 5F                      MOROP:     MVI	L, 137o               ;Set pointer to FPOP Exponent.
 2406/2FDD : 46 03 30                              CALL	SHLOOP             ;Call the SHift LOOP to rotate FPOP mantissa RIGHT
 2407/2FE0 : 10                                    INR	C                    ;And INCREMENT Exponent. Then incr difference cntr
 2408/2FE1 : 48 DB 2F                              JNZ	MOROP              ;Continue rotate opemtions until diff counter is zero
 2409/2FE4 :                            ;;; The below two instructions are changed by PATCH NR.1
 2410/2FE4 :                            ;;;SHACOP:    LLI 123                ;Set pointer to FPACC LSW minus one to provide extra
 2411/2FE4 :                            ;;;           LMI 000                ;Byte for addition ops. Clear that location to zero.
 2412/2FE4 :                            SHACOP:
 2413/2FE4 :                            ;	   CALL	PATCH1		; patch 1 inserts a few lines at 30-000
 2414/2FE4 :                            
 2415/2FE4 :                            ;;; The following is PATCH NR.1
 2416/2FE4 :                            ;          ORG	1800h	;030#000
 2417/2FE4 : 36 53                      PATCH1:    MVI	L, 123o
 2418/2FE6 : 3E 00                                 MVI	M, 000
 2419/2FE8 : 36 5B                                 MVI	L, 133o
 2420/2FEA : 3E 00                                 MVI	M, 000
 2421/2FEC :                            ;          RET
 2422/2FEC :                            ;	   MOV	A,A
 2423/2FEC :                            ;;;        MVI L, 133
 2424/2FEC :                            ;;;        LMI 000                ;THIS IS PATCH #1
 2425/2FEC : 36 57                                 MVI	L, 127o               ;Change pointer to FPACC Exponent
 2426/2FEE : 46 03 30                              CALL	SHLOOP             ;Rotate FPACC mantissa RIGHT & Increment Exponent
 2427/2FF1 : 36 5F                                 MVI	L, 137o               ;Change pointer to FPOP Exponent
 2428/2FF3 : 46 03 30                              CALL	SHLOOP             ;Rotate FPOP mantissa RIGHT & Increment Exponent
 2429/2FF6 : DD                                    MOV	D,H                    ;Rotate ops provide room for overflow. Now set up
 2430/2FF7 : 26 53                                 MVI	E, 123o               ;Pointers to LSW minus one for both FPACC & FPOP
 2431/2FF9 : 0E 04                                 MVI	B, 004                ;(FPOP already set after SHLOOP). Set precision counter
 2432/2FFB : 46 5E 31                              CALL	ADDER              ;Call quad precision ADDITION subroutine.
 2433/2FFE : 0E 00                                 MVI	B, 000                ;Set CPU register B to indicate standard normalization
 2434/3000 : 44 39 2F                              JMP	FPNORM             ;Go normalize the result and exit to caller.
 2435/3003 : CF                         SHLOOP:    MOV	B,M                    ;Shifting loop. First fetch Exponent currently being
 2436/3004 : 08                                    INR	B                    ;Pointed to and Increment the value by one.
 2437/3005 : F9                                    MOV	M,B                    ;Return the updated Exponent value to memory.
 2438/3006 : 31                                    DCR	L                    ;Decrement the pointer to mantissa portion MSW
 2439/3007 : 0E 04                                 MVI	B, 004                ;Set precision counter
 2440/3009 : C7                         FSHIFT:    MOV	A,M                    ;Fetch MSW of mantissa
 2441/300A : A0                                    ANA	A                    ;Set CPU flags after load ops
 2442/300B : 50 90 31                              JP	ROTATR             ;If MSB not a one can do normal rotate ops
 2443/300E : 12                         BRING1:    RAL                    ;If MSB is a one need to set up carrv bit for the negative
 2444/300F : 44 91 31                              JMP	ROTR               ;Number case. Then make special entry to ROTATR sub
 2445/3012 :                            
 2446/3012 :                                                              ;The following subroutine moves the contents of a string
 2447/3012 :                                                              ;of memory locations from the address pointed to by
 2448/3012 :                                                              ;CPU registers H & L to the address specified by the con-
 2449/3012 :                                                              ;tents of registers D & E when the routine is entered. The
 2450/3012 :                                                              ;process continues until the counter in register B is zero.
 2451/3012 :                            
 2452/3012 : C7                         MOVEIT:    MOV	A,M                    ;Fetch a word from memory string A
 2453/3013 : 30                                    INR	L                    ;Advance A string pointer
 2454/3014 : 46 F5 31                              CALL	SWITCH             ;Switch pointer to string B
 2455/3017 : F8                                    MOV	M,A                    ;Put word from string A into string B
 2456/3018 : 30                                    INR	L                   ;Advance B string pointer
 2457/3019 : 46 F5 31                              CALL	SWITCH             ;Switch pointer back to string A
 2458/301C : 09                                    DCR	B                    ;Decrement loop counter
 2459/301D : 2B                                    RZ                    ;Return to calling routine when counter reaches zero
 2460/301E : 44 12 30                              JMP	MOVEIT             ;Else continue transfer operations
 2461/3021 :                            
 2462/3021 :                                                              ;The following subroutine SUBTRACTS the
 2463/3021 :                                                              ;contents of the FLOATING POINT ACCUMULATOR from the
 2464/3021 :                                                              ;contents of the FLOATING POINT OPERAND and
 2465/3021 :                                                              ;leaves the result in the FPACC. The routine merely
 2466/3021 :                                                              ;negates the value in the FPACC and then goes to the
 2467/3021 :                                                              ;FPADD subroutine just presented.
 2468/3021 :                            
 2469/3021 : 36 54                      FPSUB:     MVI	L, 124o               ;Set L to address of LSW of FPACC
 2470/3023 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of FPACC
 2471/3025 : 0E 03                                 MVI	B, 003                ;Set precision counter
 2472/3027 : 46 6F 31                              CALL	COMPLM             ;Two's complement the value in the FPACC
 2473/302A : 44 8C 2F                              JMP	FPADD              ;Now go add the negated value to perform subtraction!
 2474/302D :                            
 2475/302D :                                                              ;The first part of the FLOATING POINT MULTIPLI-
 2476/302D :                                                              ;CATION subroutine calls a subroutine to check the
 2477/302D :                                                              ;original signs of the numbers that are to be multi-
 2478/302D :                                                              ;plied and perform working register clearing functions.
 2479/302D :                                                              ;Next the exponents of the numbers to be multiplied
 2480/302D :                                                              ;are added together.
 2481/302D :                            
 2482/302D : 46 7D 30                   FPMULT:    CALL	CKSIGN             ;Call routine to set up registers & ck signs of numbers
 2483/3030 : 36 5F                      ADDEXP:    MVI	L, 137o               ;Set pointer to FPOP Exponent
 2484/3032 : C7                                    MOV	A,M                    ;Fetch FPOP Exponent into the accumulator
 2485/3033 : 36 57                                 MVI	L, 127o               ;Change pointer to FPACC Exponent
 2486/3035 : 87                                    ADD	M                    ;Add FPACC Exponent to FPOP Exponent
 2487/3036 : 04 01                                 ADI	001                ;Add one more to total for algorithm compensation
 2488/3038 : F8                                    MOV	M,A                    ;Store result in FPACC Exponent location
 2489/3039 : 36 42                      SETMCT:    MVI	L, 102o               ;Change pointer to bit counter storage location
 2490/303B : 3E 17                                 MVI	M, 027o               ;Initialize bit counter to 23 decimal
 2491/303D :                            
 2492/303D :                                                              ;Next portion of the FPMULT routine is the iinplernen-
 2493/303D :                                                              ;tation of the algorithm illustrated in the flow chart
 2494/303D :                                                              ;above. This portion multiplies the values of the two
 2495/303D :                                                              ;mantissas. The final value is rounded off to leave the
 2496/303D :                                                              ;23 most significant bits as the answer that is stored
 2497/303D :                                                              ;back in the FPACC.
 2498/303D :                            
 2499/303D : 36 56                      MULTIP:    MVI	L, 126o                ;Set pointer to MSW of FPACC mantissa
 2500/303F : 0E 03                                 MVI	B, 003                ;Set precision counter
 2501/3041 : 46 90 31                              CALL	ROTATR             ;Rotate FPACC (multiplier) RIGHT into carry bit
 2502/3044 : 62 BF 30                              CC	ADOPPP             ;If carry is a one, add multiplicand to partial-product
 2503/3047 : 36 66                                 MVI	L, 146o                ;Set pointer to partial-product most significant byte
 2504/3049 : 0E 06                                 MVI	B, 006                ;Set precision counter (p-p register is double length)
 2505/304B : 46 90 31                              CALL	ROTATR             ;Shift partial-product RIGHT
 2506/304E : 36 42                                 MVI	L, 102o                ;Set pointer to bit counter storage location
 2507/3050 : D7                                    MOV	C,M                    ;Fetch current value of bit counter
 2508/3051 : 11                                    DCR	C                    ;Decrement the value of the bit counter
 2509/3052 : FA                                    MOV	M,C                    ;Restore the updated bit counter to its storage location
 2510/3053 : 48 3D 30                              JNZ	MULTIP             ;If have not multiplied for 23 (deciinal) bits, keep going
 2511/3056 : 36 66                                 MVI	L, 146o                ;If have done 23 (decimal) bits, set pntr to p-p MSW
 2512/3058 : 0E 06                                 MVI	B, 006                ;Set precision counter (for double length)
 2513/305A : 46 90 31                              CALL	ROTATR             ;Shift partial-product once more to the RIGHT
 2514/305D : 36 63                                 MVI	L, 143o                ;Set pointer to access 24'th bit in partial-product
 2515/305F : C7                                    MOV	A,M                    ;Fetch the byte containing the 24'th bit
 2516/3060 : 12                                    RAL                    ;Position the 24'th bit to be MSB in the accumulator
 2517/3061 : A0                                    ANA	A                    ;Set the CPU flags after to rotate operation and test to
 2518/3062 : 72 C9 30                              CM	MROUND             ;See if 24'th bit of p-p is a ONE. If so, must round-off
 2519/3065 : 36 53                                 MVI	L, 123o                ;Now set up pointers
 2520/3067 : E6                                    MOV	E,L                    ;To perform transfer
 2521/3068 : DD                                    MOV	D,H                    ;Of the multiplication results
 2522/3069 : 36 63                                 MVI	L, 143o                ;From the partial-product location
 2523/306B : 0E 04                                 MVI	B, 004                ;To the FPACC
 2524/306D :                            
 2525/306D :                            	
 2526/306D : 46 12 30                   EXMLDV:    CALL	MOVEIT             ;Perform the transfer from p-p to FPACC
 2527/3070 : 0E 00                                 MVI	B, 000                ;Set up CPU register B to indicate regular normalization
 2528/3072 : 46 39 2F                              CALL	FPNORM             ;Normalize the result of multiplication
 2529/3075 : 36 41                                 MVI	L, 101o               ;Now set the pointer to the original SIGNS indicator
 2530/3077 : C7                                    MOV	A,M                    ;Fetch the indicator
 2531/3078 : A0                                    ANA	A                    ;Exercise the CPU flags
 2532/3079 : 0B                                    RNZ                    ;If indicator is non-zero, answer is positive, can exit her
 2533/307A : 44 85 2F                              JMP	FPCOMP             ;If not, answer must be negated, exit via 2's complement.
 2534/307D :                            
 2535/307D :                                                              ;The following portions of the FPMULT
 2536/307D :                                                              ;routine set up working locations in memory by clearing
 2537/307D :                                                              ;locations for an expanded FPOP area and the partial-produc
 2538/307D :                                                              ;area. Next, the signs of the two numbers to be multiplied
 2539/307D :                                                              ;are examined. Negative numbers are negated
 2540/307D :                                                              ;in preparation for the multiplication
 2541/307D :                                                              ;algorithm. A SIGNS indicator register is set up during
 2542/307D :                                                              ;this process to indicate whether the final result of the
 2543/307D :                                                              ;multiplication should be positive or negative. (Negative
 2544/307D :                                                              ;if original signs of the two numbers to be multiplied are
 2545/307D :                                                              ;different.)
 2546/307D :                            
 2547/307D : 36 60                      CKSIGN:    MVI	L, 140o               ;Set pointer to start of partial-product working area
 2548/307F : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to proper page
 2549/3081 : 0E 08                                 MVI	B, 010o               ;Set up a loop counter in CPU register B
 2550/3083 : A8                                    XRA	A                    ;Clear the accumulator
 2551/3084 :                            
 2552/3084 : F8                         CLRNEX:    MOV	M,A                    ;Now clear out locations for the partial-product
 2553/3085 : 30                                    INR	L                    ;Working registers
 2554/3086 : 09                                    DCR	B                    ;Until the loop counter
 2555/3087 : 48 84 30                              JNZ	CLRNEX             ;Is zero
 2556/308A : 0E 04                      CLROPL:    MVI	B, 004                ;Set a loop counter
 2557/308C : 36 58                                 MVI	L, 130o               ;Set up pointer
 2558/308E : F8                         CLRNX1:    MOV	M,A                    ;Clear out some extra registers so that the
 2559/308F : 30                                    INR	L                    ;FPOP may be extended in length
 2560/3090 : 09                                    DCR	B                    ;Perform clearing ops until loop counter
 2561/3091 : 48 8E 30                              JNZ	CLRNX1             ;Is zero
 2562/3094 : 36 41                                 MVI	L, 101o               ;Set pointer to M/D SIGNS indicator storage location
 2563/3096 : 3E 01                                 MVI	M, 001                ;Set initial value of SIGNS indicator to plus one
 2564/3098 : 36 56                                 MVI	L, 126o               ;Change pointer to MSW of FPACC
 2565/309A : C7                                    MOV	A,M                    ;Fetch MSW of mantissa into accumulator
 2566/309B : A0                                    ANA	A                    ;Test flags
 2567/309C : 70 B0 30                              JM	NEGFPA             ;If MSB in MSW of FPACC is a one, number is negative
 2568/309F : 36 5E                      OPSGNT:    MVI	L, 136o               ;Set pointer to MSW of FPOP
 2569/30A1 : C7                                    MOV	A,M                    ;Fetch MSW of mantissa into accumulator
 2570/30A2 : A0                                    ANA	A                    ;Test flags
 2571/30A3 : 13                                    RP                    ;Return to caller if number in FPOP is positive
 2572/30A4 : 36 41                                 MVI	L, 101o               ;Else change pointer to M/D SIGNS indicator
 2573/30A6 : D7                                    MOV	C,M                    ;Fetch the value in the SIGNS indicator
 2574/30A7 : 11                                    DCR	C                    ;Decrement the value by one
 2575/30A8 : FA                                    MOV	M,C                    ;Restore the new value back to storage location
 2576/30A9 : 36 5C                                 MVI	L, 134o               ;Set pointer to LSW of FPOP
 2577/30AB : 0E 03                                 MVI	B, 003                ;Set precision counter
 2578/30AD : 44 6F 31                              JMP	COMPLM             ;Two's complement value of FPOP & return to caller
 2579/30B0 : 36 41                      NEGFPA:    MVI	L, 101o               ;Set pointer to M/D SIGNS indicator
 2580/30B2 : D7                                    MOV	C,M                    ;Fetch the value in the SIGNS indicator
 2581/30B3 : 11                                    DCR	C                    ;Decrement the value by one
 2582/30B4 : FA                                    MOV	M,C                    ;Restore the new value back to storage location
 2583/30B5 : 36 54                                 MVI	L, 124o               ;Set pointer to LSW of FPACC
 2584/30B7 : 0E 03                                 MVI	B, 003                ;Set precision counter
 2585/30B9 : 46 6F 31                              CALL	COMPLM             ;Two's complement value of FPACC
 2586/30BC : 44 9F 30                              JMP	OPSGNT             ;Proceed to check sign of FPOP
 2587/30BF :                            
 2588/30BF :                                                              ;The following subroutine adds the double length (six regis
 2589/30BF :                                                              ;multiplicand in FPOP to the partial-product register when
 2590/30BF :                                                              ;called on by the multiplication algorithm.
 2591/30BF :                            
 2592/30BF : 26 61                      ADOPPP:    MVI	E, 141o               ;Pointer to LSW of partial-product
 2593/30C1 : DD                                    MOV	D,H                    ;On same page as FPOP
 2594/30C2 : 36 59                                 MVI	L, 131o               ;LSIV of FPOP which contains extended multiplicand
 2595/30C4 : 0E 06                                 MVI	B, 006                ;Set precision counter (double length working registers)
 2596/30C6 : 44 5E 31                              JMP	ADDER              ;Add multiplicand to partial-product & return to caller
 2597/30C9 :                            
 2598/30C9 : 0E 03                      MROUND:    MVI	B, 003                ;Set up precision counter
 2599/30CB : 06 40                                 MVI	A, 100o               ;Prepare to add one to 24'th bit of partial-product
 2600/30CD : 87                                    ADD	M                    ;Add one to the 24'th bit of the partial-product
 2601/30CE : F8                         CROUND:    MOV	M,A                    ;Restore the updated byte to memory
 2602/30CF : 30                                    INR	L                    ;Advance the memory pointer to next most significant
 2603/30D0 : 06 00                                 MVI	A, 000                ;Byte of partial-product, then clear ACC without
 2604/30D2 : 8F                                    ADC	M                    ;Disturbing carry bit. Now perform add with carry to
 2605/30D3 : 09                                    DCR	B                    ;Propagate any rounding in the partial-product registers.
 2606/30D4 : 48 CE 30                              JNZ	CROUND             ;If cotinter is not zero continue propagating any carry
 2607/30D7 : F8                                    MOV	M,A                    ;Restore final byte to memory
 2608/30D8 : 07                                    RET                    ;Exit to CALLling routine
 2609/30D9 :                            
 2610/30D9 : 46 7D 30                   FPDIV:     CALL	CKSIGN             ;Call routine to set up registers & ck signs of numbers
 2611/30DC : 36 56                                 MVI	L, 126o               ;Set pointer to MSW of FPACC (divisor)
 2612/30DE : C7                                    MOV	A,M                    ;Fetch MSW of FPACC to accumulator
 2613/30DF : A0                                    ANA	A                    ;Exercise CPU flags
 2614/30E0 : 68 FA 29                              JZ	DVERR              ;If MSW of FPACC is zero go display 'DZ' error message
 2615/30E3 : 36 5F                      SUBEXP:    MVI	L, 137o               ;Set pointer to FPOP (dividend) Exponent
 2616/30E5 : C7                                    MOV	A,M                    ;Get FPOP Exponent into accumulator
 2617/30E6 : 36 57                                 MVI	L, 127o               ;Change pointer to FPACC (divisor) Exponent
 2618/30E8 : 97                                    SUB	M                    ;Subtract divisor exponent from dividend exponent
 2619/30E9 : 04 01                                 ADI	001                ;Add one for algorithm compensation
 2620/30EB : F8                                    MOV	M,A                    ;Place result in FPACC Exponent
 2621/30EC : 36 42                      SETDCT:    MVI	L, 102o               ;Set pointer to bit counter storage location
 2622/30EE : 3E 17                                 MVI	M, 027o               ;Initialize bit counter to 23 decimal
 2623/30F0 :                            
 2624/30F0 :                                                              ;Main division algorithm for mantissas
 2625/30F0 :                            
 2626/30F0 : 46 48 31                   DIVIDE:    CALL	SETSUB             ;Go subtmct divisor from dividend
 2627/30F3 : 70 05 31                              JM	NOGO               ;If result is negative then place a zero bit in quotient
 2628/30F6 : 26 5C                                 MVI	E, 134o               ;If result zero or positive then move remainder after
 2629/30F8 : 36 59                                 MVI	L, 131o               ;Subtraction from working area to become new dividend
 2630/30FA : 0E 03                                 MVI	B, 003                ;Set up moving pointers and initialize precision counter
 2631/30FC : 46 12 30                              CALL	MOVEIT             ;Perform the transfer
 2632/30FF : 06 01                                 MVI	A, 001                ;Place a one into least significant bit of accumulator
 2633/3101 : 1A                                    RAR                    ;And rotate it out into the carry bit
 2634/3102 : 44 06 31                              JMP	QUOROT             ;Proceed to rotate the carry bit into the current quotient
 2635/3105 : A8                         NOGO:      XRA	A                    ;When result is negative, put a zero in the carry bit, then
 2636/3106 : 36 64                      QUOROT:    MVI	L, 144o               ;Set up pointer to LSW of quotient register
 2637/3108 : 0E 03                                 MVI	B, 003                ;Set precision counter
 2638/310A : 46 87 31                              CALL	ROTL               ;Rotate carry bit into quotient by using special entry to
 2639/310D : 36 5C                                 MVI	L, 134o               ;ROTATL subroutine. Now set up pointer to dividend
 2640/310F : 0E 03                                 MVI	B, 003                ;LSW and set precision counter
 2641/3111 : 46 86 31                              CALL	ROTATL             ;Rotate the current dividend to the left
 2642/3114 : 36 42                                 MVI	L, 102o               ;Set pointer to bit counter storage location
 2643/3116 : D7                                    MOV	C,M                    ;Fetch the value of the bit counter
 2644/3117 : 11                                    DCR	C                    ;Decrement the value by one
 2645/3118 : FA                                    MOV	M,C                    ;Restore the new counter value to storage
 2646/3119 : 48 F0 30                              JNZ	DIVIDE             ;If bit counter is not zero, continue division process
 2647/311C : 46 48 31                              CALL	SETSUB             ;After 23 (decimal) bits, do subtraction once more for
 2648/311F : 70 3F 31                              JM	DVEXIT             ;Possible rounding. Jump ahead if no rounding required.
 2649/3122 : 36 64                                 MVI	L, 144o               ;If rounding required set pointer to LSW of quotient
 2650/3124 : C7                                    MOV	A,M                    ;Fetch LSW of quotient to accumulator
 2651/3125 : 04 01                                 ADI	001                ;Add one to 23rd bit of quotient
 2652/3127 : F8                                    MOV	M,A                    ;Restore updated LSW of quotient
 2653/3128 : 06 00                                 MVI	A, 000                ;Clear accumulator without disturbing carry bit
 2654/312A : 30                                    INR	L                    ;Advance pointer to next significant byte of quotient
 2655/312B : 8F                                    ADC	M                    ;Propagate any carry as part of rounding process
 2656/312C : F8                                    MOV	M,A                    ;Restore the updated byte of quotient
 2657/312D : 06 00                                 MVI	A, 000                ;Clear ACC again without disturbing carry bit
 2658/312F : 30                                    INR	L                    ;Advance pointer to MSW of quotient
 2659/3130 : 8F                                    ADC	M                    ;Propagate any carry to finish rounding process
 2660/3131 : F8                                    MOV	M,A                    ;Restore the updated byte of quotient
 2661/3132 : 50 3F 31                              JP	DVEXIT             ;If most significant bit of quotient is zero, go finish up
 2662/3135 : 0E 03                                 MVI	B, 003                ;If not, set precision counter
 2663/3137 : 46 90 31                              CALL	ROTATR             ;And rotate quotient to the right to clear the sign bit
 2664/313A : 36 57                                 MVI	L, 127o               ;Set pointer to FPACC Exponent
 2665/313C : CF                                    MOV	B,M                    ;Fetch FPACC exponent
 2666/313D : 08                                    INR	B                    ;Increment the value to compensate for the rotate right
 2667/313E : F9                                    MOV	M,B                    ;Restore the updated exponent value
 2668/313F : 36 63                      DVEXIT:    MVI	L, 143o               ;Set up pointers
 2669/3141 : 26 53                                 MVI	E, 123o               ;To transfer the quotient into the FPACC
 2670/3143 : 0E 04                                 MVI	B, 004                ;Set precision counter
 2671/3145 :                                                              ;THIS IS A CORRECTION FOUND IN THE NOTES
 2672/3145 : 44 6D 30                              JMP	EXMLDV             ;And exit through FPMULT routine at EXMLDV
 2673/3148 :                            
 2674/3148 :                                                              ;Subroutine to subtract divisor from dividend. Used by
 2675/3148 :                                                              ;main DIVIDE subroutine.
 2676/3148 :                            
 2677/3148 : 26 59                      SETSUB:    MVI	E, 131o               ;Set pointer to LSW of working area
 2678/314A : DD                                    MOV	D,H                    ;On same page as FPACC
 2679/314B : 36 54                                 MVI	L, 124o               ;Set pointer to LSW of FPACC (divisor)
 2680/314D : 0E 03                                 MVI	B, 003                ;Set precision counter
 2681/314F : 46 12 30                              CALL	MOVEIT             ;Perform transfer
 2682/3152 : 26 59                                 MVI	E, 131o               ;Reset pointer to LSW of working area (now divisor)
 2683/3154 : 36 5C                                 MVI	L, 134o               ;Reset pointer to LSW of FPOP (dividend)
 2684/3156 : 0E 03                                 MVI	B, 003                ;Set precision counter
 2685/3158 : 46 9A 31                              CALL	SUBBER             ;Subtract divisor from dividend
 2686/315B : C7                                    MOV	A,M                    ;Get MSW of the result of the subtraction operations
 2687/315C : A0                                    ANA	A                    ;Exercise CPU flags
 2688/315D : 07                                    RET                    ;Return to caller with status
 2689/315E : A0                         ADDER:     ANA	A                    ;Initialize the carry bit to zero upon entry
 2690/315F : C7                         ADDMOR:    MOV	A,M                    ;Fetch byte from register group A
 2691/3160 : 46 F5 31                              CALL	SWITCH             ;Switch memory pointer to register group B
 2692/3163 : 8F                                    ADC	M                    ;Add byte from A to byte from B with carry
 2693/3164 : F8                                    MOV	M,A                    ;Leave result in register group B
 2694/3165 : 09                                    DCR	B                    ;Decrement number of bytes (precision) counter
 2695/3166 : 2B                                    RZ                    ;Return to caller when all bytes in group processed
 2696/3167 : 30                                    INR	L                    ;Else advance pointer for register group B
 2697/3168 : 46 F5 31                              CALL	SWITCH             ;Switch memory pointer back to register group A
 2698/316B : 30                                    INR	L                    ;Advance the pointer for register group A
 2699/316C : 44 5F 31                              JMP	ADDMOR             ;Continue the multi-byte addition operation
 2700/316F :                            
 2701/316F :                                                              ;N'th precision two's complement (negate)
 2702/316F :                                                              ;subroutine. Performs a two's complement on the multi-byte
 2703/316F :                                                              ;registers tarting at the address pointed
 2704/316F :                                                              ; to by H & L (least significant byte) upon entry.
 2705/316F :                            
 2706/316F : C7                         COMPLM:    MOV	A,M                    ;Fetch the least significant byte of the number to ACC
 2707/3170 : 2C FF                                 XRI	377o               ;Exclusive OR to complement the byte
 2708/3172 : 04 01                                 ADI	001                ;Add one to form two's complement of byte
 2709/3174 : F8                         MORCOM:    MOV	M,A                    ;Restore the negated byte to memory
 2710/3175 : 1A                                    RAR                   ;Save the carry bit
 2711/3176 : D8                                    MOV	D,A                    ;In CPU register D
 2712/3177 : 09                                    DCR	B                    ;Decrement number of bytes (precision) counter
 2713/3178 : 2B                                    RZ                    ;Return to caller when all bytes in number processed
 2714/3179 : 30                                    INR	L                    ;Else advance the pointer
 2715/317A : C7                                    MOV	A,M                    ;Fetch the next byte of the number to ACC
 2716/317B : 2C FF                                 XRI	377o               ;Exclusive OR to complement the byte
 2717/317D : E0                                    MOV	E,A                    ;Save complemented value in register E temporarily
 2718/317E : C3                                    MOV	A,D                    ;Restore previous carry status to ACC
 2719/317F : 12                                    RAL                    ;And rotate it out to the carry bit
 2720/3180 : 06 00                                 MVI	A, 000                ;Clear ACC without disturbing carry status
 2721/3182 : 8C                                    ADC	E                    ;Add in any carry to complemented value
 2722/3183 : 44 74 31                              JMP	MORCOM             ;Continue the two's complement procedure as req'd
 2723/3186 :                            
 2724/3186 :                                                              ;N'th precision rotate left subroutine. Rotates a multi-
 2725/3186 :                                                              ;byte number left starting at the address initially
 2726/3186 :                                                              ;specified by the contents of CPU registers H & L upon
 2727/3186 :                                                              ;subroutine entry (LSW). First entry point will clear
 2728/3186 :                                                              ;the carry bit before beginning rotate operations. Second
 2729/3186 :                                                              ;entry point does not clear the carry bit.
 2730/3186 :                            
 2731/3186 : A0                         ROTATL:    ANA	A                    ;Clear the carry bit at this entry point
 2732/3187 : C7                         ROTL:      MOV	A,M                    ;Fetch a byte from memory
 2733/3188 : 12                                    RAL                    ;Rotate it left (bring carry into LSB, push MSB to carry)
 2734/3189 : F8                                    MOV	M,A                    ;Restore rotated word to memory
 2735/318A : 09                                    DCR	B                    ;Decrement precision counter
 2736/318B : 2B                                    RZ                    ;Exit to caller when finished
 2737/318C : 30                                    INR	L                    ;Else advance pointer to next byte
 2738/318D : 44 87 31                              JMP	ROTL               ;Continue rotate left operations
 2739/3190 :                            
 2740/3190 :                            
 2741/3190 :                                                              ;N'th precision rotate
 2742/3190 :                                                              ;right subroutine. Opposite of
 2743/3190 :                                                              ;above subroutine.
 2744/3190 :                            
 2745/3190 : A0                         ROTATR:    ANA	A                    ;Clear the carry bit at this entry point
 2746/3191 : C7                         ROTR:      MOV	A,M                    ;Fetch a byte from memory
 2747/3192 : 1A                                    RAR                    ;Rotate it right (carry into MSB, LSB to carry)
 2748/3193 : F8                                    MOV	M,A                    ;Restore rotated word to memory
 2749/3194 : 09                                    DCR	B                    ;Decrement precision counter
 2750/3195 : 2B                                    RZ                    ;Exit to caller when finished
 2751/3196 : 31                                    DCR	L                    ;Else decrement pointer to next byte
 2752/3197 : 44 91 31                              JMP	ROTR               ;Continue rotate right operations
 2753/319A :                            
 2754/319A :                                                              ;N'th precision subtraction subroutine.
 2755/319A :                                                              ;Number starting at location pointed to by D & E (least
 2756/319A :                                                              ;significant byte) is subtracted from number starting at
 2757/319A :                                                              ;address specified by contents of H & L.
 2758/319A :                            
 2759/319A : A0                         SUBBER:    ANA	A                    ;Initialize the carry bit to zero upon entry
 2760/319B : C7                         SUBTRA:    MOV	A,M                    ;Fetch byte from register group A
 2761/319C : 46 F5 31                              CALL	SWITCH             ;Switch memory pointer to register group B
 2762/319F : 9F                                    SBB	M                    ;Subtract byte from group B ftom that in group A
 2763/31A0 : F8                                    MOV	M,A                    ;Leave result in register group B
 2764/31A1 : 09                                    DCR	B                    ;Decrement number of bytes (precision) counter
 2765/31A2 : 2B                                    RZ                    ;Return to caller when all bytes in group processed
 2766/31A3 : 30                                    INR	L                    ;Else advance pointer for register group B
 2767/31A4 : 46 F5 31                              CALL	SWITCH             ;Switch memory pointer back to register group A
 2768/31A7 : 30                                    INR	L                    ;Advance the pointer for register group A
 2769/31A8 : 44 9B 31                              JMP	SUBTRA             ;Continue the multi-byte subtraction operation
 2770/31AB :                            
 2771/31AB :                                                              ;The next subroutine will transfer the four byte
 2772/31AB :                                                              ;register string (generally a number in floating point
 2773/31AB :                                                              ;format) from the starting address pointed to by CPU
 2774/31AB :                                                              ;registers H & L when the subroutine is entered to
 2775/31AB :                                                              ;the FPACC (floating point accumulator registers).
 2776/31AB :                            
 2777/31AB : 1E 02                      FLOAD:     MVI	D,PG01 ;\HB\OLDPG1    ;** Set page address of FPACC
 2778/31AD : 26 54                                 MVI	E, 124o               ;Set address of least signficant byte of FPACC
 2779/31AF : 0E 04                                 MVI	B, 004                ;Set precision counter to four bytes (mantissa bytes
 2780/31B1 : 44 12 30                              JMP	MOVEIT             ;Plus Exponent) and exit via the transfer routine
 2781/31B4 :                            
 2782/31B4 :                                                              ;The next several subroutines are used to perform
 2783/31B4 :                                                              ;floating pojnt register loading and transfer operations.
 2784/31B4 :                            
 2785/31B4 : E6                         FSTORE:    MOV	E,L                    ;Transfer contents of register L to E
 2786/31B5 : DD                                    MOV	D,H                    ;Transfer contents of register H to D
 2787/31B6 : 36 54                                 MVI	L, 124o               ;Set L to least significant byte of FPACC mantissa
 2788/31B8 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set page to FPACC storage area
 2789/31BA : 44 C1 31                              JMP	SETIT              ;Go transfer FPACC contents to area pointed to by D&E
 2790/31BD : 1E 02                      OPLOAD:    MVI	D,PG01 ;\HB\OLDPG1    ;** Set page to FPOP storage area
 2791/31BF : 26 5C                                 MVI	E, 134o               ;Set pointer to least significant byte of FPOP
 2792/31C1 : 0E 04                      SETIT:     MVI	B, 004                ;Set precision counter. Transfer from H & L area to
 2793/31C3 : 44 12 30                              JMP	MOVEIT             ;Locations pointed to by D & E
 2794/31C6 :                            
 2795/31C6 :                                                              ;The next subroutine perforins a double transfer opera-
 2796/31C6 :                                                              ;tion. It first transfers the contents of the FPACC into
 2797/31C6 :                                                              ;the FPOP. It then transfers new data (as pointed to by
 2798/31C6 :                                                              ;H & L upon entry to the subroutine) into the FPACC.
 2799/31C6 :                            
 2800/31C6 : 46 D6 31                   FACXOP:    CALL	SAVEHL             ;Save contents of H & L upon entry to subroutine
 2801/31C9 : 36 54                                 MVI	L, 124o               ;Set pointer to FPACC LSW
 2802/31CB : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set pointer to page of FPACC
 2803/31CD : 46 BD 31                              CALL	OPLOAD             ;Transfer FPACC to FPOP
 2804/31D0 : 46 E6 31                              CALL	RESTHL             ;Recover original subroutine entry values for H & L
 2805/31D3 : 44 AB 31                              JMP	FLOAD              ;Transfer registers pointed to by H & L into the FPACC
 2806/31D6 :                            
 2807/31D6 :                                                              ;Subroutine to save the contents of CPU registers D, E, H
 2808/31D6 :                                                              ;and L in a temporary storage area in memory.
 2809/31D6 :                            
 2810/31D6 : C5                         SAVEHL:    MOV	A,H                    ;Transfer value in H to ACC
 2811/31D7 : CE                                    MOV	B,L                    ;And value in L to B
 2812/31D8 : 36 80                                 MVI	L, 200o               ;Now set L to start of tempomry storage locations
 2813/31DA : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** And set H to storage area page
 2814/31DC : F8                                    MOV	M,A                    ;Save A (entry value of H) in memory
 2815/31DD : 30                                    INR	L                    ;Advance pointer
 2816/31DE : F9                                    MOV	M,B                    ;Save B (entry value of L) in memory
 2817/31DF : 30                                    INR	L                    ;Advance pointer
 2818/31E0 : FB                                    MOV	M,D                    ;Save D in memory
 2819/31E1 : 30                                    INR	L                    ;Advance pointer
 2820/31E2 : FC                                    MOV	M,E                    ;Save E in memory
 2821/31E3 : E8                                    MOV	H,A                    ;Restore entry value of H
 2822/31E4 : F1                                    MOV	L,B                    ;Restore entry value of L
 2823/31E5 : 07                                    RET                    ;Exit to calling routine
 2824/31E6 :                            
 2825/31E6 :                                                              ;Subroutine to restore the contents of CPU registers D,
 2826/31E6 :                                                              ;E, H and L from temporary storage in memory.
 2827/31E6 :                            
 2828/31E6 : 36 80                      RESTHL:    MVI	L, 200o               ;Set L to start of temporary storage locations
 2829/31E8 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to storage area page
 2830/31EA : C7                                    MOV	A,M                    ;Fetch stored value for li iii ACC
 2831/31EB : 30                                    INR	L                    ;Advance pointer
 2832/31EC : CF                                    MOV	B,M                    ;Fetch stored value for L into B
 2833/31ED : 30                                    INR	L                    ;Advance pointer
 2834/31EE : DF                                    MOV	D,M                    ;Fetch stored value for T.)
 2835/31EF : 30                                    INR	L                    ;Advance pointer
 2836/31F0 : E7                                    MOV	E,M                    ;Fetch stored value for
 2837/31F1 : E8                                    MOV	H,A                    ;Restore  saved value for H
 2838/31F2 : F1                                    MOV	L,B                    ;Restore saved value for L
 2839/31F3 : C7                                    MOV	A,M                    ;Leave stored value for E in ACC
 2840/31F4 : 07                                    RET                    ;Exit to calling routine
 2841/31F5 :                            
 2842/31F5 :                                                              ;Subroutine to exchange the contents of H & L with
 2843/31F5 :                                                              ;D & E.
 2844/31F5 :                            
 2845/31F5 : D5                         SWITCH:    MOV	C,H                    ;Transfer register H to C temporarily
 2846/31F6 : EB                                    MOV	H,D                    ;Place value of D into H
 2847/31F7 : DA                                    MOV	D,C                    ;Now put former H from C into D
 2848/31F8 : D6                                    MOV	C,L                    ;Transfer register L to C temporarily
 2849/31F9 : F4                                    MOV	L,E                    ;Place value of E into L
 2850/31FA : E2                                    MOV	E,C                    ;Now put former L from C into E
 2851/31FB : 07                                    RET                    ;Exit to calling routine
 2852/31FC : 2E 02                      GETINP:    MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of GETINP character counter
 2853/31FE : 36 90                                 MVI	L, 220o               ;Set L to address of GETINP character counter
 2854/3200 : D7                                    MOV	C,M                    ;Load counter value into CPU register C
 2855/3201 : 10                                    INR	C                    ;Exercise the counter in order
 2856/3202 : 11                                    DCR	C                    ;To set CPU flags. If counter is non-zero, then indexing
 2857/3203 : 48 0F 32                              JNZ	NOT0               ;Register (GETINP counter) is all set so jump ahead.
 2858/3206 : F4                                    MOV	L,E                    ;But, if counter zero, then starting to process a new
 2859/3207 : EB                                    MOV	H,D                    ;Character string. Transfer char string buffer pointer into
 2860/3208 : D7                                    MOV	C,M                    ;H & L and fetch the string's character count value (cc)
 2861/3209 : 10                                    INR	C                    ;Increment the (cc) by one to take account of (cc) byte
 2862/320A : 46 25 32                              CALL	INDEXC             ;Add contents of regis C to H & L to point to end of the
 2863/320D : 3E 00                                 MVI	M, 000                ;Character string in buffer and place a zero byte marker
 2864/320F : 36 90                      NOT0:      MVI	L, 220o               ;Set L back to address of GETINP counter which is used
 2865/3211 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** As an indexing value. Set H to correct page.
 2866/3213 : D7                                    MOV	C,M                    ;Fetch the value of GETINP counter into register C
 2867/3214 : 10                                    INR	C                    ;Increment the value in C
 2868/3215 : FA                                    MOV	M,C                    ;Restore the updated value for future use
 2869/3216 : F4                                    MOV	L,E                    ;Bring the base address of the character string buffer into
 2870/3217 : EB                                    MOV	H,D                    ;CPU registers H & L
 2871/3218 : 46 25 32                              CALL	INDEXC             ;Add contents of register C to form indexed address of
 2872/321B : C7                                    MOV	A,M                    ;Next character to be fetched as input. Fetch the next
 2873/321C : A0                                    ANA	A                    ;Character. Exercise the CPU flags.
 2874/321D : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Restore page pointer to floating point working area
 2875/321F : 0B                                    RNZ                    ;If character is non-zero, not end of string, exit to calle
 2876/3220 : 36 90                                 MVI	L, 220o               ;If zero character, must reset GETINP counter for next
 2877/3222 : 3E 00                                 MVI	M, 000                ;String. Reset pointer and clear GETINP counter to zero
 2878/3224 : 07                                    RET                    ;Then exit to calling routine
 2879/3225 :                            
 2880/3225 :                                                              ;Following subroutine causes register C to be used as an
 2881/3225 :                                                              ;indexing register. Value in C is added to address in H
 2882/3225 :                                                              ;and L to form new address.
 2883/3225 :                            
 2884/3225 : C6                         INDEXC:    MOV	A,L                    ;Place value from register L into accumulator
 2885/3226 : 82                                    ADD	C                    ;Add quantity in register C
 2886/3227 : F0                                    MOV	L,A                    ;Restore updated value back to L
 2887/3228 : 03                                    RNC                    ;Exit to caller if no carry from addition
 2888/3229 : 28                                    INR	H                    ;But, if have carry then must increment register H
 2889/322A : 07                                    RET                    ;Before returning to calling routine
 2890/322B :                            
 2891/322B :                                                              ;Main Decimal INPUT subroutine to convert strings of
 2892/322B :                                                              ;ASCII characters representing decimal fixed or floating
 2893/322B :                                                              ;point numbers to binary floating point numbers.
 2894/322B :                            
 2895/322B : E6                         DINPUT:    MOV	E,L                    ;Save entry value of register L in E. (Pointer to buffer
 2896/322C : DD                                    MOV	D,H                    ;Containing ASCII character string.) Do same for H to D.
 2897/322D : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of floating point working registers
 2898/322F : 36 68                                 MVI	L, 150o               ;Set L to start of decirnal-to-binary working area
 2899/3231 : A8                                    XRA	A                    ;Clear the accumulator
 2900/3232 : 0E 08                                 MVI	B, 010o               ;Set up a loop counter
 2901/3234 : F8                         CLRNX2:    MOV	M,A                    ;Deposit zero in working area to initialize
 2902/3235 : 30                                    INR	L                    ;Advance the memory pointer
 2903/3236 : 09                                    DCR	B                    ;Decrement the loop counter
 2904/3237 : 48 34 32                              JNZ	CLRNX2             ;Clear working area until loop counter is zero
 2905/323A : 36 43                                 MVI	L, 103o               ;Set pointer to floating point temporary registers and
 2906/323C : 0E 04                                 MVI	B, 004                ;Indicators working area. Set up a loop counter.
 2907/323E : F8                         CLRNX3:    MOV	M,A                    ;Deposit zero in working area to initialize
 2908/323F : 30                                    INR	L                    ;Advance the memory pointer
 2909/3240 : 09                                    DCR	B                    ;Decrement the loop counter
 2910/3241 : 48 3E 32                              JNZ	CLRNX3             ;Clear working area until loop counter is zero
 2911/3244 : 46 FC 31                              CALL	GETINP             ;Fetch a character from the ASCII chax string buffer
 2912/3247 : 3C AB                                 CPI	253o               ;(Typically the SYMBOL/TOKEN buffer). See if it is
 2913/3249 : 68 54 32                              JZ	NINPUT             ;Code for + sign. Jump ahead if code for + sign.
 2914/324C : 3C AD                                 CPI	255o               ;See if code for minus (-) sign.
 2915/324E : 48 57 32                              JNZ	NOTPLM             ;Jump ahead if not code for minus sign. If code for
 2916/3251 : 36 43                                 MVI	L, 103o               ;Minus sign, set pointer to MINUS flag storage location.
 2917/3253 : F8                                    MOV	M,A                    ;Set the MINUS flag to indicate a minus number
 2918/3254 : 46 FC 31                   NINPUT:    CALL	GETINP             ;Fetch another character from the ASCII char string
 2919/3257 : 3C AE                      NOTPLM:    CPI	256o               ;See if character represents a period (decimal point) in
 2920/3259 : 68 88 32                              JZ	PERIOD             ;Input string. Jump ahead if yes.
 2921/325C : 3C C5                                 CPI	305o               ;If not period, see if code for E as in Exponent
 2922/325E : 68 98 32                              JZ	FNDEXP             ;Jump ahead if yes.
 2923/3261 : 3C A0                                 CPI	240o               ;Else see if code for space.
 2924/3263 : 68 54 32                              JZ	NINPUT             ;Ignore space character, go fetch another character.
 2925/3266 : A0                                    ANA	A                    ;If none of the above see if zero byte
 2926/3267 : 68 D0 32                              JZ	ENDINP             ;Indicating end of input char string. If yes, jumn ahead.
 2927/326A : 3C B0                                 CPI	260o               ;If not end of string, check to see
 2928/326C : 70 08 2A                              JM	NUMERR             ;If character represents
 2929/326F : 3C BA                                 CPI	272o               ;A valid decimal number (0 to 9)
 2930/3271 : 50 08 2A                              JP	NUMERR             ;Display error message if not a valid digit at this point!
 2931/3274 : 36 6E                                 MVI	L, 156o               ;For valid digit, set pointer to MSW of temporary
 2932/3276 : D0                                    MOV	C,A                    ;Decimal to binary holding registers. Save character in C.
 2933/3277 : 06 F8                                 MVI	A, 370o               ;Form mask for sizing in accumulator. Now see if
 2934/3279 : A7                                    ANA	M                    ;Holding register has enough room for the conversion of
 2935/327A : 48 54 32                              JNZ	NINPUT             ;Another digit. Ignore the input if no more room.
 2936/327D : 36 45                                 MVI	L, IN_DIGIT_CC_L      ;If have room in register then set pointer to input digit
 2937/327F : CF                                    MOV	B,M                    ;Counter location. Fetch the present value.
 2938/3280 : 08                                    INR	B                    ;Increment it to account for incoming digit.
 2939/3281 : F9                                    MOV	M,B                    ;Restore updated count to storage location.
 2940/3282 : 46 35 33                              CALL	DECBIN             ;Call the DECimal to BINary conversion routine to add
 2941/3285 : 44 54 32                              JMP	NINPUT             ;In the new digit in holding registers. Continue inputting.
 2942/3288 : C8                         PERIOD:    MOV	B,A                    ;Save character code in register B
 2943/3289 : 36 46                                 MVI	L, 106o               ;Set pointer to PERIOD indicator storage location
 2944/328B : C7                                    MOV	A,M                    ;Fetch value in PERIOD indicator
 2945/328C : A0                                    ANA	A                    ;Exercise CPU flags
 2946/328D : 48 08 2A                              JNZ	NUMERR             ;If already have a period then display error message
 2947/3290 : 36 45                                 MVI	L, IN_DIGIT_CC_L      ;If not, change pointer to digit counter storage location
 2948/3292 : F8                                    MOV	M,A                    ;Clear the digit counter back to zero
 2949/3293 : 30                                    INR	L                    ;Advance pointer to PERIOD indicator
 2950/3294 : F9                                    MOV	M,B                    ;Set the PERIOD indicator
 2951/3295 : 44 54 32                              JMP	NINPUT             ;Continue processing the input character string
 2952/3298 : 46 FC 31                   FNDEXP:    CALL	GETINP             ;Get next character in Exponent
 2953/329B : 3C AB                                 CPI	253o               ;See if it is code for + sign
 2954/329D : 68 A8 32                              JZ	EXPINP             ;Jump ahead if yes.
 2955/32A0 : 3C AD                                 CPI	255o               ;If not + sign, see if minus sign
 2956/32A2 : 48 AB 32                              JNZ	NOEXPS             ;If not minus sign then jump ahead
 2957/32A5 : 36 44                                 MVI	L, 104o               ;For minus sign, set pointer to EXP SIGN indicator
 2958/32A7 : F8                                    MOV	M,A                    ;Set the EXP SIGN indicator for a minus exponent
 2959/32A8 : 46 FC 31                   EXPINP:    CALL	GETINP             ;Fetch the next character in the decimal exponent
 2960/32AB : A0                         NOEXPS:    ANA	A                    ;Exercise the CPU flags
 2961/32AC : 68 D0 32                              JZ	ENDINP             ;If character inputted was zero, then end of input string
 2962/32AF : 3C B0                                 CPI	260o               ;If not end of string, check to see
 2963/32B1 : 70 08 2A                              JM	NUMERR             ;If character represents
 2964/32B4 : 3C BA                                 CPI	272o               ;A valid decimal number (0 to 9)
 2965/32B6 : 50 08 2A                              JP	NUMERR             ;Display error message if not a valid digit at this point!
 2966/32B9 : 24 0F                                 ANI	017o               ;Else trim the ASCII code to BCD
 2967/32BB : C8                                    MOV	B,A                    ;And save in register B
 2968/32BC : 36 6F                                 MVI	L, 157o               ;Set pointer to input exponent storage location
 2969/32BE : 06 03                                 MVI	A, 003                ;Set accumulator equal to three
 2970/32C0 : BF                                    CMP	M                    ;See if any previous digit in exponent greater than three
 2971/32C1 : 70 08 2A                              JM	NUMERR             ;Display error message if yes
 2972/32C4 : D7                                    MOV	C,M                    ;Else save any previous value in register C
 2973/32C5 : C7                                    MOV	A,M                    ;And also place any previous value in accumulator
 2974/32C6 : A0                                    ANA	A                    ;Clear the carry bit with this instruction
 2975/32C7 : 12                                    RAL                    ;Single precision multiply by ten algorithm
 2976/32C8 : 12                                    RAL                    ;Two rotate lefts equals times four
 2977/32C9 : 82                                    ADD	C                    ;Adding in the digit makes total times five
 2978/32CA : 12                                    RAL                    ;Rotating left again equals times ten
 2979/32CB : 81                                    ADD	B                    ;now add in digit just inputted
 2980/32CC : F8                                    MOV	M,A                    ;Restore the value to exponent storage location
 2981/32CD : 44 A8 32                              JMP	EXPINP             ;Go get any additional exponent int)ut
 2982/32D0 : 36 43                      ENDINP:    MVI	L, 103o               ;Set pointer to mantissa SIGN indicator
 2983/32D2 : C7                                    MOV	A,M                    ;Fetch the SIGN indicator to the acclimulator
 2984/32D3 : A0                                    ANA	A                    ;Exercise the CPU flags
 2985/32D4 : 68 DE 32                              JZ	FININP             ;If SIGN indicator is zero, go finish up as nr is positive
 2986/32D7 : 36 6C                                 MVI	L, 154o               ;But, if indicator is non-zero, number is negative
 2987/32D9 : 0E 03                                 MVI	B, 003                ;Set pntr to LSW of storage registers, set precision entr
 2988/32DB : 46 6F 31                              CALL	COMPLM             ;Negate the triple-precision number in holding registers
 2989/32DE : 36 6B                      FININP:    MVI	L, 153o               ;Set pointer to input storage LS~V minus one
 2990/32E0 : A8                                    XRA	A                    ;Clear the accumulator
 2991/32E1 : F8                                    MOV	M,A                    ;Clear the LSW minus one location
 2992/32E2 : DD                                    MOV	D,H                    ;Set register D to floating point working page
 2993/32E3 : 26 53                                 MVI	E, 123o               ;Set E to address of FPACC LSW minus one
 2994/32E5 : 0E 04                                 MVI	B, 004                ;Set precision counter
 2995/32E7 : 46 12 30                              CALL	MOVEIT             ;Move number from input register to FPACC
 2996/32EA : 46 37 2F                              CALL	FPFLT              ;Now convert the binary fixed point to floating point
 2997/32ED : 36 44                                 MVI	L, 104o               ;Set pointer to Exponent SIGN indicator location
 2998/32EF : C7                                    MOV	A,M                    ;Fetch the value of the EXP SIGN indicator
 2999/32F0 : A0                                    ANA	A                    ;Exercise the CPU flags
 3000/32F1 : 36 6F                                 MVI	L, 157o               ;Reset pointer to input exponent storage location
 3001/32F3 : 68 FC 32                              JZ	POSEXP             ;If EXP SIGN indicator zero, exponent is positive
 3002/32F6 : C7                                    MOV	A,M                    ;Else, exponent is negative so must negate
 3003/32F7 : 2C FF                                 XRI	377o               ;The value in the input exponent storage location
 3004/32F9 : 04 01                                 ADI	001                ;By performing this two's complement
 3005/32FB : F8                                    MOV	M,A                    ;Restore the negated value to exponent storage location
 3006/32FC : 36 46                      POSEXP:    MVI	L, 106o               ;Set pointer to PERIOD indicator storage location
 3007/32FE : C7                                    MOV	A,M                    ;Fetch the contents of the PERIOD indicator
 3008/32FF : A0                                    ANA	A                    ;Exercise the CPU flags
 3009/3300 : 68 07 33                              JZ	EXPOK              ;If PERIOD indicator clear, no decimal point involved
 3010/3303 : 36 45                                 MVI	L, IN_DIGIT_CC_L      ;If have a decimal point, set pointer to digit counter
 3011/3305 : A8                                    XRA	A                    ;Storage location. Clear the accumulator.
 3012/3306 : 97                                    SUB	M                    ;And get a negated value of the digit counter in ACC
 3013/3307 : 36 6F                      EXPOK:     MVI	L, 157o               ;Change pointer to input exponent storage location
 3014/3309 : 87                                    ADD	M                    ;Add this value to negated digit counter value
 3015/330A : F8                                    MOV	M,A                    ;Restore new value to storage location
 3016/330B : 70 22 33                              JM	MINEXP             ;If new value is minus, skip over next subroutine
 3017/330E : 2B                                    RZ                    ;If new value is zero, no further processing required
 3018/330F :                            
 3019/330F :                                                              ;Following subroutine will multiply the floating point
 3020/330F :                                                              ;binary number stored in FPACC by ten tirnes the
 3021/330F :                                                              ;value stored in the deciinal exponent storage location.
 3022/330F :                            
 3023/330F : 36 88                      FPX10:     MVI	L, 210o               ;Set pointer to registers containing floating point
 3024/3311 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Binary representation of 10 (decimal).
 3025/3313 : 46 C6 31                              CALL	FACXOP             ;Transfer FPACC to FPOP and 10 (dec) to FPACC
 3026/3316 : 46 2D 30                              CALL	FPMULT             ;Multiply FPOP (formerly FPACC) by 10 (decimal)
 3027/3319 : 36 6F                                 MVI	L, 157o               ;Set pointer to decimal exponent storage location
 3028/331B : D7                                    MOV	C,M                    ;Fetch the exponent value
 3029/331C : 11                                    DCR	C                    ;Decrement
 3030/331D : FA                                    MOV	M,C                    ;Restore to storage
 3031/331E : 48 0F 33                              JNZ	FPX10              ;If exponent value is not zero, continue multiplication
 3032/3321 : 07                                    RET                    ;When exponent is zero can exit. Conversion completed.
 3033/3322 :                            
 3034/3322 :                                                              ;Following subroutine will multiply the floating point
 3035/3322 :                                                              ;binary number stored in PPACC by 0.1 times the value
 3036/3322 :                                                              ;(negative) stored in the decimal exponent storage location
 3037/3322 :                            
 3038/3322 :                            MINEXP:
 3039/3322 : 36 8C                      FPD10:     MVI	L, 214o               ;Set pointer to registers containing floating point
 3040/3324 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Binary representation of 0.1 (decimal).
 3041/3326 : 46 C6 31                              CALL	FACXOP             ;Transfer FPACC to FPOP and 0.1 (dec) to FPACC
 3042/3329 : 46 2D 30                              CALL	FPMULT             ;Multitply FPOP (formerly FPACC) by 0.1 (decimal)
 3043/332C : 36 6F                                 MVI	L, 157o               ;Set pointer to decimal exponent storage location
 3044/332E : CF                                    MOV	B,M                    ;Fetch the exponent value
 3045/332F : 08                                    INR	B                    ;Increment
 3046/3330 : F9                                    MOV	M,B                    ;Restore to storage
 3047/3331 : 48 22 33                              JNZ	FPD10              ;If exponent value is not zero, continue multiplication
 3048/3334 : 07                                    RET                    ;When exponent is zero can exit. Conversion completed.
 3049/3335 :                            
 3050/3335 :                                                              ;Following subroutine is used
 3051/3335 :                                                              ;to convert decimal charac-
 3052/3335 :                                                              ;ters to binary fixed point forinat
 3053/3335 :                                                              ;in a triple-precision format.
 3054/3335 :                            
 3055/3335 : 46 D6 31                   DECBIN:    CALL	SAVEHL             ;Save entry value of D, E, H and L in memory
 3056/3338 : 36 6B                                 MVI	L, 153o               ;Set pointer to temporary storage location
 3057/333A : C2                                    MOV	A,C                    ;Restore character inputted to accumulator
 3058/333B : 24 0F                                 ANI	017o               ;Trim ASCII code to BCD
 3059/333D : F8                                    MOV	M,A                    ;Store temporarily
 3060/333E : 26 68                                 MVI	E, 150o               ;Set pointer to working area LSW of multi-byte register
 3061/3340 : 36 6C                                 MVI	L, 154o               ;Set another pointer to LSW of conversion register
 3062/3342 : DD                                    MOV	D,H                    ;Make sure D set to page of working area
 3063/3343 : 0E 03                                 MVI	B, 003                ;Set precision counter
 3064/3345 : 46 12 30                              CALL	MOVEIT             ;Move original value of conversion register to working
 3065/3348 : 36 6C                                 MVI	L, 154o               ;Register. Reset pointer to LSW of conversion register.
 3066/334A : 0E 03                                 MVI	B, 003                ;Set precision counter
 3067/334C : 46 86 31                              CALL	ROTATL             ;Rotate register left, (Multiplies value by two.)
 3068/334F : 36 6C                                 MVI	L, 154o               ;Reset pointer to LSW.
 3069/3351 : 0E 03                                 MVI	B, 003                ;Set precision counter
 3070/3353 : 46 86 31                              CALL	ROTATL             ;Multiply by two again (total now times four).
 3071/3356 : 26 6C                                 MVI	E, 154o               ;Set pointer to LSW of conversion register.
 3072/3358 : 36 68                                 MVI	L, 150o               ;Set pointer to LSW of working register (original value).
 3073/335A : 0E 03                                 MVI	B, 003                ;Set precision counter.
 3074/335C : 46 5E 31                              CALL	ADDER              ;Add original value to rotated value (now times five).
 3075/335F : 36 6C                                 MVI	L, 154o               ;Reset pointer to LSW
 3076/3361 : 0E 03                                 MVI	B, 003                ;Set precision counter
 3077/3363 : 46 86 31                              CALL	ROTATL             ;Multiply by two once more (total now times ten).
 3078/3366 : 36 6A                                 MVI	L, 152o               ;Set pointer to clear working register locatiotis
 3079/3368 : A8                                    XRA	A                    ;Clear the accumulator
 3080/3369 : F8                                    MOV	M,A                    ;Clear MSW of working register
 3081/336A : 31                                    DCR	L                    ;Decrement pointer
 3082/336B : F8                                    MOV	M,A                    ;Clear next byte
 3083/336C : 36 6B                                 MVI	L, 153o               ;Set pointer to current digit storage location
 3084/336E : C7                                    MOV	A,M                    ;Fetch the current digit
 3085/336F : 36 68                                 MVI	L, 150o               ;Change pointer to LSW of working register
 3086/3371 : F8                                    MOV	M,A                    ;Deposit the current digit in LSW of working register
 3087/3372 : 26 6C                                 MVI	E, 154o               ;Set pointer to conversion register LSW
 3088/3374 : 0E 03                                 MVI	B, 003                ;Set precision counter
 3089/3376 : 46 5E 31                              CALL	ADDER              ;Add current digit to conversion register to complete
 3090/3379 : 44 E6 31                              JMP	RESTHL             ;Conversion. Exit to caller by restoring CPU registers.
 3091/337C : 2E 02                      FPOUT:     MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to working area for floating point routines
 3092/337E : 36 6F                                 MVI	L, 157o               ;Set pointer to decimal exponent storage location
 3093/3380 : 3E 00                                 MVI	M, 000                ;Initialize storage location to zero
 3094/3382 : 36 56                                 MVI	L, 126o               ;Change pointer to FPACC (number to be outputted)
 3095/3384 : C7                                    MOV	A,M                    ;And fetch MSW of FPACC
 3096/3385 : A0                                    ANA	A                    ;Test the contents of MSW of FPACC
 3097/3386 : 70 8E 33                              JM	OUTNEG             ;If most significant bit of MSW is a one, have a minus nr.
 3098/3389 : 06 A0                                 MVI	A, 240o               ;Else number is positive, set ASCII code for space for a
 3099/338B : 44 97 33                              JMP	AHEAD1             ;Positive number and go display a space
 3100/338E : 36 54                      OUTNEG:    MVI	L, 124o               ;If number in FPACC is negative must negate in order
 3101/3390 : 0E 03                                 MVI	B, 003                ;To display. Set pntr to LSW of FPACC & set prec. cntr.
 3102/3392 : 46 6F 31                              CALL	COMPLM             ;Negate the number in the FPACC to make it positive
 3103/3395 : 06 AD                                 MVI	A, 255o               ;But load ACC with ASCII code for minus sign
 3104/3397 : 46 9E 22                   AHEAD1:    CALL	ECHO               ;Call user display driver to output space or minus sign
 3105/339A : 36 48                                 MVI	L, 110o               ;Set pointer to FIXED/FLOAT indicator
 3106/339C : C7                                    MOV	A,M                    ;Fetch value of FIXED/FLOAT indicator
 3107/339D : A0                                    ANA	A                    ;Test contents of indicator. If contents are zero, calling
 3108/339E : 68 B2 33                              JZ	OUTFLT             ;Routine has directed floating point output format.
 3109/33A1 : 36 57                                 MVI	L, 127o               ;If indicator non-zero, fixed point fonnat requested if
 3110/33A3 : 06 17                                 MVI	A, 027o               ;Possible. Point to FPACC Exponent. Put 23 decimal in
 3111/33A5 : CF                                    MOV	B,M                    ;Accumulator. Fetch FPACC Exponent into register B
 3112/33A6 : 08                                    INR	B                    ;And exercise the register to test its
 3113/33A7 : 09                                    DCR	B                    ;Original contents. If FPACC Exponent is negative in
 3114/33A8 : 70 B2 33                              JM	OUTFLT             ;Value then go to floating point output forrnat. If value
 3115/33AB : 91                                    SUB	B                    ;Is positive, subtract value from 23 (decimal). If result
 3116/33AC : 70 B2 33                              JM	OUTFLT             ;Negative, number is too big to use fixed format.
 3117/33AF : 44 C0 33                              JMP	OUTFIX             ;Else, can use fixed format so skip next routine
 3118/33B2 : 36 48                      OUTFLT:    MVI	L, 110o               ;Set pointer to FIXED/FLOAT indicator.
 3119/33B4 : 3E 00                                 MVI	M, 000                ;Clear indicator to indicate floating point output format
 3120/33B6 : 06 B0                                 MVI	A, 260o               ;Load ASCII code for '0' into accumulator
 3121/33B8 : 46 9E 22                              CALL	ECHO               ;Call user display driver to output '0' as first character
 3122/33BB : 06 AE                                 MVI	A, 256o               ;Number string. Now load ASCII code for decimal point.
 3123/33BD : 46 9E 22                              CALL	ECHO               ;Call user display driver to output '.'as second character.
 3124/33C0 : 36 57                      OUTFIX:    MVI	L, 127o               ;Set pointer to FPACC Exponent
 3125/33C2 : 06 FF                                 MVI	A, 377o               ;Load accumulator with minus one
 3126/33C4 : 87                                    ADD	M                    ;Add value in FPACC Exponent
 3127/33C5 : F8                                    MOV	M,A                    ;Restore compensated exponent value
 3128/33C6 :                            
 3129/33C6 :                                                              ;Next portion of routine establishes the value for the
 3130/33C6 :                                                              ;decimal exponent that will be outputted by processing
 3131/33C6 :                                                              ;the binary exponent value in the FPACC.
 3132/33C6 :                            
 3133/33C6 : 50 E5 33                   DECEXT:    JP	DECEXD             ;If compensated exponent value is zero or positive
 3134/33C9 : 06 04                                 MVI	A, 004                ;Then go multiply FPACC by 0.1 (decimal). Else,
 3135/33CB : 87                                    ADD	M                    ;Add four to the exponent value.
 3136/33CC : 50 F7 33                              JP	DECOUT             ;If exponent now zero or positive, ready to output
 3137/33CF : 36 88                                 MVI	L, 210o               ;If exponent negative, multiply FPACC by 10 (decimal)
 3138/33D1 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set pointer to registers holding 10 (dec) in binary
 3139/33D3 : 46 C6 31                              CALL	FACXOP             ;Floating point format. Set up for multiplication.
 3140/33D6 : 46 2D 30                              CALL	FPMULT             ;Perform the multiplication. Answer in FPACC.
 3141/33D9 : 36 6F                                 MVI	L, 157o               ;Set pointer to decimal exponent storage location.
 3142/33DB : D7                                    MOV	C,M                    ;Each time the FPACC is multiplied by ten, need to
 3143/33DC : 11                                    DCR	C                    ;Decrement the value in the decinial exponent storage
 3144/33DD : FA                                    MOV	M,C                    ;Location. (This establishes decimal exponent value!)
 3145/33DE : 36 57                      DECREP:    MVI	L, 127o               ;Reset pointer to FPACC Exponent
 3146/33E0 : C7                                    MOV	A,M                    ;Fetch value in exponent
 3147/33E1 : A0                                    ANA	A                    ;Test value
 3148/33E2 : 44 C6 33                              JMP	DECEXT             ;Repeat process as required
 3149/33E5 : 36 8C                      DECEXD:    MVI	L, 214o               ;If exponent is positive, multiply FPACC by 0.1
 3150/33E7 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set pointer to registers holding 0.1 dec in binary
 3151/33E9 : 46 C6 31                              CALL	FACXOP             ;Floating point format. Set up for multipli(-ation.
 3152/33EC : 46 2D 30                              CALL	FPMULT             ;Perform the multiplication. Answer in FPACC.
 3153/33EF : 36 6F                                 MVI	L, 157o               ;Set pointer to decimal exponent storage location.
 3154/33F1 : CF                                    MOV	B,M                    ;Each time the FPACC is multiplied by one tenth, need
 3155/33F2 : 08                                    INR	B                    ;To increment the value in the decimal exponent storage
 3156/33F3 : F9                                    MOV	M,B                    ;Location. (This establishes decimal exponent value!)
 3157/33F4 : 44 DE 33                              JMP	DECREP             ;Repeat process as required
 3158/33F7 :                            
 3159/33F7 :                                                              ;The next section outputs the mantissa
 3160/33F7 :                                                              ;(or fixed point number) by converting the value remaining
 3161/33F7 :                                                              ;in the FPACC (after the decimal exponent equivalent has
 3162/33F7 :                                                              ;been extracted from the original value if required by the
 3163/33F7 :                                                              ;previous routines) to a string of decirnal digits.
 3164/33F7 : 26 74                      DECOUT:    MVI	E, 164o               ;Set pointer to LSW of output working register
 3165/33F9 : DD                                    MOV	D,H                    ;Set D to same page value as H
 3166/33FA : 36 54                                 MVI	L, 124o               ;Set pointer to LSW of FPACC
 3167/33FC : 0E 03                                 MVI	B, 003                ;Set precision counter
 3168/33FE : 46 12 30                              CALL	MOVEIT             ;Move value in FPACC to output working register
 3169/3401 : 36 77                                 MVI	L, 167o               ;Set pointer to MSW plus one of output working register
 3170/3403 : 3E 00                                 MVI	M, 000                ;Clear that location to 0
 3171/3405 : 36 74                                 MVI	L, 164o               ;Set pointer to LSW of output working register
 3172/3407 : 0E 03                                 MVI	B, 003                ;Set precision counter
 3173/3409 : 46 86 31                              CALL	ROTATL             ;Rotate register left once to compensate for sign bit
 3174/340C : 46 9A 34                              CALL	OUTX10             ;Multiply output register by 10, overflow into N4SW+ 1
 3175/340F : 36 57                      COMPEN:    MVI	L, 127o               ;Set pointer back to FPACC Exponent
 3176/3411 : CF                                    MOV	B,M                    ;Compensate for any remainder in the binary exponent
 3177/3412 : 08                                    INR	B                    ;By performing a rotate right on the output working
 3178/3413 : F9                                    MOV	M,B                    ;Register until the binary exponent becomes zero
 3179/3414 : 68 21 34                              JZ	OUTDIG             ;Go output decimal digits when this loop is finished
 3180/3417 : 36 77                                 MVI	L, 167o               ;Binary exponent compensating loop. Setpointe'r to
 3181/3419 : 0E 04                                 MVI	B, 004                ;Working register MSW+L. Set precision counter.
 3182/341B : 46 90 31                              CALL	ROTATR             ;Rotate working register to the right.
 3183/341E : 44 0F 34                              JMP	COMPEN             ;Repeat loop as required.
 3184/3421 : 36 47                      OUTDIG:    MVI	L, 107o               ;Set pointer to output digit counter storage location
 3185/3423 : 3E 07                                 MVI	M, 007                ;Initialize to value of seven
 3186/3425 : 36 77                                 MVI	L, 167o               ;Change pointer to output working register MSW+L
 3187/3427 : C7                                    MOV	A,M                    ;Fetch MSW+L byte containing BCD of digit to be
 3188/3428 : A0                                    ANA	A                    ;Displayed. Test the contents of this byte.
 3189/3429 : 68 7C 34                              JZ	ZERODG             ;If zero jump to ZERODG routine.
 3190/342C : 36 77                      OUTDGS:    MVI	L, 167o               ;Reset pointer to working register MSW+L
 3191/342E : C7                                    MOV	A,M                    ;Fetch BCD of digit to be outputted
 3192/342F : A0                                    ANA	A                    ;Exercise CPU flags
 3193/3430 : 48 4C 34                              JNZ	OUTDGX             ;If not zero, go display the digit
 3194/3433 : 36 48                                 MVI	L, 110o               ;If zero, change pointer to FIXED/FLOAT indicator
 3195/3435 : C7                                    MOV	A,M                    ;Fetch the indicator into the accumulator
 3196/3436 : A0                                    ANA	A                    ;Test value of indicator
 3197/3437 : 68 4B 34                              JZ	OUTZER             ;If in floating point mode, go display the digit
 3198/343A : 36 6F                                 MVI	L, 157o               ;Else change pointer to decimal exponent storage
 3199/343C : D7                                    MOV	C,M                    ;Location, which, for fixed point, will have a positive
 3200/343D : 11                                    DCR	C                    ;Value for all digits before the decimal point. Decrement
 3201/343E : 10                                    INR	C                    ;And increment to exercise flags. See if count is positive.
 3202/343F : 50 4B 34                              JP	OUTZER             ;If positive, must display any zero digit.
 3203/3442 : 36 76                                 MVI	L, 166o               ;If not, change pointer to MSW of working register
 3204/3444 : C7                                    MOV	A,M                    ;And test to see if any significant digits coming up
 3205/3445 : 24 E0                                 ANI	340o               ;By forming a mask and testing for presence of bits
 3206/3447 : 48 4B 34                              JNZ	OUTZER             ;If more significant digits coming up soon, display the
 3207/344A : 07                                    RET                    ;Zero digit. Else, exit to calling routine. Finished.
 3208/344B : A8                         OUTZER:    XRA	A                    ;Clear the accumulator to restore zero digit value
 3209/344C : 04 B0                      OUTDGX:    ADI	260o               ;Add 260 (octal) to BCD code in ACC to form ASCII
 3210/344E : 46 9E 22                              CALL	ECHO               ;Code and call the user's display driver subroutine
 3211/3451 : 36 48                      DECRDG:    MVI	L, 110o               ;Set pointer to FIXED/FLOAT indicator storage
 3212/3453 : C7                                    MOV	A,M                    ;Fetch the indicator to the accumulator
 3213/3454 : A0                                    ANA	A                    ;Exercise the CPU flags
 3214/3455 : 48 66 34                              JNZ	CKDECP             ;If indicator non-zero, doing fixed point output
 3215/3458 : 36 47                                 MVI	L, 107o               ;Else, get output digit counter
 3216/345A : D7                                    MOV	C,M
 3217/345B : 11                                    DCR	C                    ;Decrement the digit counter & restore to storage
 3218/345C : FA                                    MOV	M,C
 3219/345D : 68 C7 34                              JZ	EXPOUT             ;When digit counter is zero, go take care of exponent
 3220/3460 : 46 9A 34                   PUSHIT:    CALL	OUTX10             ;Else push next BCD digit out of working register
 3221/3463 : 44 2C 34                              JMP	OUTDGS             ;And continue the outputting process
 3222/3466 : 36 6F                      CKDECP:    MVI	L, 157o               ;For fixed point output, decimal exponent serves as
 3223/3468 : D7                                    MOV	C,M                    ;Counter for number of digits before decimal point
 3224/3469 : 11                                    DCR	C                    ;Fetch the counter and decrement it to account for
 3225/346A : FA                                    MOV	M,C                    ;Current digit being processed. Restore to storage.
 3226/346B : 48 73 34                              JNZ	NODECP             ;If count does not go to zero, jump ahead.
 3227/346E : 06 AE                                 MVI	A, 256o               ;When count reaches zero, load ASCII code for period
 3228/3470 : 46 9E 22                              CALL	ECHO               ;And call user's display driver to display decimal point
 3229/3473 : 36 47                      NODECP:    MVI	L, 107o               ;Set pointer to output digit counter storage location
 3230/3475 : D7                                    MOV	C,M                    ;Fetch the digit counter
 3231/3476 : 11                                    DCR	C                    ;Decrement the value
 3232/3477 : FA                                    MOV	M,C                    ;Restore to storage
 3233/3478 : 2B                                    RZ                    ;If counter reaches zero, exit to caller. Finished.
 3234/3479 : 44 60 34                              JMP	PUSHIT             ;Else continue to output the number.
 3235/347C : 36 6F                      ZERODG:    MVI	L, 157o               ;If first digit of floating point number is a zero, set
 3236/347E : D7                                    MOV	C,M                    ;Pointer to decimal exponent storage location.
 3237/347F : 11                                    DCR	C                    ;Decrement the value to compensate for skipping
 3238/3480 : FA                                    MOV	M,C                    ;Display of first digit. Restore to storage.
 3239/3481 : 36 76                                 MVI	L, 166o               ;Change pointer to MSW of output working register
 3240/3483 : C7                                    MOV	A,M                    ;Fetch MSW of output working register
 3241/3484 : A0                                    ANA	A                    ;Test the contents
 3242/3485 : 48 51 34                              JNZ	DECRDG             ;If non-zero, continue outputting
 3243/3488 : 31                                    DCR	L                    ;Else decrement pointer to next byte in working register
 3244/3489 : C7                                    MOV	A,M                    ;Fetch its contents
 3245/348A : A0                                    ANA	A                    ;Test
 3246/348B : 48 51 34                              JNZ	DECRDG             ;If non-zero, continue outputting
 3247/348E : 31                                    DCR	L                    ;Else decrement pointer to LSW of working register
 3248/348F : C7                                    MOV	A,M                    ;Fetch its contents
 3249/3490 : A0                                    ANA	A                    ;Test
 3250/3491 : 48 51 34                              JNZ	DECRDG             ;If non-zero, continue outputting
 3251/3494 : 36 6F                                 MVI	L, 157o               ;If decimal mantissa is zero, set pointer to decirnal
 3252/3496 : F8                                    MOV	M,A                    ;Exponent storage and clear it
 3253/3497 : 44 51 34                              JMP	DECRDG             ;Finish outputting
 3254/349A :                            
 3255/349A :                                                              ;Following routine multiplies the binary number in the
 3256/349A :                                                              ;output working register by ten to push the most signifi-
 3257/349A :                                                              ;cant digit out to the MSW+L byte.
 3258/349A :                            
 3259/349A : 36 77                      OUTX10:    MVI	L, 167o               ;Set pointer to work ing register M SW+ 1
 3260/349C : 3E 00                                 MVI	M, 000                ;Clear it in preparation for receiving next digit pushed
 3261/349E : 36 74                                 MVI	L, 164o               ;Into it. Change pointer to working register LSW.
 3262/34A0 : DD                                    MOV	D,H                    ;Set up register D to same page as H.
 3263/34A1 : 26 70                                 MVI	E, 160o               ;Set second pointer to LSW of second working register
 3264/34A3 : 0E 04                                 MVI	B, 004                ;Set precision counter
 3265/34A5 : 46 12 30                              CALL	MOVEIT             ;Move first working register into second
 3266/34A8 : 36 74                                 MVI	L, 164o               ;Reset pointer to LSW of first working register
 3267/34AA : 0E 04                                 MVI	B, 004                ;Set precision counter
 3268/34AC : 46 86 31                              CALL	ROTATL             ;Rotate contents of first working register left (X 2)
 3269/34AF : 36 74                                 MVI	L, 164o               ;Reset pointer to LSW
 3270/34B1 : 0E 04                                 MVI	B, 004                ;Reset precision counter
 3271/34B3 : 46 86 31                              CALL	ROTATL             ;Rotate contents left again (X 4)
 3272/34B6 : 36 70                                 MVI	L, 160o               ;Set pointer to LSW of original value in 2'nd register
 3273/34B8 : 26 74                                 MVI	E, 164o               ;Set pointer to LSW of rotated value
 3274/34BA : 0E 04                                 MVI	B, 004                ;Set precision counter
 3275/34BC : 46 5E 31                              CALL	ADDER              ;Add rotated value to original value (X 5)
 3276/34BF : 36 74                                 MVI	L, 164o               ;Reset pointer to LSW of first working register
 3277/34C1 : 0E 04                                 MVI	B, 004                ;Set precision counter
 3278/34C3 : 46 86 31                              CALL	ROTATL             ;Rotate contents left again (X 10)
 3279/34C6 : 07                                    RET                    ;Exit to calling routine
 3280/34C7 :                            
 3281/34C7 :                                                              ;The final group of routines in the floating point output
 3282/34C7 :                                                              ;section take care of outputting the decimal exponent
 3283/34C7 :                                                              ;portion of floating point numbers.
 3284/34C7 :                            
 3285/34C7 : 36 6F                      EXPOUT:    MVI	L, 157o               ;Set pointer to decimal exponent storage location
 3286/34C9 : C7                                    MOV	A,M                    ;Fetch value to the accumulator
 3287/34CA : A0                                    ANA	A                    ;Test the value
 3288/34CB : 2B                                    RZ                    ;If zero, then no exponent portion. Exit to CALLler.
 3289/34CC : 06 C5                                 MVI	A, 305o               ;Else, load ACC with ASCII code for letter E.
 3290/34CE : 46 9E 22                              CALL	ECHO               ;Display E for Exponent via user's display driver rtn
 3291/34D1 : C7                                    MOV	A,M                    ;Get decimal exponent value back into ACC
 3292/34D2 : A0                                    ANA	A                    ;Test again
 3293/34D3 : 70 DB 34                              JM	EXOUTN             ;If value is negative, skip ahead
 3294/34D6 : 06 AB                                 MVI	A, 253o               ;If positive, load ASCII code for + sign
 3295/34D8 : 44 E2 34                              JMP	AHEAD2             ;Jump to display the + sign
 3296/34DB : 2C FF                      EXOUTN:    XRI	377o               ;When decimal exponent is negative, must negate
 3297/34DD : 04 01                                 ADI	001                ;Value for display purposes. Perform two's complement
 3298/34DF : F8                                    MOV	M,A                    ;And restore the negated value to storage location
 3299/34E0 : 06 AD                                 MVI	A, 255o               ;Load ASCII code for minus sign
 3300/34E2 : 46 9E 22                   AHEAD2:    CALL	ECHO               ;Display the ASCII character in ACC
 3301/34E5 : 0E 00                                 MVI	B, 000                ;Clear register B
 3302/34E7 : C7                                    MOV	A,M                    ;Fetch the decimal exponent value back into ACC
 3303/34E8 : 14 0A                      SUB12:     SUI	012o               ;Subtract 10 (decimal) from value in ACC
 3304/34EA : 70 F2 34                              JM	TOMUCH             ;Break out of loop when accumulator goes negative
 3305/34ED : F8                                    MOV	M,A                    ;Else restore value to storage location
 3306/34EE : 08                                    INR	B                    ;Increment register B as a counter
 3307/34EF : 44 E8 34                              JMP	SUB12              ;Repeat loop to form tens value of decimal exponent
 3308/34F2 : 06 B0                      TOMUCH:    MVI	A, 260o               ;Load base ASCII value for digit into the accumulator
 3309/34F4 : 81                                    ADD	B                    ;Add to the count in B to forin tens digit of decimal
 3310/34F5 : 46 9E 22                              CALL	ECHO               ;Exponent. Display via user's driver subroutine
 3311/34F8 : C7                                    MOV	A,M                    ;Fetch remainder of decimal exponent value
 3312/34F9 : 04 B0                                 ADI	260o               ;Add in ASCII base value to form final digit
 3313/34FB : 46 9E 22                              CALL	ECHO               ;Display second digit of decirnal exponent
 3314/34FE : 07                                    RET                    ;Finished outputting. Return to caller.
 3315/34FF :                            ;;; The above RETURN SHOULD BE AT 25 367 15f7h
 3316/34FF :                            
 3317/34FF :                            ;;; NOW OPEN AREA UP TO 26 000 CAN BE USED FOR PATCHING...
 3318/34FF :                            
 3319/34FF :                            	;; THERE ARE NOW ADDRESSES AT START OF PAGE 30, NOT ASSIGNED;
 3320/34FF :                            
 3321/34FF :                            ;          ORG 	180bh	;030#013
 3322/34FF : 36 64                      NEXT:      MVI	L, 144o               ;Load L with start of AUX SYMBOL BUFFER
 3323/3501 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of AUX SYMBOL BUFFER
 3324/3503 : 3E 00                                 MVI	M, 000                ;Initialize AUX SYMBOL BUFFER by clearing first byte
 3325/3505 : 36 82                                 MVI	L, 202o               ;Change L to address of SCAN pointer
 3326/3507 : CF                                    MOV	B,M                    ;Fetch pointer value to CPU register B
 3327/3508 : 08                                    INR	B                    ;Add one to the current pointer value
 3328/3509 : 36 81                                 MVI	L, 201o               ;Load L with address of NEXT pointer storage location
 3329/350B : F9                                    MOV	M,B                    ;Place the updated SCAN pointer as the NEXT pointer
 3330/350C : 36 81                      NEXT1:     MVI	L, 201o               ;Reset L to address of NEXT pointer storage location
 3331/350E : 46 BC 21                              CALL	GETCHR             ;Fetch the character pointed to by the NEXT pointer
 3332/3511 : 68 19 35                              JZ	NEXT2              ;If the character is a space, ignore it
 3333/3514 : 36 64                                 MVI	L, 144o               ;Else, load L with start of AUX SYMBOL BUFFER
 3334/3516 : 46 E8 21                              CALL	CONCT1             ;Concatenate the character onto the AUX SYMBOL BF
 3335/3519 : 36 81                      NEXT2:     MVI	L, 201o               ;Reset L to address of NEXT pointer storage location
 3336/351B : 46 1F 22                              CALL	LOOP               ;Advance the NEXT pointer and see if end of line
 3337/351E : 48 0C 35                              JNZ	NEXT1              ;Fetch next character in line if not end of line
 3338/3521 : 36 64                                 MVI	L, 144o               ;When reach end of line, should have variable name
 3339/3523 : C7                                    MOV	A,M                    ;In the AUX SYMBOL BUFFER. Fetch the (cc) for
 3340/3524 : 3C 01                                 CPI	001                ;The buffer and see if variable name is just one letter
 3341/3526 : 48 2D 35                              JNZ	NEXT3              ;If more than one proceed directly to look for name
 3342/3529 : 36 66                                 MVI	L, 146o               ;In FOR/NEXT STACK. If have just a one letter name
 3343/352B : 3E 00                                 MVI	M, 000                ;Then set second character in buffer to zero
 3344/352D : 36 85                      NEXT3:     MVI	L, 205o               ;Load L with address of FOR/NEXT STACK pointer
 3345/352F : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to page of FOR/NEXT STACK pointer
 3346/3531 : C7                                    MOV	A,M                    ;Fetch the FOR/NEXT STACK pointer value to ACC
 3347/3532 : 02                                    RLC                    ;Rotate value left to multiply by two. Then rotate it
 3348/3533 : 02                                    RLC                    ;Left again to multiply by four. Add base address plus
 3349/3534 : 04 5E                                 ADI	136o               ;Two to form pointer to variable name in top of stack
 3350/3536 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to page of FOR/NEXT STACK
 3351/3538 : F0                                    MOV	L,A                    ;Move pointer value from ACC to CPU register L
 3352/3539 : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Set register D to page of AUX SYMBOL BUFFER
 3353/353B : 26 65                                 MVI	E, 145o               ;Set register E to first character in the buffer
 3354/353D : 0E 02                                 MVI	B, 002                ;Set B to serve as a character counter
 3355/353F : 46 14 22                              CALL	STRCPC             ;See if variable name in the NEXT statement same as
 3356/3542 : 68 4C 35                              JZ	NEXT4              ;That stored in the top of the FOR/NEXT STACK
 3357/3545 : 06 C6                      FORNXT:    MVI	A, 306o               ;Load ACC with ASCII code for letter F
 3358/3547 : 16 CE                                 MVI	C, 316o               ;Load register C with ASCII code for letter N
 3359/3549 : 44 B2 21                              JMP	ERROR              ;Display For/Next (FN) error message if required
 3360/354C : 36 F0                      NEXT4:     MVI	L, 360o               ;Load L with address of user program line pointer
 3361/354E : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of user pgm line pntr storage loc.
 3362/3550 : DF                                    MOV	D,M                    ;Fetch the page portion of the line pointer into D
 3363/3551 : 30                                    INR	L                    ;Advance the memory pointer
 3364/3552 : E7                                    MOV	E,M                    ;Fetch the low portion of the line pointer into E
 3365/3553 : 30                                    INR	L                    ;Advance pntr to AUXILIARY LINE POINTER storage
 3366/3554 : FB                                    MOV	M,D                    ;Location and store value of line pointer there too (page)
 3367/3555 : 30                                    INR	L                    ;Advance pointer to second byte of AUXILIARY line
 3368/3556 : FC                                    MOV	M,E                    ;Pointer and store value of line pointer (low portion)
 3369/3557 : 36 85                                 MVI	L, 205o               ;Load L with address of FOR/NEXT STACK pointer
 3370/3559 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to page of FOR/NEXT STACK pointer
 3371/355B : C7                                    MOV	A,M                    ;Fetch the FOR/NEXT STACK pointer value to ACC
 3372/355C : 02                                    RLC                    ;Rotate value left to multiply by two. Then rotate it
 3373/355D : 02                                    RLC                    ;Left again to multiply by four. Add base address to
 3374/355E : 04 5C                                 ADI	134o               ;Form pointer to top of FOR/NEXT STACK and place
 3375/3560 : F0                                    MOV	L,A                    ;The pointer value into CPU register L. Fetch the page
 3376/3561 : DF                                    MOV	D,M                    ;Address of the associated FOR statement line pointer
 3377/3562 : 30                                    INR	L                    ;Into register D. Advance the pointer and fetch the low
 3378/3563 : E7                                    MOV	E,M                    ;Address value into register E. Prepare to change user
 3379/3564 : 36 F0                                 MVI	L, 360o               ;Program line pointer to the FOR statement line by
 3380/3566 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Setting H & L to the user pgrn line pntr storage loc.
 3381/3568 : FB                                    MOV	M,D                    ;Place the page value in the pointer storage location
 3382/3569 : 30                                    INR	L                    ;Advance the memory pointer
 3383/356A : FC                                    MOV	M,E                    ;Place the low value in the pointer storage location
 3384/356B : EB                                    MOV	H,D                    ;Now set up H and L to point to the start of the
 3385/356C : F4                                    MOV	L,E                    ;Associated FOR statement line in the user pgm buffer
 3386/356D : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Change D to point to the line input buffer
 3387/356F : 26 00                                 MVI	E, 000                ;And set L to the gtart of the line input buffer
 3388/3571 : 46 2B 29                              CALL	MOVEC              ;Move the associated FOR statement line into the input
 3389/3574 : 36 D5                                 MVI	L, 325o               ;Line buffer. Set L to point to start of TO string which is
 3390/3576 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Stored in a text strings storage area on this page
 3391/3578 : 46 15 2A                              CALL	INSTR              ;Search the statement line for the occurrence of TO
 3392/357B : C4                                    MOV	A,E                    ;Register E will be zero if TO not found. Move E to ACC
 3393/357C : A0                                    ANA	A                    ;To make a test. If TO found then proceed to set up for
 3394/357D : 68 45 35                              JZ	FORNXT             ;Evaluation. If TO not found, then have error condition.
 3395/3580 : 04 02                                 ADI	002                ;Advance the pointer over the characters in TO string
 3396/3582 : 36 BE                                 MVI	L, 276o               ;Change L to point to EVAL pointer storage location
 3397/3584 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of EVAL pointer. Set up the starting
 3398/3586 : F8                                    MOV	M,A                    ;Position for the EVAL subroutine (after TO string)
 3399/3587 : 36 D8                                 MVI	L, 330o               ;Set L to point to start of STEP string which is stored
 3400/3589 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** In text stxings storage area on this page. Search the
 3401/358B : 46 15 2A                              CALL	INSTR              ;Statement line for the occurrence of STEP
 3402/358E : C4                                    MOV	A,E                    ;Register E will be zero if STEP not found. Move E to
 3403/358F : A0                                    ANA	A                    ;The accumulator to make a test. If STEP found must
 3404/3590 : 48 B4 35                              JNZ	NEXT5              ;Evaluate expression after STEP to get STEP SIZE.
 3405/3593 : 36 04                                 MVI	L, 004                ;Else, have an IMPLIED STEP SIZE of 1.0. Set pointer
 3406/3595 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** To start of storage area for 1.0 in floating point
 3407/3597 : 46 AB 31                              CALL	FLOAD              ;Format and call subroutine to load FPACC with 1.0
 3408/359A : 36 C4                                 MVI	L, 304o               ;Set L to start of FOR/NEXT STEP SIZE storage loc.
 3409/359C : 46 B4 31                              CALL	FSTORE             ;Store the value 1.0 in the F/N STEP SIZE registers
 3410/359F : 36 00                                 MVI	L, 000                ;Change L to the start of the input line buffer
 3411/35A1 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to the page of the input line buffer
 3412/35A3 : CF                                    MOV	B,M                    ;Fetch the (cc) into CPU register B (length of FOR line)
 3413/35A4 : 36 BF                                 MVI	L, 277o               ;Change L to EVAL FINISH pointer stomge location
 3414/35A6 : F9                                    MOV	M,B                    ;Set the EVAL FINISH pointer to the end of the line
 3415/35A7 : 46 B0 22                              CALL	EVAL               ;Evaluate the LIMIT expression to obtain FOR LIMIT
 3416/35AA : 36 C8                                 MVI	L, 310o               ;Load L with address of start of F/N LIMIT registers
 3417/35AC : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with page of FOR/NEXT LIMIT registers
 3418/35AE : 46 B4 31                              CALL	FSTORE  ;MGA 3/31/12 no lab here Store the FOR/NEXT LIMIT value
 3419/35B1 : 44 DD 35                              JMP	NEXT6              ;Since have IMPLIED STEP jump ahead
 3420/35B4 : 21                         NEXT5:     DCR	E  ;MGA 3/21/12 lab here When have STEP directive, subtract one from pointer
 3421/35B5 : 36 BF                                 MVI	L, 277o               ;To get to character before S in STEP. Save this value in
 3422/35B7 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** The EVAL FINISH pointer stomge location to serve
 3423/35B9 : FC                                    MOV	M,E                    ;As evaluation end location when obtaining TO Iiinit
 3424/35BA : 46 B0 22                              CALL	EVAL               ;Evaluate the LIMIT expression to obtain FOR LIMIT
 3425/35BD : 36 C8                                 MVI	L, 310o               ;Load L with address of start of FIN LIMIT registers
 3426/35BF : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with page of FORINEXT LIMIT registers
 3427/35C1 : 46 B4 31                              CALL	FSTORE             ;Store the FOR/NEXT LIMIT value
 3428/35C4 : 36 BF                                 MVI	L, 277o               ;Reset L to EVAL FINISH pointer storage location
 3429/35C6 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of EVAL FINISH pointer storage loc.
 3430/35C8 : C7                                    MOV	A,M                    ;Fetch the pointer value (character before S in STEP)
 3431/35C9 : 04 05                                 ADI	005                ;Add five to change pointer to character after P in STEP
 3432/35CB : 31                                    DCR	L                    ;Decrement L to point to EVAL (start) pointer
 3433/35CC : F8                                    MOV	M,A                    ;Set up the starting position for the EVAL subroutine
 3434/35CD : 36 00                                 MVI	L, 000                ; Load L with starting address of the line input buffer
 3435/35CF : CF                                    MOV	B,M                    ;Fetch the (cc) for the line input buffer (line length)
 3436/35D0 : 36 BF                                 MVI	L, 277o               ;Change L to the EVAL FINISH storage location
 3437/35D2 : F9                                    MOV	M,B                    ;Set the EVAL FINISH pointer
 3438/35D3 : 46 B0 22                              CALL	EVAL               ;Evaluate the STEP SIZE expression
 3439/35D6 : 36 C4                                 MVI	L, 304o               ;Load L with address of start of F/N STEP registers
 3440/35D8 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of FIN STEP registers
 3441/35DA : 46 B4 31                              CALL	FSTORE             ;Store the FOR/NEXT STEP SIZE value
 3442/35DD : 36 64                      NEXT6:     MVI	L, 144o               ;Load L with address of AUX SYMBOL BUFFER
 3443/35DF : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of the AUX SYMBOL BUFFER
 3444/35E1 : 3E 00                                 MVI	M, 000                ;Initialize AUX SUMBOL BUFFER with a zero byte
 3445/35E3 : 36 1C                                 MVI	L, 034o               ;Set L to start of FOR string which is stored in the
 3446/35E5 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** KEYWORD look-up table on this page
 3447/35E7 : 46 15 2A                              CALL	INSTR              ;Search the statement line for the FOR directive
 3448/35EA : C4                                    MOV	A,E                    ;Register E will be zero if FOR not found. Move E to
 3449/35EB : A0                                    ANA	A                    ;ACC and -make test to see if FOR directive located
 3450/35EC : 36 82                                 MVI	L, 202o               ;Load L with address of SCAN pointer
 3451/35EE : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of SCAN pointer
 3452/35F0 : F8                                    MOV	M,A                    ;Set up pointer to occurrence of FOR directive in line
 3453/35F1 : 68 45 35                              JZ	FORNXT             ;If FOR not found, have an error condition
 3454/35F4 : 04 03                                 ADI	003                ;If have FOR, add three to advance pointer over FOR
 3455/35F6 : 36 83                                 MVI	L, 203o               ;Set L to point to F/N pointer storage location
 3456/35F8 : F8                                    MOV	M,A                    ;Set F/N pointer to character after FOR directive
 3457/35F9 : 36 83                      NEXT7:     MVI	L, 203o               ;Set L to point to FIN pointer storage location
 3458/35FB : 46 BC 21                              CALL	GETCHR             ;Fetch a character from position pointed to by FIN pntr
 3459/35FE : 68 0B 36                              JZ	NEXT8              ;If character is a space, ignore it
 3460/3601 : 3C BD                                 CPI	275o               ;Else, test to see if character is "=" sign
 3461/3603 : 68 16 36                              JZ	NEXT9              ;If yes, have picked up variable name, jump ahead
 3462/3606 : 36 64                                 MVI	L, 144o               ;If not, set L to the start of the AUX SYMBOL BUFFER
 3463/3608 : 46 E8 21                              CALL	CONCT1             ;And store the character in the AUX SYMBOL BUFFER
 3464/360B : 36 83                      NEXT8:     MVI	L, 203o               ;Load L with address of the F/N pointer
 3465/360D : 46 1F 22                              CALL	LOOP               ;Increment the pointer and see if end of the line
 3466/3610 : 48 F9 35                              JNZ	NEXT7              ;If not, continue fetching characters
 3467/3613 : 44 45 35                              JMP	FORNXT             ;If end of line before "=" sign then have error condx
 3468/3616 : 36 82                      NEXT9:     MVI	L, 202o               ;Load L with address of SCAN pointer
 3469/3618 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of SCAN pointer
 3470/361A : C7                                    MOV	A,M                    ;Fetch pointer value to ACC (points to start of FOR
 3471/361B : 04 03                                 ADI	003                ;Directive) and add three to move pointer over FOR
 3472/361D : 36 BE                                 MVI	L, 276o               ;Directive. Change L to EVAL pointer storage location
 3473/361F : F8                                    MOV	M,A                    ;Set EVAL pointer to character after FOR in line
 3474/3620 : 36 83                                 MVI	L, 203o               ;Load L with address of FIN pointer storage location
 3475/3622 : CF                                    MOV	B,M                    ;Fetch pointer to register B (points to "=" sign) and
 3476/3623 : 09                                    DCR	B                    ;Decrement the pointer (to character before "=" sign)
 3477/3624 : 36 BF                                 MVI	L, 277o               ;Load L with address of EVAL FINISH pointer
 3478/3626 : F9                                    MOV	M,B                    ;Set EVAL FINISH pointer
 3479/3627 : 46 B0 22                              CALL	EVAL               ;Call subroutine to obtain current value of the variable
 3480/362A : 36 C4                                 MVI	L, 304o               ;Load L with address of start of F/N STEP registers
 3481/362C : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of F/N STEP registers
 3482/362E : 46 C6 31                              CALL	FACXOP             ;Call subroutine to set up FP registers for addition
 3483/3631 : 46 8C 2F                              CALL	FPADD              ;Add FIN STEP size to current VARIABLE value
 3484/3634 : 36 CC                                 MVI	L, 314o               ;Load L with address of FIN TEMP storage registers
 3485/3636 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;**Set H to page of FIN TEMP storage registers
 3486/3638 : 46 B4 31                              CALL	FSTORE             ;Save the result of the addition in F/N TEMP registers
 3487/363B : 36 C8                                 MVI	L, 310o               ;Load L with starting address of F/N LIMIT registers
 3488/363D : 46 C6 31                              CALL	FACXOP             ;Call subroutine to set up FP registers for subtraction
 3489/3640 : 46 21 30                              CALL	FPSUB              ;Subtract F/N LIMIT value from VARIABLE value
 3490/3643 : 36 C6                                 MVI	L, 306o               ;Set pointer to MSW of F/N STEP registers
 3491/3645 : C7                                    MOV	A,M                    ;Fetch this value into the ACC
 3492/3646 : A0                                    ANA	A                    ;Test to see if STEP value might be zero
 3493/3647 : 36 56                                 MVI	L, 126o               ;Load L with address of MSW of FPACC
 3494/3649 : C7                                    MOV	A,M                    ;Fetch this value into the ACC
 3495/364A : 68 45 35                              JZ	FORNXT             ;If STEP size was zero, then endless loop, an error condx
 3496/364D : 70 6C 36                              JM	NEXT11             ;If STEP size less than zero make alternate test on limit
 3497/3650 : A0                                    ANA	A                    ;Test the contents of the MSW of the FPACC
 3498/3651 : 70 73 36                              JM	NEXT12             ;Continue FORINEXT loop if current variable value is
 3499/3654 : 68 73 36                              JZ	NEXT12             ;Less than or equal to the F/N LIMIT value
 3500/3657 : 36 F3                      NEXT10:    MVI	L, 363o               ;If out of LIMIT range, load L with address of the AUX
 3501/3659 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** PGM LINE pointer. (Contains pointer to the NEXT
 3502/365B : E7                                    MOV	E,M                    ;Statement line that initiated this routine.) Fetch the
 3503/365C : 31                                    DCR	L                    ;Low part of the address into E, decrement the memory
 3504/365D : DF                                    MOV	D,M                    ;And get the page part of the address into CPU register
 3505/365E : 31                                    DCR	L                    ;Decrement memory pointer to the low portion of the
 3506/365F : FC                                    MOV	M,E                    ;User pgm buffer line pointer (regular pointer) and set it
 3507/3660 : 31                                    DCR	L                    ;With the value from the AUX line pntr, decrement the
 3508/3661 : FB                                    MOV	M,D                    ;Pointer and do the same for the page portion
 3509/3662 : 36 85                                 MVI	L, 205o               ;Set L to address of FOR/NEXT STACK pointer
 3510/3664 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to page of FOR/NEXT STACK pointer
 3511/3666 : CF                                    MOV	B,M                    ;Fetch and decrement the
 3512/3667 : 09                                    DCR	B                    ;FOR/NEXT STACK pointer value
 3513/3668 : F9                                    MOV	M,B                    ;To perform effective popping operation
 3514/3669 : 44 59 2A                              JMP	NXTLIN             ;Statement line after NEXT statement is done next
 3515/366C : A0                         NEXT11:    ANA	A                    ;When F/N STEP is negative, reverse test so that if the
 3516/366D : 50 73 36                              JP	NEXT12             ;Variable value is greater than or equal to the F/N LIMIT
 3517/3670 : 44 57 36                              JMP	NEXT10             ;The FOR/NEXT loop continues. Else it is finished.
 3518/3673 : 36 CC                      NEXT12:    MVI	L, 314o               ;Load L with address of FIN TEMP storage registers
 3519/3675 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to FIN TEMP storage registers page
 3520/3677 : 46 AB 31                              CALL	FLOAD              ;Transfer the updated variable value to the FPACC
 3521/367A : 46 C6 27                              CALL	RESTSY             ;Restore the variable name and value
 3522/367D : 46 49 27                              CALL	STOSYM             ;In the VARIABLES table. Exit routine so that
 3523/3680 : 44 59 2A                              JMP	NXTLIN             ;Statement line after FOR statement is done next
 3524/3683 :                            
 3525/3683 :                            ;;; The label BACKSP SHOULD BE AT 31 217 198fh
 3526/3683 :                            
 3527/3683 : 06 8D                      BACKSP:    MVI	A, 215o               ;Load ASCII code for carriage-return into the ACC
 3528/3685 : 46 9E 22                              CALL	ECHO               ;Display the carriage-return
 3529/3688 : 46 9E 22                              CALL	ECHO               ;Repeat to provide extra time if TTY
 3530/368B : 36 23                                 MVI	L, 043o               ;Load L with address of COLUMN COUNTER
 3531/368D : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of COLUMN COUNTER
 3532/368F : 3E 01                                 MVI	M, 001                ;Set COLUMN COUNTER to first column
 3533/3691 : 36 54                                 MVI	L, 124o               ;Set L to address containing desired TAB position
 3534/3693 : C7                                    MOV	A,M                    ;Fetch the desired TAB position value
 3535/3694 : A0                                    ANA	A                    ;Test to see if it is
 3536/3695 : 33                                    RM                    ;Negative or zero
 3537/3696 : 2B                                    RZ                    ;In which case return to caller
 3538/3697 : 44 2E 27                              JMP	TAB1               ;Else, proceed to perform the TAB operation.
 3539/369A :                            
 3540/369A :                            	
 3541/369A :                            ;;; The label FOR5 SHOULD START AT 31 246 19a6h
 3542/369A :                            	
 3543/369A : 36 85                      FOR5:      MVI	L, 205o               ;Load L with address of the FOR/NEXT STACK pointer
 3544/369C : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Load H with page of the FOR/NEXT STACK pntr
 3545/369E : C7                                    MOV	A,M                    ;Fetch the stack pointer to the ACC.
 3546/369F : 02                                    RLC                    ;Rotate it left to multiply by two, then rotate it again to
 3547/36A0 : 02                                    RLC                    ;Multiply by four. Add this value to the base address
 3548/36A1 : 04 5E                                 ADI	136o               ;Plus two of the base address to point to the next part of
 3549/36A3 : E0                                    MOV	E,A                    ;The FOR/NEXT STACK. Place this value in register E.
 3550/36A4 : DD                                    MOV	D,H                    ;Set D to the FORINEXT STACK area page.
 3551/36A5 : 36 65                                 MVI	L, 145o               ;Load L with the address of the first character in the
 3552/36A7 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** AUX SYMBOL BUFFER and set up H to this page.
 3553/36A9 : 0E 02                                 MVI	B, 002                ;Set up register B as a number of bytes to move counter.
 3554/36AB : 46 12 30                              CALL	MOVEIT             ;Move the variable name into the FOR/NEXT STACK.
 3555/36AE : 46 49 27                              CALL	STOSYM             ;Store initial variable value in the VARIABLES TABLE.
 3556/36B1 : 44 59 2A                              JMP	NXTLIN             ;Continue with next line in user program buffer.
 3557/36B4 :                            
 3558/36B4 :                            
 3559/36B4 :                            ;;; The label PARSEP SHOULD START AT 31 300 19c0h
 3560/36B4 : 36 7E                      PARSEP:    MVI	L, 176o               ;Load L with PARSER TOKEN storage location. Set
 3561/36B6 : 3E 00                                 MVI	M, 000                ;The value indicating end of expression. Call the
 3562/36B8 : 46 F0 23                              CALL	PARSER             ;PARSER subroutine for final time for the expression.
 3563/36BB : 36 97                                 MVI	L, 227o               ;Change L to point to the ARITH STACK pointer.
 3564/36BD : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to the page of the ARITH STACK pointer.
 3565/36BF : C7                                    MOV	A,M                    ;Fetch the ARITH STACK pointer value.
 3566/36C0 : 3C 98                                 CPI	230o               ;Should indicate only one value (answer) in stack.
 3567/36C2 : 2B                                    RZ                    ;Exit with answer in FPACC if ARITH STACK is O.K.
 3568/36C3 : 44 86 28                              JMP	SYNERR             ;Else have a syntax error!
 3569/36C6 :                            
 3570/36C6 :                            ;;; THERE IS SOME BLANK ADDRESSES HERE 317-NEXT PAGE
 3571/36C6 :                            
 3572/36C6 :                            ;          ORG	1a00h	; 032#000
 3573/36C6 : 36 0C                      SQRX:      MVI	L, 014o               ;Load L with address of FP TEMP registers
 3574/36C8 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of FP TEMP. Move contents of FPACC
 3575/36CA : 46 B4 31                              CALL	FSTORE             ;[Argument of SQR(X)] into FP TEMP for storage.
 3576/36CD : 36 56                                 MVI	L, 126o               ;Load L with MSW of FPACC
 3577/36CF : C7                                    MOV	A,M                    ;Fetch the MSW into the accumulator
 3578/36D0 : A0                                    ANA	A                    ;Check the sign of the number in the FPACC
 3579/36D1 : 70 5B 37                              JM	SQRERR             ;If number negative, cannot take square root
 3580/36D4 : 68 C3 25                              JZ	CFALSE             ;If number is zero, return with zero value in FPACC
 3581/36D7 : 36 0F                                 MVI	L, 017o               ;Load L with address of FP TEMP Exponent register
 3582/36D9 : C7                                    MOV	A,M                    ;Fetch the Exponent value into the ACC
 3583/36DA : A0                                    ANA	A                    ;Check sign of the Fxponent
 3584/36DB : 70 E7 36                              JM	NEGEXP             ;If Exponent less than zero, process negative Exponent
 3585/36DE : 1A                                    RAR                    ;If Exponent positive, rotate right to divide by two
 3586/36DF : C8                                    MOV	B,A                    ;And save the result in CPU register B
 3587/36E0 : 06 00                                 MVI	A, 000                ;Clear the accumulator without disturbing Carry bit
 3588/36E2 : 12                                    RAL                    ;Rotate Carry bit into the ACC to save remainder
 3589/36E3 : F8                                    MOV	M,A                    ;Store the remainder back in FP TEMP Exponent reg.
 3590/36E4 : 44 F8 36                              JMP	SQREXP             ;Jump to continue processing
 3591/36E7 : C8                         NEGEXP:    MOV	B,A                    ;For negative Exponent, form two Is complement by
 3592/36E8 : A8                                    XRA	A                    ;Placing the positive value in CPU register B, clearing
 3593/36E9 : 91                                    SUB	B                    ;The accumulator, and then subtracting B from the ACC
 3594/36EA : A0                                    ANA	A                    ;Clear the Carry bit after the complementing operation
 3595/36EB : 1A                                    RAR                    ;Rotate the value right to divide by two
 3596/36EC : C8                                    MOV	B,A                    ;Save the result in CPU register B
 3597/36ED : 06 00                                 MVI	A, 000                ;Clear the accumulator without disturbing Carry bit
 3598/36EF : 88                                    ADC	A                    ;Add Carry bit to the accumulator as remainder
 3599/36F0 : F8                                    MOV	M,A                    ;Store the remainder back in FP TEMP Exponent reg
 3600/36F1 : 68 F5 36                              JZ	NOREMD             ;If remainder was zero skip ahead. If not, increment the
 3601/36F4 : 08                                    INR	B                    ;Result of the divide by two ops to compen for negative
 3602/36F5 : A8                         NOREMD:    XRA	A                    ;Clear the accumulator
 3603/36F6 : 91                                    SUB	B                    ;Subtract the quotient of the divide by two op to
 3604/36F7 : C8                                    MOV	B,A                    ;Form two's complement and save the result in register B
 3605/36F8 : 36 0B                      SQREXP:    MVI	L, 013o               ;Load L with address of TEMP register
 3606/36FA : F9                                    MOV	M,B                    ;Store Fxponent quotient from above ops in TEMP
 3607/36FB : 36 04                                 MVI	L, 004                ;Load L with address of FP registers containing +1.0
 3608/36FD : 26 1C                                 MVI	E, 034o               ;Load E with address of SQR APPROX working registers
 3609/36FF : DD                                    MOV	D,H                    ;Set D to same page as H
 3610/3700 : 0E 04                                 MVI	B, 004                ;Set up register B as a number of bytes to move counter
 3611/3702 : 46 12 30                              CALL	MOVEIT             ;Transfer value +1.0 into SQR APPROX registers
 3612/3705 : 46 C3 25                              CALL	CFALSE             ;Now clear the FPACC registers
 3613/3708 : 36 24                                 MVI	L, 044o               ;Load L with address of LAST SQR APPROX temp regs.
 3614/370A : 46 B4 31                              CALL	FSTORE             ;Initialize the LAST SQR APPROX regs to value of zero
 3615/370D : 36 1C                      SQRLOP:    MVI	L, 034o               ;Load L with address of SQR APPROX working registers
 3616/370F : 46 AB 31                              CALL	FLOAD              ;Transfer SQR APPROX into the FPACC
 3617/3712 : 36 0C                                 MVI	L, 014o               ;Load L with address of SQR ARG storage registers
 3618/3714 : 46 BD 31                              CALL	OPLOAD             ;Transfer SQR ARG into the FPOP
 3619/3717 : 46 D9 30                              CALL	FPDIV              ;Divde SQR ARG by SQR APPROX (Fon-n X/A)
 3620/371A : 36 1C                                 MVI	L, 034o               ;Load L with address of SQR APPROX registers
 3621/371C : 46 BD 31                              CALL	OPLOAD             ;Transfer SQR APPROX into the FPOP
 3622/371F : 46 8C 2F                              CALL	FPADD              ;Add to form value (X/A + A)
 3623/3722 : 36 57                                 MVI	L, 127o               ;Load L with address of FPACC Exponent register
 3624/3724 : CF                                    MOV	B,M                    ;Fetch Exponent value into CPU register B
 3625/3725 : 09                                    DCR	B                    ;Subtract one to effectively divide FPACC by two
 3626/3726 : F9                                    MOV	M,B                    ;Restore to memory. (Now have ((X/A + A) /2)
 3627/3727 : 36 1C                                 MVI	L, 034o               ;Load L with address of SQR APPROX registers
 3628/3729 : 46 B4 31                              CALL	FSTORE             ;Store contents of FPACC as new SQR APPROX
 3629/372C : 36 24                                 MVI	L, 044o               ;Load L with address of LAST SQR APPROX registers
 3630/372E : 46 BD 31                              CALL	OPLOAD             ;Transfer LAST SQR APPROX into the FPOP
 3631/3731 : 46 21 30                              CALL	FPSUB              ;Subtract (LAST SQR APPROX - SQR APPROX)
 3632/3734 : 36 57                                 MVI	L, 127o               ;Load L with address of FPACC Exponent
 3633/3736 : C7                                    MOV	A,M                    ;Fetch the Exponent into the accumulator
 3634/3737 : 3C F7                                 CPI	367o                ;See if difference less than 2 to the minus ninth
 3635/3739 :                            ;;; The below is changed for PATCH 2
 3636/3739 :                            ;;; following is the original code
 3637/3739 :                            ;;;           JTS SQRCNV             ;If so, approximation has converged
 3638/3739 :                            ;;; Now is the new line
 3639/3739 :                            ;	   JMP	PATCH2
 3640/3739 :                            ;;; following is PATCH 2
 3641/3739 :                            
 3642/3739 :                            ;	ORG	1af4h	; 032#364
 3643/3739 : 70 4F 37                   PATCH2	JM	SQRCNV
 3644/373C : 31                         	DCR	L
 3645/373D : C7                         	MOV	A,M
 3646/373E : A0                         	ANA	A
 3647/373F : 68 4F 37                   	JZ	SQRCNV
 3648/3742 :                            ;	JMP	SQR1
 3649/3742 :                            ;;; The above jump should start at 32 375 1afdh
 3650/3742 :                            ;;;;           DCR L
 3651/3742 :                            ;;;;           MOV A,M
 3652/3742 :                            ;;;;           ANA A
 3653/3742 :                            ;;;;           JZ SQRCNV             ;THIS IS PATCH #2
 3654/3742 : 36 1C                      SQR1:	   MVI	L, 034o               ;Else, load L with address of SQR APPROX
 3655/3744 : DD                                    MOV	D,H                    ;Set D to same page as H
 3656/3745 : 26 24                                 MVI	E, 044o               ;And E with address of LAST SQR APPROX
 3657/3747 : 0E 04                                 MVI	B, 004o               ;Set up register B as a number of bytes to move counter
 3658/3749 : 46 12 30                              CALL	MOVEIT             ;Transfer SQR APPROX into LAST SQR APPROX
 3659/374C : 44 0D 37                              JMP	SQRLOP             ;Continue ops until approximation converges
 3660/374F : 36 0B                      SQRCNV:    MVI	L, 013o               ;Load L with address of TEMP register. Fetch the
 3661/3751 : C7                                    MOV	A,M                    ;Exponenent quotient store there into accumulator.
 3662/3752 : 36 1F                                 MVI	L, 037o               ;Change L to point to SQR APPROX exponent.
 3663/3754 : 87                                    ADD	M                    ;Add SQR APPROX exponent to quotient value.
 3664/3755 : F8                                    MOV	M,A                    ;Store sum back in SQR APPROX Exponent register.
 3665/3756 : 36 1C                                 MVI	L, 034o               ;Load L with address of SQR APPROX. Transfer the
 3666/3758 : 44 AB 31                              JMP	FLOAD              ;SQR APPROX into FPACC as answer and exit.
 3667/375B : 06 D3                      SQRERR:    MVI	A, 323o               ;Load ASCII code for letter S into the accumulator.
 3668/375D : 16 D1                                 MVI	C, 321o               ;Load ASCII code for letter Q into CPU register C.
 3669/375F : 44 B2 21                              JMP	ERROR              ;Display the SQuare root (SQ) error message.
 3670/3762 :                            ;;; above instruction starts at 223
 3671/3762 :                            ;;; some blank addresses available here.
 3672/3762 :                            
 3673/3762 :                            ;          ORG	1aa0h              ; 032#240
 3674/3762 : 36 34                      RNDX:      MVI	L, 064o               ;Load L with address of SEED storage registers
 3675/3764 : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page for floating point working registers
 3676/3766 : 46 AB 31                              CALL	FLOAD              ;Transfer SEED into the FPACC
 3677/3769 : 36 28                                 MVI	L, 050o               ;Load L with address of random constant A
 3678/376B : 46 BD 31                              CALL	OPLOAD             ;Transfer random constant A into the FPOP
 3679/376E : 46 2D 30                              CALL	FPMULT             ;Multiply to form (SEED * A)
 3680/3771 : 36 30                                 MVI	L, 060o               ;Load L with address of random constant C
 3681/3773 : 46 BD 31                              CALL	OPLOAD             ;Transfer random constant C into the FPOP
 3682/3776 : 46 8C 2F                              CALL	FPADD              ;Add to fom (SEED * A) + C
 3683/3779 : 36 34                                 MVI	L, 064o               ;Load L with address of SEED storage registers
 3684/377B : 46 B4 31                              CALL	FSTORE             ;Store I (SEED * A) + C] in former SEED registers
 3685/377E : 36 57                                 MVI	L, 127o               ;Load L with address of FPACC Exponent register
 3686/3780 : C7                                    MOV	A,M                    ;Fetch Exponent value into the accumulator
 3687/3781 : 14 10                                 SUI	020o               ;Subtract 16 (decimal) to effectively divide by 65,536
 3688/3783 : F8                                    MOV	M,A                    ;Now FPACC = [((SEED * A) + C)/65,536]
 3689/3784 : 46 03 2F                              CALL	FPFIX              ;Convert floating to fixed point to obtain integer part
 3690/3787 : 36 53                                 MVI	L, 123o               ;Load L with address of FPACC Extension register
 3691/3789 : 3E 00                                 MVI	M, 000                ;Clear the FPACC Extension register
 3692/378B : 36 57                                 MVI	L, 127o               ;Load L with address of FPACC Exponent
 3693/378D : 3E 00                                 MVI	M, 000                ;Clear the FPACC Exponent register
 3694/378F : 46 37 2F                              CALL	FPFLT              ;Fetch INT(((SEED * A) + C)/65,536) into the FPACC
 3695/3792 : 36 57                                 MVI	L, 127o               ;Load L with address of FPACC Exponent
 3696/3794 : C7                                    MOV	A,M                    ;Fetch FPACC Exponent into the accumulator
 3697/3795 : 04 10                                 ADI	020o               ;Add 16 (decimal) to effectively multiply by 65,536
 3698/3797 : F8                                    MOV	M,A                    ;(65,536 * INT[ ((SEED * A) + C)/65,5361) in FPACC
 3699/3798 : 36 34                                 MVI	L, 064o               ;Load L with address of [(SEED * A) + C]
 3700/379A : 46 BD 31                              CALL	OPLOAD             ;Transfer it into FPOP. Subtract FPACC to form
 3701/379D : 46 21 30                              CALL	FPSUB              ;[(SEED * A) + C] MOD 65,536
 3702/37A0 : 36 34                                 MVI	L, 064o               ;Load L with address of former SEED registers
 3703/37A2 : 46 B4 31                              CALL	FSTORE             ;Store SEED MOD 65,536 in place of [(SEED * A) + Cl
 3704/37A5 : 36 57                                 MVI	L, 127o               ;Load L with address of FPACC Exponent
 3705/37A7 : C7                                    MOV	A,M                    ;Fetch FPACC Exponent into the ACC and subtract
 3706/37A8 : 14 10                                 SUI	020o               ;16 (decimal) to form (SEED MOD 65,536)/65,536
 3707/37AA : F8                                    MOV	M,A                    ;So that random number in FPACC is between
 3708/37AB : 07                                    RET                    ;0.0 and +1.0 and exit to calling routine
 3709/37AC :                            ;;; THE ABOVE RETURN SHOULD BE 32 351 1ae9h
 3710/37AC :                            
 3711/37AC :                            ;;; NOTE OPEN ADDRESSES TO END OF PAGE 32
 3712/37AC :                            
 3713/37AC :                            
 3714/37AC :                            	;; PAGES 33 TO REMAINDER OF MEMORY
 3715/37AC :                            	;; OR START OF OPTIONAL ARRAY HANDLING
 3716/37AC :                            	;; ROUTINES USED AS USER PROGRAM BUFFER
 3717/37AC :                            
 3718/37AC :                            	;; OPTIONAL ARRAY ROUTINES ASSEMBLED FOR OPERATION
 3719/37AC :                            	;; IN THE UPPER 3 PAGES OF A 12K SYSTEM ARE LISTED HERE.
 3720/37AC :                            
 3721/37AC :                            ;          ORG	2d00h              ; 055#000
 3722/37AC :                            
 3723/37AC : 36 56                      PRIGH1:    MVI	L, 126o               ;Load L with address of the MSW in the FPACC
 3724/37AE : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of FPACC
 3725/37B0 : C7                                    MOV	A,M                    ;Fetch MSW of FPACC into the ACC.
 3726/37B1 : A0                                    ANA	A                    ;Test to see if value in FPACC is positive.
 3727/37B2 : 70 0A 38                              JM	OUTRNG             ;If not, go display error message.
 3728/37B5 : 46 03 2F                              CALL	FPFIX              ;If O.K. then convert floating point to fixed point
 3729/37B8 : 36 54                                 MVI	L, 124o               ;Load L with address of LSAL of converted value
 3730/37BA : C7                                    MOV	A,M                    ;Fetch the LSW of the value into the ACC
 3731/37BB : 14 01                                 SUI	001                ;Subtract one from the value to establish proper
 3732/37BD : 02                                    RLC                    ;Origin for future ops. Now rotate the value twice
 3733/37BE : 02                                    RLC                    ;To effectively multiply by four. Save the
 3734/37BF : D0                                    MOV	C,A                    ;Calculated result in CPU register C
 3735/37C0 : 36 83                                 MVI	L, 203o               ;Load L with address of F/A STACK TEMP
 3736/37C2 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Load H with page of F/A STACK TEMP
 3737/37C4 : C7                                    MOV	A,M                    ;Fetch the value into the accumulator
 3738/37C5 : 2C FF                                 XRI	377o               ;Complement the value
 3739/37C7 : 02                                    RLC                    ;Rotate the value twice to multiply by four (the number
 3740/37C8 : 02                                    RLC                    ;Of bytes per entry in the ARRAY VARIABLES table).
 3741/37C9 : 04 50                                 ADI	120o               ;Add the starting address of the ARRAY VARIABLES
 3742/37CB : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** TABLE to forin pointer. Set page address in H.
 3743/37CD : F0                                    MOV	L,A                    ;Point to the name in the ARRAY VARIABLES
 3744/37CE : 30                                    INR	L                    ;Increment the pointer value twice to move over the
 3745/37CF : 30                                    INR	L                    ;Name in the table and point to starting address for the
 3746/37D0 : C7                                    MOV	A,M                    ;Array values in the ARRAY VALUES table. Fetch this
 3747/37D1 : 82                                    ADD	C                    ;Address to the ACC. Now add in the figure calculated
 3748/37D2 : F0                                    MOV	L,A                    ;To reach desired subscripted data storage location. Set
 3749/37D3 : 2E 05                                 MVI	H,PG57 ;\HB\OLDPG57   ;tt The pointer to that location. Load the floating point
 3750/37D5 : 44 AB 31                              JMP	FLOAD              ;Value stored there into the FPACC and exit to caller.
 3751/37D8 :                            
 3752/37D8 :                            
 3753/37D8 :                            ;;; The label FUNAR2 SHOULD START AT 55-054 2d2ch
 3754/37D8 : 36 82                      FUNAR2:    MVI	L, 202o               ;Load L with address of TEMP COUNTER
 3755/37DA : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Load H with page of counter
 3756/37DC : CF                                    MOV	B,M                    ;Fetch the counter value
 3757/37DD : 08                                    INR	B                    ;Increment the value
 3758/37DE : F9                                    MOV	M,B                    ;Restore the value to memory
 3759/37DF : 16 02                                 MVI	C, 002                ;Initialize register C to a value of two for future ops
 3760/37E1 : 36 4C                                 MVI	L, 114o               ;Load L with address of start of ARRAY VARIABLES
 3761/37E3 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** TABLE (less four). Set H to page of the table.
 3762/37E5 : 46 B4 26                              CALL	TABADR             ;Calculate address of start of next narne in table.
 3763/37E8 : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Load D with page of the SYMBOL BUFFER
 3764/37EA : 26 50                                 MVI	E, 120o               ;Set E to starting address of the SYMBOL BUFFER
 3765/37EC : 46 F6 21                              CALL	STRCP              ;Compare name in ARRAY VARIABLES table to the
 3766/37EF : 68 00 38                              JZ	FUNAR3             ;Contents of the SYMBOL BUFFER. If match, go set up
 3767/37F2 : 36 82                                 MVI	L, 202o               ;Array token value. Else, reset L to address of TEMP
 3768/37F4 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** COUNTER. Set H to page of TEMP COUNTER.
 3769/37F6 : C7                                    MOV	A,M                    ;Fetch the counter value into the accumulator.
 3770/37F7 : 36 3D                                 MVI	L, 075o               ;Change L to number of arrays storage location.
 3771/37F9 : BF                                    CMP	M                    ;Compare number of entries checked against number
 3772/37FA : 48 D8 37                              JNZ	FUNAR2             ;Possible. Keep searching table if not finished.
 3773/37FD : 44 96 26                              JMP	FAERR              ;If finished and no match than have F/A error condx.
 3774/3800 : 36 82                      FUNAR3:    MVI	L, 202o               ;Load L with address of TEMP COUNTER
 3775/3802 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Load H with page of counter.
 3776/3804 : A8                                    XRA	A                    ;Clear the accumulator. Subtract the value in the TEMP
 3777/3805 : 9F                                    SBB	M                    ;COUNTER from zero to obtain two's complement.
 3778/3806 : F8                                    MOV	M,A                    ;Place this back in counter location as ARRAY TOKEN
 3779/3807 : 44 A3 26                              JMP	FUNAR4             ;VALUE (negative). Go place the value on F/A STACK.
 3780/380A :                            
 3781/380A :                            
 3782/380A :                            ;;; The label OUTRNG STARTS AT 55 136 2d5eh
 3783/380A : 06 CF                      OUTRNG:    MVI	A, 317o               ;Load the ASCII code for letter 0 into the accumulator
 3784/380C : 16 D2                                 MVI	C, 322o               ;Load the ASCII code for letter R into register C
 3785/380E : 44 B2 21                              JMP	ERROR              ;Go display Out of Range (OR) error message.
 3786/3811 :                            
 3787/3811 :                            
 3788/3811 :                            
 3789/3811 :                            
 3790/3811 : 46 C6 27                   ARRAY:     CALL	RESTSY             ;Transfer contents of AUX SYMBOL BUFFER into the
 3791/3814 : 44 1C 38                              JMP	ARRAY2             ;SYMBOL BUFFER. (Entry when have actual LET)
 3792/3817 : 36 82                      ARRAY1:    MVI	L, 202o               ;Load L with address of SCAN pointer
 3793/3819 : 44 1E 38                              JMP	ARRAY3             ;Proceed to process. (Entry point for IMPLIED LET)
 3794/381C : 36 83                      ARRAY2:    MVI	L, 203o               ;Load L with address of LET pointer
 3795/381E : 2E 03                      ARRAY3:    MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to pointer page
 3796/3820 : CF                                    MOV	B,M                    ;Fetch pointer to location where "(" found in statement
 3797/3821 : 08                                    INR	B                    ;Line. Increment it to point to next character in the line.
 3798/3822 : 36 BE                                 MVI	L, 276o               ;Load L with address of EVAL pointer and load it with
 3799/3824 : F9                                    MOV	M,B                    ;The starting address for the EVAL routine
 3800/3825 : 36 86                                 MVI	L, 206o               ;Change L to address of ARRAY SETUP pointer
 3801/3827 : F9                                    MOV	M,B                    ;And also store address in that location
 3802/3828 : 36 86                      ARRAY4:    MVI	L, 206o               ;Load L with address of ARRAY SETUP pointer
 3803/382A : 46 BC 21                              CALL	GETCHR             ;Fetch character pointed to by ARRAY SETUP pntr
 3804/382D : 3C A9                                 CPI	251o               ;See if character is ")" ? If so, then have located
 3805/382F : 68 41 38                              JZ	ARRAY5             ;End of the subscript. If not, reset
 3806/3832 : 36 86                                 MVI	L, 206o               ;to the ARRAY SETUP pointer. Increment the
 3807/3834 : 46 1F 22                              CALL	LOOP               ;Pointer and test for the end of the statement line.
 3808/3837 : 48 28 38                              JNZ	ARRAY4             ;If not end of line, continue looking for right paren.
 3809/383A : 06 C1                                 MVI	A, 301o               ;If reach end of line before right parenthesis than load
 3810/383C : 16 C6                                 MVI	C, 306o               ;ASCII code for letters A and F and display message
 3811/383E : 44 B2 21                              JMP	ERROR              ;Indicating Array Forrnat (AF) error condition
 3812/3841 : 36 86                      ARRAY5:    MVI	L, 206o               ;Load L with address of ARRAY SETUP pointer
 3813/3843 : CF                                    MOV	B,M                    ;Fetch pointer (pointing to ")"sign) into register B
 3814/3844 : 09                                    DCR	B                    ;Decrement it to move back to end of subscript number
 3815/3845 : 36 BF                                 MVI	L, 277o               ;Load L with address of EVAL FINISH pointer location
 3816/3847 : F9                                    MOV	M,B                    ;Place the pointer value in the EVAL FINISH pointer
 3817/3848 : 36 87                                 MVI	L, 207o               ;Load L with address of LOOP COUNTER
 3818/384A : 3E 00                                 MVI	M, 000                ;Initialize LOOP COUNTER to value of zero
 3819/384C : 36 87                      ARRAY6:    MVI	L, 207o               ;Load L with address of LOOP COUNTER
 3820/384E : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of LOOP COUNTER
 3821/3850 : CF                                    MOV	B,M                    ;Fetch the counter value
 3822/3851 : 08                                    INR	B                    ;Increment it
 3823/3852 : F9                                    MOV	M,B                    ;Restore the counter value to memory
 3824/3853 : 16 02                                 MVI	C, 002                ;Set up counter in register C for future ops
 3825/3855 : 36 4C                                 MVI	L, 114o               ;Load L with address of start of ARRAY VARIABLES
 3826/3857 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Table less four). Set H to page of the table.
 3827/3859 : 46 B4 26                              CALL	TABADR             ;Calculate the address of next entry in the table
 3828/385C : 26 50                                 MVI	E, 120o               ;Load register E with starting address of SYMBOL BUFF
 3829/385E : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Set D to page of SYMBOL BUFFER
 3830/3860 : 46 F6 21                              CALL	STRCP              ;Compare entry in table against contents of SYMBOL BF
 3831/3863 : 68 76 38                              JZ	ARRAY7             ;If match, have found array naine in the table.
 3832/3866 : 36 87                                 MVI	L, 207o               ;Else, set L to address of the LOOP COUNTER
 3833/3868 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of the LOOP COUNTER
 3834/386A : C7                                    MOV	A,M                    ;Fetch the counter value to the ACC
 3835/386B : 36 3D                                 MVI	L, 075o               ;Change L to the counter containing number of arrays
 3836/386D : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to the proper page
 3837/386F : BF                                    CMP	M                    ;Compare number of arrays to count in LOOP CNTR
 3838/3870 : 48 4C 38                              JNZ	ARRAY6             ;If more entries in the table, continue looking for match
 3839/3873 : 44 96 26                              JMP	FAERR              ;If no matching name in table then have an error condx.
 3840/3876 : 46 B0 22                   ARRAY7:    CALL	EVAL               ;Call subroutine to evaluate subscript expression
 3841/3879 : 46 03 2F                              CALL	FPFIX              ;Convert the subscript value obtained to fixed forrnat
 3842/387C : 36 87                                 MVI	L, 207o               ;Load L with address of LOOP COUNTER
 3843/387E : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of the LOOP COUNTER
 3844/3880 : CF                                    MOV	B,M                    ;Fetch the value in the LOOP COUNTER into the ACC
 3845/3881 : 16 02                                 MVI	C, 002                ;Set up counter in register C future ops
 3846/3883 : 36 4C                                 MVI	L, 114o               ;Load L with address of ARRAY VARIABLES
 3847/3885 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Table less four). Set H to page of the table.
 3848/3887 : 46 B4 26                              CALL	TABADR             ;Calculate the address of entry in the table
 3849/388A : 30                                    INR	L                    ;Advance the ARRAY VARIABLES table pointer twice
 3850/388B : 30                                    INR	L                    ;To advance pointer over array name.
 3851/388C : D7                                    MOV	C,M                    ;Fetch array base address in ARRAY VALUES table
 3852/388D : 36 54                                 MVI	L, 124o               ;Load L with address of subscript value
 3853/388F : 2E 02                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of subscript value
 3854/3891 : C7                                    MOV	A,M                    ;Fetch the subscript value into the accumulator
 3855/3892 : 14 01                                 SUI	001                ;Subtract one from subscript value to allow for zero
 3856/3894 : 02                                    RLC                    ;Origin. Now multiply by four
 3857/3895 : 02                                    RLC                    ;Using rotates (number of bytes required for each entry
 3858/3896 : 82                                    ADD	C                    ;In the ARRAY VALUES table). Add in base address to
 3859/3897 : 36 84                                 MVI	L, 204o               ;The calculated value to form final address in the
 3860/3899 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** ARRAY VALUES table. Now set H & L to TEMP
 3861/389B : F8                                    MOV	M,A                    ;ARRAY ELEMENT storage location & store the addr.
 3862/389C : 36 81                                 MVI	L, 201o               ;Change L to point to ARRAY FLAG
 3863/389E : 3E FF                                 MVI	M, 377o               ;Set the ARRAY FLAG for future use
 3864/38A0 : 07                                    RET                    ;Exit to calling routine
 3865/38A1 :                            
 3866/38A1 :                            
 3867/38A1 :                            ;;; The label DIM SHOULD START AT 55 365 2df5h
 3868/38A1 : 46 C9 21                   DIM:       CALL	CLESYM             ;Initialize the SYMBOL BUFFER to cleared condition
 3869/38A4 : 36 82                                 MVI	L, 202o               ;Load L with address of SCAN pointer
 3870/38A6 : CF                                    MOV	B,M                    ;Fetch SCAN pointer value into register B
 3871/38A7 : 08                                    INR	B                    ;Add one to the SCAN pointer value
 3872/38A8 : 36 83                                 MVI	L, 203o               ;Change L to DIM pointer (formerly TOKEN) storage
 3873/38AA : F9                                    MOV	M,B                    ;Store the updated SCAN pointer as the DIM pointer
 3874/38AB : 36 83                      DIM1:      MVI	L, 203o               ;Load L with the address of DIM pointer storage location
 3875/38AD : 46 BC 21                              CALL	GETCHR             ;Fetch a character from the line input buffer
 3876/38B0 : 68 BB 38                              JZ	DIM2               ;If character fetched is a space, ignore it
 3877/38B3 : 3C A8                                 CPI	250o               ;Else see if character is "(" left parenthesis
 3878/38B5 : 68 C6 38                              JZ	DIM3               ;If so, should have ARRAY VARIABLE naine in buffer
 3879/38B8 : 46 E4 21                              CALL	CONCTS             ;If not, append the character to the SYMBOL BUFFER
 3880/38BB : 36 83                      DIM2:      MVI	L, 203o               ;Load L with the address of DIM pointer stomge location
 3881/38BD : 46 1F 22                              CALL	LOOP               ;Increment the pointer and see if end of line
 3882/38C0 : 48 AB 38                              JNZ	DIM1               ;If not end of line, fetch next character
 3883/38C3 : 44 8B 39                              JMP	DIMERR             ;Else have a DIMension error condition
 3884/38C6 : 36 86                      DIM3:      MVI	L, 206o               ;Load L with address of ARRAY pointer storage loc
 3885/38C8 : 3E 00                                 MVI	M, 000                ;Initialize ARRAY pointer to starting value of zero
 3886/38CA : 36 86                      DIM4:      MVI	L, 206o               ;Load L with address of ARRAY pointer storage loc
 3887/38CC : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of ARRAY pointer storage location
 3888/38CE : C7                                    MOV	A,M                    ;Fetch value in ARRAY pointer to ACC (effectively
 3889/38CF : 02                                    RLC                    ;Represents number of arrays defined in pgm). Rotate
 3890/38D0 : 02                                    RLC                    ;Left twice to multiply by four (niunber of bytes per
 3891/38D1 : 04 4C                                 ADI	114o               ;entry in ARRAY VARIABLES table). Add to base
 3892/38D3 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Address to form pointer to ARRAY VARIA.BLES
 3893/38D5 : F0                                    MOV	L,A                    ;Table and set up H & L as the memory pointer.
 3894/38D6 : 26 50                                 MVI	E, 120o               ;Load E with starting address of the SYMBOL BUFFER
 3895/38D8 : 1E 03                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Load D with the page address of the SYMBOL BUFF
 3896/38DA : 46 F6 21                              CALL	STRCP              ;Compare contents of SYMBOL BF to entry in ARRAY
 3897/38DD : 68 6D 39                              JZ	DIM9               ;VARIABLES table. If same, have duplicate array name.
 3898/38E0 : 36 86                                 MVI	L, 206o               ;Else, load L with address of ARRAY pointer storage
 3899/38E2 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of ARRAY pointer storage
 3900/38E4 : CF                                    MOV	B,M                    ;Fetch the ARRAY pointer value to register B
 3901/38E5 : 08                                    INR	B                    ;Increment the value
 3902/38E6 : F9                                    MOV	M,B                    ;Restore it to ARRAY pointer storage location
 3903/38E7 : 36 3D                                 MVI	L, 075o               ;Change L to number of arrays storage location
 3904/38E9 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to page of the number of arrays stomge loc
 3905/38EB : C7                                    MOV	A,M                    ;Fetch the number of arrays value to the ACC
 3906/38EC : 09                                    DCR	B                    ;Restore B to previous count
 3907/38ED : B9                                    CMP	B                    ;Compare number of arrays tested against nr defined
 3908/38EE : 48 CA 38                              JNZ	DIM4               ;If not equal, continue searching ARRAY VARIABLES
 3909/38F1 : 36 3D                                 MVI	L, 075o               ;Table. When table searched with no match, then must
 3910/38F3 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Append naine to table. First set pointer to number
 3911/38F5 : CF                                    MOV	B,M                    ;Of arrays storage location. Fetch that value and
 3912/38F6 : 08                                    INR	B                    ;Add one to account for new name being added.
 3913/38F7 : F9                                    MOV	M,B                    ;Restore the updated value back to memory.
 3914/38F8 : 36 3E                                 MVI	L, 076o               ;Change pointer to ARRAY TEMP pointer storage
 3915/38FA : F9                                    MOV	M,B                    ;Store pointer to current array in ARRAY TEMP too.
 3916/38FB : 36 86                                 MVI	L, 206o               ;Load L with address of ARRAY pointer stomge loc.
 3917/38FD : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of ARRAY pointer storage location
 3918/38FF : F9                                    MOV	M,B                    ;And update it also for new array being added.
 3919/3900 : C7                                    MOV	A,M                    ;Fetch the current ARRAY pointer value to the ACC
 3920/3901 : 02                                    RLC                    ;Multiply it times four by performing two rotate left
 3921/3902 : 02                                    RLC                    ;Operations and add it to base value to form address in
 3922/3903 : 04 4C                                 ADI	114o               ;The ARRAY VARIABLES table. Place the low part
 3923/3905 : E0                                    MOV	E,A                    ;Of this calculated address value into register E.
 3924/3906 : 1E 04                                 MVI	D,PG27 ;\HB\OLDPG27   ;** Set register D to the page of the table.
 3925/3908 : 36 50                                 MVI	L, 120o               ;Load L with the start of the SYMBOL BUFFER
 3926/390A : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with the page of the SYMBOL BUFFER
 3927/390C : 46 2B 29                              CALL	MOVEC              ;Move the array name from the SYMBOL BUFFER to
 3928/390F : 46 C9 21                              CALL	CLESYM             ;The ARRAY VARIABLES table. Then clear the
 3929/3912 : 36 83                                 MVI	L, 203o               ;SYMBOL BUFFER. Reset L to the DIM pointer storage
 3930/3914 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Location. Set H to the DIM pointer page.
 3931/3916 : CF                                    MOV	B,M                    ;Fetch the pointer value (points to "(" part of DIM
 3932/3917 : 08                                    INR	B                    ;Statement). Increment the pointer to next character in
 3933/3918 : 36 84                                 MVI	L, 204o               ;The line input buffer. Cbange L to DIMEN pointer.
 3934/391A : F9                                    MOV	M,B                    ;Store the updated DIM pointer in DIMEN storage loc.
 3935/391B : 36 84                      DIM5:      MVI	L, 204o               ;Set L to DIMEN pointer storage location
 3936/391D : 46 BC 21                              CALL	GETCHR             ;Fetch character in line input buffer
 3937/3920 : 68 35 39                              JZ	DIM6               ;Ignore character for space
 3938/3923 : 3C A9                                 CPI	251o               ;If not space, see if character is right parenthesis
 3939/3925 : 68 40 39                              JZ	DIM7               ;If yes, process DIMension size (array length)
 3940/3928 : 3C B0                                 CPI	260o               ;If not, see if character is a valid decimal number
 3941/392A : 70 8B 39                              JM	DIMERR             ;If not valid number, have DIMension error condition
 3942/392D : 3C BA                                 CPI	272o               ;Continue testing for valid decitnal number
 3943/392F : 50 8B 39                              JP	DIMERR             ;If not valid number, then DIMension error condition
 3944/3932 : 46 E4 21                              CALL	CONCTS             ;If valid decirnal number, append digit to SYMBOL BF
 3945/3935 : 36 84                      DIM6:      MVI	L, 204o               ;Set L to DIMEN pointer storage location
 3946/3937 : 46 1F 22                              CALL	LOOP               ;Advance the pointer value and check for end of the line
 3947/393A : 48 1B 39                              JNZ	DIM5               ;If not end of line, continue fetching DIMension size
 3948/393D : 44 8B 39                              JMP	DIMERR             ;If end of line before right parenthesis, have error condx.
 3949/3940 : 36 50                      DIM7:      MVI	L, 120o               ;Load L with address of start of SYMBOL BUFFER
 3950/3942 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of SYMBOL BUFFER. (Now
 3951/3944 : 46 2B 32                              CALL	DINPUT             ;Contains DIMension size.) Convert buffer to floating
 3952/3947 : 46 03 2F                              CALL	FPFIX              ;Point number and then reformat to fixed point.
 3953/394A : 36 54                                 MVI	L, 124o               ;Load L with address of LSW of fixed point number
 3954/394C : C7                                    MOV	A,M                    ; And fetch the low order byte of the nr into the ACC
 3955/394D : 02                                    RLC                    ;Rotate it left two tirnes to multiply it by four (the
 3956/394E : 02                                    RLC                    ;Number of bytes required to store a floating point nr).
 3957/394F : D0                                    MOV	C,A                    ;Store this value in CPU register C temporarily
 3958/3950 : 36 3E                                 MVI	L, 076o               ;Set L to ARRAY TEMP storage location.
 3959/3952 : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to ARRAY TEMP pointer page.
 3960/3954 : C7                                    MOV	A,M                    ;Fetch the value in ARRAY TEMP (points to ARRAY
 3961/3955 : 14 01                                 SUI	001                ;VARIABLES table). Subtract one from the pointer
 3962/3957 : 02                                    RLC                    ;Value and multiply the result by four using rotate left
 3963/3958 : 02                                    RLC                    ;Instructions. Add this value to a base address
 3964/3959 : 04 52                                 ADI	122o               ;(Augmented by two) to point to ARRAY VALUES
 3965/395B : F0                                    MOV	L,A                    ;Pointer storage location in the ARRAY VARIABLES
 3966/395C : 2E 04                                 MVI	H,PG27 ;\HB\OLDPG27   ;Table and set the pointer up in registers H & L.
 3967/395E : CF                                    MOV	B,M                    ;Fetch the starting address in the ARRAY VALUES
 3968/395F : 04 04                                 ADI	004                ;Table for the previous array into register B. Now add
 3969/3961 : F0                                    MOV	L,A                    ;Four to the ARRAY VARIABLES table pointer to
 3970/3962 : C1                                    MOV	A,B                    ;Point to curront ARRAY VALUES starting address.
 3971/3963 : 82                                    ADD	C                    ;Add the previous array starting address plus number of
 3972/3964 : F8                                    MOV	M,A                    ;Bytes required and store as starting loc for next array
 3973/3965 : 36 84                      DIM8:      MVI	L, 204o               ;Set L to address of DIMEN pointer storage location
 3974/3967 : 2E 03                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of DIMEN pointer
 3975/3969 : CF                                    MOV	B,M                    ;Fetch pointer value (points to ") " in line)
 3976/396A : 36 83                                 MVI	L, 203o               ;Change L to DIM pointer storage location
 3977/396C : F9                                    MOV	M,B                    ;Store former DIMEN value back in DIM pointer
 3978/396D : 36 83                      DIM9:      MVI	L, 203o               ;Load L with address of DIM pointer storage location
 3979/396F : 46 BC 21                              CALL	GETCHR             ;Fetch a character from the line input buffer
 3980/3972 : 3C AC                                 CPI	254o               ;See if character is a comma (,) sign
 3981/3974 : 68 82 39                              JZ	DIM10              ;If yes, have another array being defined on the line
 3982/3977 : 36 83                                 MVI	L, 203o               ;If not, reset L to the DIM pointer
 3983/3979 : 46 1F 22                              CALL	LOOP               ;Increment the pointer and see if end of the line
 3984/397C : 48 6D 39                              JNZ	DIM9               ;If not end of the line, keep looking for a comma
 3985/397F : 44 59 2A                              JMP	NXTLIN             ;Else exit the DIM statement routine to continue pgm
 3986/3982 : 36 83                      DIM10:     MVI	L, 203o               ;Set L to DIM pointer storage location
 3987/3984 : CF                                    MOV	B,M                    ;Fetch pointer value (points to comma sign just found)
 3988/3985 : 36 82                                 MVI	L, 202o               ;Load L with address of SCAN pointer storage location
 3989/3987 : F9                                    MOV	M,B                    ;Place DIM pointer into the-SCAN pointer
 3990/3988 : 44 A1 38                              JMP	DIM                ;Continue processing DIM statement line for next array
 3991/398B : 06 C4                      DIMERR:    MVI	A, 304o               ;On error condition, load ASCII code for letter D in ACC
 3992/398D : 16 C5                                 MVI	C, 305o               ;And ASCII code for letter E in CPU register C
 3993/398F : 44 B2 21                              JMP	ERROR              ;Go display the Dirnension Error (DE) message.
 3994/3992 :                            
 3995/3992 :                            ;------------------------------------------------------------------------
 3996/3992 :                            
 3997/3992 :                            ;;; THE ABOVE MUST CONCLUDE BEFORE BY PAGE 1 STARTS
 3998/3992 :                            
 3999/3992 :                            ;;; Page one has many constants and variables.
 4000/3992 :                            
 4001/3992 :                            ;		ORG	PG01 * 0100h	;001#000
 4002/3D00 :                            		ORG	ORG_PG01
 4003/3D00 :                            
 4004/3D00 : 00 00 00 00                		db	0,0,0,0		;DATA *4
 4005/3D04 : 00 00 40 01                		db	0,0,100o,1	;DATA 000,000,100,001	; STORES FLOATING POINT CONSTANT +1.0
 4006/3D08 : 00 00 00                   		db	0,0,0		;DATA *3
 4007/3D0B : 00                         		db	0		;DATA 000		; EXPONENT COUNTER
 4008/3D0C : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; STORES FLOATING POINT NUMBER TEMPORARILLY
 4009/3D10 : 00 00 00 00                		db	0,0,0,0		;DATA *4
 4010/3D14 : 00 00 C0 01                		db	0,0,300o,1	;DATA 000,000,300,001	; STORES FLOATING POINT CONSTANT -1.0
 4011/3D18 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; SCRATCH PAD AREA (16 BYTES)
 4012/3D1C : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
 4013/3D20 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
 4014/3D24 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
 4015/3D28 : 01 50 72 02                		db	1,120o,162o,2o	;DATA 001,120,162,002	; STORES RANDOM NUMBER GENERATOR CONSTANT VALUE
 4016/3D2C : 00 00 00 00                		db	0,0,0,0		;DATA *4
 4017/3D30 : 03 68 6F 0C                		db	3,150o,157o,14o	;DATA 003,150,157,014	; STORES RANDOM NUMBER GENERATOR CONSTANT VALUE
 4018/3D34 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; SCRATCH PAD AREA (12 BYTES) (01 064-077)
 4019/3D38 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
 4020/3D3C : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
 4021/3D40 : 00 00                      		db	0,0		;DATA 000,000		; SIGN INDICATOR
 4022/3D42 : 00                         		db	0		;DATA 000		; BITS COUNTER
 4023/3D43 : 00 00                      		db	0,0		;DATA 000,000		; SIGN INDICATOR
 4024/3D45 : 00                         IN_DIGIT_CC_L0	db	0		;DATA 000		; INPUT DIGIT COUNTER
 4025/3D46 : =45H                       IN_DIGIT_CC_L	equ	105o
 4026/3D46 : 00                         		db	0		;DATA 000		; TEMP STORATE
 4027/3D47 : 00                         		db	0		;DATA 000		; OUTPUT DIGIT COUNTER
 4028/3D48 : 00                         		db	0		;DATA 000 		; FP MODE INDICATOR
 4029/3D49 : 00 00 00 00 00 00 00       		db	0,0,0,0,0,0,0	;DATA *7		; NOT ASSIGNED (SHOULD BE 01 111-117)
 4030/3D50 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; FPACC EXTENSION
 4031/3D54 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; FPACC LSW, NSW, MSW, EXPONENT
 4032/3D58 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; FPOP  Extension
 4033/3D5C : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; FPOP  LSW, NSW, MSW, EXPONENT
 4034/3D60 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; FLOATING POINT WORKING AREA
 4035/3D64 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; (SHOULD BE AT 01 140-01-167)
 4036/3D68 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
 4037/3D6C : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
 4038/3D70 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
 4039/3D74 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
 4040/3D78 : 00 00 00 00 00 00 00 00    		db	0,0,0,0,0,0,0,0	;DATA *8		; NOT ASSIGNED (SHOULD BE 01 170-01 177)
 4041/3D80 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; TEMPORARY REGISTER STORAGE AREA (D,E,H&L)
 4042/3D84 : 00 00 00 00                		db	0,0,0,0		;DATA *4		; NOT ASSIGNED (01 204-01 207)
 4043/3D88 : 00 00 50 04                		db	0,0,120o,4	;DATA 000,000,120,004	; STORES FLOATING POINT CONSTANT +10.0
 4044/3D8C : 67 66 66 FD                		db	147o,146o,146o,375o	;DATA 147,146,146,375	; STORES FLOATING POINT CONSTANT +0.1
 4045/3D90 : 00                         		db	0		;DATA 000		; GETINP COUNTER
 4046/3D91 : 00 00 00 00 00 00          		db	0,0,0,0,0,0	;DATA *6		; NOT ASSIGNED (01 221-01 226)
 4047/3D97 : 00                         		db	0		;DATA 000		; ARITHMETIC STACK POINTER (01 227)
 4048/3D98 : 00                         		db	0		;DATA 000		; ARITHMETIC STACK (NOT CLEAR HOW LONG)
 4049/3D99 :                            
 4050/3D99 :                            ;		ORG	PG01 * 0100h + 0bah	;001#272
 4051/3DBA :                            		ORG	ORG_PG01 + 0bah	;001#272
 4052/3DBA : 04                         		db	4		;DATA 004		; CC FOR SAVE
 4053/3DBB :                            ;		db	"SAVE"		;DATA "SAVE"
 4054/3DBB : C5                         		db	"E"+80h
 4055/3DBC : D8                         		db	"X"+80h
 4056/3DBD : C9                         		db	"I"+80h
 4057/3DBE : D4                         		db	"T"+80h
 4058/3DBF : 03                         		db	3		;DATA 004		; CC FOR LOAD
 4059/3DC0 :                            ;		db	"LOAD"		;DATA "LOAD"
 4060/3DC0 : CD                         		db	"M"+80h
 4061/3DC1 : CF                         		db	"O"+80h
 4062/3DC2 : CE                         		db	"N"+80h
 4063/3DC3 : A0                         		db	" "+80h
 4064/3DC4 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; UNCLEAR WHAT THIS IS (01 304-01 317) ZEROS
 4065/3DC8 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; (PROBABLY STEP, FOR/NEXT, AND ARRAY PTR TEMP)
 4066/3DCC : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
 4067/3DD0 :                            					;; AT THIS POINT WE SHOULD BE AT LOCATION 01 320 01d0h
 4068/3DD0 : 04                         		db	4		;DATA 4
 4069/3DD1 :                            ;		db	"THEN"		;DATA "THEN"
 4070/3DD1 : D4                         		db	"T"+80h
 4071/3DD2 : C8                         		db	"H"+80h
 4072/3DD3 : C5                         		db	"E"+80h
 4073/3DD4 : CE                         		db	"N"+80h
 4074/3DD5 : 02                         		db	2		;DATA 2
 4075/3DD6 :                            ;		db	"TO"		;DATA "TO"
 4076/3DD6 : D4                         		db	"T"+80h
 4077/3DD7 : CF                         		db	"O"+80h
 4078/3DD8 : 04                         		db	4		;DATA 4
 4079/3DD9 :                            ;		db	"STEP"		;DATA "STEP"
 4080/3DD9 : D3                         		db	"S"+80h
 4081/3DDA : D4                         		db	"T"+80h
 4082/3DDB : C5                         		db	"E"+80h
 4083/3DDC : D0                         		db	"P"+80h
 4084/3DDD : 04                         		db	4		;DATA 4
 4085/3DDE :                            ;		db	"LIST"		;DATA "LIST"
 4086/3DDE : CC                         		db	"L"+80h
 4087/3DDF : C9                         		db	"I"+80h
 4088/3DE0 : D3                         		db	"S"+80h
 4089/3DE1 : D4                         		db	"T"+80h
 4090/3DE2 : 03                         		db	3		;DATA 3
 4091/3DE3 :                            ;		db	"RUN"		;DATA "RUN"
 4092/3DE3 : D2                         		db	"R"+80h
 4093/3DE4 : D5                         		db	"U"+80h
 4094/3DE5 : CE                         		db	"N"+80h
 4095/3DE6 : 03                         		db	3		;DATA 3
 4096/3DE7 :                            ;		db	"SCR"		;DATA "SCR
 4097/3DE7 : D3                         		db	"S"+80h
 4098/3DE8 : C3                         		db	"C"+80h
 4099/3DE9 : D2                         		db	"R"+80h
 4100/3DEA : 0B                         		db	013o		;DATA 013		; CC FOR "READY" MESSAGE
 4101/3DEB : 94 8D 8A                   		db	224o,215o,212o	;DATA 224,215,212	; CTRL-T, CARRIAGE RETURN, LINE FEED
 4102/3DEE :                            ;		db	"READY"		;DATA "READY"
 4103/3DEE : D2                         		db	"R"+80h
 4104/3DEF : C5                         		db	"E"+80h
 4105/3DF0 : C1                         		db	"A"+80h
 4106/3DF1 : C4                         		db	"D"+80h
 4107/3DF2 : D9                         		db	"Y"+80h
 4108/3DF3 : 8D 8A 8A                   		db	215o,212o,212o	;DATA 215,212,212	; CARRIAGE RETURN, LINE FEED, LINE FEED;
 4109/3DF6 : 09                         		db	011o		;DATA 011
 4110/3DF7 :                            ;		db	" AT LINE "	;DATA " AT LINE "
 4111/3DF7 : A0                         		db	" "+80h
 4112/3DF8 : C1                         		db	"A"+80h
 4113/3DF9 : D4                         		db	"T"+80h
 4114/3DFA : A0                         		db	" "+80h
 4115/3DFB : CC                         		db	"L"+80h
 4116/3DFC : C9                         		db	"I"+80h
 4117/3DFD : CE                         		db	"N"+80h
 4118/3DFE : C5                         		db	"E"+80h
 4119/3DFF : A0                         		db	" "+80h
 4120/3E00 :                            
 4121/3E00 :                            	;; THIS SHOULD BE THE END OF PAGE 01
 4122/3E00 :                            
 4123/3E00 :                            ;	ORG	PG26 * 100h	;026#000
 4124/3E00 :                            	ORG	ORG_PG26	;026#000
 4125/3E00 :                            
 4126/3E00 : 00                         	db	0		;DATA 000		; CC FOR INPUT LINE BUFFER
 4127/3E01 : 00 00 00 00 00 00 00 00 00 	db	79 dup (0)	;DATA *79 		; THE INPUT LINE BUFFER
      3E0A : 00 00 00 00 00 00 00 00 00
      3E13 : 00 00 00 00 00 00 00 00 00
      3E1C : 00 00 00 00 00 00 00 00 00
      3E25 : 00 00 00 00 00 00 00 00 00
      3E2E : 00 00 00 00 00 00 00 00 00
      3E37 : 00 00 00 00 00 00 00 00 00
      3E40 : 00 00 00 00 00 00 00 00 00
      3E49 : 00 00 00 00 00 00 00      
 4128/3E50 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; THESE ARE SYMBOL BUFFER STORAGE
 4129/3E54 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4130/3E58 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; SHOULD BE 26-120 TO 26 143
 4131/3E5C : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4132/3E60 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4133/3E64 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; THESE LOCATIONS ARE AUXILIARY SYMBOL BUFFER
 4134/3E68 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4135/3E6C : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; SHOULD BE 26 144 TO 26 175
 4136/3E70 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4137/3E74 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4138/3E78 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4139/3E7C : 00 00                      	db	0,0		;DATA 000,000
 4140/3E7E : 00                         	db	0		;DATA 000		; TEMP SCAN STORAGE REGISTER
 4141/3E7F : 00                         	db	0		;DATA 000		; TAB FLAG
 4142/3E80 : 00                         	db	0		;DATA 000		; EVAL CURRENT TEMP REG.
 4143/3E81 : 00                         	db	0		;DATA 000		; SYNTAX LINE NUMBER
 4144/3E82 : 00                         	db	0		;DATA 000		; SCAN TEMPORARY REGISTER
 4145/3E83 : 00                         	db	0		;DATA 000		; STATEMENT TOKEN
 4146/3E84 : 00 00                      	db	0,0		;DATA 000,000		; TEMPORARY WORKING REGISTERS
 4147/3E86 : 00 00                      	db	0,0		;DATA 000,000		; ARRAY POINTERS
 4148/3E88 :                            ;;; NOW WE SHOULD BE UP TO 26 210 1688h
 4149/3E88 : 00                         	db	0		;DATA 000		; OPERATOR STACK POINTER
 4150/3E89 : 00 00 00 00 00 00 00 00 00 	db	15 dup (0)	;DATA *15		; OPERATOR STACK
      3E92 : 00 00 00 00 00 00         
 4151/3E98 : 00                         	db	0		;DATA 000		; FUN/ARRAY STACK POINTER
 4152/3E99 : 00 00 00 00 00 00 00       	db	7 dup (0)	;DATA *7			; FUNCTION/ARRAY STACK
 4153/3EA0 :                            ;;; THE LAST BYTE SHOULD HAVE BEEN 26 237 169fh
 4154/3EA0 :                            
 4155/3EA0 :                            
 4156/3EA0 :                            	;; HEIRARCHY TABLE (FOR OUT OF STACK OPS)
 4157/3EA0 :                            	;; USED BY PARSER ROUTINE.
 4158/3EA0 :                            ;;; This SHOULD START AT 26 240
 4159/3EA0 : 00                         	db	0		;DATA 000		; EOS
 4160/3EA1 : 03                         	db	3		;DATA 003		; PLUS SIGN
 4161/3EA2 : 03                         	db	3		;DATA 003		; MINUS SIGN
 4162/3EA3 : 04                         	db	4		;DATA 004		; MULTIPLICATION SIGN
 4163/3EA4 : 04                         	db	4		;DATA 004		; DIVISION SIGN
 4164/3EA5 : 05                         	db	5		;DATA 005		; EXPONENT SIGN
 4165/3EA6 : 06                         	db	6		;DATA 006		; LEFT PARENTHESIS
 4166/3EA7 : 01                         	db	1		;DATA 001		; RIGHT PARENTHESIS
 4167/3EA8 : 02                         	db	2		;DATA 002		; NOT ASSIGNED
 4168/3EA9 : 02                         	db	2		;DATA 002		; LESS THAN SIGN
 4169/3EAA : 02                         	db	2		;DATA 002		; Equal sign
 4170/3EAB : 02                         	db	2		;DATA 002		; GREATER THAN SIGN
 4171/3EAC : 02                         	db	2		;DATA 002		; LESS THAN OR EQUAL COMBO
 4172/3EAD : 02                         	db	2		;DATA 002		; EQUAL OR GREATER THAN
 4173/3EAE : 02                         	db	2		;DATA 002		; LESS THAN OR GREATER THAN
 4174/3EAF :                            
 4175/3EAF :                            	;; HEIRARCHY TABLE (FOR INTO STACK OPS)
 4176/3EAF :                            	;; USED BY PARSER ROUTINE.
 4177/3EAF :                            ;;; This SHOULD START AT 26 257 16afh
 4178/3EAF : 00                         	db	0		;DATA 000		; EOS
 4179/3EB0 : 03                         	db	3		;DATA 003		; PLUS SIGN
 4180/3EB1 : 03                         	db	3		;DATA 003		; MINUS SIGN
 4181/3EB2 : 04                         	db	4		;DATA 004		; MULTIPLICATION SIGN
 4182/3EB3 : 04                         	db	4		;DATA 004		; DIVISION SIGN
 4183/3EB4 : 05                         	db	5		;DATA 005		; EXPONENTIATION SIGN
 4184/3EB5 : 01                         	db	1		;DATA 001		; LEFT PARENTHESIS
 4185/3EB6 : 01                         	db	1		;DATA 001		; RIGHT PARENTHESIS
 4186/3EB7 : 02                         	db	2		;DATA 002		; NOT ASSIGNED
 4187/3EB8 : 02                         	db	2		;DATA 002		; LESS THAN SIGN
 4188/3EB9 : 02                         	db	2		;DATA 002		; EQUAL SIGN
 4189/3EBA : 02                         	db	2		;DATA 002		; GREATER THAN SIGN
 4190/3EBB : 02                         	db	2		;DATA 002		; LESS THAN OR EQUAL SIGN
 4191/3EBC : 02                         	db	2		;DATA 002		; EQUAL TO OR GREATER THAN
 4192/3EBD : 02                         	db	2		;DATA 002		; LESS THAN OR GREATER THAN
 4193/3EBE :                            
 4194/3EBE : 00                         	db	0		;DATA 000		; EVAL START POINTER
 4195/3EBF : 00                         	db	0		;DATA 000		; EVAL FINISH POINTER
 4196/3EC0 :                            
 4197/3EC0 :                            	;; FUNCTION NAMES TABLE
 4198/3EC0 :                            ;;; This SHOULD START AT 26 300 16c0h
 4199/3EC0 :                            
 4200/3EC0 : 03                         	db	3		;DATA 3
 4201/3EC1 :                            ;	db	"INT"		;DATA "INT"
 4202/3EC1 : C9                         	db	"I"+80h
 4203/3EC2 : CE                         	db	"N"+80h
 4204/3EC3 : D4                         	db	"T"+80h
 4205/3EC4 : 03                         	db	3		;DATA 3
 4206/3EC5 :                            ;	db	"SGN"		;DATA "SGN"
 4207/3EC5 : D3                         	db	"S"+80h
 4208/3EC6 : C7                         	db	"G"+80h
 4209/3EC7 : CE                         	db	"N"+80h
 4210/3EC8 : 03                         	db	3		;DATA 3
 4211/3EC9 :                            ;	db	"ABS"		;DATA "ABS"
 4212/3EC9 : C1                         	db	"A"+80h
 4213/3ECA : C2                         	db	"B"+80h
 4214/3ECB : D3                         	db	"S"+80h
 4215/3ECC : 03                         	db	3		;DATA 3
 4216/3ECD :                            ;	db	"SQR"		;DATA "SQR"
 4217/3ECD : D3                         	db	"S"+80h
 4218/3ECE : D1                         	db	"Q"+80h
 4219/3ECF : D2                         	db	"R"+80h
 4220/3ED0 : 03                         	db	3		;DATA 3
 4221/3ED1 :                            ;	db	"TAB"		;DATA "TAB"
 4222/3ED1 : D4                         	db	"T"+80h
 4223/3ED2 : C1                         	db	"A"+80h
 4224/3ED3 : C2                         	db	"B"+80h
 4225/3ED4 : 03                         	db	3		;DATA 3
 4226/3ED5 :                            ;	db	"RND"		;DATA "RND"
 4227/3ED5 : D2                         	db	"R"+80h
 4228/3ED6 : CE                         	db	"N"+80h
 4229/3ED7 : C4                         	db	"D"+80h
 4230/3ED8 : 03                         	db	3		;DATA 3
 4231/3ED9 :                            ;	db	"CHR"		;DATA "CHR"
 4232/3ED9 : C3                         	db	"C"+80h
 4233/3EDA : C8                         	db	"H"+80h
 4234/3EDB : D2                         	db	"R"+80h
 4235/3EDC : 03                         	db	3		;DATA 3
 4236/3EDD :                            ;	db	"UDF"		;DATA "UDF"
 4237/3EDD : D5                         	db	"U"+80h
 4238/3EDE : C4                         	db	"D"+80h
 4239/3EDF : C6                         	db	"F"+80h
 4240/3EE0 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; LINE NUMBER BUFFER STORAGE
 4241/3EE4 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; (SHOULD BE 340-347)
 4242/3EE8 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; AUX LINE NUMBER BUFFER
 4243/3EEC : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; (SHOULD BE 350-357)
 4244/3EF0 :                            ;;; The following data is a change in page 3 of Scelbal update issue 4
 4245/3EF0 :                            ;;; which apparently makes the "INSERT" command work correctly, the
 4246/3EF0 :                            ;;; first time (later SCR commands load 33 into this spot) 
 4247/3EF0 : 1B                         	db	033o		;DATA 033 		; USER PGM LINE PTR (PG)
 4248/3EF1 : 00                         	db	0		;DATA 000 		; USER PGM LINE PTR (LOW)
 4249/3EF2 : 00                         	db	0		;DATA 000 		; AUX PGM LINE PTR (PG)
 4250/3EF3 : 00                         	db	0		;DATA 000 		; AUX PGM LINE PTR (LOW)
 4251/3EF4 : 00                         	db	0		;DATA 000 		; END OF USER PGM BUFFER PTR (PG)
 4252/3EF5 : 00                         	db	0		;DATA 000 		; END OF USER PGM BUFFER PTR (LOW)
 4253/3EF6 : 00                         	db	0		;DATA 000		; PARENTHESIS COUNTER (366)
 4254/3EF7 : 00                         	db	0		;DATA 000		; QUOTE INDICATOR
 4255/3EF8 : 00                         	db	0		;DATA 000		; TABLE COUNTER (370)
 4256/3EF9 :                            ;;; locations 371-377 NOT ASSIGNED
 4257/3EF9 :                            
 4258/ 400 :                            	org	PG27 * 100h		;ORG 027#000
 4259/3F00 :                            	org	ORG_PG27		;ORG 027#000
 4260/3F00 : 03                         	db	3		;DATA 3
 4261/3F01 :                            ;	db	"REM"		;DATA "REM"
 4262/3F01 : D2                         	db	"R"+80h
 4263/3F02 : C5                         	db	"E"+80h
 4264/3F03 : CD                         	db	"M"+80h
 4265/3F04 : 02                         	db	2		;DATA 2
 4266/3F05 :                            ;	db	"IF"		;DATA "IF"
 4267/3F05 : C9                         	db	"I"+80h
 4268/3F06 : C6                         	db	"F"+80h
 4269/3F07 : 03                         	db	3		;DATA 3
 4270/3F08 :                            ;	db	"LET"		;DATA "LET"
 4271/3F08 : CC                         	db	"L"+80h
 4272/3F09 : C5                         	db	"E"+80h
 4273/3F0A : D4                         	db	"T"+80h
 4274/3F0B : 04                         	db	4		;DATA 4
 4275/3F0C :                            ;	db	"GOTO"		;DATA "GOTO"
 4276/3F0C : C7                         	db	"G"+80h
 4277/3F0D : CF                         	db	"O"+80h
 4278/3F0E : D4                         	db	"T"+80h
 4279/3F0F : CF                         	db	"O"+80h
 4280/3F10 : 05                         	db	5		;DATA 5
 4281/3F11 :                            ;	db	"PRINT"		;DATA "PRINT"
 4282/3F11 : D0                         	db	"P"+80h
 4283/3F12 : D2                         	db	"R"+80h
 4284/3F13 : C9                         	db	"I"+80h
 4285/3F14 : CE                         	db	"N"+80h
 4286/3F15 : D4                         	db	"T"+80h
 4287/3F16 : 05                         	db	5		;DATA 5
 4288/3F17 :                            ;	db	"INPUT"		;DATA "INPUT"
 4289/3F17 : C9                         	db	"I"+80h
 4290/3F18 : CE                         	db	"N"+80h
 4291/3F19 : D0                         	db	"P"+80h
 4292/3F1A : D5                         	db	"U"+80h
 4293/3F1B : D4                         	db	"T"+80h
 4294/3F1C : 03                         	db	3		;DATA 3
 4295/3F1D :                            ;	db	"FOR"		;DATA "FOR"
 4296/3F1D : C6                         	db	"F"+80h
 4297/3F1E : CF                         	db	"O"+80h
 4298/3F1F : D2                         	db	"R"+80h
 4299/3F20 : 04                         	db	4		;DATA 4
 4300/3F21 :                            ;	db	"NEXT"		;DATA "NEXT"
 4301/3F21 : CE                         	db	"N"+80h
 4302/3F22 : C5                         	db	"E"+80h
 4303/3F23 : D8                         	db	"X"+80h
 4304/3F24 : D4                         	db	"T"+80h
 4305/3F25 : 05                         	db	5		;DATA 5
 4306/3F26 :                            ;	db	"GOSUB"		;DATA "GOSUB"
 4307/3F26 : C7                         	db	"G"+80h
 4308/3F27 : CF                         	db	"O"+80h
 4309/3F28 : D3                         	db	"S"+80h
 4310/3F29 : D5                         	db	"U"+80h
 4311/3F2A : C2                         	db	"B"+80h
 4312/3F2B : 06                         	db	6		;DATA 6
 4313/3F2C :                            ;	db	"RETURN"	;DATA "RETURN"
 4314/3F2C : D2                         	db	"R"+80h
 4315/3F2D : C5                         	db	"E"+80h
 4316/3F2E : D4                         	db	"T"+80h
 4317/3F2F : D5                         	db	"U"+80h
 4318/3F30 : D2                         	db	"R"+80h
 4319/3F31 : CE                         	db	"N"+80h
 4320/3F32 : 03                         	db	3		;DATA 3
 4321/3F33 :                            ;	db	"DIM"		;DATA "DIM"
 4322/3F33 : C4                         	db	"D"+80h
 4323/3F34 : C9                         	db	"I"+80h
 4324/3F35 : CD                         	db	"M"+80h
 4325/3F36 : 03                         	db	3		;DATA 3
 4326/3F37 :                            ;	db	"END"		;DATA "END"
 4327/3F37 : C5                         	db	"E"+80h
 4328/3F38 : CE                         	db	"N"+80h
 4329/3F39 : C4                         	db	"D"+80h
 4330/3F3A : 00                         	db	0		;DATA 0
 4331/3F3B :                            
 4332/3F3B :                            	; END OF TABLE, SHOULD BE 072 3ah
 4333/3F3B :                            
 4334/3F3B : 00                         	db	0		;DATA 000		; GOSUB STACK POINTER
 4335/3F3C : 00                         	db	0		;DATA *1			; NOT ASSIGNED;
 4336/3F3D : 00                         	db	0		;DATA 000		; NUMBER OF ARRAYS COUNTER
 4337/3F3E : 00                         	db	0		;DATA 000		; ARRAY POINTER
 4338/3F3F : 00                         	db	0		;DATA 000		; VARIABLES COUNTER SHOULD BE 077
 4339/3F40 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; USED AS THE GOSUB STACK 100-117
 4340/3F44 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4341/3F48 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4342/3F4C : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4343/3F50 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; USED AS ARRAY VARIABLES TABLE
 4344/3F54 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; SHOULD BE 120-137
 4345/3F58 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4346/3F5C : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4347/3F60 :                            
 4348/3F60 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; USED FOR FOR/NEXT STACK STORAGE
 4349/3F64 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; SHOULD BE 140 TO 177
 4350/3F68 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4351/3F6C : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4352/3F70 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4353/3F74 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4354/3F78 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4355/3F7C : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 4356/3F80 : 00                         	db	0		;DATA 000		; FOR/NEXT STACK POINTER
 4357/3F81 : 00                         	db	0		;DATA 000		; ARRAY/VARIABLE FLAG
 4358/3F82 : 00                         	db	0		;DATA 000  		; STOSYM COUNTER
 4359/3F83 : 00                         	db	0		;DATA 000		; FUN/ARRAY STACK POINTER (203
 4360/3F84 : 00                         	db	0		;DATA 000		; ARRAY VALUES POINTER
 4361/3F85 : 00 00 00                   	db	0,0,0		;DATA *3			; NOT USED (SHOULD BE 205-207)
 4362/3F88 : 00                         	db	0		;DATA 000		; USED AS VARIABLES SYMBOL TABLE
 4363/3F89 : 00 00 00 00 00 00 00 00 00 	db	119 dup (0)	;DATA *119		; (SHOULD BE 211-377 RESERVED)
      3F92 : 00 00 00 00 00 00 00 00 00
      3F9B : 00 00 00 00 00 00 00 00 00
      3FA4 : 00 00 00 00 00 00 00 00 00
      3FAD : 00 00 00 00 00 00 00 00 00
      3FB6 : 00 00 00 00 00 00 00 00 00
      3FBF : 00 00 00 00 00 00 00 00 00
      3FC8 : 00 00 00 00 00 00 00 00 00
      3FD1 : 00 00 00 00 00 00 00 00 00
      3FDA : 00 00 00 00 00 00 00 00 00
      3FE3 : 00 00 00 00 00 00 00 00 00
      3FEC : 00 00 00 00 00 00 00 00 00
      3FF5 : 00 00 00 00 00 00 00 00 00
      3FFE : 00 00                     
 4364/4000 :                            
 4365/4000 :                            
 AS V1.42 Beta [Bld 290] - Source File sc1.asm - Page 3 - 8/11/2025 18:46:17


  Symbol Table (* = unused):
  --------------------------

 ABSX :                        2702 C |  ACCSET :                      2F79 C |
 ACNONZ :                      2F66 C |  ACZERT :                      2F53 C |
 AD4DE :                       25CA C |  ADBDE :                       29CA C |
 ADDER :                       315E C | *ADDEXP :                      3030 C |
 ADDMOR :                      315F C |  ADOPPP :                      30BF C |
 ADV :                         221B C |  ADVDE :                       2A3F C |
 AHEAD1 :                      3397 C |  AHEAD2 :                      34E2 C |
*ARCHITECTURE :                                        "i386-unknown-win32" - |
 ARRAY :                       3811 C |  ARRAY1 :                      3817 C |
 ARRAY2 :                      381C C |  ARRAY3 :                      381E C |
 ARRAY4 :                      3828 C |  ARRAY5 :                      3841 C |
 ARRAY6 :                      384C C |  ARRAY7 :                      3876 C |
 BACKSP :                      3683 C |  BGNPGRAM :                       6 - |
 BIGERR :                      21AE C | *BRING1 :                      300E C |
*CASESENSITIVE :                  0 - |  CFALSE :                      25C3 C |
 CHRX :                        271B C |  CINP :                        20CD C |
 CINPUT :                      22AD C |  CINP_BS :                     20DD C |
 CKDECP :                      3466 C | *CKEQEX :                      2FA5 C |
 CKSIGN :                      307D C |  CLESYM :                      21C9 C |
 CLRNEX :                      3084 C |  CLRNX1 :                      308E C |
 CLRNX2 :                      3234 C |  CLRNX3 :                      323E C |
*CLROPL :                      308A C |  CODE_START :                  2000 - |
 COMPEN :                      340F C |  COMPLM :                      316F C |
 CONCT1 :                      21E8 C | *CONCTA :                      21D0 C |
 CONCTE :                      21F3 C |  CONCTN :                      21DA C |
 CONCTS :                      21E4 C | *CONSTPI :        3.141592653589793 - |
 CONTIN :                      2940 C |  CPHLDE :                      29C4 C |
 CPRINT :                      20E0 C |  CPRINT_1 :                    20F7 C |
 CP_BS :                       2100 C |  CP_BS2 :                      2109 C |
 CP_BS3 :                      2112 C |  CP_NO :                       20FF C |
 CP_OK :                       20F6 C |  CRLF :                        227D C |
 CROUND :                      30CE C |  CTRLC :                       29D0 C |
 CTRUE :                       25BE C |  DATE :                 "8/11/2025" - |
 DEC :                         2290 C |  DECBIN :                      3335 C |
 DECEXD :                      33E5 C |  DECEXT :                      33C6 C |
 DECNO :                       2296 C |  DECOUT :                      33F7 C |
 DECRDG :                      3451 C |  DECREP :                      33DE C |
 DIM :                         38A1 C |  DIM1 :                        38AB C |
 DIM10 :                       3982 C |  DIM2 :                        38BB C |
 DIM3 :                        38C6 C |  DIM4 :                        38CA C |
 DIM5 :                        391B C |  DIM6 :                        3935 C |
 DIM7 :                        3940 C | *DIM8 :                        3965 C |
 DIM9 :                        396D C |  DIMERR :                      398B C |
 DINPUT :                      322B C |  DIRECT :                      2A94 C |
 DIVIDE :                      30F0 C |  DVERR :                       29FA C |
 DVEXIT :                      313F C |  DVLOOP :                      260E C |
 ECHO :                        229E C |  ENDINP :                      32D0 C |
 ENDPGRAM :                      1E - |  ENTRY_SCR :                   2826 C |
 EQ :                          257A C |  ERROR :                       21B2 C |
 EVAL :                        22B0 C |  EXEC :                        27D2 C |
 EXEC1 :                       27D9 C |  EXIT :                        20B5 C |
 EXMLDV :                      306D C |  EXOUTN :                      34DB C |
 EXPINP :                      32A8 C |  EXPOK :                       3307 C |
 EXPOUT :                      34C7 C |  FACXOP :                      31C6 C |
 FAERR :                       2696 C | *FALSE :                          0 - |
 FINER1 :                      29EE C |  FINERR :                      29D7 C |
 FININP :                      32DE C |  FIXERR :                      2A01 C |
 FLOAD :                       31AB C | *FLOATMAX :      1.797693134866E308 - |
 FNDEXP :                      3298 C |  FOR :                         2E7F C |
 FOR1 :                        2EB5 C |  FOR2 :                        2EC1 C |
 FOR3 :                        2ED3 C |  FOR4 :                        2EDE C |
 FOR5 :                        369A C |  FORERR :                      2EAE C |
 FORNXT :                      3545 C |  FP0 :                         2E7A C |
 FPADD :                       2F8C C |  FPCOMP :                      2F85 C |
 FPD10 :                       3322 C |  FPDIV :                       30D9 C |
 FPFIX :                       2F03 C |  FPFIXL :                      2F1E C |
 FPFLT :                       2F37 C |  FPMULT :                      302D C |
 FPNORM :                      2F39 C |  FPONE :                       25BE C |
 FPOPER :                      2510 C |  FPOUT :                       337C C |
 FPSUB :                       3021 C |  FPX10 :                       330F C |
 FPZERO :                      2F2C C |  FRAC :                        2BF3 C |
*FSHIFT :                      3009 C |  FSTORE :                      31B4 C |
 FUNAR1 :                      2669 C |  FUNAR2 :                      37D8 C |
 FUNAR3 :                      3800 C |  FUNAR4 :                      26A3 C |
 FUNARR :                      265C C |  GE :                          25A7 C |
 GETAU0 :                      28A5 C |  GETAU1 :                      28BE C |
 GETAU2 :                      28D3 C |  GETAUX :                      289B C |
 GETCHP :                      2958 C |  GETCHR :                      21BC C |
 GETINP :                      31FC C |  GOSERR :                      2DF2 C |
 GOSUB :                       2DA9 C |  GOSUB1 :                      2DB8 C |
 GOTO :                        2C87 C |  GOTO1 :                       2C94 C |
 GOTO2 :                       2CAB C |  GOTO3 :                       2CB3 C |
 GOTO4 :                       2CBC C |  GOTO5 :                       2CC3 C |
 GOTO6 :                       2CD8 C |  GOTO7 :                       2CEB C |
*GOTOER :                      2D1B C |  GT :                          2587 C |
 HAJIME :                      2081 C | *HAS64 :                          1 - |
 IF :                          2D22 C |  IF1 :                         2D4D C |
 IF2 :                         2D6E C |  IF3 :                         2D81 C |
 IF4 :                         2D8B C |  IFERR :                       2D46 C |
*INCLIN :                      29B2 C |  INDEXB :                      2298 C |
 INDEXC :                      3225 C |  INPUT :                       2E00 C |
 INPUT1 :                      2E0A C |  INPUT2 :                      2E2A C |
 INPUT3 :                      2E2D C |  INPUT4 :                      2E3E C |
 INPUTN :                      2E6B C |  INPUTX :                      2E4F C |
 INSER1 :                      299E C |  INSER3 :                      29B2 C |
 INSERT :                      298A C |  INSTR :                       2A15 C |
 INSTR1 :                      2A19 C |  INSTR2 :                      2A3C C |
 INT1 :                        26F3 C |  INT2 :                        26FD C |
 INTEXP :                      25CF C |  INTX :                        26BF C |
*INT_PTR :                       41 - |  IN_DATA :                        1 - |
 IN_DIGIT_CC_L :                 45 - | *IN_DIGIT_CC_L0 :              3D45 C |
 IN_STATUS :                      0 - |  JMP_ADDR :                    1EFC - |
 LE :                          2597 C |  LET :                         2C24 C |
 LET0 :                        2C16 C |  LET1 :                        2C2D C |
 LET2 :                        2C36 C |  LET3 :                        2C56 C |
 LET4 :                        2C5D C |  LET5 :                        2C6C C |
*LETERR :                      2C65 C |  LINEUP :                      2FC6 C |
 LIST :                        27F7 C | *LISTON :                         1 - |
 LOOK0 :                       2F57 C |  LOOKU1 :                      244D C |
 LOOKU2 :                      2465 C |  LOOKU4 :                      249D C |
 LOOKUP :                      2437 C |  LOOP :                        221F C |
 LOOP_PG01 :                   208E C |  LOOP_PG26 :                   209C C |
 LOOP_PG27 :                   20AA C |  LT :                          256D C |
*MACEXP :                         7 - |  MINEXP :                      3322 C |
*MOMCPU :                     8008E - | *MOMCPUNAME :             "8008NEW" - |
 MON :                         20B9 C |  MORACC :                      2FCE C |
 MORCOM :                      3174 C |  MOROP :                       2FDB C |
 MOVEC :                       292B C |  MOVECP :                      27CD C |
 MOVEIT :                      3012 C |  MOVEPG :                      292D C |
 MOVOP :                       2F95 C |  MROUND :                      30C9 C |
 MULOOP :                      25FD C |  MULTIP :                      303D C |
 NE :                          25B4 C |  NEGEXP :                      36E7 C |
 NEGFPA :                      30B0 C | *NESTMAX :                      100 - |
 NEXT :                        34FF C |  NEXT1 :                       350C C |
 NEXT10 :                      3657 C |  NEXT11 :                      366C C |
 NEXT12 :                      3673 C |  NEXT2 :                       3519 C |
 NEXT3 :                       352D C |  NEXT4 :                       354C C |
 NEXT5 :                       35B4 C |  NEXT6 :                       35DD C |
 NEXT7 :                       35F9 C |  NEXT8 :                       360B C |
 NEXT9 :                       3616 C |  NINPUT :                      3254 C |
 NODECP :                      3473 C |  NOEXC0 :                      2F43 C |
 NOEXPO :                      2421 C |  NOEXPS :                      32AB C |
 NOGO :                        3105 C |  NOLIST :                      2808 C |
 NONZAC :                      2FA0 C |  NOREMD :                      36F5 C |
 NOSAME :                      290A C |  NOSCR :                       2855 C |
 NOT0 :                        320F C |  NOTDEL :                      2241 C |
 NOTEND :                      28E3 C |  NOTPLM :                      3257 C |
 NUMERR :                      2A08 C |  NXTLIN :                      2A59 C |
 OPLOAD :                      31BD C |  OPN :                         2003 C |
 OPN_MSG :                     2004 C |  OPN_MSG1 :                    2080 C |
 OPSGNT :                      309F C |  ORG_PG01 :                    3D00 - |
 ORG_PG26 :                    3E00 - |  ORG_PG27 :                    3F00 - |
 OUTDGS :                      342C C |  OUTDGX :                      344C C |
 OUTDIG :                      3421 C |  OUTFIX :                      33C0 C |
 OUTFLT :                      33B2 C |  OUTNEG :                      338E C |
 OUTRNG :                      380A C |  OUTX10 :                      349A C |
 OUTZER :                      344B C |  OUT_DATA :                      10 - |
 PARNER :                      2560 C |  PARNUM :                      240A C |
 PARSE :                       24B5 C |  PARSE1 :                      24E3 C |
 PARSE2 :                      24F6 C |  PARSEP :                      36B4 C |
 PARSER :                      23F0 C | *PATCH1 :                      2FE4 C |
*PATCH2 :                      3739 C | *PATCH3 :                      29F1 C |
 PCOM1 :                       2C0E C |  PCOMMA :                      2BFA C |
 PERIOD :                      3288 C |  PFPOUT :                      2BD7 C |
 PG01 :                           2 - |  PG26 :                           3 - |
 PG27 :                           4 - |  PG57 :                           5 - |
 POSEXP :                      32FC C |  PRIGH1 :                      37AC C |
 PRIGHT :                      261F C |  PRINT :                       2AF0 C |
 PRINT1 :                      2B01 C |  PRINT2 :                      2B0D C |
 PRINT3 :                      2B2E C |  PRINT4 :                      2B48 C |
*PRINT5 :                      2B57 C |  PRINT6 :                      2B60 C |
 PUSHIT :                      3460 C |  QUOROT :                      3106 C |
 QUOTE :                       2B8E C |  QUOTE1 :                      2B9B C |
 QUOTE2 :                      2BBE C | *QUOTER :                      2BB1 C |
*RELAXED :                        0 - |  REMOV1 :                      297C C |
 REMOVE :                      2969 C |  RESIGN :                      2F80 C |
 RESTHL :                      31E6 C |  RESTSY :                      27C6 C |
 RETERR :                      2DF9 C |  RETURN :                      2DCF C |
 RNDX :                        3762 C |  ROTATL :                      3186 C |
 ROTATR :                      3190 C |  ROTL :                        3187 C |
 ROTR :                        3191 C |  RUN :                         2A43 C |
 SAMLIN :                      2A79 C |  SAVEHL :                      31D6 C |
 SAVESY :                      27BC C |  SCAN1 :                       22C8 C |
 SCAN10 :                      23DD C |  SCAN11 :                      237F C |
 SCAN12 :                      23A2 C |  SCAN13 :                      23C5 C |
 SCAN14 :                      23CC C |  SCAN15 :                      23D3 C |
 SCAN16 :                      23DA C |  SCAN2 :                       22DC C |
 SCAN3 :                       2301 C |  SCAN4 :                       230B C |
 SCAN5 :                       2317 C |  SCAN6 :                       2323 C |
 SCAN7 :                       2337 C |  SCAN8 :                       2350 C |
 SCAN9 :                       235C C |  SCANFN :                      2305 C |
 SCRLOP :                      284C C | *SETDCT :                      30EC C |
 SETIT :                       31C1 C | *SETMCT :                      3039 C |
 SETSUB :                      3148 C |  SGNX :                        270C C |
 SHACOP :                      2FE4 C |  SHIFT0 :                      2FDA C |
 SHLOOP :                      3003 C |  SKPNEG :                      2FB7 C |
*SQR1 :                        3742 C |  SQRCNV :                      374F C |
 SQRERR :                      375B C |  SQREXP :                      36F8 C |
 SQRLOP :                      370D C |  SQRX :                        36C6 C |
 STOSY1 :                      275C C |  STOSY2 :                      2772 C |
 STOSY3 :                      278A C |  STOSY5 :                      27B3 C |
 STOSYM :                      2749 C |  STRCP :                       21F6 C |
 STRCPC :                      2214 C |  STRCPE :                      220A C |
 STRCPL :                      2200 C |  STRIN :                       2228 C |
 STRIN1 :                      222A C |  STRINF :                      225E C |
 SUB12 :                       34E8 C |  SUBBER :                      319A C |
*SUBEXP :                      30E3 C |  SUBHL :                       2267 C |
 SUBTRA :                      319B C |  SWITCH :                      31F5 C |
 SYNERR :                      2886 C |  SYNTAX :                      211C C |
 SYNTOK :                      288D C |  SYNTX1 :                      2129 C |
 SYNTX2 :                      2140 C |  SYNTX3 :                      214D C |
 SYNTX4 :                      2153 C |  SYNTX5 :                      2178 C |
 SYNTX6 :                      2170 C |  SYNTX7 :                      21A4 C |
 SYNTX8 :                      21A9 C |  SYNTXL :                      2183 C |
 TAB1 :                        272E C |  TABAD1 :                      26B5 C |
 TABADR :                      26B4 C | *TABC :                        273E C |
 TABLOP :                      2741 C |  TABX :                        272B C |
 TEXTC :                       226D C |  TEXTCL :                      2271 C |
 TIME :                  "18:46:17" - |  TOMUCH :                      34F2 C |
*TRUE :                           1 - |  UDEFX :                       20B6 C |
*VERSION :                     142F - | *Z80SYNTAX :                      0 - |
 ZERO :                        2BE9 C |  ZERODG :                      347C C |

    423 symbols
     37 unused symbols

 AS V1.42 Beta [Bld 290] - Source File sc1.asm - Page 4 - 8/11/2025 18:46:17


  Defined Functions:
  ------------------

LO                                    | HI                                   

 AS V1.42 Beta [Bld 290] - Source File sc1.asm - Page 5 - 8/11/2025 18:46:17


  Code Pages:
  ----------

STANDARD (0 changed characters)

1 code page

0.21 seconds assembly time

   4365 lines source file
      2 passes
      0 errors
      0 warnings
