 AS V1.42 Beta [Bld 290] - Source File monitor.asm - Page 1 - 8/11/2025 18:35:26


    1/   0 :                                        PAGE 0             ; suppress page headings in ASW listing file
    2/   0 :                            ;
    3/   0 :                            ; Copyright (c) 2025 by Gazelle
    4/   0 :                            ;
    5/   0 :                            ;/* Permission is hereby granted, free of charge, to any person obtaining
    6/   0 :                            ; * a copy of this software and associated documentation files (the
    7/   0 :                            ; * "Software"), to deal in the Software without restriction, including
    8/   0 :                            ; * without limitation the rights to use, copy, modify, merge, publish,
    9/   0 :                            ; * distribute, sublicense, and/or sell copies of the Software, and to
   10/   0 :                            ; * permit persons to whom the Software is furnished to do so, subject to
   11/   0 :                            ; * the following conditions:
   12/   0 :                            ; *
   13/   0 :                            ; * The above copyright notice and this permission notice shall be
   14/   0 :                            ; * included in all copies or substantial portions of the Software.
   15/   0 :                            ; *
   16/   0 :                            ; * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   17/   0 :                            ; * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   18/   0 :                            ; * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   19/   0 :                            ; * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   20/   0 :                            ; * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   21/   0 :                            ; * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   22/   0 :                            ; * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   23/   0 :                            ; */
   24/   0 :                            ;
   25/   0 :                            ; Serial monitor for EMU8008 based on Product of Jim Loos
   26/   0 :                            ; modified for EMU8008 by Gazelle
   27/   0 :                            ;
   28/   0 :                            ; Repsitory https://github.com/Gazelle8087/EMU8008
   29/   0 :                            ; 
   30/   0 :                            ; 2025/08/11 Rev. 1.00 Initial release
   31/   0 :                            ;
   32/   0 :                            ;---------------------------------------------------------------------------------------------------------------------------------
   33/   0 :                            ; Copyright 2022 Jim Loos
   34/   0 :                            ;
   35/   0 :                            ; Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files
   36/   0 :                            ; (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge,
   37/   0 :                            ; publish, distribute, sub-license, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do
   38/   0 :                            ; so, subject to the following conditions:
   39/   0 :                            ;
   40/   0 :                            ; The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
   41/   0 :                            ;
   42/   0 :                            ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
   43/   0 :                            ; OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   44/   0 :                            ; LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
   45/   0 :                            ; IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   46/   0 :                            ;---------------------------------------------------------------------------------------------------------------------------------
   47/   0 :                            
   48/   0 :                            ;------------------------------------------------------------------------
   49/   0 :                            ; Serial Monitor for 8008 SBC
   50/   0 :                            ;
   51/   0 :                            ; Commands:
   52/   0 :                            ;   B - Binary file download (no error checking)
   53/   0 :                            ;   C - Call subroutine
   54/   0 :                            ;   D - Dump memory
   55/   0 :                            ;   E - Examine/modify memory
   56/   0 :                            ;   F - Fill memory
   57/   0 :                            ;   G - Goto address
   58/   0 :                            ;   H - Intel Hex file download
   59/   0 :                            ;   I - Input from port
   60/   0 :                            ;   J - Jump to address
   61/   0 :                            ;   O - Output to port
   62/   0 :                            ;   S - SCELBAL
   63/   0 :                            ;
   64/   0 :                            ; V2.0 uses 16K of the 32K 27256 EPROM. the Serial Monitor occupies the first 8K of the EPROM. 
   65/   0 :                            ; the Scelbi BASIC Interpreter (SCELBAL) occupies the second 8K of the EPROM. when reset, the SBC
   66/   0 :                            ; starts executing code from the first 8K of EPROM (Monitor). when 'S' is entered at the Monitor's 
   67/   0 :                            ; prompt, the SBC 'bank switches' to select the second 8K of the 27256 EPROM for execution (SCELBAL).
   68/   0 :                            ;
   69/   0 :                            ; assemble both 'monitor.asm' and 'scelbal-in-eprom.asm' with the AS Macro Assembler 
   70/   0 :                            ; (http://john.ccac.rwth-aachen.de:8000/as/). use the assembler's P2BIN utility to generate two 
   71/   0 :                            ; binary files. concatenate the resulting two binary files into one file for your EPROM programmer.
   72/   0 :                            ; one way is to use the DOS 'COPY' command: 'copy /b monitor.bin + scelbal-in-eprom.bin eprom.bin'.
   73/   0 :                            ; I prefer to use the concatenate function in the Freeware Hex Editor 'HxD' by Maël Hörz
   74/   0 :                            ; (https://mh-nexus.de/en/hxd/)
   75/   0 :                            ;
   76/   0 :                            ; serial I/O at 2400 bps N-8-1
   77/   0 :                            ;------------------------------------------------------------------------
   78/   0 :                            
   79/   0 :                            ;		include "bitfuncs.inc"	;comment out by Gazelle
   80/   0 :                            
   81/   0 :                            hi		FUNCTION hex4,hex4/256	;midified by Gazelle
   82/   0 :                            lo		FUNCTION hex4,hex4&0ffh	;modified by Gazelle
   83/   0 :                            
   84/   0 :                            		cpu 8008new             ; use "new" 8008 mnemonics
   85/   0 :                            
   86/   0 :                            ; temporary storage for registers;
   87/   0 : =1EF0H                     save_H:		equ	1ef0h		;midified by Gazelle
   88/   0 : =1EF1H                     save_L:		equ	1ef1h		;midified by Gazelle
   89/   0 : =1EF2H                     save_B:		equ	1ef2h		;midified by Gazelle
   90/   0 : =1EF3H                     save_C:		equ	1ef3h		;midified by Gazelle
   91/   0 : =1EF4H                     save_D:		equ	1ef4h		;midified by Gazelle
   92/   0 : =1EF5H                     save_E:		equ	1ef5h		;midified by Gazelle
   93/   0 : =1EF6H                     esccount:	equ	1ef6h		;midified by Gazelle
   94/   0 : =1EFCH                     jmp_addr:	equ	1efcH		;midified by Gazelle
   95/   0 :                            
   96/   0 : =1BH                       ESCAPE		equ	1bh
   97/   0 : =0DH                       RETURN		equ	0dh
   98/   0 :                            
   99/   0 : =0H                        IN_STATUS	equ 	00h		;DO NOT change, Should match to PIC firmware
  100/   0 : =1H                        IN_DATA		equ	01h		;DO NOT change, Should match to PIC firmware
  101/   0 : =2H                        index_A		equ	02h		;A = ram[A]
  102/   0 : =3H                        restore_A	equ	03h
  103/   0 : =4H                        rentore_flag	equ	04h
  104/   0 : =5H                        data_get	equ	05h
  105/   0 : =6H                        data_SP_read	equ	06h
  106/   0 : =7H                        data_POP	equ	07h
  107/   0 :                            
  108/   0 : =8H                        INT_port	equ	08h
  109/   0 : =9H                        INT_exit	equ	09h
  110/   0 : =0AH                       ROM_offset	equ	0ah
  111/   0 : =0BH                       save_A		equ	0bh
  112/   0 : =0CH                       save_flag	equ	0ch
  113/   0 : =0DH                       data_put	equ	0dh
  114/   0 : =0EH                       data_SP_write	equ	0eh
  115/   0 : =0FH                       data_PUSH	equ	0fh
  116/   0 : =10H                       OUT_DATA	equ 	10h		;DO NOT change, Should match to PIC firmware
  117/   0 :                            
  118/   0 :                            ; when the reset pushbutton is pressed, the flip-flop is set which generates an interrupt
  119/   0 :                            ; and clears the address latches. thus, the first instruction is thus always fetched from 
  120/   0 :                            ; address 0. the instruction at address 0 must be a single byte transfer instruction in 
  121/   0 :                            ; order to set the program counter. i.e., it must be one of the RST opcodes.
  122/   0 :                            
  123/   0 : =41H                       INT_PTR		equ	41h		;DO NOT change, Should match to PIC firmware
  124/   0 : =3CH                       HLT_addr	equ	3ch
  125/   0 : =34H                       RST_addr	equ	34h
  126/   0 : =50H                       HLT_vector	equ	50h
  127/   0 : =60H                       INT_vector	equ	60h
  128/   0 : =80H                       INT_log		equ	80h
  129/   0 :                            
  130/   0 :                            		org	0
  131/   0 : 44 00 20                   		jmp	start		;inturrupt procedure
  132/   3 : 53                         		out	INT_exit	;DO NOT delete this "OUT INT_exit" need to exit from INT procedure
  133/   4 :                            
  134/   8 :                            		org	8
  135/   8 : 44 36 26                   		jmp	putch
  136/   B :                            
  137/  10 :                            		org	10h
  138/  10 : 44 1D 26                   		jmp	getch
  139/  13 :                            
  140/  3C :                            		org	HLT_addr	;after HLT inturrupt come here
  141/  3C : 44 03 20                   		jmp	HLT_break
  142/  3F :                            
  143/  48 :                            		org	48h
  144/  48 : 4E 67 3E 01 7F 1D 1D 7F    		db	4eh,67h,3eh,1h,7fh,1dh,1dh,7fh	;"CPU-8008"
  145/  50 :                            
  146/  50 :                            
  147/  41 :                            		org	INT_PTR		;PIC fetch inturrupt code from ram[INT_PTR]
  148/  41 : 00                         		db	0		;Power on INT code stored in ram[0]
  149/  42 : 80                         		db	INT_log		;Inturrupt log will be stored in ram[INT_log]-
  150/  43 :                            
  151/  50 :                            		org	HLT_vector	;HLT inturrput execution code aray
  152/  50 : 07                         		ret
  153/  51 : 07                         		ret
  154/  52 : 07                         		ret
  155/  53 : 07                         		ret
  156/  54 : 07                         		ret
  157/  55 : 07                         		ret
  158/  56 : 07                         		ret
  159/  57 : 07                         		ret
  160/  58 : 44 3C 00                   		jmp	HLT_addr
  161/  5B : 53                         		out	INT_exit	;DO NOT delete this OUT
  162/  5C :                            
  163/  60 :                            		org	INT_vector	;software intturrupt code array
  164/  60 : 44                         		db	44h		;jmp	111h
  165/  61 : 11                         stack1_l	db	11h
  166/  62 : 01                         stack1_h	db	01h
  167/  63 : 46                         		db	46h		;call	222h
  168/  64 : 22                         stack2_l	db	22h
  169/  65 : 02                         stack2_h	db	02h
  170/  66 : 46                         		db	46h		;call	333h
  171/  67 : 33                         stack3_l	db	33h
  172/  68 : 03                         stack3_h	db	03h
  173/  69 : 46                         		db	46h		;call	444h
  174/  6A : 44                         stack4_l	db	44h
  175/  6B : 04                         stack4_h	db	04h
  176/  6C : 46                         		db	46h		;call	555h
  177/  6D : 55                         stack5_l	db	55h
  178/  6E : 05                         stack5_h	db	05h
  179/  6F : 46                         		db	46h		;call	666h
  180/  70 : 66                         stack6_l	db	66h
  181/  71 : 06                         stack6_h	db	06h
  182/  72 : 46                         		db	46h		;call	777h
  183/  73 : 77                         stack7_l	db	77h
  184/  74 : 07                         stack7_h	db	07h
  185/  75 : 46                         		db	46h		;call	RST_addr
  186/  76 : 34 00                      stack8		dw	RST_addr
  187/  78 : 53                         		out	INT_exit
  188/  79 :                            
  189/2000 :                            		org	2000H		; start of EPROM
  190/2000 : 44 3B 20                   start:		jmp	start0
  191/2003 :                            
  192/2003 :                            HLT_break:
  193/2003 : 57                         		out	save_A		;save A
  194/2004 : 47                         		in	restore_A	;save flag into [43h] C=d3 P=d2 Z=d1 S=d0
  195/2005 : 06 00                      		mvi	a,0
  196/2007 : 1A                         		rar			;if CY=1 then A equal 80h
  197/2008 : 68 18 20                   		jz	gsav3		;C=d3 P=d2 Z=d1 S=d0
  198/200B : 0E 18                      		mvi	b,18h
  199/200D : 50 12 20                   		jp	gsav1
  200/2010 : 0E 78                      		mvi	b,78h
  201/2012 : 78 17 20                   gsav1:		jpe	gsav2
  202/2015 : 34 04                      		ori	04h
  203/2017 : B1                         gsav2:		ora	b
  204/2018 : 59                         gsav3:		out	save_flag
  205/2019 :                            
  206/2019 : 2E 20                      		mvi	h,hi(break_msg)
  207/201B : 36 32                      		mvi	l,lo(break_msg)
  208/201D : 46 0F 26                   		call	puts
  209/2020 : 2E 00                      		mvi	h,0
  210/2022 : 36 81                      		mvi	l,81h
  211/2024 : C7                         		mov	a,m
  212/2025 : 46 CF 25                   		call	write_hex
  213/2028 : 31                         		dcr	l
  214/2029 : C7                         		mov	a,m
  215/202A : 14 01                      		sui	1
  216/202C : 46 CF 25                   		call	write_hex
  217/202F : 44 4F 20                   		jmp	prompt
  218/2032 :                            
  219/2032 : 48 61 6C 74 20 61 74 20 00 break_msg	db	"Halt at ",0
  220/203B :                            
  221/203B : 2E 1E                      start0:     mvi h,hi(esccount)          ; clear the escape key counter
  222/203D : 36 F6                                  mvi l,lo(esccount)
  223/203F : 3E 00                                  mvi m,0
  224/2041 :                            
  225/2041 : 2E 26                                  mvi h,hi(titletxt)          ; display the title
  226/2043 : 36 4C                                  mvi l,lo(titletxt)
  227/2045 : 46 0F 26                               call puts
  228/2048 :                            
  229/2048 : 2E 26                      menu:       mvi h,hi(menutxt)           ; display the menu
  230/204A : 36 C2                                  mvi l,lo(menutxt)
  231/204C : 46 0F 26                               call puts
  232/204F :                            
  233/204F : 2E 27                      prompt:     mvi h,hi(prompttxt)         ; prompt for input
  234/2051 : 36 9B                                  mvi l,lo(prompttxt)
  235/2053 : 46 0F 26                               call puts
  236/2056 : 46 1D 26                   prompt0:    call getch                  ; get input command from user
  237/2059 : 3C 3A                                  cpi ':'
  238/205B : 68 40 22                               jz hexdl1a                  ; hex file download started
  239/205E : 3C 1B                                  cpi ESCAPE                  ; is the input the escape key?
  240/2060 : 48 6D 20                               jnz prompt1                 ; nope
  241/2063 : 2E 1E                                  mvi h,hi(esccount)
  242/2065 : 36 F6                                  mvi l,lo(esccount)
  243/2067 : CF                                     mov b,m
  244/2068 : 08                                     inr b                       ; yes, increment the escape key count
  245/2069 : F9                                     mov m,b
  246/206A : 44 56 20                               jmp prompt0                 ; go back for more imput
  247/206D : 3C 3F                      prompt1:    cpi '?'                     ; is the input '?'
  248/206F : 48 88 20                               jnz prompt2                 ; nope 
  249/2072 : 2E 1E                                  mvi h,hi(esccount)
  250/2074 : 36 F6                                  mvi l,lo(esccount)
  251/2076 : C7                                     mov a,m
  252/2077 : 3E 00                                  mvi m,0
  253/2079 : 3C 02                                  cpi 2                       ; was the escape key pressed twice in succession?
  254/207B : 48 48 20                               jnz menu                    ; nope, display the menu
  255/207E : 2E 29                                  mvi h,hi(copytxt)           ; escape, escape followed by '?' displays the copyright notice
  256/2080 : 36 8F                                  mvi l,lo(copytxt)
  257/2082 : 46 0F 26                               call puts
  258/2085 : 44 4F 20                               jmp prompt
  259/2088 :                            
  260/2088 : 2E 1E                      prompt2:    mvi h,hi(esccount)
  261/208A : 36 F6                                  mvi l,lo(esccount)
  262/208C : 3E 00                                  mvi m,0
  263/208E : 3C 61                                  cpi 'a'                     ; is the input character below 'a'?
  264/2090 : 60 95 20                               jc $+5                      ; skip the next instruction if the character is already upper case
  265/2093 : 14 20                                  sui 20H                     ; else, convert to the character to upper case
  266/2095 : 46 36 26                               call putch                  ; echo the character
  267/2098 : 3C 42                                  cpi 'B'
  268/209A : 68 F8 21                               jz bindl                    ; binary file download
  269/209D : 3C 43                                  cpi 'C'
  270/209F : 68 EA 22                               jz callsub                  ; call subroutine
  271/20A2 : 3C 44                                  cpi 'D'
  272/20A4 : 68 DC 20                               jz dump                     ; dump memory
  273/20A7 : 3C 45                                  cpi 'E'
  274/20A9 : 68 8D 21                               jz examine                  ; examine/modify memory
  275/20AC : 3C 46                                  cpi 'F'
  276/20AE : 68 4D 21                               jz fill                     ; fill memory
  277/20B1 : 3C 47                                  cpi 'G'
  278/20B3 : 68 BB 22                               jz goto                     ; goto address
  279/20B6 : 3C 48                                  cpi 'H'
  280/20B8 : 68 2A 22                               jz hexdl                    ; Intel hex file download
  281/20BB : 3C 49                                  cpi 'I'
  282/20BD : 68 0F 23                               jz input                    ; input from port
  283/20C0 : 3C 4A                                  cpi 'J'
  284/20C2 : 68 CB 22                               jz jump                     ; jump to address
  285/20C5 : 3C 4F                                  cpi 'O'
  286/20C7 : 68 45 23                               jz output                   ; output to port
  287/20CA : 3C 53                                  cpi 'S'
  288/20CC : 68 80 23                               jz scelbal                  ; jump to SCELBAL
  289/20CF : 3C 0D                                  cpi 0DH
  290/20D1 : 68 48 20                               jz menu                     ; display the menu
  291/20D4 : 06 3F                                  mvi a,'?'
  292/20D6 : 46 36 26                               call putch                  ; whaaat??
  293/20D9 : 44 4F 20                               jmp prompt
  294/20DC :                            
  295/20DC :                            ;------------------------------------------------------------------------
  296/20DC :                            ; dump a page of memory in hex and ascii
  297/20DC :                            ; space key aborts display.
  298/20DC :                            ;------------------------------------------------------------------------
  299/20DC : 2E 27                      dump:       mvi h,hi(dumptxt)
  300/20DE : 36 9F                                  mvi l,lo(dumptxt)
  301/20E0 : 46 0F 26                               call puts     
  302/20E3 : 46 A3 23                               call get_addr               ; get the four digit address
  303/20E6 : 60 4F 20                               jc prompt                   ; exit prematurely if space, enter or escape
  304/20E9 : 2E 28                                  mvi h,hi(columntxt)
  305/20EB : 36 A4                                  mvi l,lo(columntxt)
  306/20ED : 46 0F 26                               call puts
  307/20F0 : 2E 1E                                  mvi h,hi(save_H)
  308/20F2 : 36 F0                                  mvi l,lo(save_H)
  309/20F4 : CF                                     mov b,m                     ; move the high byte of the address into B
  310/20F5 : 30                                     inr l
  311/20F6 : C7                                     mov a,m                     ; move the high byte of the address into A
  312/20F7 : 24 F0                                  ani 0F0H                    ; start on a 16 byte boundry
  313/20F9 : F0                                     mov l,a                     ; move it to L
  314/20FA : E9                                     mov h,b
  315/20FB : 46 05 26                   dump2:      call crlf                   ; start on a new line
  316/20FE : C5                                     mov a,h
  317/20FF : 46 CF 25                               call write_hex              ; write the high byte of the address
  318/2102 : C6                                     mov a,l
  319/2103 : 46 CF 25                               call write_hex              ; write the low byte of the address
  320/2106 : 46 0A 26                               call space
  321/2109 :                            
  322/2109 :                                        ; write one line of 16 bytes in hex and then in ascii
  323/2109 :                            dump3:
  324/2109 : 41                                     in IN_STATUS
  325/210A : 1A                                     rar
  326/210B : 60 4F 20                               jc prompt                   ; abort if start bit detected
  327/210E : C7                                     mov a,m                     ; retrieve the byte from memory
  328/210F : 46 CF 25                               call write_hex              ; write it as two hex digits
  329/2112 : 46 0A 26                               call space
  330/2115 : 30                                     inr l
  331/2116 : C6                                     mov a,l
  332/2117 : 24 0F                                  ani 0FH                     ; 16 bytes?
  333/2119 : 68 1F 21                               jz dump4                    ; move on to print ascii characters
  334/211C : 44 09 21                               jmp dump3                   ; otherwise, next address
  335/211F :                            
  336/211F :                                        ; ascii characters
  337/211F : 46 0A 26                   dump4:      call space
  338/2122 : 41                                     in IN_STATUS
  339/2123 : 1A                                     rar
  340/2124 : 60 4F 20                               jc prompt                   ; abort if start bit detected
  341/2127 : C6                                     mov a,l                     
  342/2128 : 14 10                                  sui 16
  343/212A : F0                                     mov l,a                     ; back to the starting address for this line
  344/212B : C7                         dump5:      mov a,m                     ; retrieve the byte from memory
  345/212C : 3C 20                                  cpi 32                      ; control character?
  346/212E : 60 36 21                               jc dump6                    ; jump if the byte from memory is < 32
  347/2131 : 3C 80                                  cpi 128                     ; extended ascii?
  348/2133 : 60 38 21                               jc dump7                    ; jump if the byte from memory is < 128
  349/2136 : 06 2E                      dump6:      mvi a,'.'                   ; print '.' for non-printable sacii
  350/2138 : 46 36 26                   dump7:      call putch
  351/213B : 41                                     in IN_STATUS
  352/213C : 1A                                     rar
  353/213D : 60 4F 20                               jc prompt
  354/2140 : 30                                     inr l                       ; next address
  355/2141 : 68 4F 20                               jz prompt                   ; exit if finished with this page
  356/2144 : C6                                     mov a,l                     ; next address
  357/2145 : 24 0F                                  ani 0FH                     ; 16 bytes?
  358/2147 : 68 FB 20                               jz dump2                    ; jump if end of line
  359/214A : 44 2B 21                               jmp dump5                   ; otherwise, next memory address
  360/214D :                            
  361/214D :                            ;------------------------------------------------------------------------
  362/214D :                            ; fill a block of memory with a value
  363/214D :                            ;------------------------------------------------------------------------
  364/214D : 2E 27                      fill:       mvi h,hi(filltxt)
  365/214F : 36 BA                                  mvi l,lo(filltxt)
  366/2151 : 46 0F 26                               call puts
  367/2154 : 46 A3 23                               call get_addr               ; get the four digit address
  368/2157 : 60 4F 20                               jc prompt                   ; exit prematurely if space, enter or escape
  369/215A : 46 B9 23                               call get_count              ; get the four digit count
  370/215D : 60 4F 20                               jc prompt                   ; exit prematurely if space, enter or escape
  371/2160 : 2E 28                                  mvi h,hi(valuetxt)
  372/2162 : 36 91                                  mvi l,lo(valuetxt)
  373/2164 : 46 0F 26                               call puts                   ; prompt for the value
  374/2167 : 46 5D 25                               call get_two                ; get the value used to fill in A
  375/216A : 2E 1E                                  mvi h,hi(save_B)
  376/216C : 36 F2                                  mvi l,lo(save_B)
  377/216E : CF                                     mov b,m                     ; retrieve the count high byte from memory
  378/216F : 30                                     inr l
  379/2170 : D7                                     mov c,m                     ; retrieve the count low byte from memory
  380/2171 : 2E 1E                                  mvi h,hi(save_H)
  381/2173 : 36 F0                                  mvi l,lo(save_H)
  382/2175 : DF                                     mov d,m                     ; retrieve the address high byte from memory
  383/2176 : 30                                     inr l
  384/2177 : E7                                     mov e,m                     ; retrieve the address low byte from memory
  385/2178 : EB                                     mov h,d                     ; get the address high byte from D
  386/2179 : F4                                     mov l,e                     ; get the address low byte from E
  387/217A : F8                         fillloop:   mov m,a                     ; save the value in memory
  388/217B : 30                                     inr l                       ; increment L
  389/217C : 48 80 21                               jnz fillloop1
  390/217F : 28                                     inr h                       ; increment H
  391/2180 : 46 9B 23                   fillloop1:  call decBC
  392/2183 : D8                                     mov d,a                     ; save the fill byte in D
  393/2184 : C2                                     mov a,c                     ; get the count low byte 
  394/2185 : B1                                     ora b                       ; OR with the count high byte
  395/2186 : C3                                     mov a,d                     ; restore the fill byte from D
  396/2187 : 48 7A 21                               jnz fillloop
  397/218A : 44 4F 20                               jmp prompt
  398/218D :                            
  399/218D :                            ;------------------------------------------------------------------------
  400/218D :                            ; examine/modify memory.
  401/218D :                            ; space increments memory pointer without affecting value.
  402/218D :                            ; enter or escape exits.
  403/218D :                            ;------------------------------------------------------------------------
  404/218D : 2E 27                      examine:    mvi h,hi(examinetxt)
  405/218F : 36 AB                                  mvi l,lo(examinetxt)
  406/2191 : 46 0F 26                               call puts 
  407/2194 : 46 A3 23                               call get_addr               ; get the four digit address
  408/2197 : 60 4F 20                               jc prompt                   ; exit prematurely if space, enter or escape
  409/219A : 46 05 26                               call crlf
  410/219D : 2E 1E                                  mvi h,hi(save_H)
  411/219F : 36 F0                                  mvi l,lo(save_H)
  412/21A1 : DF                                     mov d,m                     ; retrieve the address high byte from memory
  413/21A2 : 30                                     inr l
  414/21A3 : E7                                     mov e,m                     ; retrieve the address low byte from memory
  415/21A4 : EB                                     mov h,d                     ; get the address high byte from D
  416/21A5 : F4                                     mov l,e                     ; get the address low byte from E
  417/21A6 : 46 05 26                   examine1:   call crlf
  418/21A9 : C5                                     mov a,h
  419/21AA : 46 CF 25                               call write_hex              ; high byte of the address
  420/21AD : C6                                     mov a,l
  421/21AE : 46 CF 25                               call write_hex              ; low byte of the address
  422/21B1 : 46 CF 23                               call save_HL
  423/21B4 : 2E 29                                  mvi h,hi(arrowtxt)
  424/21B6 : 36 4F                                  mvi l,lo(arrowtxt)
  425/21B8 : 46 0F 26                               call puts    
  426/21BB : 46 D9 23                               call restore_HL
  427/21BE : C7                                     mov a,m
  428/21BF : 46 CF 25                               call write_hex              ; value stored at memory
  429/21C2 : 46 CF 23                               call save_HL
  430/21C5 : 2E 29                                  mvi h,hi(newvaluetxt)
  431/21C7 : 36 55                                  mvi l,lo(newvaluetxt)
  432/21C9 : 46 0F 26                               call puts    
  433/21CC : 46 D9 23                               call restore_HL
  434/21CF : 46 5D 25                   examine3:   call get_two                ; two hex digits
  435/21D2 : 60 DE 21                               jc examine4                 ; jump if space, enter or escape
  436/21D5 : F8                                     mov m,a                     ; else save the new value in memory at this address
  437/21D6 : 30                                     inr l                       ; next address
  438/21D7 : 48 A6 21                               jnz examine1
  439/21DA : 28                                     inr h
  440/21DB : 44 A6 21                               jmp examine1
  441/21DE : 3C 20                      examine4:   cpi ' '                     ; space?
  442/21E0 : 48 EB 21                               jnz examine5
  443/21E3 : 30                                     inr l                       ; next address
  444/21E4 : 48 A6 21                               jnz examine1
  445/21E7 : 28                                     inr h
  446/21E8 : 44 A6 21                               jmp examine1
  447/21EB : 3C 0D                      examine5:   cpi 0DH                     ; enter?
  448/21ED : 68 4F 20                               jz  prompt
  449/21F0 : 3C 1B                                  cpi 1BH                     ; escape?
  450/21F2 : 68 4F 20                               jz  prompt
  451/21F5 : 44 CF 21                               jmp examine3
  452/21F8 :                            
  453/21F8 :                            ;------------------------------------------------------------------------
  454/21F8 :                            ; load a binary file into memory using the Tera Term "Send file" function.
  455/21F8 :                            ; use this function cautiously as there is, of course, no error checking.
  456/21F8 :                            ; when using the Tera Term "Send file" function, make sure that:
  457/21F8 :                            ;   1. the serial port transmit delay is set to at least 2 msec/char
  458/21F8 :                            ;   2. the "Binary" option check box on the Send File dialog box is checked.
  459/21F8 :                            ; the download is assumed to be finished when no characters have been received
  460/21F8 :                            ; from Tera Term for 3 seconds.
  461/21F8 :                            ; uses BC as the "idle" counter.
  462/21F8 :                            ;------------------------------------------------------------------------
  463/21F8 : 2E 28                      bindl:      mvi h,hi(binloadtxt)  
  464/21FA : 36 3B                                  mvi l,lo(binloadtxt) 
  465/21FC : 46 0F 26                               call puts 
  466/21FF :                                        
  467/21FF : 46 A3 23                               call get_addr               ; get the four digit hex load address
  468/2202 : 60 4F 20                               jc prompt                   ; exit prematurely if space, enter or escape
  469/2205 :                            
  470/2205 : 2E 28                                  mvi h,hi(dnldtxt)
  471/2207 : 36 DB                                  mvi l,lo(dnldtxt)
  472/2209 : 46 0F 26                               call puts                   ; prompt for download
  473/220C :                            
  474/220C : 2E 1E                                  mvi h,hi(save_H)
  475/220E : 36 F0                                  mvi l,lo(save_H)
  476/2210 : DF                                     mov d,m                     ; retrieve the start address high byte from memory into D
  477/2211 : 30                                     inr l
  478/2212 : E7                                     mov e,m                     ; retrieve the start address low byte from memory into E
  479/2213 : EB                                     mov h,d                     ; get the start address high byte into H
  480/2214 : F4                                     mov l,e                     ; get the start address low byte into L
  481/2215 :                            
  482/2215 : 46 1D 26                               call getch                  ; get the first byte of the file from the serial port
  483/2218 : F8                                     mov m,a                     ; write the first byte to memory
  484/2219 : 30                                     inr l                       ; increment the low byte of the address pointer
  485/221A : 48 1E 22                               jnz bindl0                  ; go get next byte
  486/221D : 28                                     inr h                       ; increment the high byte of the address pointer
  487/221E :                            
  488/221E :                            bindl0:
  489/221E :                            ;            mvi b,40H                   ; initialize "idle" counter (BC) to 16284
  490/221E :                            ;            mvi c,0
  491/221E :                            ;bindl1:     in 0                        ; get input from the serial port
  492/221E :                            ;            rar                         ; rotate the received serial bit right into carry
  493/221E :                            ;            jnc bindl2                  ; jump if start bit has been detected
  494/221E :                            ;            dcr c                       ; else decrement the low byte of the "idle" counter
  495/221E :                            ;            jnz bindl1
  496/221E :                            ;            dcr b                       ; secrement the high byte of the "idle" counter
  497/221E :                            ;            jnz bindl1
  498/221E :                            ;            jmp finished                ; the "idle" counter has reached zero (no characters for 3 seconds)
  499/221E :                            
  500/221E : 46 1D 26                   bindl2:     call getch                  ; start bit has been detected, get the byte from the serial port
  501/2221 : F8                                     mov m,a                     ; write the byte to memory
  502/2222 : 30                                     inr l                       ; increment the low byte of the address pointer
  503/2223 : 48 1E 22                               jnz bindl0                  ; go back for the next byte
  504/2226 : 28                                     inr h                       ; increment the high byte of the address pointer 
  505/2227 : 44 1E 22                               jmp bindl0                  ; go back for the next byte
  506/222A :                            
  507/222A :                            ;------------------------------------------------------------------------
  508/222A :                            ; load an Intel HEX file into memory using the Tera Term "Send file" function.
  509/222A :                            ; uses D for the record's byte count. uses B to hold the record's checksum.
  510/222A :                            ; when the download is finished, jump to the address contained in the last record.
  511/222A :                            ; when using the Tera Term "Send file" function, make sure that:
  512/222A :                            ;   1. the serial port transmit delay is set to at least 1 mSec/char
  513/222A :                            ;   2. the "Binary" option check box on the Send File dialog box is NOT checked.
  514/222A :                            ;------------------------------------------------------------------------
  515/222A : 2E 28                      hexdl:      mvi h,hi(hexloadtxt)
  516/222C : 36 58                                  mvi l,lo(hexloadtxt)
  517/222E : 46 0F 26                               call puts 
  518/2231 :                            
  519/2231 : 2E 29                                  mvi h,hi(waittxt)
  520/2233 : 36 03                                  mvi l,lo(waittxt)
  521/2235 : 46 0F 26                               call puts                   ; prompt for download
  522/2238 :                            
  523/2238 : 46 25 26                   hexdl1:     call getche                 ; get the first character of the record and echo it
  524/223B : 3C 3A                                  cpi ':'                     ; start of record character?
  525/223D : 48 38 22                               jnz hexdl1                  ; loop until start of record found
  526/2240 :                            
  527/2240 : 46 A4 22                   hexdl1a:    call hexbyte                ; get byte count
  528/2243 : 3C 00                                  cpi 0                       ; zero byte count?
  529/2245 : 68 7E 22                               jz waitend                  ; zero means last record
  530/2248 : D8                                     mov d,a                     ; save the byte count in D
  531/2249 : C8                                     mov b,a                     ; save as the checksum in B
  532/224A :                            
  533/224A : 46 A4 22                               call hexbyte                ; get address hi byte
  534/224D : E8                                     mov h,a                     ; save hi byte in H
  535/224E : 81                                     add b                       ; add to the checksum
  536/224F : C8                                     mov b,a                     ; save the checksum in B
  537/2250 : 46 A4 22                               call hexbyte                ; get address lo byte
  538/2253 : F0                                     mov l,a                     ; save lo byte in L
  539/2254 : 81                                     add b                       ; add to the checksum
  540/2255 : C8                                     mov b,a                     ; save the checksum in B
  541/2256 :                            
  542/2256 : 46 A4 22                               call hexbyte                ; get record type
  543/2259 : 3C 01                                  cpi 1                       ; end of file?
  544/225B : 68 7E 22                               jz waitend                  ; record type 1 means end of file
  545/225E : D0                                     mov c,a                     ; save record type in C
  546/225F : 81                                     add b                       ; add record type to checksum
  547/2260 : C8                                     mov b,a                     ; save the checksum
  548/2261 : C2                                     mov a,c                     ; restore the record type from C
  549/2262 :                            
  550/2262 : 46 A4 22                   hexdl2:     call hexbyte                ; get the next data byte
  551/2265 : F8                                     mov m,a                     ; store it in memory
  552/2266 : 81                                     add b                       ; add to the checksum
  553/2267 : C8                                     mov b,a                     ; save the checksum
  554/2268 : 30                                     inr l                       ; increment lo byte of address pointer
  555/2269 : 48 6D 22                               jnz hexdl3
  556/226C : 28                                     inr h                       ; increment hi byte of address pointer
  557/226D : 19                         hexdl3:     dcr d
  558/226E : 68 74 22                               jz hexdl4                   ; all bytes in this record downloaded
  559/2271 : 44 62 22                               jmp hexdl2                  ; go back for next data byte
  560/2274 :                            
  561/2274 : 46 A4 22                   hexdl4:     call hexbyte                ; get the checksum byte
  562/2277 : 81                                     add b                       ; add to the checksum
  563/2278 :                            ; Since the record's checksum byte is the two's complement and therefore the additive inverse
  564/2278 :                            ; of the data checksum, the verification process can be reduced to summing all decoded byte 
  565/2278 :                            ; values, including the record's checksum, and verifying that the LSB of the sum is zero.
  566/2278 : 48 9C 22                               jnz cksumerr                ; non zero means checksum error
  567/227B : 44 38 22                               jmp hexdl1                  ; else, go back for the next record
  568/227E :                            
  569/227E :                            ; get the last record
  570/227E : 46 A4 22                   waitend:    call hexbyte                ; get the last address hi byte
  571/2281 : E8                                     mov h,a                     ; save hi byte in H
  572/2282 : 46 A4 22                               call hexbyte                ; get the last address lo byte
  573/2285 : F0                                     mov l,a                     ; save lo byte in L
  574/2286 : 46 CF 23                               call save_HL                ; save HL for later
  575/2289 :                            
  576/2289 : 46 A4 22                               call hexbyte                ; get the last record type
  577/228C : 46 A4 22                               call hexbyte                ; get the last checksum
  578/228F :                            
  579/228F : 2E 29                      finished:   mvi h,hi(loadedtxt)
  580/2291 : 36 2E                                  mvi l,lo(loadedtxt)
  581/2293 : 46 0F 26                               call puts                   ; print "File loaded."
  582/2296 : 46 D9 23                               call restore_HL
  583/2299 : 44 D8 22                               jmp jump1                   ; jump to the address in the last record
  584/229C :                            
  585/229C : 2E 29                      cksumerr:   mvi h,hi(errortxt)
  586/229E : 36 3D                                  mvi l,lo(errortxt)
  587/22A0 : 46 0F 26                               call puts                   ; print "Checksum error."
  588/22A3 : 00                                     hlt                         ; stay here until reset
  589/22A4 :                            
  590/22A4 :                            ;------------------------------------------------------------------------
  591/22A4 :                            ; get two hex digits from the serial port during the hex download and 
  592/22A4 :                            ; convert them into a byte returned in A. 
  593/22A4 :                            ; uses A, C and E
  594/22A4 :                            ;------------------------------------------------------------------------
  595/22A4 : 46 25 26                   hexbyte:    call getche             ; get the first character and echo it
  596/22A7 : 46 F0 25                               call ascii2hex          ; convert to hex nibble
  597/22AA : 02                                     rlc                     ; rotate into the most significant nibble
  598/22AB : 02                                     rlc
  599/22AC : 02                                     rlc
  600/22AD : 02                                     rlc
  601/22AE : 24 F0                                  ani 0F0H                ; mast out least signifficant nibble
  602/22B0 : D0                                     mov c,a                 ; save the first digit in C as the most significant nibble
  603/22B1 :                                        
  604/22B1 : 46 25 26                               call getche             ; get the second character and echo it
  605/22B4 : 46 F0 25                               call ascii2hex          ; convert to hex nibble
  606/22B7 : 24 0F                                  ani 0FH                 ; mask out the most significant bits
  607/22B9 : B2                                     ora c                   ; combine the two nibbles
  608/22BA : 07                                     ret
  609/22BB :                            
  610/22BB :                            ;------------------------------------------------------------------------
  611/22BB :                            ; go to a memory address (same as Jump to a memory address)
  612/22BB :                            ;------------------------------------------------------------------------
  613/22BB : 2E 27                      goto:       mvi h,hi(gototxt)
  614/22BD : 36 FC                                  mvi l,lo(gototxt)
  615/22BF : 46 0F 26                               call puts
  616/22C2 : 46 C6 24                               call get_four               ; get the four digit address into HL
  617/22C5 : 60 4F 20                               jc prompt                   ; exit if escape
  618/22C8 : 44 D8 22                               jmp jump1                   ; continue below
  619/22CB :                            
  620/22CB :                            ;------------------------------------------------------------------------
  621/22CB :                            ; jump to a memory address
  622/22CB :                            ;------------------------------------------------------------------------
  623/22CB : 2E 27                      jump:       mvi h,hi(jumptxt)
  624/22CD : 36 C6                                  mvi l,lo(jumptxt)
  625/22CF : 46 0F 26                               call puts
  626/22D2 : 46 C6 24                               call get_four               ; get the four digit address into HL
  627/22D5 : 60 4F 20                               jc prompt                   ; exit if escape
  628/22D8 : DD                         jump1:      mov d,h                     ; save the high byte of the address in D
  629/22D9 : E6                                     mov e,l                     ; save the low byte of the address in E
  630/22DA : 2E 1E                                  mvi h,hi(jmp_addr)
  631/22DC : 36 FC                                  mvi l,lo(jmp_addr)
  632/22DE : 3E 44                                  mvi m,44H                   ; store the "jmp" instruction at jmp_addr
  633/22E0 : 30                                     inr l                       ; next memory location
  634/22E1 : FC                                     mov m,e                     ; store the low byte of jump address at jmp_addr+1
  635/22E2 : 30                                     inr l                       ; next memory location
  636/22E3 : FB                                     mov m,d                     ; store the high byte of jump address at jmp_addr+2
  637/22E4 : 46 05 26                               call crlf                   ; start of a new line
  638/22E7 : 44 FC 1E                               jmp jmp_addr                ; go jump!
  639/22EA :                            
  640/22EA :                            ;------------------------------------------------------------------------
  641/22EA :                            ; call a subroutine
  642/22EA :                            ;------------------------------------------------------------------------
  643/22EA : 2E 27                      callsub:    mvi h,hi(calltxt)
  644/22EC : 36 E0                                  mvi l,lo(calltxt)
  645/22EE : 46 0F 26                               call puts
  646/22F1 : 46 C6 24                               call get_four               ; get the four digit address into HL
  647/22F4 : 60 4F 20                               jc prompt                   ; exit if escape
  648/22F7 : DD                                     mov d,h                     ; save the high byte of the address in D
  649/22F8 : E6                                     mov e,l                     ; save the low byte of the address in E
  650/22F9 : 2E 1E                                  mvi h,hi(jmp_addr)
  651/22FB : 36 FC                                  mvi l,lo(jmp_addr)
  652/22FD : 3E 46                                  mvi m,46H                   ; store "CALL" instruction at jmp+addr
  653/22FF : 30                                     inr l
  654/2300 : FC                                     mov m,e                     ; store the low byte of the subroutine address at jmp_addr+1
  655/2301 : 30                                     inr l                       ; next memory location
  656/2302 : FB                                     mov m,d                     ; store the high byte of the subroutine address at jmp_addr+2
  657/2303 : 30                                     inr l
  658/2304 : 3E 07                                  mvi m,07H                   ; store "RET" instruction at jmp_addr+3
  659/2306 : 46 05 26                               call crlf                   ; start of a new line
  660/2309 : 46 FC 1E                               call jmp_addr               ; call the subroutine
  661/230C : 44 4F 20                               jmp prompt
  662/230F :                            
  663/230F :                            ;------------------------------------------------------------------------
  664/230F :                            ; get a byte from an input port
  665/230F :                            ;------------------------------------------------------------------------
  666/230F : 2E 28                      input:      mvi h,hi(inputtxt)
  667/2311 : 36 14                                  mvi l,lo(inputtxt)
  668/2313 : 46 0F 26                               call puts
  669/2316 : 2E 29                                  mvi h,hi(porttxt)
  670/2318 : 36 5D                                  mvi l,lo(porttxt)
  671/231A : 46 0F 26                               call puts    
  672/231D : 46 5D 25                               call get_two
  673/2320 : 60 4F 20                               jc prompt                   ; exit if escape
  674/2323 : 24 07                                  ani 00000111B
  675/2325 : 02                                     rlc
  676/2326 : 34 41                                  ori 01000001B
  677/2328 : 2E 1E                                  mvi h,hi(jmp_addr)
  678/232A : 36 FC                                  mvi l,lo(jmp_addr)
  679/232C : F8                                     mov m,a                   ; store the "IN" instruction at jmp_addr
  680/232D : 30                                     inr l
  681/232E : 3E 07                                  mvi m,07H                 ; store the "RET" instruction at jmp_addr+1
  682/2330 : 46 FC 1E                               call jmp_addr             ; execute the "IN" instruction
  683/2333 : D8                                     mov d,a                   ; save the input data in E
  684/2334 : 2E 29                                  mvi h,hi(arrowtxt)
  685/2336 : 36 4F                                  mvi l,lo(arrowtxt)
  686/2338 : 46 0F 26                               call puts
  687/233B : C3                                     mov a,d
  688/233C : 46 CF 25                               call write_hex
  689/233F : 46 05 26                               call crlf
  690/2342 : 44 4F 20                               jmp prompt
  691/2345 :                            
  692/2345 :                            ;------------------------------------------------------------------------
  693/2345 :                            ; send a byte to an output port
  694/2345 :                            ;------------------------------------------------------------------------
  695/2345 : 2E 28                      output:     mvi h,hi(outputtxt)
  696/2347 : 36 28                                  mvi l,lo(outputtxt)
  697/2349 : 46 0F 26                               call puts
  698/234C : 2E 29                                  mvi h,hi(porttxt)
  699/234E : 36 5D                                  mvi l,lo(porttxt)
  700/2350 : 46 0F 26                               call puts    
  701/2353 : 46 5D 25                               call get_two
  702/2356 : 60 4F 20                               jc prompt                   ; exit if escape
  703/2359 : D8                                     mov d,a                     ; save the port address in D
  704/235A : 2E 29                                  mvi h,hi(bytetxt)
  705/235C : 36 76                                  mvi l,lo(bytetxt)
  706/235E : 46 0F 26                               call puts   
  707/2361 : 46 5D 25                               call get_two
  708/2364 : 60 4F 20                               jc prompt                   ; exit if escape
  709/2367 : E0                                     mov e,a                     ; save the date byte in E
  710/2368 : C3                                     mov a,d                     ; recall the address from D
  711/2369 : 24 1F                                  ani 00011111B               ; construct the "OUT" instruction
  712/236B : 02                                     rlc
  713/236C : 34 41                                  ori 01000001B
  714/236E : 2E 1E                                  mvi h,hi(jmp_addr)
  715/2370 : 36 FC                                  mvi l,lo(jmp_addr)
  716/2372 : F8                                     mov m,a                   ; store the "OUT" instruction at jmp_addr
  717/2373 : 30                                     inr l
  718/2374 : 3E 07                                  mvi m,07H                 ; store the "RET" instruction at jmp_addr+1
  719/2376 : C4                                     mov a,e                   ; recall the data byte from E
  720/2377 : 46 FC 1E                               call jmp_addr             ; execute the "OUT" instruction
  721/237A : 46 05 26                               call crlf                 ; start of a new line
  722/237D : 44 4F 20                               jmp prompt
  723/2380 :                            
  724/2380 :                            ;------------------------------------------------------------------------
  725/2380 :                            ; load code into RAM which, when executed, will set the bits of output port 10
  726/2380 :                            ; to control the A14 and A13 address lines of the EPROM. when executed, the code
  727/2380 :                            ; in RAM sets the address lines to select the second 8K of EPROM and then jumps
  728/2380 :                            ; to address 2000H which is the start of the SCELBAL BASIC interpreter.
  729/2380 :                            ;------------------------------------------------------------------------
  730/2380 : 2E 28                      scelbal:    mvi h,hi(scelbaltxt)
  731/2382 : 36 50                                  mvi l,lo(scelbaltxt)
  732/2384 : 46 0F 26                               call puts
  733/2387 : 2E 1E                                  mvi h,hi(jmp_addr)
  734/2389 : 36 FC                                  mvi l,lo(jmp_addr)
  735/238B : 3E 55                                  mvi m,55H                 ; store OUT 0ah instruction at 'jmp_addr'
  736/238D : 30                                     inr l
  737/238E : 3E 44                                  mvi m,44H                 ; store "JMP" instruction at 'jmp_addr'+1
  738/2390 : 30                                     inr l
  739/2391 : 3E 00                                  mvi m,00H                 ; store "00H" (the lo byte of address 2000H) at 'jmp_addr'+2
  740/2393 : 30                                     inr l
  741/2394 : 3E 20                                  mvi m,20H                 ; store "20H" (the hi byte of address 2000H) at 'jmp_addr'+3
  742/2396 : 06 20                                  mvi a,20H                 ; value for ROM access offset for second 8K of ROM area
  743/2398 : 44 FC 1E                               jmp jmp_addr              ; go set the address bits and then jump to the beginning SCELBAL in the second 8K of ROM
  744/239B :                            
  745/239B :                            ;------------------------------------------------------------------------
  746/239B :                            ; subroutine to decrement double-byte value in BC
  747/239B :                            ;------------------------------------------------------------------------
  748/239B : 11                         decBC:     dcr c                        ; decrement contents of C
  749/239C : 10                                    inr c                        ; now increment C to set/reset flags
  750/239D : 48 A1 23                              jnz decbc1                   ; if C not presently zero, skip decrementing B
  751/23A0 : 09                                    dcr b                        ; else decrement B
  752/23A1 : 11                         decbc1:    dcr c                        ; do the actual decrement of C
  753/23A2 : 07                                    ret
  754/23A3 :                            
  755/23A3 :                            ;------------------------------------------------------------------------
  756/23A3 :                            ; get a four digit address (in hex) and store it the high byte at "save_H" and 
  757/23A3 :                            ; the low byte at "save_L". 
  758/23A3 :                            ; on return BC contains the address and HL points to "save_H".
  759/23A3 :                            ; uses A, BC, DE and HL.
  760/23A3 :                            ;------------------------------------------------------------------------
  761/23A3 : 2E 28                      get_addr:   mvi h,hi(addresstxt)
  762/23A5 : 36 6A                                  mvi l,lo(addresstxt)
  763/23A7 : 46 0F 26                               call puts                   ; prompt for the address
  764/23AA : 46 C6 24                               call get_four               ; get the address
  765/23AD : 23                                     rc                          ; return prematurely if escape key
  766/23AE : CD                                     mov b,h
  767/23AF : D6                                     mov c,l
  768/23B0 : 2E 1E                                  mvi h,hi(save_H)
  769/23B2 : 36 F0                                  mvi l,lo(save_H)
  770/23B4 : F9                                     mov m,b                     ; save the address high byte in memory
  771/23B5 : 30                                     inr l                       ; next memory location
  772/23B6 : FA                                     mov m,c                     ; save the address low byte in memory
  773/23B7 : 31                                     dcr l
  774/23B8 : 07                                     ret
  775/23B9 :                            
  776/23B9 :                            ;------------------------------------------------------------------------
  777/23B9 :                            ; get a four digit count (in hex) and store it the high byte at "save_B" 
  778/23B9 :                            ; and the low byte at "save_C"
  779/23B9 :                            ; on return BC contains the count and HL points to "save_B".
  780/23B9 :                            ; uses A, BC, DE and HL.
  781/23B9 :                            ;------------------------------------------------------------------------
  782/23B9 : 2E 28                      get_count:  mvi h,hi(hcounttxt)
  783/23BB : 36 7E                                  mvi l,lo(hcounttxt)
  784/23BD : 46 0F 26                               call puts                   ; prompt for the count
  785/23C0 : 46 C6 24                               call get_four               ; get the count
  786/23C3 : 23                                     rc                          ; return prematurely if space, enter or escape
  787/23C4 : CD                                     mov b,h
  788/23C5 : D6                                     mov c,l
  789/23C6 : 2E 1E                                  mvi h,hi(save_B)
  790/23C8 : 36 F2                                  mvi l,lo(save_B)
  791/23CA : F9                                     mov m,b                     ; save the high byte of the count in memory
  792/23CB : 30                                     inr l
  793/23CC : FA                                     mov m,c                     ; save the low byte of the count in memory
  794/23CD : 31                                     dcr l
  795/23CE : 07                                     ret
  796/23CF :                            
  797/23CF :                            ;------------------------------------------------------------------------
  798/23CF :                            ; save the contents of H and L in a temporary storage area in memory.
  799/23CF :                            ; uses H and L, D and E.
  800/23CF :                            ;------------------------------------------------------------------------
  801/23CF : DD                         save_HL:   mov d,h                ; transfer value in H to A
  802/23D0 : E6                                    mov e,l                ; and value in L to E
  803/23D1 : 2E 1E                                 mvi h,hi(save_H)       ; and set H to storage area page
  804/23D3 : 36 F0                                 mvi l,lo(save_H)       ; now set L to temporary storage locations
  805/23D5 : FB                                    mov m,d                ; save A (entry value of H) in memory
  806/23D6 : 30                                    inr l                  ; advance pointer
  807/23D7 : FC                                    mov m,e                ; save E (entry value of L) in memory
  808/23D8 : 07                                    ret
  809/23D9 :                            
  810/23D9 :                            ;------------------------------------------------------------------------
  811/23D9 :                            ; restore the contents H and L from temporary storage in memory.
  812/23D9 :                            ; uses H and L, D and E.
  813/23D9 :                            ;------------------------------------------------------------------------
  814/23D9 : 2E 1E                      restore_HL:mvi h,hi(save_H)       ; and set L to storage area page
  815/23DB : 36 F0                                 mvi l,lo(save_H)       ; now set L to start of temporary storage locations
  816/23DD : DF                                    mov d,m                ; fetch stored value for H into A
  817/23DE : 30                                    inr l                  ; advance pointer
  818/23DF : E7                                    mov e,m                ; fetch stored value for L into E
  819/23E0 : 30                                    inr l                  ; advance pointer
  820/23E1 : EB                                    mov h,d                ; restore  saved value for H
  821/23E2 : F4                                    mov l,e                ; restore saved value for L
  822/23E3 : 07                                    ret
  823/23E4 :                            
  824/23E4 :                            ;------------------------------------------------------------------------      
  825/23E4 :                            ; save the contents of B and C in a temporary storage area in memory.
  826/23E4 :                            ; uses H and L
  827/23E4 :                            ;------------------------------------------------------------------------
  828/23E4 : 2E 1E                      save_BC:   mvi h,hi(save_B)       ; and set H to storage area page
  829/23E6 : 36 F2                                 mvi l,lo(save_B)       ; now set L to temporary storage locations
  830/23E8 : F9                                    mov m,b                ; save B in memory
  831/23E9 : 30                                    inr l                  ; advance pointer
  832/23EA : FA                                    mov m,c                ; save C in memory
  833/23EB : 07                                    ret
  834/23EC :                            
  835/23EC :                            ;------------------------------------------------------------------------
  836/23EC :                            ; restore the contents B and C from temporary storage in memory.
  837/23EC :                            ; uses H and L
  838/23EC :                            ;------------------------------------------------------------------------
  839/23EC : 2E 1E                      restore_BC:mvi h,hi(save_B)       ; and set L to storage area page
  840/23EE : 36 F2                                 mvi l,lo(save_B)       ; now set L to start of temporary storage locations
  841/23F0 : CF                                    mov b,m                ; fetch stored value for B
  842/23F1 : 30                                    inr l                  ; advance pointer
  843/23F2 : D7                                    mov c,m                ; fetch stored value for C
  844/23F3 : 30                                    inr l                  ; advance pointer
  845/23F4 : 07                                    ret
  846/23F5 :                            
  847/23F5 :                            ;------------------------------------------------------------------------
  848/23F5 :                            ; save the contents of D and E in a temporary storage area in memory.
  849/23F5 :                            ; uses H and L
  850/23F5 :                            ;------------------------------------------------------------------------
  851/23F5 : 2E 1E                      save_DE:   mvi h,hi(save_D)       ; and set H to storage area page
  852/23F7 : 36 F4                                 mvi l,lo(save_D)       ; now set L to temporary storage locations
  853/23F9 : FB                                    mov m,d                ; save D in memory
  854/23FA : 30                                    inr l                  ; advance pointer
  855/23FB : FC                                    mov m,e                ; save E in memory
  856/23FC : 07                                    ret
  857/23FD :                            
  858/23FD :                            ;------------------------------------------------------------------------
  859/23FD :                            ; restore the contents D and E from temporary storage in memory.
  860/23FD :                            ; uses DE and HL
  861/23FD :                            ;------------------------------------------------------------------------
  862/23FD : 2E 1E                      restore_DE:mvi h,hi(save_D)       ; and set L to storage area page
  863/23FF : 36 F4                                 mvi l,lo(save_D)       ; now set L to start of temporary storage locations
  864/2401 : DF                                    mov d,m                ; fetch stored value for D
  865/2402 : 30                                    inr l                  ; advance pointer
  866/2403 : E7                                    mov e,m                ; fetch stored value for E
  867/2404 : 30                                    inr l                  ; advance pointer
  868/2405 : 07                                    ret
  869/2406 :                            
  870/2406 :                            ;------------------------------------------------------------------------
  871/2406 :                            ; enter decimal digits until terminated with carriage return or escape. 
  872/2406 :                            ; returns with carry set if escape, otherwise returns with the binary 
  873/2406 :                            ; value in HL and carry clear.
  874/2406 :                            ; uses A, B, DE and HL
  875/2406 :                            ;------------------------------------------------------------------------
  876/2406 : 2E 00                      get_dec:    mvi h,0
  877/2408 : 36 00                                  mvi l,0
  878/240A : 46 1D 26                   get_dec1:   call getch      ; get input from serial
  879/240D : 3C 0D                                  cpi RETURN      ; carriage return?
  880/240F : 48 14 24                               jnz get_dec2
  881/2412 : A0                                     ana a           ; clear carry
  882/2413 : 07                                     ret
  883/2414 :                            
  884/2414 : 3C 1B                      get_dec2:   cpi ESCAPE      ; escape?
  885/2416 : 48 1D 24                               jnz get_dec3 
  886/2419 : 06 01                                  mvi a,1
  887/241B : 0A                                     rrc             ; set carry flag
  888/241C : 07                                     ret
  889/241D :                            
  890/241D : 3C 30                      get_dec3:   cpi '0'
  891/241F : 60 0A 24                               jc get_dec1     ; go back for another digit if the digit in A is less than 0
  892/2422 : 3C 3A                                  cpi '9'+1
  893/2424 : 40 0A 24                               jnc get_dec1    ; go back for another digit if the digit in A is greater than 9
  894/2427 : 46 36 26                               call putch      ; since it's legit, echo the digit
  895/242A : 14 30                                  sui 30H         ; convert the ASCII decimal digit in A to binary
  896/242C : C8                                     mov b,a         ; save the decimal digit in B
  897/242D :                            
  898/242D : DD                                     mov d,h
  899/242E : E6                                     mov e,l         ; copy HL into DE
  900/242F :                            
  901/242F :                                        ; double HL (effectively multiplying HL by 2)
  902/242F : C6                                     mov a,l
  903/2430 : 86                                     add l
  904/2431 : F0                                     mov l,a
  905/2432 : C5                                     mov a,h
  906/2433 : 8D                                     adc h
  907/2434 : E8                                     mov h,a
  908/2435 :                            
  909/2435 :                                        ; double HL again (effectively multiplying HL by 4)
  910/2435 : C6                                     mov a,l
  911/2436 : 86                                     add l
  912/2437 : F0                                     mov l,a
  913/2438 : C5                                     mov a,h
  914/2439 : 8D                                     adc h
  915/243A : E8                                     mov h,a
  916/243B :                            
  917/243B :                                        ; add DE (containing the original value of HL) to HL (effectively multiplying HL by 5)
  918/243B : C6                                     mov a,l
  919/243C : 84                                     add e
  920/243D : F0                                     mov l,a
  921/243E : C5                                     mov a,h
  922/243F : 8B                                     adc d
  923/2440 : E8                                     mov h,a
  924/2441 :                            
  925/2441 :                                        ; double HL again (effectively multiplying HL by 10)
  926/2441 : C6                                     mov a,l
  927/2442 : 86                                     add l
  928/2443 : F0                                     mov l,a
  929/2444 : C5                                     mov a,h
  930/2445 : 8D                                     adc h
  931/2446 : E8                                     mov h,a
  932/2447 :                            
  933/2447 :                                        ; add the new digit (saved in B) to HL
  934/2447 : C6                                     mov a,l
  935/2448 : 81                                     add b
  936/2449 : F0                                     mov l,a
  937/244A : C5                                     mov a,h
  938/244B : 1E 00                                  mvi d,0
  939/244D : 8B                                     adc d
  940/244E : E8                                     mov h,a
  941/244F :                            
  942/244F : 44 0A 24                               jmp get_dec1      ; go back for the next decimal digit
  943/2452 :                            
  944/2452 :                            ;------------------------------------------------------------------------
  945/2452 :                            ; print the 8 bit binary number in A as three decimal digits.
  946/2452 :                            ; leading zeros are suppressed.
  947/2452 :                            ; uses A, BC and DE.
  948/2452 :                            ;------------------------------------------------------------------------
  949/2452 : 26 00                      prndec8:    mvi e,0         ; clear the leading zero flag (suppress zeros)
  950/2454 : 1E 64                                  mvi d,100       ; power of 10, starts as 100
  951/2456 : 16 2F                      prndec8a:   mvi c,'0'-1     ; C serves as the counter (starts at 1 less than ascii zero)
  952/2458 : 10                         prndec8b:   inr c
  953/2459 : 93                                     sub d           ; subtract power of 10
  954/245A : 40 58 24                               jnc prndec8b    ; go back for another subtraction if the difference is still positive
  955/245D : 83                                     add d           ; else , add back the power of 10
  956/245E : C8                                     mov b,a         ; save the difference in B
  957/245F : C2                                     mov a,c         ; get the counter from C
  958/2460 : 3C 31                                  cpi '1'         ; is it zero?
  959/2462 : 40 6B 24                               jnc prndec8c    ; jump if the counter is greater than ascii zero
  960/2465 : C4                                     mov a,e         ; recall the leading zero flag from E
  961/2466 : B0                                     ora a           ; set flags according to the leading zero flag
  962/2467 : C2                                     mov a,c         ; restore the counter from C
  963/2468 : 68 70 24                               jz prndec8d     ; skip printing the digit if the leading zero flag is zero
  964/246B : 46 36 26                   prndec8c:   call putch      ; else, print the digit
  965/246E : 26 FF                                  mvi e,0FFH      ; set the leading zero flag
  966/2470 : C3                         prndec8d:   mov a,d
  967/2471 : 14 5A                                  sui 90          ; reduce power of ten from 100 to 10
  968/2473 : D8                                     mov d,a
  969/2474 : C1                                     mov a,b         ; recall the difference from B
  970/2475 : 40 56 24                               jnc prndec8a    ; go back for the tens digit
  971/2478 : 04 30                                  adi '0'         ; else, convert the ones digit to ascii
  972/247A : 46 36 26                               call putch      ; print the last digit
  973/247D : 07                                     ret
  974/247E :                            
  975/247E :                            ;------------------------------------------------------------------------
  976/247E :                            ; print the 16 bit binary number in HL as five decimal digits.
  977/247E :                            ; leading zeros are suppressed.
  978/247E :                            ; uses A, HL, BC and DE.
  979/247E :                            ;------------------------------------------------------------------------
  980/247E : 0E 00                      prndec16:   mvi b,0         ; clear the leading zero flag
  981/2480 : 1E 27                                  mvi d,hi(10000)
  982/2482 : 26 10                                  mvi e,lo(10000) ; DE now contains 10000
  983/2484 : 46 A2 24                               call subtr      ; count and print the ten thousands digit
  984/2487 : 1E 03                                  mvi d,hi(1000)
  985/2489 : 26 E8                                  mvi e,lo(1000)  ; DE now contains 1000            
  986/248B : 46 A2 24                               call subtr      ; count and print the thousands digit
  987/248E : 1E 00                                  mvi d,0
  988/2490 : 26 64                                  mvi e,100       ; DE now contains 100
  989/2492 : 46 A2 24                               call subtr      ; count and print the hundreds digit
  990/2495 : 1E 00                                  mvi d,0
  991/2497 : 26 0A                                  mvi e,10        ; DE now contains 10
  992/2499 : 46 A2 24                               call subtr      ; count and print the tens digit
  993/249C : C6                                     mov a,l         ; get the units digit
  994/249D : 04 30                                  adi '0'         ; convert the units digit to ascii
  995/249F : 44 36 26                               jmp putch       ; print the units digit
  996/24A2 :                            
  997/24A2 :                            ; count and print the number of times the power of ten in DE can be subtracted from HL
  998/24A2 : 16 2F                      subtr:      mvi c,'0'-1     ; initialize the counter in C
  999/24A4 : 10                         subtr1:     inr c           ; increment the counter
 1000/24A5 : C6                                     mov a,l
 1001/24A6 : 94                                     sub e           ; subtract E from L
 1002/24A7 : F0                                     mov l,a
 1003/24A8 : C5                                     mov a,h
 1004/24A9 : 9B                                     sbb d           ; subtract D from H
 1005/24AA : E8                                     mov h,a
 1006/24AB : 40 A4 24                               jnc subtr1      ; continue subtracting until underflow
 1007/24AE :                            
 1008/24AE :                                        ; underflow occured, add the power of ten back to HL
 1009/24AE : C6                                     mov a,l
 1010/24AF : 84                                     add e           ; add E back to L
 1011/24B0 : F0                                     mov l,a
 1012/24B1 : C5                                     mov a,h
 1013/24B2 : 8B                                     adc d           ; add D back to H
 1014/24B3 : E8                                     mov h,a
 1015/24B4 : C2                                     mov a,c
 1016/24B5 :                            
 1017/24B5 :                                        ; check for zero
 1018/24B5 : 3C 31                                  cpi '1'
 1019/24B7 : 40 C1 24                               jnc subtr2      ; jump if the count in C is greater than zero
 1020/24BA : C1                                     mov a,b         ; else, recall the leading zero flag
 1021/24BB : B0                                     ora a           ; set flags
 1022/24BC : C2                                     mov a,c         ; recall the count
 1023/24BD : 2B                                     rz              ; return if the leading zero is zero
 1024/24BE : 44 36 26                               jmp putch       ; else, print the digit
 1025/24C1 :                            
 1026/24C1 : 0E FF                      subtr2:     mvi b,0FFH      ; set the leading zero flag
 1027/24C3 : 44 36 26                               jmp putch       ; print the digit
 1028/24C6 :                            
 1029/24C6 :                            ;------------------------------------------------------------------------
 1030/24C6 :                            ; reads four hex digits from the serial port and converts them into two
 1031/24C6 :                            ; bytes returned in H and L.  enter key exits with fewer than four digits.
 1032/24C6 :                            ; returns with carry flag set if escape key is pressed.
 1033/24C6 :                            ; in addition to H and L, uses A, BC and E.
 1034/24C6 :                            ;------------------------------------------------------------------------
 1035/24C6 : 46 93 25                   get_four:   call get_hex            ; get the first character
 1036/24C9 : 40 DB 24                               jnc get_four2           ; not space, enter nor escape
 1037/24CC : 3C 1B                                  cpi 1BH                 ; escape key?
 1038/24CE : 48 C6 24                               jnz get_four            ; go back for another try
 1039/24D1 : 06 01                      get_four1:  mvi a,1
 1040/24D3 : 0A                                     rrc                     ; set the carry flag
 1041/24D4 : 06 1B                                  mvi a,1BH
 1042/24D6 : 2E 00                                  mvi h,0
 1043/24D8 : 36 00                                  mvi l,0
 1044/24DA : 07                                     ret                     ; return with escape in A and carry set
 1045/24DB :                            ; the first digit is a valid hex digit 0-F
 1046/24DB : 46 F0 25                   get_four2:  call ascii2hex          ; convert to hex nibble
 1047/24DE : 02                                     rlc                     ; rotate into the most significant nibble
 1048/24DF : 02                                     rlc
 1049/24E0 : 02                                     rlc
 1050/24E1 : 02                                     rlc
 1051/24E2 : 24 F0                                  ani 0F0H                ; mast out least signifficant nibble
 1052/24E4 : F0                                     mov l,a                 ; save the first nibble in L
 1053/24E5 :                            
 1054/24E5 :                            ; get the second character            
 1055/24E5 : 46 93 25                   get_four3:  call get_hex            ; get the second character
 1056/24E8 : 40 01 25                               jnc get_four5
 1057/24EB : 3C 1B                                  cpi 1BH                 ; escape key?
 1058/24ED : 68 D1 24                               jz get_four1
 1059/24F0 : 3C 0D                                  cpi 0DH                 ; enter key?
 1060/24F2 : 48 E5 24                               jnz get_four3
 1061/24F5 : C6                                     mov a,l                 ; recall the first nibble from L
 1062/24F6 : 0A                                     rrc                     ; rotate back to least significant nibble
 1063/24F7 : 0A                                     rrc
 1064/24F8 : 0A                                     rrc
 1065/24F9 : 0A                                     rrc
 1066/24FA : 24 0F                                  ani 0FH                 ; mask out most significant nibble
 1067/24FC : F0                                     mov l,a                 ; put the first digit in L
 1068/24FD : 2E 00                      get_four4:  mvi h,0                 ; clear H
 1069/24FF : 90                                     sub a                   ; clear the carry flag
 1070/2500 : 07                                     ret
 1071/2501 :                            
 1072/2501 :                            ; the second character is a valid hex digit 0-F            
 1073/2501 : 46 F0 25                   get_four5:  call ascii2hex          ; convert to hex nibble
 1074/2504 : 24 0F                                  ani 0FH                 ; mask out the most significant bits
 1075/2506 : B6                                     ora l                   ; combine the two nibbles
 1076/2507 : F0                                     mov l,a                 ; save the first two digits in L
 1077/2508 :                            
 1078/2508 :                            ; the first two digits are in L. get the third character
 1079/2508 : 46 93 25                   get_four6:  call get_hex            ; get the third character
 1080/250B : 40 1B 25                               jnc get_four7           ; not space, escape nor enter
 1081/250E : 3C 1B                                  cpi 1BH                 ; escape key?
 1082/2510 : 68 D1 24                               jz get_four1
 1083/2513 : 3C 0D                                  cpi 0DH                 ; enter key?
 1084/2515 : 48 08 25                               jnz get_four6           ; go back for another try
 1085/2518 : 44 FD 24                               jmp get_four4           ; exit with carry set
 1086/251B :                            
 1087/251B :                            ; the third character is a valid hex digit 0-F            
 1088/251B : 46 F0 25                   get_four7:  call ascii2hex          ; convert to hex nibble
 1089/251E : 02                                     rlc                     ; rotate into the most significant nibble
 1090/251F : 02                                     rlc
 1091/2520 : 02                                     rlc
 1092/2521 : 02                                     rlc
 1093/2522 : 24 F0                                  ani 0F0H                ; mast out least signifficant nibble
 1094/2524 : E8                                     mov h,a                 ; save the nibble in H
 1095/2525 :                            
 1096/2525 :                            ; the first two digits are in L. the third digit is in H. get the fourth character
 1097/2525 : 46 93 25                   get_four8:  call get_hex            ; get the fourth character
 1098/2528 : 40 52 25                               jnc get_four9
 1099/252B : 3C 1B                                  cpi 1BH                 ; escape key?
 1100/252D : 68 D1 24                               jz get_four1
 1101/2530 : 3C 0D                                  cpi 0DH                 ; enter key?
 1102/2532 : 48 25 25                               jnz get_four8           ; go back for another try
 1103/2535 :                            
 1104/2535 :                            ; enter key pressed...            
 1105/2535 : C5                                     mov a,h                 ; retrieve the third digit from H
 1106/2536 : 0A                                     rrc                     ; rotate the third digit back to least significant nibble
 1107/2537 : 0A                                     rrc
 1108/2538 : 0A                                     rrc
 1109/2539 : 0A                                     rrc
 1110/253A : 24 0F                                  ani 0FH                 ; mask out most significant nibble
 1111/253C : E8                                     mov h,a
 1112/253D :                            ; the first two digits are in L, the third digit is in H
 1113/253D : CD                                     mov b,h                 ; save the third digit in B
 1114/253E : D6                                     mov c,l                 ; save the first two digits in C
 1115/253F :                                        
 1116/253F : C6                                     mov a,l
 1117/2540 : 02                                     rlc                     ; rotate the second digit to the most sifnificant nibble
 1118/2541 : 02                                     rlc
 1119/2542 : 02                                     rlc
 1120/2543 : 02                                     rlc
 1121/2544 : 24 F0                                  ani 0F0H                ; mask bits
 1122/2546 : B5                                     ora h                   ; combine the second and third digits
 1123/2547 : F0                                     mov l,a                 ; second and third digits now in L
 1124/2548 :                                        
 1125/2548 : C2                                     mov a,c                 ; get the first two digits from C
 1126/2549 : 0A                                     rrc                     ; rotate the first digit to the least significant nibble
 1127/254A : 0A                                     rrc
 1128/254B : 0A                                     rrc
 1129/254C : 0A                                     rrc
 1130/254D : 24 0F                                  ani 0FH                 ; mask out the most significant bits
 1131/254F : E8                                     mov h,a                 ; first digit now in H
 1132/2550 : 90                                     sub a                   ; clear the carry flag
 1133/2551 : 07                                     ret
 1134/2552 :                                        
 1135/2552 :                            ; the fourth character is a valid hex digit 0-F
 1136/2552 : 46 F0 25                   get_four9:  call ascii2hex          ; convert to hex nibble
 1137/2555 : 24 0F                                  ani 0FH                 ; mask out the most significant bits
 1138/2557 : B5                                     ora h                   ; combine the two nibbles
 1139/2558 : D6                                     mov c,l                 ; save the first two digits in C
 1140/2559 : F0                                     mov l,a                 ; save the last two digits in L
 1141/255A : EA                                     mov h,c                 ; save the first two digits in H
 1142/255B : 90                                     sub a                   ; clear the carry flag
 1143/255C : 07                                     ret
 1144/255D :                            
 1145/255D :                            ;------------------------------------------------------------------------
 1146/255D :                            ; get two hex digits from the serial port and convert them into a
 1147/255D :                            ; byte returned in A.  enter key exits if fewer than two digits.
 1148/255D :                            ; returns with carry flag set if escape key is pressed.
 1149/255D :                            ; uses A, BC and E
 1150/255D :                            ;------------------------------------------------------------------------
 1151/255D : 46 93 25                   get_two:    call get_hex            ; get the first character
 1152/2560 : 60 8D 25                               jc get_two5             ; jump if space, enter or escape
 1153/2563 :                            
 1154/2563 :                            ; the first character is a valid hex digit 0-F
 1155/2563 : 46 F0 25                               call ascii2hex          ; convert to hex nibble
 1156/2566 : 02                                     rlc                     ; rotate into the most significant nibble
 1157/2567 : 02                                     rlc
 1158/2568 : 02                                     rlc
 1159/2569 : 02                                     rlc
 1160/256A : 24 F0                                  ani 0F0H                ; mast out least signifficant nibble
 1161/256C : D0                                     mov c,a                 ; save the first digit in C as the most significant nibble
 1162/256D :                                        
 1163/256D : 46 93 25                               call get_hex            ; get the second character
 1164/2570 : 40 83 25                               jnc get_two2
 1165/2573 : 3C 0D                                  cpi 0DH                 ; enter key?
 1166/2575 : 48 8D 25                               jnz get_two5            ; jump if space or escape
 1167/2578 : C2                                     mov a,c                 ; retrieve the first digit
 1168/2579 : 0A                                     rrc                     ; rotate the first digit back the the least significant nibble
 1169/257A : 0A                                     rrc
 1170/257B : 0A                                     rrc
 1171/257C : 0A                                     rrc
 1172/257D : 24 0F                                  ani 0FH                 ; mask out the most significant nibble
 1173/257F : C8                                     mov b,a                 ; save the first digit in B
 1174/2580 : 44 8A 25                               jmp get_two3
 1175/2583 :                            
 1176/2583 :                            ; the second character is a valid hex digit 0-F            
 1177/2583 : 46 F0 25                   get_two2:   call ascii2hex          ; convert to hex nibble
 1178/2586 : 24 0F                                  ani 0FH                 ; mask out the most significant bits
 1179/2588 : B2                                     ora c                   ; combine the two nibbles
 1180/2589 : C8                                     mov b,a
 1181/258A : 90                         get_two3:   sub a                   ; clear the carry flag
 1182/258B : C1                                     mov a,b
 1183/258C : 07                                     ret
 1184/258D :                            
 1185/258D :                            ; return with carry flag set
 1186/258D : C8                         get_two5:   mov b,a
 1187/258E : 06 01                                  mvi a,1
 1188/2590 : 0A                                     rrc                     ; set the carry flag
 1189/2591 : C1                                     mov a,b
 1190/2592 : 07                                     ret
 1191/2593 :                            
 1192/2593 :                            ;------------------------------------------------------------------
 1193/2593 :                            ; get an ASCII hex character 0-F in A from the serial port.
 1194/2593 :                            ; echo the character if it's a valid hex digit.
 1195/2593 :                            ; return with the carry flag set if ENTER, ESCAPE, or SPACE
 1196/2593 :                            ; uses A, B, and E
 1197/2593 :                            ;------------------------------------------------------------------
 1198/2593 : 46 1D 26                   get_hex:    call getch
 1199/2596 : 24 7F                                  ani 01111111B           ; mask out most significant bit
 1200/2598 : 3C 0D                                  cpi 0DH
 1201/259A : 68 C9 25                               jz get_hex3             ; jump if enter key
 1202/259D : 3C 1B                                  cpi 1BH
 1203/259F : 68 C9 25                               jz get_hex3             ; jump if escape key
 1204/25A2 : 3C 20                                  cpi 20H
 1205/25A4 : 68 C9 25                               jz get_hex3             ; jump if space
 1206/25A7 : 3C 30                                  cpi '0'
 1207/25A9 : 60 93 25                               jc get_hex              ; try again if less than '0'
 1208/25AC : 3C 61                                  cpi 'a'
 1209/25AE : 60 B3 25                               jc get_hex1             ; jump if already upper case...
 1210/25B1 : 14 20                                  sui 20H                 ; else convert to upper case
 1211/25B3 : 3C 47                      get_hex1:   cpi 'G'
 1212/25B5 : 40 93 25                               jnc get_hex             ; try again if greater than 'F'
 1213/25B8 : 3C 3A                                  cpi ':'
 1214/25BA : 60 C2 25                               jc get_hex2             ; continue if '0'-'9'
 1215/25BD : 3C 41                                  cpi 'A'
 1216/25BF : 60 93 25                               jc get_hex              ; try again if less than 'A'
 1217/25C2 :                                        
 1218/25C2 : C8                         get_hex2:   mov b,a                 ; save the character in B
 1219/25C3 : 46 36 26                               call putch              ; echo the character
 1220/25C6 : 90                                     sub a                   ; clear the carry flag
 1221/25C7 : C1                                     mov a,b                 ; restore the character
 1222/25C8 : 07                                     ret                     ; return with carry cleared and character in a
 1223/25C9 :                            
 1224/25C9 : C8                         get_hex3:   mov b,a
 1225/25CA : 06 01                                  mvi a,1
 1226/25CC : 0A                                     rrc                     ; set carry flag
 1227/25CD : C1                                     mov a,b
 1228/25CE : 07                                     ret                     ; return with carry set and character in a  
 1229/25CF :                            
 1230/25CF :                            ;-------------------------------------------------------------------------
 1231/25CF :                            ; write the byte in A to the serial port as two ASCII hex characters.
 1232/25CF :                            ; uses A, D and E.
 1233/25CF :                            ;-------------------------------------------------------------------------
 1234/25CF : D8                         write_hex:  mov d,a                 ; save the byte in D
 1235/25D0 : 0A                                     rrc                     ; rotate most significant nibble into lower 4 bits
 1236/25D1 : 0A                                     rrc
 1237/25D2 : 0A                                     rrc
 1238/25D3 : 0A                                     rrc
 1239/25D4 : 46 E2 25                               call hex2ascii          ; convert the most significand digit to ascii
 1240/25D7 : 46 36 26                               call putch              ; print the most significant digit
 1241/25DA : C3                                     mov a,d                 ; restore
 1242/25DB : 46 E2 25                               call hex2ascii
 1243/25DE : 46 36 26                               call putch
 1244/25E1 : 07                                     ret
 1245/25E2 :                            
 1246/25E2 :                            ;------------------------------------------------------------------------
 1247/25E2 :                            ; convert the lower nibble in A to an ASCII hex character returned in A.
 1248/25E2 :                            ; uses A and E.
 1249/25E2 :                            ;------------------------------------------------------------------------
 1250/25E2 : 24 0F                      hex2ascii:  ani 0FH                 ; mask all but the lower nibble
 1251/25E4 : E0                                     mov e,a                 ; save the nibble in E
 1252/25E5 : 14 0A                                  sui 10
 1253/25E7 : C4                                     mov a,e
 1254/25E8 : 60 ED 25                               jc hex2ascii1           ; jump if the nibble is less than 10
 1255/25EB : 04 07                                  adi 7                   ; add 7 to convert to A-F
 1256/25ED : 04 30                      hex2ascii1: adi 30H
 1257/25EF : 07                                     ret
 1258/25F0 :                            
 1259/25F0 :                            ;------------------------------------------------------------------------
 1260/25F0 :                            ; convert an ascii character in A to its hex equivalent.
 1261/25F0 :                            ; return value in lower nibble, upper nibble zeros
 1262/25F0 :                            ; uses A and E.
 1263/25F0 :                            ;------------------------------------------------------------------------
 1264/25F0 : 3C 61                      ascii2hex:  cpi 'a'
 1265/25F2 : 60 F7 25                               jc ascii2hex1           ; jump if already upper case...
 1266/25F5 : 14 20                                  sui 20H                 ; else convert to upper case
 1267/25F7 : 14 30                      ascii2hex1: sui 30H
 1268/25F9 : E0                                     mov e,a                 ; save the result in b
 1269/25FA : 14 0A                                  sui 0AH                 ; subtract 10 decimal
 1270/25FC : 60 03 26                               jc  ascii2hex2
 1271/25FF : C4                                     mov a,e                 ; restore the value
 1272/2600 : 14 07                                  sui 7
 1273/2602 : E0                                     mov e,a
 1274/2603 : C4                         ascii2hex2: mov a,e
 1275/2604 : 07                                     ret
 1276/2605 :                            
 1277/2605 :                            ;------------------------------------------------------------------------
 1278/2605 :                            ; serially print carrage return and line feed
 1279/2605 :                            ; uses A and E.
 1280/2605 :                            ;------------------------------------------------------------------------
 1281/2605 : 06 0D                      crlf:       mvi a,0DH
 1282/2607 : 46 36 26                               call putch
 1283/260A :                            ;            mvi a,0AH
 1284/260A :                            ;            jmp putch
 1285/260A :                            
 1286/260A :                            ;------------------------------------------------------------------------
 1287/260A :                            ; serially print a space
 1288/260A :                            ; uses A and E.
 1289/260A :                            ;------------------------------------------------------------------------
 1290/260A : 06 20                      space:      mvi a,' '
 1291/260C : 44 36 26                               jmp putch
 1292/260F :                            
 1293/260F :                            ;------------------------------------------------------------------------
 1294/260F :                            ; serially print the null terminated string whose address is in HL.
 1295/260F :                            ; uses A and E and HL
 1296/260F :                            ;------------------------------------------------------------------------
 1297/260F : C7                         puts:       mov a,m
 1298/2610 : A0                                     ana a
 1299/2611 : 2B                                     rz                      ; end of string
 1300/2612 : 46 36 26                               call putch
 1301/2615 : 30                                     inr l                   ; next character
 1302/2616 : 48 0F 26                               jnz puts
 1303/2619 : 28                                     inr h
 1304/261A : 44 0F 26                               jmp puts
 1305/261D :                            
 1306/261D :                            ;INPORT      equ 0                   ; serial input port address
 1307/261D :                            ;OUTPORT     equ 08H                 ; serial output port address
 1308/261D :                            ;-----------------------------------------------------------------------------------------
 1309/261D :                            ; wait for a character from the serial port. 
 1310/261D :                            ; receives 1 start bit, 8 data bits and 1 stop bit at 9600 bps.(depends on PIC firmware)
 1311/261D :                            ; do not echo. return the character in A.
 1312/261D :                            ; uses A and E.
 1313/261D :                            ;
 1314/261D :                            ; This subroutine rewrited for EMU8008 by Gazelle.
 1315/261D :                            ;-----------------------------------------------------------------------------------------
 1316/261D : 41                         getch:		in	IN_STATUS
 1317/261E : 24 01                      		ani	1
 1318/2620 : 68 1D 26                   		jz	getch
 1319/2623 :                            
 1320/2623 : 43                         		in	IN_DATA
 1321/2624 : 07                         		ret
 1322/2625 :                            ;-----------------------------------------------------------------------------------------
 1323/2625 :                            ; wait for a character from the serial port. 
 1324/2625 :                            ; receives 1 start bit, 8 data bits and 1 stop bit at 9600 bps.(depends on PIC firmware)
 1325/2625 :                            ; echo each bit as it is received. return the received character in A.
 1326/2625 :                            ; uses A and E.
 1327/2625 :                            ;
 1328/2625 :                            ; This subroutine rewrited for EMU8008 by Gazelle.
 1329/2625 :                            ;-----------------------------------------------------------------------------------------
 1330/2625 : 41                         getche:		in	IN_STATUS
 1331/2626 : 24 01                      		ani	1
 1332/2628 : 68 25 26                   		jz	getche
 1333/262B :                            
 1334/262B : 43                         		in	IN_DATA
 1335/262C :                            
 1336/262C : E0                         getche_1:	mov	e,a		; save the character from A to E
 1337/262D : 41                         getche_2:	in	IN_STATUS
 1338/262E : 24 02                      		ani	2
 1339/2630 : 68 2D 26                   		jz	getche_2
 1340/2633 : C4                         		mov	a,e
 1341/2634 : 61                         		out	OUT_DATA
 1342/2635 : 07                         		ret
 1343/2636 :                            ;------------------------------------------------------------------------
 1344/2636 :                            ; sends the character in A out from the serial port.
 1345/2636 :                            ; transmits 1 start bit, 8 data bits and 1 stop at 9600 bps.(depends on PIC firmware)
 1346/2636 :                            ; uses A and E.
 1347/2636 :                            ;
 1348/2636 :                            ; This subroutine rewrited for EMU8008 by Gazelle.
 1349/2636 :                            ;------------------------------------------------------------------------
 1350/2636 : E0                         putch:		mov	e,a		; save the character from A to E
 1351/2637 : 41                         putch_1:	in	IN_STATUS
 1352/2638 : 24 02                      		ani	2
 1353/263A : 68 37 26                   		jz	putch_1
 1354/263D : C4                         		mov	a,e
 1355/263E : 61                         		out	OUT_DATA
 1356/263F : 3C 0D                      		cpi	0dh
 1357/2641 : 0B                         		rnz
 1358/2642 : 26 0A                      		mvi	e,0ah
 1359/2644 : 44 37 26                   		jmp	putch_1
 1360/2647 :                            ;------------------------------------------------------------------------
 1361/2647 :                            ;; delay in microseconds = (((255-value in E)*16)+19) * 4 microseconds
 1362/2647 :                            ;------------------------------------------------------------------------
 1363/2647 : 20                         delay:      inr e
 1364/2648 : 48 47 26                               jnz delay
 1365/264B : 07                         delay1:     ret
 1366/264C :                            
 1367/264C :                            ;------------------------------------------------------------------------
 1368/264C : 0D                         titletxt:   db  "\r"
 1369/264D : 53 65 72 69 61 6C 20 4D 6F             db  "Serial Monitor for Intel 8008 SBC V2.0\r"
      2656 : 6E 69 74 6F 72 20 66 6F 72
      265F : 20 49 6E 74 65 6C 20 38 30
      2668 : 30 38 20 53 42 43 20 56 32
      2671 : 2E 30 0D                  
 1370/2674 : 4D 6F 64 69 66 69 65 64 20             db	"Modified for EMU8008 by Gazelle\r"
      267D : 66 6F 72 20 45 4D 55 38 30
      2686 : 30 38 20 62 79 20 47 61 7A
      268F : 65 6C 6C 65 0D            
 1371/2694 : 52 65 76 2E 20 31 2E 30 30             db  "Rev. 1.00 Assembled on ",DATE," at ",TIME,"\r",0
      269D : 20 41 73 73 65 6D 62 6C 65
      26A6 : 64 20 6F 6E 20 38 2F 31 31
      26AF : 2F 32 30 32 35 20 61 74 20
      26B8 : 31 38 3A 33 35 3A 32 36 0D
      26C1 : 00                        
 1372/26C2 : 0D                         menutxt:    db  "\r"
 1373/26C3 : 42 20 2D 20 42 69 6E 61 72             db  "B - Binary file download\r"
      26CC : 79 20 66 69 6C 65 20 64 6F
      26D5 : 77 6E 6C 6F 61 64 0D      
 1374/26DC : 43 20 2D 20 43 61 6C 6C 20             db  "C - Call subroutine\r"
      26E5 : 73 75 62 72 6F 75 74 69 6E
      26EE : 65 0D                     
 1375/26F0 : 44 20 2D 20 44 75 6D 70 20             db  "D - Dump RAM\r"
      26F9 : 52 41 4D 0D               
 1376/26FD : 45 20 2D 20 45 78 61 6D 69             db  "E - Examine/Modify RAM\r"
      2706 : 6E 65 2F 4D 6F 64 69 66 79
      270F : 20 52 41 4D 0D            
 1377/2714 : 46 20 2D 20 46 69 6C 6C 20             db  "F - Fill RAM\r"
      271D : 52 41 4D 0D               
 1378/2721 : 48 20 2D 20 48 65 78 20 66             db  "H - Hex file download\r"
      272A : 69 6C 65 20 64 6F 77 6E 6C
      2733 : 6F 61 64 0D               
 1379/2737 : 47 20 2D 20 47 6F 20 74 6F             db  "G - Go to address\r"
      2740 : 20 61 64 64 72 65 73 73 0D
 1380/2749 : 49 20 2D 20 49 6E 70 75 74             db  "I - Input byte from port\r"
      2752 : 20 62 79 74 65 20 66 72 6F
      275B : 6D 20 70 6F 72 74 0D      
 1381/2762 : 4A 20 2D 20 4A 75 6D 70 20             db  "J - Jump to address\r"
      276B : 74 6F 20 61 64 64 72 65 73
      2774 : 73 0D                     
 1382/2776 : 4F 20 2D 20 4F 75 74 70 75             db  "O - Output byte to port\r"
      277F : 74 20 62 79 74 65 20 74 6F
      2788 : 20 70 6F 72 74 0D         
 1383/278E : 53 20 2D 20 53 43 45 4C 42             db  "S - SCELBAL\r",0
      2797 : 41 4C 0D 00               
 1384/279B :                            
 1385/279B : 0D 3E 3E 00                prompttxt:  db  "\r>>",0
 1386/279F : 75 6D 70 20 6D 65 6D 6F 72 dumptxt:    db  "ump memory\r",0
      27A8 : 79 0D 00                  
 1387/27AB : 78 61 6D 69 6E 65 20 6D 65 examinetxt: db  "xamine memory\r",0
      27B4 : 6D 6F 72 79 0D 00         
 1388/27BA : 69 6C 6C 20 6D 65 6D 6F 72 filltxt:    db  "ill memory\r",0
      27C3 : 79 0D 00                  
 1389/27C6 : 75 6D 70 20 74 6F 20 61 64 jumptxt:    db  "ump to address: (in hex) ",0 
      27CF : 64 72 65 73 73 3A 20 28 69
      27D8 : 6E 20 68 65 78 29 20 00   
 1390/27E0 : 61 6C 6C 20 73 75 62 72 6F calltxt:    db  "all subroutine at address: ",0 
      27E9 : 75 74 69 6E 65 20 61 74 20
      27F2 : 61 64 64 72 65 73 73 3A 20
      27FB : 00                        
 1391/27FC : 6F 20 74 6F 20 61 64 64 72 gototxt:    db  "o to address: (in hex) ",0
      2805 : 65 73 73 3A 20 28 69 6E 20
      280E : 68 65 78 29 20 00         
 1392/2814 : 6E 70 75 74 20 62 79 74 65 inputtxt    db  "nput byte from port",0
      281D : 20 66 72 6F 6D 20 70 6F 72
      2826 : 74 00                     
 1393/2828 : 75 74 70 75 74 20 62 79 74 outputtxt   db  "utput byte to port",0 
      2831 : 65 20 74 6F 20 70 6F 72 74
      283A : 00                        
 1394/283B : 69 6E 61 72 79 20 66 69 6C binloadtxt: db  "inary file download\r",0 
      2844 : 65 20 64 6F 77 6E 6C 6F 61
      284D : 64 0D 00                  
 1395/2850 : 43 45 4C 42 41 4C 0D 00    scelbaltxt: db  "CELBAL\r",0
 1396/2858 : 65 78 20 66 69 6C 65 20 64 hexloadtxt: db  "ex file download\r",0
      2861 : 6F 77 6E 6C 6F 61 64 0D 00
 1397/286A : 0D 41 64 64 72 65 73 73 3A addresstxt: db  "\rAddress: (in hex) ",0 
      2873 : 20 28 69 6E 20 68 65 78 29
      287C : 20 00                     
 1398/287E : 20 20 43 6F 75 6E 74 3A 20 hcounttxt:  db  "  Count: (in hex) ",0
      2887 : 28 69 6E 20 68 65 78 29 20
      2890 : 00                        
 1399/2891 : 20 20 56 61 6C 75 65 3A 20 valuetxt:   db  "  Value: (in hex) ",0   
      289A : 28 69 6E 20 68 65 78 29 20
      28A3 : 00                        
 1400/28A4 : 0D 20 20 20 20 20 20 30 30 columntxt:  db  "\r      00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F",0
      28AD : 20 30 31 20 30 32 20 30 33
      28B6 : 20 30 34 20 30 35 20 30 36
      28BF : 20 30 37 20 30 38 20 30 39
      28C8 : 20 30 41 20 30 42 20 30 43
      28D1 : 20 30 44 20 30 45 20 30 46
      28DA : 00                        
 1401/28DB : 0D 57 61 69 74 69 6E 67 20 dnldtxt:    db  "\rWaiting for the binary file download.\r",0   
      28E4 : 66 6F 72 20 74 68 65 20 62
      28ED : 69 6E 61 72 79 20 66 69 6C
      28F6 : 65 20 64 6F 77 6E 6C 6F 61
      28FF : 64 2E 0D 00               
 1402/2903 : 0D 57 61 69 74 69 6E 67 20 waittxt:    db  "\rWaiting for the Intel hex file download.\r",0
      290C : 66 6F 72 20 74 68 65 20 49
      2915 : 6E 74 65 6C 20 68 65 78 20
      291E : 66 69 6C 65 20 64 6F 77 6E
      2927 : 6C 6F 61 64 2E 0D 00      
 1403/292E : 0D 46 69 6C 65 20 6C 6F 61 loadedtxt:  db  "\rFile loaded.\r",0  
      2937 : 64 65 64 2E 0D 00         
 1404/293D : 0D 43 68 65 63 6B 73 75 6D errortxt:   db  "\rChecksum error!\r",0
      2946 : 20 65 72 72 6F 72 21 0D 00
 1405/294F : 20 2D 2D 3E 20 00          arrowtxt:   db  " --> ",0
 1406/2955 : 20 20 4E 65 77 3A 20 00    newvaluetxt:db  "  New: ",0
 1407/295D : 0D 50 6F 72 74 20 61 64 64 porttxt     db  "\rPort address: (in hex) ",0
      2966 : 72 65 73 73 3A 20 28 69 6E
      296F : 20 68 65 78 29 20 00      
 1408/2976 : 0D 4F 75 74 70 75 74 20 62 bytetxt     db  "\rOutput byte:  (in hex) ",0
      297F : 79 74 65 3A 20 20 28 69 6E
      2988 : 20 68 65 78 29 20 00      
 1409/298F : 0D 49 6E 74 65 6C 20 38 30 copytxt     db  "\rIntel 8008 SBC Monitor © Copyright 2022 by Jim Loos\r",0
      2998 : 30 38 20 53 42 43 20 4D 6F
      29A1 : 6E 69 74 6F 72 20 A9 20 43
      29AA : 6F 70 79 72 69 67 68 74 20
      29B3 : 32 30 32 32 20 62 79 20 4A
      29BC : 69 6D 20 4C 6F 6F 73 0D 00
 1410/29C5 : 0D 45 50 52 4F 4D 20 63 68 epromtxt    db "\rEPROM checksum error!\r",0
      29CE : 65 63 6B 73 75 6D 20 65 72
      29D7 : 72 6F 72 21 0D 00         
 1411/29DD :                            
 1412/29DD : 00 00 00 00 00 00 00 00 00             db 4000H-$ dup (0)      ; fill the rest of the EPROM space with zeros  
      29E6 : 00 00 00 00 00 00 00 00 00
      29EF : 00 00 00 00 00 00 00 00 00
      29F8 : 00 00 00 00 00 00 00 00 00
      2A01 : 00 00 00 00 00 00 00 00 00
      2A0A : 00 00 00 00 00 00 00 00 00
      2A13 : 00 00 00 00 00 00 00 00 00
      2A1C : 00 00 00 00 00 00 00 00 00
      2A25 : 00 00 00 00 00 00 00 00 00
      2A2E : 00 00 00 00 00 00 00 00 00
      2A37 : 00 00 00 00 00 00 00 00 00
      2A40 : 00 00 00 00 00 00 00 00 00
      2A49 : 00 00 00 00 00 00 00 00 00
      2A52 : 00 00 00 00 00 00 00 00 00
      2A5B : 00 00 00 00 00 00 00 00 00
      2A64 : 00 00 00 00 00 00 00 00 00
      2A6D : 00 00 00 00 00 00 00 00 00
      2A76 : 00 00 00 00 00 00 00 00 00
      2A7F : 00 00 00 00 00 00 00 00 00
      2A88 : 00 00 00 00 00 00 00 00 00
      2A91 : 00 00 00 00 00 00 00 00 00
      2A9A : 00 00 00 00 00 00 00 00 00
      2AA3 : 00 00 00 00 00 00 00 00 00
      2AAC : 00 00 00 00 00 00 00 00 00
      2AB5 : 00 00 00 00 00 00 00 00 00
      2ABE : 00 00 00 00 00 00 00 00 00
      2AC7 : 00 00 00 00 00 00 00 00 00
      2AD0 : 00 00 00 00 00 00 00 00 00
      2AD9 : 00 00 00 00 00 00 00 00 00
      2AE2 : 00 00 00 00 00 00 00 00 00
      2AEB : 00 00 00 00 00 00 00 00 00
      2AF4 : 00 00 00 00 00 00 00 00 00
      2AFD : 00 00 00 00 00 00 00 00 00
      2B06 : 00 00 00 00 00 00 00 00 00
      2B0F : 00 00 00 00 00 00 00 00 00
      2B18 : 00 00 00 00 00 00 00 00 00
      2B21 : 00 00 00 00 00 00 00 00 00
      2B2A : 00 00 00 00 00 00 00 00 00
      2B33 : 00 00 00 00 00 00 00 00 00
      2B3C : 00 00 00 00 00 00 00 00 00
      2B45 : 00 00 00 00 00 00 00 00 00
      2B4E : 00 00 00 00 00 00 00 00 00
      2B57 : 00 00 00 00 00 00 00 00 00
      2B60 : 00 00 00 00 00 00 00 00 00
      2B69 : 00 00 00 00 00 00 00 00 00
      2B72 : 00 00 00 00 00 00 00 00 00
      2B7B : 00 00 00 00 00 00 00 00 00
      2B84 : 00 00 00 00 00 00 00 00 00
      2B8D : 00 00 00 00 00 00 00 00 00
      2B96 : 00 00 00 00 00 00 00 00 00
      2B9F : 00 00 00 00 00 00 00 00 00
      2BA8 : 00 00 00 00 00 00 00 00 00
      2BB1 : 00 00 00 00 00 00 00 00 00
      2BBA : 00 00 00 00 00 00 00 00 00
      2BC3 : 00 00 00 00 00 00 00 00 00
      2BCC : 00 00 00 00 00 00 00 00 00
      2BD5 : 00 00 00 00 00 00 00 00 00
      2BDE : 00 00 00 00 00 00 00 00 00
      2BE7 : 00 00 00 00 00 00 00 00 00
      2BF0 : 00 00 00 00 00 00 00 00 00
      2BF9 : 00 00 00 00 00 00 00 00 00
      2C02 : 00 00 00 00 00 00 00 00 00
      2C0B : 00 00 00 00 00 00 00 00 00
      2C14 : 00 00 00 00 00 00 00 00 00
      2C1D : 00 00 00 00 00 00 00 00 00
      2C26 : 00 00 00 00 00 00 00 00 00
      2C2F : 00 00 00 00 00 00 00 00 00
      2C38 : 00 00 00 00 00 00 00 00 00
      2C41 : 00 00 00 00 00 00 00 00 00
      2C4A : 00 00 00 00 00 00 00 00 00
      2C53 : 00 00 00 00 00 00 00 00 00
      2C5C : 00 00 00 00 00 00 00 00 00
      2C65 : 00 00 00 00 00 00 00 00 00
      2C6E : 00 00 00 00 00 00 00 00 00
      2C77 : 00 00 00 00 00 00 00 00 00
      2C80 : 00 00 00 00 00 00 00 00 00
      2C89 : 00 00 00 00 00 00 00 00 00
      2C92 : 00 00 00 00 00 00 00 00 00
      2C9B : 00 00 00 00 00 00 00 00 00
      2CA4 : 00 00 00 00 00 00 00 00 00
      2CAD : 00 00 00 00 00 00 00 00 00
      2CB6 : 00 00 00 00 00 00 00 00 00
      2CBF : 00 00 00 00 00 00 00 00 00
      2CC8 : 00 00 00 00 00 00 00 00 00
      2CD1 : 00 00 00 00 00 00 00 00 00
      2CDA : 00 00 00 00 00 00 00 00 00
      2CE3 : 00 00 00 00 00 00 00 00 00
      2CEC : 00 00 00 00 00 00 00 00 00
      2CF5 : 00 00 00 00 00 00 00 00 00
      2CFE : 00 00 00 00 00 00 00 00 00
      2D07 : 00 00 00 00 00 00 00 00 00
      2D10 : 00 00 00 00 00 00 00 00 00
      2D19 : 00 00 00 00 00 00 00 00 00
      2D22 : 00 00 00 00 00 00 00 00 00
      2D2B : 00 00 00 00 00 00 00 00 00
      2D34 : 00 00 00 00 00 00 00 00 00
      2D3D : 00 00 00 00 00 00 00 00 00
      2D46 : 00 00 00 00 00 00 00 00 00
      2D4F : 00 00 00 00 00 00 00 00 00
      2D58 : 00 00 00 00 00 00 00 00 00
      2D61 : 00 00 00 00 00 00 00 00 00
      2D6A : 00 00 00 00 00 00 00 00 00
      2D73 : 00 00 00 00 00 00 00 00 00
      2D7C : 00 00 00 00 00 00 00 00 00
      2D85 : 00 00 00 00 00 00 00 00 00
      2D8E : 00 00 00 00 00 00 00 00 00
      2D97 : 00 00 00 00 00 00 00 00 00
      2DA0 : 00 00 00 00 00 00 00 00 00
      2DA9 : 00 00 00 00 00 00 00 00 00
      2DB2 : 00 00 00 00 00 00 00 00 00
      2DBB : 00 00 00 00 00 00 00 00 00
      2DC4 : 00 00 00 00 00 00 00 00 00
      2DCD : 00 00 00 00 00 00 00 00 00
      2DD6 : 00 00 00 00 00 00 00 00 00
      2DDF : 00 00 00 00 00 00 00 00 00
      2DE8 : 00 00 00 00 00 00 00 00 00
      2DF1 : 00 00 00 00 00 00 00 00 00
      2DFA : 00 00 00 00 00 00 00 00 00
      2E03 : 00 00 00 00 00 00 00 00 00
      2E0C : 00 00 00 00 00 00 00 00 00
      2E15 : 00 00 00 00 00 00 00 00 00
      2E1E : 00 00 00 00 00 00 00 00 00
      2E27 : 00 00 00 00 00 00 00 00 00
      2E30 : 00 00 00 00 00 00 00 00 00
      2E39 : 00 00 00 00 00 00 00 00 00
      2E42 : 00 00 00 00 00 00 00 00 00
      2E4B : 00 00 00 00 00 00 00 00 00
      2E54 : 00 00 00 00 00 00 00 00 00
      2E5D : 00 00 00 00 00 00 00 00 00
      2E66 : 00 00 00 00 00 00 00 00 00
      2E6F : 00 00 00 00 00 00 00 00 00
      2E78 : 00 00 00 00 00 00 00 00 00
      2E81 : 00 00 00 00 00 00 00 00 00
      2E8A : 00 00 00 00 00 00 00 00 00
      2E93 : 00 00 00 00 00 00 00 00 00
      2E9C : 00 00 00 00 00 00 00 00 00
      2EA5 : 00 00 00 00 00 00 00 00 00
      2EAE : 00 00 00 00 00 00 00 00 00
      2EB7 : 00 00 00 00 00 00 00 00 00
      2EC0 : 00 00 00 00 00 00 00 00 00
      2EC9 : 00 00 00 00 00 00 00 00 00
      2ED2 : 00 00 00 00 00 00 00 00 00
      2EDB : 00 00 00 00 00 00 00 00 00
      2EE4 : 00 00 00 00 00 00 00 00 00
      2EED : 00 00 00 00 00 00 00 00 00
      2EF6 : 00 00 00 00 00 00 00 00 00
      2EFF : 00 00 00 00 00 00 00 00 00
      2F08 : 00 00 00 00 00 00 00 00 00
      2F11 : 00 00 00 00 00 00 00 00 00
      2F1A : 00 00 00 00 00 00 00 00 00
      2F23 : 00 00 00 00 00 00 00 00 00
      2F2C : 00 00 00 00 00 00 00 00 00
      2F35 : 00 00 00 00 00 00 00 00 00
      2F3E : 00 00 00 00 00 00 00 00 00
      2F47 : 00 00 00 00 00 00 00 00 00
      2F50 : 00 00 00 00 00 00 00 00 00
      2F59 : 00 00 00 00 00 00 00 00 00
      2F62 : 00 00 00 00 00 00 00 00 00
      2F6B : 00 00 00 00 00 00 00 00 00
      2F74 : 00 00 00 00 00 00 00 00 00
      2F7D : 00 00 00 00 00 00 00 00 00
      2F86 : 00 00 00 00 00 00 00 00 00
      2F8F : 00 00 00 00 00 00 00 00 00
      2F98 : 00 00 00 00 00 00 00 00 00
      2FA1 : 00 00 00 00 00 00 00 00 00
      2FAA : 00 00 00 00 00 00 00 00 00
      2FB3 : 00 00 00 00 00 00 00 00 00
      2FBC : 00 00 00 00 00 00 00 00 00
      2FC5 : 00 00 00 00 00 00 00 00 00
      2FCE : 00 00 00 00 00 00 00 00 00
      2FD7 : 00 00 00 00 00 00 00 00 00
      2FE0 : 00 00 00 00 00 00 00 00 00
      2FE9 : 00 00 00 00 00 00 00 00 00
      2FF2 : 00 00 00 00 00 00 00 00 00
      2FFB : 00 00 00 00 00 00 00 00 00
      3004 : 00 00 00 00 00 00 00 00 00
      300D : 00 00 00 00 00 00 00 00 00
      3016 : 00 00 00 00 00 00 00 00 00
      301F : 00 00 00 00 00 00 00 00 00
      3028 : 00 00 00 00 00 00 00 00 00
      3031 : 00 00 00 00 00 00 00 00 00
      303A : 00 00 00 00 00 00 00 00 00
      3043 : 00 00 00 00 00 00 00 00 00
      304C : 00 00 00 00 00 00 00 00 00
      3055 : 00 00 00 00 00 00 00 00 00
      305E : 00 00 00 00 00 00 00 00 00
      3067 : 00 00 00 00 00 00 00 00 00
      3070 : 00 00 00 00 00 00 00 00 00
      3079 : 00 00 00 00 00 00 00 00 00
      3082 : 00 00 00 00 00 00 00 00 00
      308B : 00 00 00 00 00 00 00 00 00
      3094 : 00 00 00 00 00 00 00 00 00
      309D : 00 00 00 00 00 00 00 00 00
      30A6 : 00 00 00 00 00 00 00 00 00
      30AF : 00 00 00 00 00 00 00 00 00
      30B8 : 00 00 00 00 00 00 00 00 00
      30C1 : 00 00 00 00 00 00 00 00 00
      30CA : 00 00 00 00 00 00 00 00 00
      30D3 : 00 00 00 00 00 00 00 00 00
      30DC : 00 00 00 00 00 00 00 00 00
      30E5 : 00 00 00 00 00 00 00 00 00
      30EE : 00 00 00 00 00 00 00 00 00
      30F7 : 00 00 00 00 00 00 00 00 00
      3100 : 00 00 00 00 00 00 00 00 00
      3109 : 00 00 00 00 00 00 00 00 00
      3112 : 00 00 00 00 00 00 00 00 00
      311B : 00 00 00 00 00 00 00 00 00
      3124 : 00 00 00 00 00 00 00 00 00
      312D : 00 00 00 00 00 00 00 00 00
      3136 : 00 00 00 00 00 00 00 00 00
      313F : 00 00 00 00 00 00 00 00 00
      3148 : 00 00 00 00 00 00 00 00 00
      3151 : 00 00 00 00 00 00 00 00 00
      315A : 00 00 00 00 00 00 00 00 00
      3163 : 00 00 00 00 00 00 00 00 00
      316C : 00 00 00 00 00 00 00 00 00
      3175 : 00 00 00 00 00 00 00 00 00
      317E : 00 00 00 00 00 00 00 00 00
      3187 : 00 00 00 00 00 00 00 00 00
      3190 : 00 00 00 00 00 00 00 00 00
      3199 : 00 00 00 00 00 00 00 00 00
      31A2 : 00 00 00 00 00 00 00 00 00
      31AB : 00 00 00 00 00 00 00 00 00
      31B4 : 00 00 00 00 00 00 00 00 00
      31BD : 00 00 00 00 00 00 00 00 00
      31C6 : 00 00 00 00 00 00 00 00 00
      31CF : 00 00 00 00 00 00 00 00 00
      31D8 : 00 00 00 00 00 00 00 00 00
      31E1 : 00 00 00 00 00 00 00 00 00
      31EA : 00 00 00 00 00 00 00 00 00
      31F3 : 00 00 00 00 00 00 00 00 00
      31FC : 00 00 00 00 00 00 00 00 00
      3205 : 00 00 00 00 00 00 00 00 00
      320E : 00 00 00 00 00 00 00 00 00
      3217 : 00 00 00 00 00 00 00 00 00
      3220 : 00 00 00 00 00 00 00 00 00
      3229 : 00 00 00 00 00 00 00 00 00
      3232 : 00 00 00 00 00 00 00 00 00
      323B : 00 00 00 00 00 00 00 00 00
      3244 : 00 00 00 00 00 00 00 00 00
      324D : 00 00 00 00 00 00 00 00 00
      3256 : 00 00 00 00 00 00 00 00 00
      325F : 00 00 00 00 00 00 00 00 00
      3268 : 00 00 00 00 00 00 00 00 00
      3271 : 00 00 00 00 00 00 00 00 00
      327A : 00 00 00 00 00 00 00 00 00
      3283 : 00 00 00 00 00 00 00 00 00
      328C : 00 00 00 00 00 00 00 00 00
      3295 : 00 00 00 00 00 00 00 00 00
      329E : 00 00 00 00 00 00 00 00 00
      32A7 : 00 00 00 00 00 00 00 00 00
      32B0 : 00 00 00 00 00 00 00 00 00
      32B9 : 00 00 00 00 00 00 00 00 00
      32C2 : 00 00 00 00 00 00 00 00 00
      32CB : 00 00 00 00 00 00 00 00 00
      32D4 : 00 00 00 00 00 00 00 00 00
      32DD : 00 00 00 00 00 00 00 00 00
      32E6 : 00 00 00 00 00 00 00 00 00
      32EF : 00 00 00 00 00 00 00 00 00
      32F8 : 00 00 00 00 00 00 00 00 00
      3301 : 00 00 00 00 00 00 00 00 00
      330A : 00 00 00 00 00 00 00 00 00
      3313 : 00 00 00 00 00 00 00 00 00
      331C : 00 00 00 00 00 00 00 00 00
      3325 : 00 00 00 00 00 00 00 00 00
      332E : 00 00 00 00 00 00 00 00 00
      3337 : 00 00 00 00 00 00 00 00 00
      3340 : 00 00 00 00 00 00 00 00 00
      3349 : 00 00 00 00 00 00 00 00 00
      3352 : 00 00 00 00 00 00 00 00 00
      335B : 00 00 00 00 00 00 00 00 00
      3364 : 00 00 00 00 00 00 00 00 00
      336D : 00 00 00 00 00 00 00 00 00
      3376 : 00 00 00 00 00 00 00 00 00
      337F : 00 00 00 00 00 00 00 00 00
      3388 : 00 00 00 00 00 00 00 00 00
      3391 : 00 00 00 00 00 00 00 00 00
      339A : 00 00 00 00 00 00 00 00 00
      33A3 : 00 00 00 00 00 00 00 00 00
      33AC : 00 00 00 00 00 00 00 00 00
      33B5 : 00 00 00 00 00 00 00 00 00
      33BE : 00 00 00 00 00 00 00 00 00
      33C7 : 00 00 00 00 00 00 00 00 00
      33D0 : 00 00 00 00 00 00 00 00 00
      33D9 : 00 00 00 00 00 00 00 00 00
      33E2 : 00 00 00 00 00 00 00 00 00
      33EB : 00 00 00 00 00 00 00 00 00
      33F4 : 00 00 00 00 00 00 00 00 00
      33FD : 00 00 00 00 00 00 00 00 00
      3406 : 00 00 00 00 00 00 00 00 00
      340F : 00 00 00 00 00 00 00 00 00
      3418 : 00 00 00 00 00 00 00 00 00
      3421 : 00 00 00 00 00 00 00 00 00
      342A : 00 00 00 00 00 00 00 00 00
      3433 : 00 00 00 00 00 00 00 00 00
      343C : 00 00 00 00 00 00 00 00 00
      3445 : 00 00 00 00 00 00 00 00 00
      344E : 00 00 00 00 00 00 00 00 00
      3457 : 00 00 00 00 00 00 00 00 00
      3460 : 00 00 00 00 00 00 00 00 00
      3469 : 00 00 00 00 00 00 00 00 00
      3472 : 00 00 00 00 00 00 00 00 00
      347B : 00 00 00 00 00 00 00 00 00
      3484 : 00 00 00 00 00 00 00 00 00
      348D : 00 00 00 00 00 00 00 00 00
      3496 : 00 00 00 00 00 00 00 00 00
      349F : 00 00 00 00 00 00 00 00 00
      34A8 : 00 00 00 00 00 00 00 00 00
      34B1 : 00 00 00 00 00 00 00 00 00
      34BA : 00 00 00 00 00 00 00 00 00
      34C3 : 00 00 00 00 00 00 00 00 00
      34CC : 00 00 00 00 00 00 00 00 00
      34D5 : 00 00 00 00 00 00 00 00 00
      34DE : 00 00 00 00 00 00 00 00 00
      34E7 : 00 00 00 00 00 00 00 00 00
      34F0 : 00 00 00 00 00 00 00 00 00
      34F9 : 00 00 00 00 00 00 00 00 00
      3502 : 00 00 00 00 00 00 00 00 00
      350B : 00 00 00 00 00 00 00 00 00
      3514 : 00 00 00 00 00 00 00 00 00
      351D : 00 00 00 00 00 00 00 00 00
      3526 : 00 00 00 00 00 00 00 00 00
      352F : 00 00 00 00 00 00 00 00 00
      3538 : 00 00 00 00 00 00 00 00 00
      3541 : 00 00 00 00 00 00 00 00 00
      354A : 00 00 00 00 00 00 00 00 00
      3553 : 00 00 00 00 00 00 00 00 00
      355C : 00 00 00 00 00 00 00 00 00
      3565 : 00 00 00 00 00 00 00 00 00
      356E : 00 00 00 00 00 00 00 00 00
      3577 : 00 00 00 00 00 00 00 00 00
      3580 : 00 00 00 00 00 00 00 00 00
      3589 : 00 00 00 00 00 00 00 00 00
      3592 : 00 00 00 00 00 00 00 00 00
      359B : 00 00 00 00 00 00 00 00 00
      35A4 : 00 00 00 00 00 00 00 00 00
      35AD : 00 00 00 00 00 00 00 00 00
      35B6 : 00 00 00 00 00 00 00 00 00
      35BF : 00 00 00 00 00 00 00 00 00
      35C8 : 00 00 00 00 00 00 00 00 00
      35D1 : 00 00 00 00 00 00 00 00 00
      35DA : 00 00 00 00 00 00 00 00 00
      35E3 : 00 00 00 00 00 00 00 00 00
      35EC : 00 00 00 00 00 00 00 00 00
      35F5 : 00 00 00 00 00 00 00 00 00
      35FE : 00 00 00 00 00 00 00 00 00
      3607 : 00 00 00 00 00 00 00 00 00
      3610 : 00 00 00 00 00 00 00 00 00
      3619 : 00 00 00 00 00 00 00 00 00
      3622 : 00 00 00 00 00 00 00 00 00
      362B : 00 00 00 00 00 00 00 00 00
      3634 : 00 00 00 00 00 00 00 00 00
      363D : 00 00 00 00 00 00 00 00 00
      3646 : 00 00 00 00 00 00 00 00 00
      364F : 00 00 00 00 00 00 00 00 00
      3658 : 00 00 00 00 00 00 00 00 00
      3661 : 00 00 00 00 00 00 00 00 00
      366A : 00 00 00 00 00 00 00 00 00
      3673 : 00 00 00 00 00 00 00 00 00
      367C : 00 00 00 00 00 00 00 00 00
      3685 : 00 00 00 00 00 00 00 00 00
      368E : 00 00 00 00 00 00 00 00 00
      3697 : 00 00 00 00 00 00 00 00 00
      36A0 : 00 00 00 00 00 00 00 00 00
      36A9 : 00 00 00 00 00 00 00 00 00
      36B2 : 00 00 00 00 00 00 00 00 00
      36BB : 00 00 00 00 00 00 00 00 00
      36C4 : 00 00 00 00 00 00 00 00 00
      36CD : 00 00 00 00 00 00 00 00 00
      36D6 : 00 00 00 00 00 00 00 00 00
      36DF : 00 00 00 00 00 00 00 00 00
      36E8 : 00 00 00 00 00 00 00 00 00
      36F1 : 00 00 00 00 00 00 00 00 00
      36FA : 00 00 00 00 00 00 00 00 00
      3703 : 00 00 00 00 00 00 00 00 00
      370C : 00 00 00 00 00 00 00 00 00
      3715 : 00 00 00 00 00 00 00 00 00
      371E : 00 00 00 00 00 00 00 00 00
      3727 : 00 00 00 00 00 00 00 00 00
      3730 : 00 00 00 00 00 00 00 00 00
      3739 : 00 00 00 00 00 00 00 00 00
      3742 : 00 00 00 00 00 00 00 00 00
      374B : 00 00 00 00 00 00 00 00 00
      3754 : 00 00 00 00 00 00 00 00 00
      375D : 00 00 00 00 00 00 00 00 00
      3766 : 00 00 00 00 00 00 00 00 00
      376F : 00 00 00 00 00 00 00 00 00
      3778 : 00 00 00 00 00 00 00 00 00
      3781 : 00 00 00 00 00 00 00 00 00
      378A : 00 00 00 00 00 00 00 00 00
      3793 : 00 00 00 00 00 00 00 00 00
      379C : 00 00 00 00 00 00 00 00 00
      37A5 : 00 00 00 00 00 00 00 00 00
      37AE : 00 00 00 00 00 00 00 00 00
      37B7 : 00 00 00 00 00 00 00 00 00
      37C0 : 00 00 00 00 00 00 00 00 00
      37C9 : 00 00 00 00 00 00 00 00 00
      37D2 : 00 00 00 00 00 00 00 00 00
      37DB : 00 00 00 00 00 00 00 00 00
      37E4 : 00 00 00 00 00 00 00 00 00
      37ED : 00 00 00 00 00 00 00 00 00
      37F6 : 00 00 00 00 00 00 00 00 00
      37FF : 00 00 00 00 00 00 00 00 00
      3808 : 00 00 00 00 00 00 00 00 00
      3811 : 00 00 00 00 00 00 00 00 00
      381A : 00 00 00 00 00 00 00 00 00
      3823 : 00 00 00 00 00 00 00 00 00
      382C : 00 00 00 00 00 00 00 00 00
      3835 : 00 00 00 00 00 00 00 00 00
      383E : 00 00 00 00 00 00 00 00 00
      3847 : 00 00 00 00 00 00 00 00 00
      3850 : 00 00 00 00 00 00 00 00 00
      3859 : 00 00 00 00 00 00 00 00 00
      3862 : 00 00 00 00 00 00 00 00 00
      386B : 00 00 00 00 00 00 00 00 00
      3874 : 00 00 00 00 00 00 00 00 00
      387D : 00 00 00 00 00 00 00 00 00
      3886 : 00 00 00 00 00 00 00 00 00
      388F : 00 00 00 00 00 00 00 00 00
      3898 : 00 00 00 00 00 00 00 00 00
      38A1 : 00 00 00 00 00 00 00 00 00
      38AA : 00 00 00 00 00 00 00 00 00
      38B3 : 00 00 00 00 00 00 00 00 00
      38BC : 00 00 00 00 00 00 00 00 00
      38C5 : 00 00 00 00 00 00 00 00 00
      38CE : 00 00 00 00 00 00 00 00 00
      38D7 : 00 00 00 00 00 00 00 00 00
      38E0 : 00 00 00 00 00 00 00 00 00
      38E9 : 00 00 00 00 00 00 00 00 00
      38F2 : 00 00 00 00 00 00 00 00 00
      38FB : 00 00 00 00 00 00 00 00 00
      3904 : 00 00 00 00 00 00 00 00 00
      390D : 00 00 00 00 00 00 00 00 00
      3916 : 00 00 00 00 00 00 00 00 00
      391F : 00 00 00 00 00 00 00 00 00
      3928 : 00 00 00 00 00 00 00 00 00
      3931 : 00 00 00 00 00 00 00 00 00
      393A : 00 00 00 00 00 00 00 00 00
      3943 : 00 00 00 00 00 00 00 00 00
      394C : 00 00 00 00 00 00 00 00 00
      3955 : 00 00 00 00 00 00 00 00 00
      395E : 00 00 00 00 00 00 00 00 00
      3967 : 00 00 00 00 00 00 00 00 00
      3970 : 00 00 00 00 00 00 00 00 00
      3979 : 00 00 00 00 00 00 00 00 00
      3982 : 00 00 00 00 00 00 00 00 00
      398B : 00 00 00 00 00 00 00 00 00
      3994 : 00 00 00 00 00 00 00 00 00
      399D : 00 00 00 00 00 00 00 00 00
      39A6 : 00 00 00 00 00 00 00 00 00
      39AF : 00 00 00 00 00 00 00 00 00
      39B8 : 00 00 00 00 00 00 00 00 00
      39C1 : 00 00 00 00 00 00 00 00 00
      39CA : 00 00 00 00 00 00 00 00 00
      39D3 : 00 00 00 00 00 00 00 00 00
      39DC : 00 00 00 00 00 00 00 00 00
      39E5 : 00 00 00 00 00 00 00 00 00
      39EE : 00 00 00 00 00 00 00 00 00
      39F7 : 00 00 00 00 00 00 00 00 00
      3A00 : 00 00 00 00 00 00 00 00 00
      3A09 : 00 00 00 00 00 00 00 00 00
      3A12 : 00 00 00 00 00 00 00 00 00
      3A1B : 00 00 00 00 00 00 00 00 00
      3A24 : 00 00 00 00 00 00 00 00 00
      3A2D : 00 00 00 00 00 00 00 00 00
      3A36 : 00 00 00 00 00 00 00 00 00
      3A3F : 00 00 00 00 00 00 00 00 00
      3A48 : 00 00 00 00 00 00 00 00 00
      3A51 : 00 00 00 00 00 00 00 00 00
      3A5A : 00 00 00 00 00 00 00 00 00
      3A63 : 00 00 00 00 00 00 00 00 00
      3A6C : 00 00 00 00 00 00 00 00 00
      3A75 : 00 00 00 00 00 00 00 00 00
      3A7E : 00 00 00 00 00 00 00 00 00
      3A87 : 00 00 00 00 00 00 00 00 00
      3A90 : 00 00 00 00 00 00 00 00 00
      3A99 : 00 00 00 00 00 00 00 00 00
      3AA2 : 00 00 00 00 00 00 00 00 00
      3AAB : 00 00 00 00 00 00 00 00 00
      3AB4 : 00 00 00 00 00 00 00 00 00
      3ABD : 00 00 00 00 00 00 00 00 00
      3AC6 : 00 00 00 00 00 00 00 00 00
      3ACF : 00 00 00 00 00 00 00 00 00
      3AD8 : 00 00 00 00 00 00 00 00 00
      3AE1 : 00 00 00 00 00 00 00 00 00
      3AEA : 00 00 00 00 00 00 00 00 00
      3AF3 : 00 00 00 00 00 00 00 00 00
      3AFC : 00 00 00 00 00 00 00 00 00
      3B05 : 00 00 00 00 00 00 00 00 00
      3B0E : 00 00 00 00 00 00 00 00 00
      3B17 : 00 00 00 00 00 00 00 00 00
      3B20 : 00 00 00 00 00 00 00 00 00
      3B29 : 00 00 00 00 00 00 00 00 00
      3B32 : 00 00 00 00 00 00 00 00 00
      3B3B : 00 00 00 00 00 00 00 00 00
      3B44 : 00 00 00 00 00 00 00 00 00
      3B4D : 00 00 00 00 00 00 00 00 00
      3B56 : 00 00 00 00 00 00 00 00 00
      3B5F : 00 00 00 00 00 00 00 00 00
      3B68 : 00 00 00 00 00 00 00 00 00
      3B71 : 00 00 00 00 00 00 00 00 00
      3B7A : 00 00 00 00 00 00 00 00 00
      3B83 : 00 00 00 00 00 00 00 00 00
      3B8C : 00 00 00 00 00 00 00 00 00
      3B95 : 00 00 00 00 00 00 00 00 00
      3B9E : 00 00 00 00 00 00 00 00 00
      3BA7 : 00 00 00 00 00 00 00 00 00
      3BB0 : 00 00 00 00 00 00 00 00 00
      3BB9 : 00 00 00 00 00 00 00 00 00
      3BC2 : 00 00 00 00 00 00 00 00 00
      3BCB : 00 00 00 00 00 00 00 00 00
      3BD4 : 00 00 00 00 00 00 00 00 00
      3BDD : 00 00 00 00 00 00 00 00 00
      3BE6 : 00 00 00 00 00 00 00 00 00
      3BEF : 00 00 00 00 00 00 00 00 00
      3BF8 : 00 00 00 00 00 00 00 00 00
      3C01 : 00 00 00 00 00 00 00 00 00
      3C0A : 00 00 00 00 00 00 00 00 00
      3C13 : 00 00 00 00 00 00 00 00 00
      3C1C : 00 00 00 00 00 00 00 00 00
      3C25 : 00 00 00 00 00 00 00 00 00
      3C2E : 00 00 00 00 00 00 00 00 00
      3C37 : 00 00 00 00 00 00 00 00 00
      3C40 : 00 00 00 00 00 00 00 00 00
      3C49 : 00 00 00 00 00 00 00 00 00
      3C52 : 00 00 00 00 00 00 00 00 00
      3C5B : 00 00 00 00 00 00 00 00 00
      3C64 : 00 00 00 00 00 00 00 00 00
      3C6D : 00 00 00 00 00 00 00 00 00
      3C76 : 00 00 00 00 00 00 00 00 00
      3C7F : 00 00 00 00 00 00 00 00 00
      3C88 : 00 00 00 00 00 00 00 00 00
      3C91 : 00 00 00 00 00 00 00 00 00
      3C9A : 00 00 00 00 00 00 00 00 00
      3CA3 : 00 00 00 00 00 00 00 00 00
      3CAC : 00 00 00 00 00 00 00 00 00
      3CB5 : 00 00 00 00 00 00 00 00 00
      3CBE : 00 00 00 00 00 00 00 00 00
      3CC7 : 00 00 00 00 00 00 00 00 00
      3CD0 : 00 00 00 00 00 00 00 00 00
      3CD9 : 00 00 00 00 00 00 00 00 00
      3CE2 : 00 00 00 00 00 00 00 00 00
      3CEB : 00 00 00 00 00 00 00 00 00
      3CF4 : 00 00 00 00 00 00 00 00 00
      3CFD : 00 00 00 00 00 00 00 00 00
      3D06 : 00 00 00 00 00 00 00 00 00
      3D0F : 00 00 00 00 00 00 00 00 00
      3D18 : 00 00 00 00 00 00 00 00 00
      3D21 : 00 00 00 00 00 00 00 00 00
      3D2A : 00 00 00 00 00 00 00 00 00
      3D33 : 00 00 00 00 00 00 00 00 00
      3D3C : 00 00 00 00 00 00 00 00 00
      3D45 : 00 00 00 00 00 00 00 00 00
      3D4E : 00 00 00 00 00 00 00 00 00
      3D57 : 00 00 00 00 00 00 00 00 00
      3D60 : 00 00 00 00 00 00 00 00 00
      3D69 : 00 00 00 00 00 00 00 00 00
      3D72 : 00 00 00 00 00 00 00 00 00
      3D7B : 00 00 00 00 00 00 00 00 00
      3D84 : 00 00 00 00 00 00 00 00 00
      3D8D : 00 00 00 00 00 00 00 00 00
      3D96 : 00 00 00 00 00 00 00 00 00
      3D9F : 00 00 00 00 00 00 00 00 00
      3DA8 : 00 00 00 00 00 00 00 00 00
      3DB1 : 00 00 00 00 00 00 00 00 00
      3DBA : 00 00 00 00 00 00 00 00 00
      3DC3 : 00 00 00 00 00 00 00 00 00
      3DCC : 00 00 00 00 00 00 00 00 00
      3DD5 : 00 00 00 00 00 00 00 00 00
      3DDE : 00 00 00 00 00 00 00 00 00
      3DE7 : 00 00 00 00 00 00 00 00 00
      3DF0 : 00 00 00 00 00 00 00 00 00
      3DF9 : 00 00 00 00 00 00 00 00 00
      3E02 : 00 00 00 00 00 00 00 00 00
      3E0B : 00 00 00 00 00 00 00 00 00
      3E14 : 00 00 00 00 00 00 00 00 00
      3E1D : 00 00 00 00 00 00 00 00 00
      3E26 : 00 00 00 00 00 00 00 00 00
      3E2F : 00 00 00 00 00 00 00 00 00
      3E38 : 00 00 00 00 00 00 00 00 00
      3E41 : 00 00 00 00 00 00 00 00 00
      3E4A : 00 00 00 00 00 00 00 00 00
      3E53 : 00 00 00 00 00 00 00 00 00
      3E5C : 00 00 00 00 00 00 00 00 00
      3E65 : 00 00 00 00 00 00 00 00 00
      3E6E : 00 00 00 00 00 00 00 00 00
      3E77 : 00 00 00 00 00 00 00 00 00
      3E80 : 00 00 00 00 00 00 00 00 00
      3E89 : 00 00 00 00 00 00 00 00 00
      3E92 : 00 00 00 00 00 00 00 00 00
      3E9B : 00 00 00 00 00 00 00 00 00
      3EA4 : 00 00 00 00 00 00 00 00 00
      3EAD : 00 00 00 00 00 00 00 00 00
      3EB6 : 00 00 00 00 00 00 00 00 00
      3EBF : 00 00 00 00 00 00 00 00 00
      3EC8 : 00 00 00 00 00 00 00 00 00
      3ED1 : 00 00 00 00 00 00 00 00 00
      3EDA : 00 00 00 00 00 00 00 00 00
      3EE3 : 00 00 00 00 00 00 00 00 00
      3EEC : 00 00 00 00 00 00 00 00 00
      3EF5 : 00 00 00 00 00 00 00 00 00
      3EFE : 00 00 00 00 00 00 00 00 00
      3F07 : 00 00 00 00 00 00 00 00 00
      3F10 : 00 00 00 00 00 00 00 00 00
      3F19 : 00 00 00 00 00 00 00 00 00
      3F22 : 00 00 00 00 00 00 00 00 00
      3F2B : 00 00 00 00 00 00 00 00 00
      3F34 : 00 00 00 00 00 00 00 00 00
      3F3D : 00 00 00 00 00 00 00 00 00
      3F46 : 00 00 00 00 00 00 00 00 00
      3F4F : 00 00 00 00 00 00 00 00 00
      3F58 : 00 00 00 00 00 00 00 00 00
      3F61 : 00 00 00 00 00 00 00 00 00
      3F6A : 00 00 00 00 00 00 00 00 00
      3F73 : 00 00 00 00 00 00 00 00 00
      3F7C : 00 00 00 00 00 00 00 00 00
      3F85 : 00 00 00 00 00 00 00 00 00
      3F8E : 00 00 00 00 00 00 00 00 00
      3F97 : 00 00 00 00 00 00 00 00 00
      3FA0 : 00 00 00 00 00 00 00 00 00
      3FA9 : 00 00 00 00 00 00 00 00 00
      3FB2 : 00 00 00 00 00 00 00 00 00
      3FBB : 00 00 00 00 00 00 00 00 00
      3FC4 : 00 00 00 00 00 00 00 00 00
      3FCD : 00 00 00 00 00 00 00 00 00
      3FD6 : 00 00 00 00 00 00 00 00 00
      3FDF : 00 00 00 00 00 00 00 00 00
      3FE8 : 00 00 00 00 00 00 00 00 00
      3FF1 : 00 00 00 00 00 00 00 00 00
      3FFA : 00 00 00 00 00 00         
 1413/4000 :                            
 1414/4000 :                                       end
 AS V1.42 Beta [Bld 290] - Source File monitor.asm - Page 2 - 8/11/2025 18:35:26


  Symbol Table (* = unused):
  --------------------------

 ADDRESSTXT :                  286A C |
*ARCHITECTURE :                                        "i386-unknown-win32" - |
 ARROWTXT :                    294F C |  ASCII2HEX :                   25F0 C |
 ASCII2HEX1 :                  25F7 C |  ASCII2HEX2 :                  2603 C |
 BINDL :                       21F8 C |  BINDL0 :                      221E C |
*BINDL2 :                      221E C |  BINLOADTXT :                  283B C |
 BREAK_MSG :                   2032 C |  BYTETXT :                     2976 C |
 CALLSUB :                     22EA C |  CALLTXT :                     27E0 C |
*CASESENSITIVE :                  0 - |  CKSUMERR :                    229C C |
 COLUMNTXT :                   28A4 C | *CONSTPI :        3.141592653589793 - |
 COPYTXT :                     298F C |  CRLF :                        2605 C |
*DATA_GET :                       5 - | *DATA_POP :                       7 - |
*DATA_PUSH :                     0F - | *DATA_PUT :                      0D - |
*DATA_SP_READ :                   6 - | *DATA_SP_WRITE :                 0E - |
 DATE :                 "8/11/2025" - |  DECBC :                       239B C |
 DECBC1 :                      23A1 C |  DELAY :                       2647 C |
*DELAY1 :                      264B C |  DNLDTXT :                     28DB C |
 DUMP :                        20DC C |  DUMP2 :                       20FB C |
 DUMP3 :                       2109 C |  DUMP4 :                       211F C |
 DUMP5 :                       212B C |  DUMP6 :                       2136 C |
 DUMP7 :                       2138 C |  DUMPTXT :                     279F C |
*EPROMTXT :                    29C5 C |  ERRORTXT :                    293D C |
 ESCAPE :                        1B - |  ESCCOUNT :                    1EF6 - |
 EXAMINE :                     218D C |  EXAMINE1 :                    21A6 C |
 EXAMINE3 :                    21CF C |  EXAMINE4 :                    21DE C |
 EXAMINE5 :                    21EB C |  EXAMINETXT :                  27AB C |
*FALSE :                          0 - |  FILL :                        214D C |
 FILLLOOP :                    217A C |  FILLLOOP1 :                   2180 C |
 FILLTXT :                     27BA C | *FINISHED :                    228F C |
*FLOATMAX :      1.797693134866E308 - |  GETCH :                       261D C |
 GETCHE :                      2625 C | *GETCHE_1 :                    262C C |
 GETCHE_2 :                    262D C |  GET_ADDR :                    23A3 C |
 GET_COUNT :                   23B9 C | *GET_DEC :                     2406 C |
 GET_DEC1 :                    240A C |  GET_DEC2 :                    2414 C |
 GET_DEC3 :                    241D C |  GET_FOUR :                    24C6 C |
 GET_FOUR1 :                   24D1 C |  GET_FOUR2 :                   24DB C |
 GET_FOUR3 :                   24E5 C |  GET_FOUR4 :                   24FD C |
 GET_FOUR5 :                   2501 C |  GET_FOUR6 :                   2508 C |
 GET_FOUR7 :                   251B C |  GET_FOUR8 :                   2525 C |
 GET_FOUR9 :                   2552 C |  GET_HEX :                     2593 C |
 GET_HEX1 :                    25B3 C |  GET_HEX2 :                    25C2 C |
 GET_HEX3 :                    25C9 C |  GET_TWO :                     255D C |
 GET_TWO2 :                    2583 C |  GET_TWO3 :                    258A C |
 GET_TWO5 :                    258D C |  GOTO :                        22BB C |
 GOTOTXT :                     27FC C |  GSAV1 :                       2012 C |
 GSAV2 :                       2017 C |  GSAV3 :                       2018 C |
*HAS64 :                          1 - |  HCOUNTTXT :                   287E C |
 HEX2ASCII :                   25E2 C |  HEX2ASCII1 :                  25ED C |
 HEXBYTE :                     22A4 C |  HEXDL :                       222A C |
 HEXDL1 :                      2238 C |  HEXDL1A :                     2240 C |
 HEXDL2 :                      2262 C |  HEXDL3 :                      226D C |
 HEXDL4 :                      2274 C |  HEXLOADTXT :                  2858 C |
 HLT_ADDR :                      3C - |  HLT_BREAK :                   2003 C |
 HLT_VECTOR :                    50 - | *INDEX_A :                        2 - |
 INPUT :                       230F C |  INPUTTXT :                    2814 C |
 INT_EXIT :                       9 - |  INT_LOG :                       80 - |
*INT_PORT :                       8 - |  INT_PTR :                       41 - |
 INT_VECTOR :                    60 - |  IN_DATA :                        1 - |
 IN_STATUS :                      0 - |  JMP_ADDR :                    1EFC - |
 JUMP :                        22CB C |  JUMP1 :                       22D8 C |
 JUMPTXT :                     27C6 C | *LISTON :                         1 - |
 LOADEDTXT :                   292E C | *MACEXP :                         7 - |
 MENU :                        2048 C |  MENUTXT :                     26C2 C |
*MOMCPU :                     8008E - | *MOMCPUNAME :             "8008NEW" - |
*NESTMAX :                      100 - |  NEWVALUETXT :                 2955 C |
 OUTPUT :                      2345 C |  OUTPUTTXT :                   2828 C |
 OUT_DATA :                      10 - |  PORTTXT :                     295D C |
*PRNDEC16 :                    247E C | *PRNDEC8 :                     2452 C |
 PRNDEC8A :                    2456 C |  PRNDEC8B :                    2458 C |
 PRNDEC8C :                    246B C |  PRNDEC8D :                    2470 C |
 PROMPT :                      204F C |  PROMPT0 :                     2056 C |
 PROMPT1 :                     206D C |  PROMPT2 :                     2088 C |
 PROMPTTXT :                   279B C |  PUTCH :                       2636 C |
 PUTCH_1 :                     2637 C |  PUTS :                        260F C |
*RELAXED :                        0 - | *RENTORE_FLAG :                   4 - |
 RESTORE_A :                      3 - | *RESTORE_BC :                  23EC C |
*RESTORE_DE :                  23FD C |  RESTORE_HL :                  23D9 C |
 RETURN :                        0D - | *ROM_OFFSET :                    0A - |
 RST_ADDR :                      34 - |  SAVE_A :                        0B - |
 SAVE_B :                      1EF2 - | *SAVE_BC :                     23E4 C |
*SAVE_C :                      1EF3 - |  SAVE_D :                      1EF4 - |
*SAVE_DE :                     23F5 C | *SAVE_E :                      1EF5 - |
 SAVE_FLAG :                     0C - |  SAVE_H :                      1EF0 - |
 SAVE_HL :                     23CF C | *SAVE_L :                      1EF1 - |
 SCELBAL :                     2380 C |  SCELBALTXT :                  2850 C |
 SPACE :                       260A C | *STACK1_H :                      62 C |
*STACK1_L :                      61 C | *STACK2_H :                      65 C |
*STACK2_L :                      64 C | *STACK3_H :                      68 C |
*STACK3_L :                      67 C | *STACK4_H :                      6B C |
*STACK4_L :                      6A C | *STACK5_H :                      6E C |
*STACK5_L :                      6D C | *STACK6_H :                      71 C |
*STACK6_L :                      70 C | *STACK7_H :                      74 C |
*STACK7_L :                      73 C | *STACK8 :                        76 C |
 START :                       2000 C |  START0 :                      203B C |
 SUBTR :                       24A2 C |  SUBTR1 :                      24A4 C |
 SUBTR2 :                      24C1 C |  TIME :                  "18:35:26" - |
 TITLETXT :                    264C C | *TRUE :                           1 - |
 VALUETXT :                    2891 C | *VERSION :                     142F - |
 WAITEND :                     227E C |  WAITTXT :                     2903 C |
 WRITE_HEX :                   25CF C | *Z80SYNTAX :                      0 - |

    198 symbols
     55 unused symbols

 AS V1.42 Beta [Bld 290] - Source File monitor.asm - Page 3 - 8/11/2025 18:35:26


  Defined Functions:
  ------------------

LO                                    | HI                                   

 AS V1.42 Beta [Bld 290] - Source File monitor.asm - Page 4 - 8/11/2025 18:35:26


  Code Pages:
  ----------

STANDARD (0 changed characters)

1 code page

0.13 seconds assembly time

   1415 lines source file
      2 passes
      0 errors
      0 warnings
